# Definition of a text widget that displays formatted HTML.
#
# @Author: Edward A. Lee
# @Contributors: Stephen Uhler (HTML library), Christopher Hylands
#
# @Version: @(#)HTML.itcl	1.174   01/27/99
#
# @Copyright (c) 1995-1999 The Regents of the University of California.
# All rights reserved.
# 
# Permission is hereby granted, without written agreement and without
# license or royalty fees, to use, copy, modify, and distribute this
# software and its documentation for any purpose, provided that the
# above copyright notice and the following two paragraphs appear in all
# copies of this software.
# 
# IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY
# FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
# ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF
# THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.
# 
# THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE
# PROVIDED HEREUNDER IS ON AN "AS IS" BASIS, AND THE UNIVERSITY OF
# CALIFORNIA HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,
# ENHANCEMENTS, OR MODIFICATIONS.
# 
# 						PT_COPYRIGHT_VERSION_2
#
# Portions of the code in this file are modified from the HTML library
# by Stephen Uhler (of Sun Microsystems), and "surfit", written by
# members of the PASTIME project at the Australian National University.
# The copyrights below apply to those versions:
#
#	Copyright (c) 1996 Australian National University and
#	Sun Microsystems
#
#--------
#
#	PASTIME Project
#	Cooperative Research Centre for Advanced Computational Systems
#	COPYRIGHT NOTICE AND DISCLAIMER.
#
#	Copyright (c) 1995 ANU and CSIRO
#	on behalf of the participants in
#	the CRC for Advanced Computational Systems (ACSys)
#
# This software and all associated data and documentation ("Software")
# was developed for research purposes and ACSys does not warrant that 
# it is error free or fit for any purpose.  ACSys disclaims all liability
# for all claims, expenses, losses, damages and costs any user may incur 
# as a result of using, copying or modifying the Software.
#
#
# 						COPYRIGHTENDKEY
#######################################################################

# FIXME: Known bugs
# - The rendering is quite slow.  Needs to be speeded up.
# - The Tcl extension should use more standard HTML syntax.
# - Embedded windows should be supported.
# - Save As currently saves as plain text only.

# Load the HTML library, if necessary, and make adjustments.
if {[info commands HMinit_win] == {}} {
    uplevel #0 {
	source [::tycho::url join $TYCHO lib html_library html_library.tcl]

	# Make format adjustments -- better than the default
	set HMtag_map(h2) {size 20 weight bold}
	set HMtag_map(h3) {size 20 style i}
	set HMtag_map(h4) {size 16 weight bold}
	set HMtag_map(h5) {size 16 style i}

        set HMinitialtag_map $HMtag_map(hmstart)
        unset HMtag_map(hmstart)
    }
}

#######################################################################
#### HTML
# This widget parses HTML using the library by Stephen Uhler and
# displays it in a Tk text widget. We support local file accesses as
# well as remote files (HTTP, FTP, etc). The HTML source can be
# specified using the insertData{} method or indirectly using the -file
# option. If the HTML will have references to other files (such as
# image files) that are relative, then the reference directory should
# be specified using the -directory option if the insertData{} method was
# used.  Otherwise, the directory is inferred from the -file option.
# 
class ::tycho::HTML {
    inherit ::tycho::Edit

    ###################################################################
    ####                       options                             ####

    # The directory for relative references to images and the like,
    itk_option define -directory directory Directory {}

    # Override the slowNetwork preference for this html browser.
    itk_option define -image image Image 0

    # If true (the default), underline hyperlinks.
    itk_option define -underlinelinks underlineLinks UnderlineLinks 1

    # The default display font -- currently an X font, but should
    # be made symbolic in Tk 8.0
    itk_option define -displayfont displayFont Font [::tycho::font Times 14]

    # The default constant-width font -- currently an X font, but should
    # be made symbolic in Tk 8.0
    itk_option define -cwfont cwFont Font [::tycho::font {Courier New} 14]

    constructor {args} {}
    destructor {}

    ###################################################################
    ####                      public methods                       ####

    # Prompt the user for a file name and load in place of the current file.
    method altFile {}

    # Start up appletviewer on the current file.
    method appletViewer {}

    # Go back to the previous view.
    method back {}

    # Clear the window.
    method clear {}
 
    # Decrease the current font size in this widget.
    method downSize {}
    
    # Execute Tcl code embedded in the HTML.
    method execTcl {x y}

    # Go forward to a previously-seen view.
    method forward {}

    # Open a help window.
    method help {}

    # Open a file and go to its internal point identified by name.
    method hyperJump {filename {point {}} {push 1}}

    # This is used to distinguish between 1) hyperjump an absolute location
    # (ie. /icons/file.xbm) within a HTML file and 2) user's hyperjump to
    # absolute local file location (ie. /usrs/eal)
    method hyperJumpUser {filename} {hyperJump $filename _}

    # Insert the specified data.
    method insertData {data}

    # Insert the contents of the directory.
    method insertDirectoryContents {dirname}

    # Return 1 if rendering is in progress, and 0 otherwise.
    method isRendering {} {return $isrendering}

    # Return 1 if the slowNetwork preference is set.
    method isSlowNetwork {}

    # Return the reference directory.
    method lastDirectory {}

    # Display the link destination in the status bar.
    method linkEnter {xpos ypos {subwindow {}} }

    # Process a subwindow link.
    method linkHitSubWindow {subwindow}

    # Open up a new browser, invoked by button 2
    method openNewBrowser {win x y}

    # Open the source file using an HTML editor.
    method openSource {}

    # Print the selection or the entire contents.
    method print {}

    # Output the rendering status from 0 (not done) to 1 (complete)
    method progress {}

    # Reload from the last saved version of the file.
    method reload {}

    # Go to the specified hypertext reference, line, or range.
    method seeFragment {point}

    # Indicate whether rendering is currently in progress.
    method setRendering {val} {set isrendering $val}

    # Request that rendering stop.  Note that it does not occur immediately.
    method stopRendering {}

    # Return the full path name of the text window.
    method textWinName {}
  
    # Increase the current font size in this widget.
    method upSize {}

    ###################################################################
    ####                      public procedures                    ####

    # Render the given text for a particular HTML object.
    proc render {obj {html {}}} {}

    ###################################################################
    ####                     protected methods                     ####

    # Initialize the menu/status/tool bars associated with this widget.
    protected method _initializeBars {menubar statusbar toolbar}

    # Configure the popup menu depending on the current context
    protected method configureContextMenu {}
   
    ###################################################################
    ####                      protected variables                  ####

    # Indicate whether a rendering operation is in progress.
    protected variable isrendering 0

    ###################################################################
    ####                      private methods                      ####

    # Return currentHTMLText if it exists.
    private method getCurrentHTML {} {
        if [info exists currentHTMLText] {
            return $currentHTMLText
        } {
            return {}
        }
    }

    # Initialize the menubar.
    private method _initializeMenubar {menubar}

    # Initialize the toolbar.
    private method _initializeToolbar {toolbar}

    # Push a new file onto the stack.
    private method pushNextHTMLFile {}

    # Return 1 if the extension is the extension of an image file.
    private method isAnImageFileExtension {extension}

    ###################################################################
    ####                     private variables                     ####

    # The current HTML text (saved so re-rendering is possible)
    private variable currentHTMLText

    # The length of the current HTML text
    private variable currentHTMLLength
    
    # Size modification for quick font changes  
    private variable fontOffset 0
    
    # Keep count of the number of calls to seeFragment
    private variable seecount 0

    # The "stack" of traversed files. This is really just a Tcl list.
    private variable stack {}

    # The current position in the "stack"
    private variable stackpos 0

    # The name of the global array used to store the state of the window.
    private variable stateArrayName {}
}

#########################################################################
#### -cwfont configuration
# Parse the given X font to figure out what font family, size,
# and style to use for constant-width fonts, and modify the
# HMtag_map array accordingly.
#
configbody ::tycho::HTML::cwfont {
    global HMtag_map

    set f [::tycho::FontManager::parseFont $itk_option(-cwfont)]

    # Get the initial font attributes used by the renderer
    # and overwrite the family, size, and style
    switch -exact [string tolower [lindex $f 2]] {
	"roman" {
	    set weight medium
	    set style r
	}
	"bold" {
	    set weight bold
	    set style r
	}
	"italic" {
	    set weight medium
	    set style i
	}
	"bolditalic" {
	    set weight bold
	    set style i
	}
    }
    # Process each tag -- "tcl" is treated specially in HMtag_tcl
    foreach tag {code kbd pre tt} {
	array set temp $HMtag_map($tag)
	# Used to remove spaces from family name --
        # On NT, this turns "courier new" into "couriernew", and the
        # the latter does not map into a fixed width font!
	set temp(family) [lindex $f 0]
	set temp(size) [lindex $f 1]
	# "kbd" tag is always bold
	if { $tag != "kbd" } {
	    set temp(weight) $weight
	}
	set temp(style) $style
	set HMtag_map($tag) [array get temp]
    }

    # Re-render the window. In theory, all that should be necessary
    # is to change the font attributes for all tags, but...
    ::tycho::HTML::render $this
}

#########################################################################
#### -displayfont configuration
# Parse the given X font to figure out what font family, size,
# and style to use for the display font, then set it in the
# HMinitialtag_map array.
#
configbody ::tycho::HTML::displayfont {
    global HMinitialtag_map

    set f [::tycho::FontManager::parseFont $itk_option(-displayfont)]
    
    # Get the initial font attributes used by the renderer
    # and overwrite the family, size, and style
    array set temp $HMinitialtag_map
    # Remove spaces from family name
    set temp(family) [join [lindex $f 0] ""]
    set temp(size) [lindex $f 1]
    switch -exact [string tolower [lindex $f 2]] {
	"roman" {
	    set temp(weight) medium
	    set temp(style) r
	}
	"bold" {
	    set temp(weight) bold
	    set temp(style) r
	}
	"italic" {
	    set temp(weight) medium
	    set temp(style) i
	}
	"bolditalic" {
	    set temp(weight) bold
	    set temp(style) i
	}
    }
    set HMinitialtag_map [array get temp]

    # Re-render the window. In theory, all that should be necessary
    # is to change the font attributes for all tags, but...
    ::tycho::HTML::render $this
}

#########################################################################
#### -underlinelinks configuration
# Set the text format for the "link" tag to turn underlining on or off.
#
configbody ::tycho::HTML::underlinelinks {
    # Modifications on configuration in the HTML library:
    $itk_component(text) tag configure link \
	    -underline $itk_option(-underlinelinks)
}

###################################################################
#
body ::tycho::HTML::constructor {args} {

    set text $itk_component(text)

    # Initialize the text window.  The returned value is supposed to be
    # the global variable used to store the state of the window, but isn't.
    HMinit_win $text
    $text tag bind link <2>       "$this openNewBrowser $text %x %y"
    $text tag bind link <Shift-1> "$this openNewBrowser $text %x %y"
    # Override the editor's button 2 which was generating error here
    bind $text <ButtonRelease-2> "break"

    # Add a binding for links to display the destination.
    $text tag bind link <Enter> "$this linkEnter %x %y"
    # If we don't have a <Motion> tag for the link, then if we have several
    # links stacked on top of each other horizontally, the status bar
    # is not updated as we move the mouse from link to link (see tynt.html).
    $text tag bind link <Motion> "$this linkEnter %x %y"
    $text tag bind link <Leave> "$this statusbar putMessage {}"

    # Additions:
    $text tag configure subscript -offset -6
    $text tag configure superscript -offset +6

    set stateArrayName HM$text

    eval itk_initialize $args

    # Subscribe to the style-sheets
    stylesheet subscribe \
	    -displayfont    fonts displayFont \
	    -cwfont         fonts cwFont \
	    -underlinelinks text underlineLinks

    if {$itk_option(-directory) == {}} {
        configure -directory [::tycho::url dirname [filename]]
    }

    bind $text <space> "$this scroll 1; break"

    # Scroll using cursor keys w/o waiting for invisible cursor to move.
    bind $text <Up> "$text yview scroll -1 units; break"
    bind $text <Down> "$text yview scroll 1 units; break"
    bind $text <Home> "$text see 1.0; break"
    bind $text <End> "$text see end-1c; break"

    # Double clicks normally select text, something we don't want here.
    bind $text <Double-Button-1> {break}

    bind $prefix <<OpenSource>> "$this openSource; break"

    # disable certain bindings
    bind $prefix <<Save>> {bell; break}
    bind $prefix <<SaveAs>> {bell; break}
    bind $prefix <<AltFile>> {bell; break}
    bind $prefix <<ToggleReadOnly>> {bell; break}
    bind $prefix <<InsertFile>> {bell; break}
    bind $prefix <<RevisionControl>> {bell; break}

    # Add bindings for forward and back
    bind $text <Meta-Left> "$this back"
    bind $text <Control-Left> "$this back"
    bind $text <Alt-Left> "$this back"
    bind $text <Meta-Right> "$this forward"
    bind $text <Control-Right> "$this forward"
    bind $text <Alt-Right> "$this forward"

    # Don't break on Alt-key combinations: the top-level window needs
    # it for menu traversal
    # FIXME: should this be here, or in TopLevel or in Displayer?
    bind $prefix <Alt-Key> {tkTraverseToMenu %W %A; tkMenuUnpost {}}

    # Make the insertion cursor invisible.
    $text configure -insertofftime 0
    $text configure -insertbackground [$text cget -background]

    # Put some space around the text
    $text configure -padx 0.25c -pady 0.25c
}

###################################################################
#
body ::tycho::HTML::destructor {} {
    stopRendering
}

    ###################################################################
    ###################################################################
    ####                      public methods                       ####

###################################################################
#### altFile
# Query the user for a filename, and if the selected file has the
# extension ".html", ".htm", or "htl", insert its contents in place of the
# currently displayed HTML.  Otherwise, view its contents in a new window.
#
body ::tycho::HTML::altFile {} {
    set filename [safeEval ::tycho::queryfilename {Alternate file to load:}]
    if {$filename != {}} {
	hyperJump $filename
    }
}

#####################################################################
#### appletViewer
# Start up appletviewer on the current file
#
body ::tycho::HTML::appletViewer {} {
     ::tycho::execModal "appletviewer [filename]" \
             [tycho::url dirname [filename]]
}

#####################################################################
#### back
# Go back to the previous view, popping it off the stack.
#
body ::tycho::HTML::back {} {
    # If there's nowhere to go...
    if { $stackpos <= 0 } {
	return
    }
    # Update the current file with the current position
    if { [llength $stack] > $stackpos } {
        set stack [lreplace $stack $stackpos $stackpos \
                [list [filename] [currentPoint]]]
    } else {
        lappend stack [list [filename] [currentPoint]]
    }

    # Move back one position
    incr stackpos -1
    set ref [lindex $stack $stackpos]

    # Disable the back button if there are no more to go
    # forwards to. Enable the forward button.
    if { $stackpos <= 0 } {
        toolbar disable back
    }
    toolbar enable forward

    # Jump to the file
    set filename [lindex $ref 0]
    set point [lindex $ref 1]
    # Use the optional third argument to avoid being recorded for
    # backtracking.
    hyperJump $filename $point 0
}

#####################################################################
#### clear
# Clear the current text.
#
body ::tycho::HTML::clear {} {
    HMreset_win [textWinName]
}

#####################################################################
#### downSize 
# Decrease the font size of the current widget. 
# Redefined from ::tycho::Edit
#
body ::tycho::HTML::downSize {} {
    if {$fontOffset > 0} {
        set fontOffset [expr $fontOffset - 1 - ($fontOffset / 2)]
    } else {
        incr fontOffset -2
    }
    HMset_state [textWinName] -size $fontOffset
    render $this
}

#####################################################################
#### execTcl
# Execute the Tcl code under the "current" mark.
# The Tcl code is simply the largest contiguous region of text tagged
# "tcl".  The code is executed in the global scope, and the result is
# displayed.
#
body ::tycho::HTML::execTcl {x y} {
    set cmd [getTaggedText tcl]
    if {$cmd != {}} {
        set tags [[textWinName] tag names @$x,$y]
        # Handle tcl java tags
        if {[lsearch -exact $tags tcljava] > 0} {
            global tyjavapresent
            if {![info exists tyjavapresent]} {
                ::tycho::htmlmessage {Sorry, this command will only work in a\
                        Tycho binary that has Java inside. See the \
                <a href="$TYCHO/java/doc/index.html">Java</a> page for more \
                information.}
                return
            }
        }
	set result [uplevel #0 $cmd]
        if {$result != {}} {
            if {[lsearch -exact $tags tclq] < 0} {
                safeEval ::tycho::inform "Returned:\n$result"
            } {
                putStatus "Returned: $result"
            }
        } {
            putStatus "null string returned"
        }
    }
}

#####################################################################
#### forward
# Go forward to a previously seen and backed-over view.
#
body ::tycho::HTML::forward {} {
    # Is there a window to move to?
    if { $stackpos >= [expr [llength $stack] - 1] } {
	return
    }
    # Update the current position
    set stack [lreplace $stack $stackpos $stackpos \
            [list [filename] [currentPoint]]]

    # Move forwards
    incr stackpos
    set ref [lindex $stack $stackpos]

    # Disable the forward button if there are no more to go
    # forwards to. Enable the back button.
    if { $stackpos >= [expr [llength $stack] - 1] } {
        toolbar disable forward
    }
    toolbar enable back

    # Jump to the file
    set filename [lindex $ref 0]
    set point [lindex $ref 1]
    # Use the optional third argument to avoid being recorded for
    # backtracking.
    hyperJump $filename $point 0
}

#########################################################################
#### help
# Open a help window.
#
body ::tycho::HTML::help {} {
    global ::TYCHO
    ::tycho::File::openContext \
	    [::tycho::url join $TYCHO kernel html doc html.html] html
}

#####################################################################
#### hyperJump
# Open a file and go to its internal point identified by name. If the
# filename has the extension ".html", ".htm", or "htl", and this window
# is inside a <code>Displayer</code> object, then open it in
# this same window. If the filename is the empty string, then move the
# view to a location within the same file. If filename is relative
# (does not begin with "/", "~", or "$"), then prepend the directory of
# the file currently being viewed. Then, expand the filename using
# <code>::tycho::expandPath</code> and open the resulting file with
# <code>::tycho::File::openContext</code>, which will choose an editor
# based on the filename extension. Finally, invoke
# <code>seeFragment</code> to view the specified point within the file.
# The format for the <i>point</i> argument depends on the type of file
# being opened. For HTML files, it will normally be the name of an
# anchor in the file or specified "yview" location within the file. For
# text files, it will normally be either "{line <i>linenumber</i>}" or
# "{range <i>start</i> <i>end</i>}", where <i>start</i> and <i>end</i>
# have the form <i>linenumber.characternumber</i>. If the third
# argument, which is optional, has value 0, then the jump is not
# recorded for backtracking.
#
# NOTE: This method really should support the syntax "filename#fragment"
# in the filename argument.  Someday.
#
body ::tycho::HTML::hyperJump {filename {point {}} {push 1}} {
    if {$filename != {}} {
        # Mail protocol is an except of a resource, since the only
        # allowable operations on it are: open, puts, and close.
        # We need to create a new editor (EditMail).
        if [regexp -nocase {^mailto:} $filename] {
            set mailinfo [::tycho::ResourceMail::splitURL $filename]
            ::tycho::view EditMail -toolbar 1 \
                    -mailto "[lindex $mailinfo 0]@[lindex $mailinfo 1]" \
                    -textheight [expr [stylesheet get layout textHeight] - 8]
            return
        }

        # Process the image given absolute&&remote path
        if {$push==0} {
            # Push 0 means back, so filename is always absolute!
            set filename $filename
        } elseif { [::tycho::url pathtype $filename] == "absolute" && \
                ([::tycho::url protocol $filename] != "" || $point == "_")} {
            # Exception 2-- from the context of a remote file:
            #   [join /tmp/tarsky http://ptolemy] = http://ptolemy
            #   [join http://weld http://ptolemy] = http://ptolemy
            #   [join http://weld /icons/file]    = http://weld/file
            #
            # Exception 3-- from the context of the user input:
            #   [join http://ptolemy /usrs/eal]   = /usrs/eal
            #
            # We need to take care of this case because it's impossible
            # to make "::tycho::url join" sensibly take care of it.
            set filename $filename
        } elseif {[string match \$* $filename] || [string match ~* $filename]} {
            # if it begins $PTOLEMY, $TYCHO, ~eal, etc.
            set filename [::tycho::expandPath $filename]
        } else {
            # Default behavior is to join the paths
            set filename [::tycho::url join \
                    [::tycho::url dirname [filename]] $filename]
        }

        # If the file is a local directory, and index.html exists, open it.
        # Otherwise just display the contents of the local directory.
        set contenttype [::tycho::resource contenttype $filename]
        set ext [::tycho::url extension $filename]
        if {$contenttype=="directory"} {
            set newfilename [::tycho::url join $filename index.html]
            if [::tycho::resource exists $newfilename] {
                set filename $newfilename
                unset newfilename
            } else {
		global ptolemyfeature
		if { $ptolemyfeature(octtools) && \
                        [::tycho::resource exists [::tycho::url join \
                        $filename schematic {contents;}]]} {
		    # If Ptolemy is present, then open this as a facet
                    ::pvOpenWindow [::ptkOpenFacet \
			    $filename schematic contents]
		    return
		}

		# Display a listing of the file
                # For backtracking
                if $push {
                    pushNextHTMLFile
                }
                configure -directory [::tycho::url dirname $filename]
                configure -file $filename
                toolbar clear location
                toolbar insert location $filename
                # Reset the insertion cursor to the origin, or else we will
                # try to preserve the point in the file.
                $itk_component(text) mark set insert 1.0

                if {$point != {}} {
		    $this seeFragment $point
                }
		insertDirectoryContents $filename
		return
            }
        }

        # If the filename has the ".html", ".htm", or ".htl" extension, open it
        # in this window (unless it is already open in another window or
        # we are not inside a Displayer).
        if {   ([string match "text/html" $contenttype] || \
                [isAnImageFileExtension $ext]) && \
                [displayer] != {}} {
            # IF this is a html file, make sure that the path name
            # is augmented to the correct name. For example,
            #   http://ptolemy/~kchang 
            # should be augmented to:
            #   http://ptolemy/~kchang/
            ::tycho::resource stat $filename tmpstat
            if {[info exists tmpstat(url)]} {
                set filename $tmpstat(url)
            }

            # Special care is required here because there might be a
            # source file open for either the old or the new file. If
            # there is a source file for the old HTML file, it will now
            # appear in the "Window" menu. If there is one for the new
            # file, it should now be removed from the Window menu (the
            # HTML browser widget will take its place).

            # If the destination file is already open, raise it.
            if {[info exists filesOpen($filename)] && \
                    [eval $filesOpen($filename) isa ::tycho::HTML]} {
                ::tycho::File::hyperJump $filename $point
                return
            }

            # If the destination file does not exist, issue a message.
            if ![::tycho::resource readable $filename] {
                ::tycho::warn \
                        "File does not exist or is not readable:\n$filename"
                return
            }

            # For backtracking
            if $push {
                pushNextHTMLFile
            }

	    # If the file does not have <body bgcolor="xxx">, then reset
	    # to the default colors
	    upvar #0 $stateArrayName var
	    $itk_component(text) configure \
                    -insertbackground $var(S_bgcolor) \
		    -background $var(S_bgcolor) \
		    -foreground $var(S_fgcolor)

            configure -directory [::tycho::url dirname $filename]
            configure -file $filename
            toolbar clear location
            toolbar insert location $filename

            # Reset the insertion cursor to the origin, or else we will
            # try to preserve the point in the file.
            $itk_component(text) mark set insert 1.0

            # Reload the file -- images files will be handled specially
            # in reload{}
            reload

            if {$point != {}} {
		$this seeFragment $point
            }
            configure -readonly 1
            return
        }
    } {
        # For backtracking
        if $push {
            pushNextHTMLFile
        }
    }

    # Here's a nasty little hack in order to display download
    # progress: if the file is remote, start a progress display
    # and then open the file in order to force a download.
    # FIXME: Should do a read as well, since some protocols
    # may not download until read. Leave this until Tcl8.0
    # so it will work with binary data too.
    # FIXME: This code is repeated from download{} -- can we
    # be more oganized about this?!
    if [::tycho::resource isremote $filename] {
        set obj [::tycho::resource new $filename]
        statusbar progress \
                "[string toupper [::tycho::url protocol $filename]] Download" \
                "$obj progress"
        $obj open "r"
        $obj close
    }

    # The file is not an HTML file, or is not specified,
    # so defer to the superclass.
    chain $filename $point
}

#####################################################################
#### insertData
# Insert the specified data, cancelling any previous rendering.
#
body ::tycho::HTML::insertData {data} {
    stopRendering

    set currentHTMLText $data
    set currentHTMLLength [string length $data]

    # Because the HTML rendering is slow, defer it to run
    # after the text widget is mapped. In order to make
    # the window appear immediately, precede the rendering by
    # an update. (Don't really know know why this is needed,
    # but it works better this way...)
    whenMapped text "::tycho::safeUpdate $this"
    whenMapped text [list ::tycho::HTML::render $this $data]
}

#####################################################################
#### insertDirectoryContents
# Insert the contents of the the directory 'dirname' into the html
# widget.  We use this if the user visits a directory that does not
# have a index.html file so that the user can see the contents of the
# directory.
#
body ::tycho::HTML::insertDirectoryContents {dirname} {
    clear
    set toc "<h1>Contents of [::tycho::simplifyPath $dirname]</h1>\n\
            <pre><A HREF=\"..\">.. Up to higher level directory</A>"

    # A string with 20 spaces, that we use to left justify the links
    # We print the contents of the file inside a preformatted block
    # so that we can align the text properly.
    set spaceString "                   "

    # Don't need to add [tycho::url join $dirname *], the "*" is implied.
    set dirFiles [lsort [::tycho::resource dirlist $dirname]]

    foreach dirFile $dirFiles {
        # If the filename is over 20 chars long, truncate it and add ...
        set shortName [::tycho::url tail $dirFile]
        if [::tycho::resource isdirectory $dirFile] {
            # FIXME Unixism?  We are adding a / here, what about mac and windows
            set shortName "$shortName/"
        }
        if {[string length $shortName] > 20} {
            set shortName "[string range $shortName 0 16]..."
        }
        if [catch {::tycho::resource stat $dirFile stat} msg] {
            set toc [format \
                    "%s<br><A HREF=\"%s\">%s</A>%s  Couldn`t stat\n" \
                    $toc $dirFile \
                    $shortName \
                    [string range $spaceString \
                    1 [expr {20 - [string length $shortName]}]] \
                ]
        } else {
            set toc [format \
                    "%s<br><A HREF=\"%s\">%s</A>%s %6s %s\n" \
                    $toc $dirFile \
                    $shortName \
                    [string range $spaceString \
                    1 [expr {20 - [string length $shortName]}]] \
                    $stat(size) \
                    [clock format $stat(mtime)]]
        }
    }
    insertData $toc
}

#####################################################################
#### lastDirectory
# Return the directory for relative references to images and the like.
#
body ::tycho::HTML::lastDirectory {} {
    return $itk_option(-directory)
}

#####################################################################
#### linkEnter
# Display the link destination in the status bar for the link below
# the specified mouse position.  If the subwindow argument is present,
# then ignore the xpos and ypos arguments and get the x,y coordinates
# from the bbox of the subwindow.
#
body ::tycho::HTML::linkEnter {xpos ypos {subwindow {}} } {
    if { $subwindow != {} } {
        set bbox [$itk_component(text) bbox $subwindow]
        set tags [$itk_component(text) tag names \
                @[lindex $bbox 0],[lindex $bbox 1]]
    } {
        set tags [$itk_component(text) tag names @$xpos,$ypos]
    }
    set link [lindex $tags [lsearch -glob $tags L:*]]
    # regsub -all {[^L]*L:([^ ]*).*}  $tags {\1} link
    regsub L: $link {} link
    statusbar putMessage $link
}

#####################################################################
#### linkHitSubWindow
# Process a link hit in a subwindow.
#
body ::tycho::HTML::linkHitSubWindow {subwindow} {
    eval HMlink_hit $itk_component(text) \
            [lrange [$itk_component(text) bbox $subwindow] 0 1]
}

#####################################################################
#### newbrowser
# Open up a new browser (through middle mouse button)
#
body ::tycho::HTML::openNewBrowser {win x y} {
    set point {}    ;# Take care of case of "#link"

    # Find out the link name based on x and y
    set tags [$win tag names @$x,$y]
    set filename [lindex $tags [lsearch -glob $tags L:*]]
    # regsub -all {[^L]*L:([^ ]*).*}  $tags {\1} filename
    regsub L: $filename {} filename

    # The following is needed frequently because johnr refuses to
    # add more intelligence to [tycho::url join]
    #
    # This routine is the same as the one in hyperJump
    if {[regexp {^#(.*)} $filename _ point]} {
        # Case of same link using "#link" tag
        set filename [filename]
    } elseif {    [::tycho::url pathtype $filename] == "absolute" && \
            [::tycho::url protocol $filename] != ""} {
        # Case when we go from http to http absolute (and join is stupid)
        set filename $filename
    } elseif {[string match \$* $filename] || [string match ~* $filename]} {
        # if it begins $PTOLEMY, $TYCHO, ~eal, etc.
        set image [::tycho::expandPath $filename]
    } else {
        set filename [::tycho::url join \
                [::tycho::url dirname [filename]] $filename]
    }

    # Forward routine-- we need to make sure that the filename is correct.
    # This is due to the fact that openContext doesn't check whether the
    # file is correct or not. Therefore, we want to make sure we pass
    # the right filename to openContext.
    #
    # This routine is the same as the one in hyperJump
    set ext [::tycho::url extension $filename]
    set contenttype [::tycho::resource contenttype $filename]
    if {   ([string match "text/html" $contenttype] || \
            [isAnImageFileExtension $ext]) && \
            [displayer] != {}} {
        ::tycho::resource stat $filename tmpstat
        if {[info exists tmpstat(url)]} {
            set filename $tmpstat(url)
        }
    }

    set newbrowser [::tycho::File::openContext $filename]

    # If we need to jump to the point, jump.
    if {$point!={}} {
        # Need to catch in case the new browser is not HTML browser (ie.
        # text editor) and we are forced to hyperJump with wrong # of args.
        # after idle "catch \"$newbrowser hyperJump $filename [list $point] 1\""

	$newbrowser hyperJump $filename $point
    }
}

#####################################################################
#### openSource
# Open the source file using an editor specialized for editing HTML.
#
body ::tycho::HTML::openSource {} {
    # Pass openContext the "edithtml" mode to make it open the
    # same file in another mode
    ::tycho::openContext [filename] edithtml
}

#####################################################################
#### print
# Print the selection or, if there is no selection, the entire contents.
# At the moment, this first warns the user that it is not fully implemented,
# querying him or her to see whether to proceed.  Then, it
# queries the user for the print command to use.  A temporary file is
# created and then deleted to do the printing.  The name of that file
# will be appended to the end of the command specified by the user before
# it is invoked.
#
body ::tycho::HTML::print {} {
    if [safeEval ::tycho::askuser {Printing HTML is not fully implemented. \
            A fairly crude facsimile of the text only will be printed. \
            Proceed?}] {
        ::tycho::Edit::print
    }
}

#####################################################################
#### progress
# output the current progress of rendering. This is more
# important than the status of a download of a particular
# file because user cares about the entire HTML progress,
# not individual files.
#
body ::tycho::HTML::progress {} {
    if !$isrendering {
        return 1
    } else {
        # putStatus [uplevel #0 \[set HMrender_progress([component text])\]]"
        # after idle "$this progress"
        expr [uplevel #0 set HMrender_progress([component text])] \
                / double($currentHTMLLength)
    }
}

#####################################################################
#### reload
# Reload from the last saved version of the current file. This method
# first disables read-only status (if it is set), then replaces the
# current data with data from the current file, and then sets read-only
# status. The data is marked unmodified after loading the file, and the
# clipboard is restored to its form prior to the reload. The actual
# replacement of the data occurs via the method
# <code>insertData</code>.
#
body ::tycho::HTML::reload {} {
    set filename [filename]
    
    # Here's a nasty little hack in order to display download
    # progress: if the file is remote, start a progress display
    # and then open the file in order to force a download.
    # FIXME: Should do a read as well, since some protocols
    # may not download until read. Leave this until Tcl8.0
    # so it will work with binary data too.
    if [::tycho::resource isremote $filename] {
        set obj [::tycho::resource new $filename]
        statusbar progress \
                "[string toupper [::tycho::url protocol $filename]] Download" \
                "$obj progress"
        $obj open "r"
        $obj close
    }

    # Handle Image files specially
    set ext [::tycho::url extension $filename]
    if [isAnImageFileExtension $ext] {
        clear
        insertData \
                "<img src=\"$filename\" alt=\"$filename\">"
    } else {
        ::tycho::File::reload
    }
    # Mark read-only to prevent modifications.
    configure -readonly 1
}

#####################################################################
#### seeFragment
# Goto the specified hypertext reference, line number, or range.
# The <i>point</i> argument can take any of three forms:
# <pre>
#    {line <i>linenumber</i>}
#    {range <i>startindex endindex</i>}
#    {yview <i>fraction</i>}
#    <i>name</i>
# </pre>
# In the first three forms, the point is a list beginning with the keyword
# "line", "range", or "yview".  If the point has neither of these forms, then
# it is interpreted as the name of named anchor in the HTML file.
# In all cases, the background color of the matching text is changed
# temporarily.  Notice that this will not be visible if the "range" form
# is used and the two indices are equal.  As a side effect, the selection
# (if there is one) is cleared.
#
# Note that when moving from one point to another in the same HTML
# file, this method may sometimes appear not to do anything. This
# is because the method only makes the point visible, rather than
# moving it to the top of the window as, say, Netscape does. This
# should perhaps be altered.
#
body ::tycho::HTML::seeFragment {point} {
    set text $itk_component(text)
    if {[llength $point] == 2 && [lindex $point 0] == {line}} {
        # First form: A line number.
        set ln [lindex $point 1]
        set sidx [$text index "$ln.0"]
        set eidx [$text index "$ln.0 lineend +1 char"]
    } elseif {[llength $point] == 3 && [lindex $point 0] == {range}} {
        # Second form: A range of indexes
        set sidx [lindex $point 1]
        set eidx [lindex $point 2]
    } elseif {[llength $point] == 2 && [lindex $point 0] == {yview}} {
        # Third form: a yview spec.
        $text yview moveto [lindex $point 1]
        return
    } {
        # Third form: a named anchor.
        ::tycho::safeUpdate $prefix
        HMgoto $text $point
        return
    }
    if {$sidx != {} && $eidx != {}} {
        # If rendering is in progress, the point may not exist yet.
        if {[$text compare $sidx >= end]} {
            if {$seecount < 40} {
                incr seecount
                after 400 [code evalIfExists $this seeFragment $point]
                return
            } {
                # Give up.  Probably point will never be visible.
                set sidx end
                set eidx end
            }
        }
        set seecount 0
	$text tag add hypertarget $sidx $eidx
	$text tag configure hypertarget \
		-background [stylesheet get text targetColor]
	$text tag configure hypertarget \
		-foreground black
	component text mark set insert $sidx; 	\
                selection clear -displayof $text; $text see insert
        after 8000 [list catch \
               [list $text tag delete hypertarget]]
    }
}

#####################################################################
#### isSlowNetwork
# Return 1 if the slowNetwork preference is set and the -image itk_option
# is null.  If -image is set, then we assume the user really does want
# to see the image.
#
body ::tycho::HTML::isSlowNetwork {} {
    if {$itk_option(-image) != 0 } { 
	return 0
    } else {
	return [stylesheet get system slowNetwork]
    }
}

#####################################################################
#### stopRendering
# Stop the rendering.  This simply disables the HMrender proc by
# setting a flag that causes HMrender to return immediately without
# doing anything.
#
body ::tycho::HTML::stopRendering {} {
    # The HTML library version 0.3 has a bug where HMset_state win -stop 1
    # does not properly set the stop bit in the control array.  So
    # instead, we set it directly.
    # HMset_state [textWinName] -stop 1
    upvar #0 $stateArrayName var
    set var(stop) 1
}

#####################################################################
#### textWinName
# Return the full path name of the text widget. Note that this path
# name is defined as a command at the global scope. This is intended
# only to be used for interfacing to legacy Tcl/Tk code that interacts
# directly with a Tk text widget. A null string is returned if for some
# reason the text window name does not exist (due to an error in
# construction).
#
body ::tycho::HTML::textWinName {} {
    if [info exists itk_component(text)] {
	return $itk_component(text)
    } {
	return {}
    }
}

#####################################################################
#### upSize
# Increase the font size in the current widget.
# Redefined from ::tycho::Edit
#
body ::tycho::HTML::upSize {} {
    if {$fontOffset > 0} {
        set fontOffset [expr ($fontOffset / 2) + 1 + $fontOffset]
    } else {
        incr fontOffset 2
    }        
    HMset_state [textWinName] -size $fontOffset
    render $this
}

    ###################################################################
    ###################################################################
    ####                      public procedures                    ####

#####################################################################
#### render
# Render the given HTML text in the given <code>HTML</code> window.
# If the given HTML text is not given or is a null string, then use the
# value of the data previously given with the insertData{} method for
# the given object as the text.
# This is a procedure rather than a method because the object it operates
# on may be destroyed during the rendering process.  It should be invoked
# in the background, using "after", not in the constructor!
# Otherwise, the constructor does not complete until rendering is
# finished.  Moreover, the "update" calls in the rendering are dangerous
# in a constructor.
#
body ::tycho::HTML::render {obj {html {}}} {
    if {[infoObjects $obj] == {} || ![$obj isa ::tycho::HTML]} {
	return
    }
    if {$html == {}} {
        set html [$obj getCurrentHTML]
    }
    # Cancel previous rendering if necessary.
    if [$obj isRendering] {
        $obj stopRendering
        # Allow some time for rendering to complete.
        after 100 [list ::tycho::HTML::render $obj $html]
        return
    }

    $obj setRendering 1

    # Get the name of the Tk text widget.
    set tktext [$obj textWinName]
    $tktext configure -state normal
    
    # Remove all existing text in the widget.
    $tktext delete 1.0 end

    # Put the insertion cursor at the top
    $tktext mark set insert 1.0
    $tktext mark gravity insert left

    HMreset_win $tktext

    # Start the progress display. This has to use a global array because
    # the HMrender is not in the context of this class.
    uplevel #0 "set HMrender_progress($tktext) 0"
    $obj statusbar progress "HTML Rendering" "$obj progress"
    ::tycho::safeUpdate $obj

    # Remove HTML comments. This will barf on nested comments
    # (are they legal anyway?)
    set filtered {}
    while { [regexp -indices {<!--} $html idx] } {
        append filtered [string range $html 0 [expr [lindex $idx 0] - 1]]
        set html [string range $html [lindex $idx 1] end]
        if ![regexp -indices -- {-->} $html idx] {
            break
        }
        set html [string range $html [expr [lindex $idx 1] + 1] end]
    }
    append filtered $html
    set html $filtered

    # Note that the following parsing operation results in many
    # calls to update, which can result in the widget $this being destroyed.
    HMparse_html $html "HMrender $tktext"

    # The catch is in case the object no longer exists
    catch {
	$obj setRendering 0
    }

    # FIXME: The following removes the insertion cursor, which
    # is good, but disables all the navigation bindings, which
    # is bad.  Perhaps those bindings can be redone in the
    # HTML class.
    # $tktext configure -state disabled
}


#########################################################################
#########################################################################
####                    protected methods                            ####

#####################################################################
#### _initializeBars
# Initialize the menu, status, and toolbars associated with this widget.
# If any of these arguments is null, the associated bar does not
# exist and must be ignored. This method is called from within
# the attachDisplayer{} method.
#
body ::tycho::HTML::_initializeBars {menubar statusbar toolbar} {
    chain $menubar $statusbar $toolbar
     
    if {$toolbar != {}} {
        # We have to qualify the call to this supposed-ly private
        # method because Itcl (2.2) has virtual private methods!
        ::tycho::HTML::_initializeToolbar $toolbar
    }      

    # Modify the menu commands appropriately.
    if {$menubar != {}} {
        # We have to qualify the call to this supposed-ly private
        # method because Itcl (2.2) has virtual private methods!
        ::tycho::HTML::_initializeMenubar $menubar
    }

    configure -readonly 1

    # Disable auto-save.
    configure -save 0
}

#####################################################################
#### configureContextMenu
# Configure the popup menu according to context. For HTML viewers, this
# looks for a corresponding itcl file and offers to open that if it
# finds one.
#
body ::tycho::HTML::configureContextMenu {} {
    ::tycho::TWidget::configureContextMenu

    if { $itk_option(-file) != "" && $itk_option(-file) != "NoName" } {
	set link [::tycho::url split $itk_option(-file)]
	set path [lrange $link 0 [expr [llength $link] - 4]]
	set fname [join [concat \
		[lreplace [split [lindex $link end] .] end end] "itcl"] .]
	set link [eval ::tycho::url join $path $fname]

	if { [::tycho::resource exists $link] } {
	    contextmenu add "Open source" \
		    -command "$this hyperJump $link"
	}
    }
}

#########################################################################
#########################################################################
####                     private methods                             ####

#####################################################################
#### _initializeMenubar
# Initialize the menu bar.  Adds entries specific to this class.
#
body ::tycho::HTML::_initializeMenubar {menubar} {
    # Remove items from File
    $menubar delete reload
    $menubar delete switchfile
    $menubar delete togglereadonly
    $menubar delete revisioncontrol
    $menubar delete gotoline
    $menubar delete insert
    $menubar delete save
    $menubar delete evaluate
    $menubar delete compareto
    $menubar delete filesep2

    # Remove items from Edit
    $menubar delete undoredo
    $menubar delete editsep1

    # Leave but disable
    $menubar disable cut
    $menubar disable paste

    # Remove the Format menu altogether
    $menubar delete format

    $menubar insert command opensource saveas \
	    -label "Open Source" \
            -underline 5 \
            -accelerator [::tycho::Shortcuts::getLabel OpenSource] \
            -command "$this openSource"

    # Delete entire Format menu
    $menubar delete Format

    # Setup Special menu
    $menubar separator specialsep1 special
    $menubar command appletviewer special \
	    -label "Appletviewer" \
            -underline 0 \
            -command "$this appletViewer"
    global tcl_platform
    if {$tcl_platform(platform) == "macintosh"} {
        $menubar disable appletviewer
    }
}

#####################################################################
#### _initializeToolbar
# Initialize the tool bar.  Adds entries specific to this class.
#
body ::tycho::HTML::_initializeToolbar {toolbar} {
    # Add buttons to the toolbar, if it exists.
    # Also add bindings to the text window.
    set text $itk_component(text)
    
    $toolbar button back \
	    -description {Go back to the previously-viewed page} \
            -underline 0 \
            -text Back -command "$this back" -state disabled
    bind $text <Key-b> "$this back; break"
    
    $toolbar button forward \
	    -description {Go forward to the next previously-viewed page} \
            -underline 3 \
            -text Forward -command "$this forward" -state disabled
    bind $text <Key-w> "$this forward; break"
    
    global ::TYCHO
    
    $toolbar button home \
	    -description {Go to the Tycho home page} \
            -underline 0 \
            -text Home -command "$this hyperJump \
	    [::tycho::url join \$TYCHO doc index.html]"
    bind $text <Key-h> "$this hyperJump \
	    [::tycho::url join \$TYCHO doc index.html]; break"
    
    $toolbar button reload \
            -description {Reload and reparse from the file} \
            -underline 0 \
            -text Reload -command "$this reload"
    bind $text <Key-r> "$this reload; break"

    # FIXME: The following is a hack into the toolbar because it doesn't
    # support the SHIFT-B1 binding... just simple button.
    catch {
        bind $toolbar.buttonsite.inside.buttonreload <Shift-Button-1> \
                "::tycho::ResourceRemote::initialize"
        bind $toolbar.buttonsite.inside.buttonreload <Control-Button-1> \
                "::tycho::ResourceRemote::initialize"
    }
    
    $toolbar button open \
	    -description {Open a new file} \
            -underline 0 \
            -text Open -command "$this altFile"
    bind $text <Key-o> "$this altFile; break"
    bind $text <<Open>> "$this altFile; break"

    $toolbar button find \
	    -description {Find text or a pattern on this page} \
            -underline 0 \
            -text Find -command "$this search"
    bind $text <Key-f> "$this search; break"
    bind $text <Find> "$this search; break"
    bind $text <<Find>> "$this search; break"
    bind $text <<Search>> "$this search; break"

    $toolbar button stop \
	    -description {Abort rendering} \
            -underline 0 \
            -text Stop -command "$this stopRendering"
    bind $text <Key-s> "$this stopRendering; break"

    # Add the entry widget displaying the current page
    $toolbar entry location Location [filename] "$this hyperJumpUser"

    # Make sure that Alt-key still brings up the menus, rather than
    # triggering one of the bindings above.
    # Formerly, we disabled bindings for control keys, but
    # this means that under Windows, Control-f will not bring up
    # the search window.
    foreach key {b w h r o f s} {
        bind $text <Alt-Key-$key> { }
        #bind $text <Control-Key-$key> { }
    }
}

#####################################################################
#### pushNextHTMLFile
#
body ::tycho::HTML::pushNextHTMLFile {} {
    # Clear windows from this one ahea
    if { [llength $stack] > [expr $stackpos + 1] } {
        set stack [lreplace $stack $stackpos end]
    }

    # Set this one again, updating with the current point
    lappend stack [list [filename] [currentPoint]]

    # Move the stack pointer up
    incr stackpos

    # Disable the "forward" button, enable the "back" button
    toolbar disable forward
    toolbar enable back
}

#####################################################################
#### isAnImageFileExtension
# Return 1 if the extension is the extension of an image file.
#
body ::tycho::HTML::isAnImageFileExtension {ext} {
    # Make sure extension is case insensitive
    return [expr {([regexp -nocase "^.gif" $ext] || \
            [regexp -nocase "^.ppm" $ext] || \
            [regexp -nocase "^.pgm" $ext] || \
            [regexp -nocase "^.xbm" $ext] || \
            [regexp -nocase "^.jpg" $ext] || \
            [regexp -nocase "^.jpeg" $ext]) && [displayer]!={} }]
}


    ##################################################################
    ###################################################################
    ####         modifications to the HTML library                 ####

# Instead of blindly inserting newlines, as done in the original
# library, we only insert them if they are not already there.
# The following table indicates how many newlines are desired
# by the tag. It replaces "HMinsert_map" in the original library.

array set HMinsert_space_map {
	blockquote 2 /blockquote 1
	br	1
	dd	1 /dd	1
	dl	1 /dl	1
	dt	1
	form 1	/form 1
	h1	2	/h1	2
	h2	2	/h2	2
	h3	2	/h3	2
	h4	2	/h4	2
	h5	1	/h5	1
	h6	1	/h6	1
	li   1
	/dir 1
	/ul 1
	/ol 1
	/menu 1
	p	2
	pre 1	/pre 2
}

array set HMparam_map {
    -foreground S_fgcolor
    -background S_bgcolor
}

#######################################################################
# The following empty procedures prevent calls to "unknown", which
# is very expensive.  This makes the HTML parser significantly faster.

foreach tag {
    !-- a address applet author b banner
    base big blockquote body br caption center
    cite code dd dfn div dl dt em form h1 h2 h3 h4 h5 h6 head hr
    html i img input isindex kbd li link map meta ol option p param
    pre samp script select small strike strong style sub sup table
    td textarea th title tr tt u ul var
    /a /address /applet /author /b /banner /big /blockquote /body /caption
    /center /cite /code /dfn /div /dl /em /form /h1 /h2 /h3
    /h4 /h5 /h6 /head /html /i /kbd /map /ol /p /pre /samp /select
    /small /strike /strong /sub /sup /table /textarea /title /tt /u /ul /var
} {
    if {[info proc HMtag_$tag] == {}} {
        proc HMtag_$tag {win param text} {}
    }
}

#######################################################################
#### HMcurrent_tags
# extract set of current text tags
# tags starting with T map directly to text tags, all others are
# handled specially.  There is an application callback, HMset_font
# to allow the application to do font error handling.
# Modified by EAL for greater efficiency.  Avoid calls that set
# fonts or get fonts if they've occurred before.
#
proc HMcurrent_tags {win} {
    upvar #0 HM$win var

    set family [lindex $var(family) end]
    set size [lindex $var(size) end]
    set weight [lindex $var(weight) end]
    set style [lindex $var(style) end]
    set S_adjust_size [lindex $var(S_adjust_size) end]
    set font "font:$family:$size:$weight:$style:$S_adjust_size"

    # Avoid repeatedly configuring the same font tag.
    global HMfont_tag_done
    if ![info exists HMfont_tag_done($win$font)] {
        set xfont [HMx_font $family $size $weight $style $S_adjust_size]
        HMset_font $win $font $xfont
        set HMfont_tag_done($win$font) $xfont
    } {
        set xfont $HMfont_tag_done($win$font)
    }
    set indent [llength $var(indent)]
    incr indent -1
    lappend tags $font indent$indent
    foreach tag [array names var T*] {
        lappend tags [lindex $var($tag) end]
    }
    set var(font) $font
    set var(xfont) $xfont
    set var(level) $indent
    return $tags
}

#######################################################################
#### HMextract_param
# Modify Uhler's implementation
# to not get confused by the presense of the keyword in a value.
#
# extract a value from parameter list (this needs a re-do)
# returns "1" if the keyword is found, "0" otherwise
#   param:  A parameter list.  It should alredy have been processed to
#           remove any entity references
#   key:    The parameter name
#   val:    The variable to put the value into (use key as default)

proc HMextract_param {param key {val ""}} {
    if {$val == ""} {
        upvar $key result
    } else {
        upvar $val result
    }
    set ws "    \n\r"
    
    # look for name=value combinations.  Either (') or (") are
    # valid delimiters    (for emacs highlighting) ;#"
    if {[regsub -nocase [format {.*%s[%s]*=[%s]*"([^"]*).*} $key $ws $ws] \
            $param {\1} value] ||
    [regsub -nocase [format {.*%s[%s]*=[%s]*'([^']*).*} $key $ws $ws] \
            $param {\1} value] ||
    [regsub -nocase [format {.*%s[%s]*=[%s]*([^%s]+).*} $key $ws $ws $ws] \
            $param {\1} value] } {
        set result $value
        return 1
    }

    # now look for valueless names
    # I should strip out name=value pairs, so we don't end up with "name"
    # inside the "value" part of some other key word - some day
    
    set bad \[^=a-zA-Z\]+
    # NOTE: Fixed to ignore if there is an "=".  EAL
    # FIXME: There is a case where this will fail.  If you have
    # <tag key1=value key2>, where key2 is valueless tag, the valueless
    # tag will not be identified.
    if {[regexp -nocase  "^\[^=\]*$bad$key$bad" -$param-]} {
        return 1
    } else {
        return 0
    }
}

#######################################################################
#### HMgoto
# Modify Uhler's implementation
# to support names with spaces and to make it more robust.
#
# The application should call here with the fragment name
# to cause the display to go to this spot.
# If the target exists, go there (and do the callback),
# otherwise schedule the goto to happen when we see the reference.
#
proc HMgoto {win where {callback HMwent_to}} {
    upvar #0 HM$win var

    # Note that javadoc produces tags like NamedObj(java.lang.String)
    # which contains the magic symbols: ( and ),
    # so we can't use regexp or string match, we must use lsearch -exact
    if {[lsearch -exact [$win mark names] "N:$where" ] != -1} {
	catch {$win see "N:$where"}
        update
	eval $callback $win [list $where]
	return 1
    } else {
	set var(goto) $where
	return 0
    }
}

#######################################################################
#### HMinit_state
# initialize the window's state array
# Parameters beginning with S_ are NOT reset
#  adjust_size:		global font size adjuster
#  unknown:		character to use for unknown entities
#  tab:			tab stop (in cm)
#  stop:		enabled to stop processing
#  update:		how many tags between update calls
#  tags:		number of tags processed so far
#  symbols:		Symbols to use on un-ordered lists
#  bgcolor:             The background color.
#  fgcolor:             The foreground color.
#
proc HMinit_state {win} {
    upvar #0 HM$win var
    array set tmp [array get var S_*]
    catch {unset var}
    array set var {
        stop 0
        tags 0
        fill 0
        list list
        S_adjust_size 0
        S_tab 1.5
        S_unknown \xb7
        S_update 10
        S_symbols O*=+-o\xd7\xb0>:\xb7
        S_insert HTMLInsert
        linkfg blue
        dlindent 0
    }
    set var(S_bgcolor) [$win cget -background]
    set var(S_fgcolor) [$win cget -foreground]
    array set var [array get tmp]
    set var(bgcolor) $var(S_bgcolor)
    set var(fgcolor) $var(S_fgcolor)
}

#######################################################################
#### HMlink_callback
# Override the HTML library definition for the hyperlink callback
# function. File/Resource now have support for remote files.
# Files and names within a file work perfectly.
#
# If the window lies within an HTML widget, and the 
# link is to another HTML file, then we reuse the same
# window to display the referenced file. Otherwise, we open a new
# window.
#
proc HMlink_callback {win href} {
    if {![winfo exists $win]} {return}

    # Get the name of the HTML widget.
    set HTML [uplevel #0 winfoCommand [winfoMegawidget $win]]

    # NOTE: https is secure HTTP, which we don't support.
    if [regexp -nocase {^gopher:|^news:|^telnet:|^wais:|^https:} $href] {
	if ![::tycho::askuser "OK to invoke netscape to view $href?"] {
            # The user said no, so just return
            return
        } {
            # The user said yes
            global tcl_platform
	    switch $tcl_platform(platform) {
                unix {
                    if [catch \
		        {::tycho::tyexec netscape -remote openURL($href) &} \
			    errMsg] {
			::tycho::ErrorMessage .netscapeError -text $errMsg
			wm deiconify .netscapeError
		    }
		}
                windows {
		    # FIXME: It would be nice if we could open up
		    # a URL in a windows netscape without restarting netscape
		    # each time, but this requires 
		    # DDE or OLE.  For more info, search the Netscape
		    # website for 'openURL', or look at
		    # http://home.netscape.com/newsref/std/x-remote.html
                    if [catch {::tycho::tyexec netscape $href &} errMsg] {
                        ::tycho::ErrorMessage .netscapeError -text $errMsg
                        wm deiconify .netscapeError
                    }
                }
		default {
                    ::tycho::ErrorMessage .netscapeError -text \
                            "Sorry, exec is not supported on the \
			    $tcl_platform(platform) platform."
                    wm deiconify .netscapeError
		}
	    }
            return
	}
    }

    if {![regexp {(file:)?([^#]*)#(.+)} $href dummy noise file fragment]} {
	regexp {(file:)?([^#]*)} $href dummy noise file
	set fragment {}
    }

    # Got a reference to a file (or if file == {}, a local point).
    uplevel #0 [list $HTML hyperJump $file $fragment]
}
###########################################
#### HMparse_html
# Turn HTML into TCL commands
#   html    A string containing an html document
#   cmd		A command to run for each html tag found
#   start	The name of the dummy html start/stop tags
#
# The only difference from the original HMparse_html is that we
# substitute backslashes
#
proc HMparse_html {html {cmd HMtest_parse} {start hmstart}} {
	regsub -all \{ $html {\&ob;} html
	regsub -all \} $html {\&cb;} html
        # substitute backslashes 
	regsub -all {\\} $html {\&#92} html

	set w " \t\r\n"	;# white space
	proc HMcl x {return "\[$x\]"}
	set exp <(/?)([HMcl ^$w>]+)[HMcl $w]*([HMcl ^>]*)>
	set sub "\}\n$cmd {\\2} {\\1} {\\3} \{"
	regsub -all $exp $html $sub html
	eval "$cmd {$start} {} {} \{ $html \}"
	eval "$cmd {$start} / {} {}"
}
#######################################################################
#### HMrender
# HMrender gets called for every html tag
#   win:   The name of the text widget to render into
#   tag:   The html tag (in arbitrary case)
#   not:   a "/" or the empty string
#   param: The un-interpreted parameter list
#   text:  The plain text until the next html tag
# If the tag has an entry in the HMtag_map, then that entry is used
# to change the state (font, size, etc.).  If there is a
# procedure called HMtag_$tag, then that procedure is invoked.
#
proc HMrender {win tag not param text} {
    # Update the count used to track current progress.
    # This is in a global array because this proc is global...
    uplevel #0 "set HMrender_progress($win) \
            \[expr \[set HMrender_progress($win)\] \
            + [string length "<> $tag $not $param $text"]\]"

    upvar #0 HM$win var
    if {$var(stop)} return
    global HMtag_map HMinsert_space_map HMlist_elements
    set tag [string tolower $tag]
    set text [HMmap_esc $text]
    
    # manage compact rendering of lists
    if {[info exists HMlist_elements($tag)]} {
        # NOTE: mod EAL.  Syntax error in the original.
        set list "list [expr {[HMextract_param $param compact] ? {compact} : {list}}]"
    } else {
        set list ""
    }
    
    # adjust (push or pop) tag state
    if [info exists HMtag_map($tag)] {
        HMstack $win $not "$HMtag_map($tag) $list"
    }
    
    set insert $var(S_insert)
    # insert white space (with current font).  NOTE: modified by EAL.
    if [info exists HMinsert_space_map($not$tag)] {
        set ins $insert
        # Skip if we are the top of the widget.
        if ![$win compare $ins == 1.0] {
            set spaces $HMinsert_space_map($not$tag)
            for {set ind $spaces} {$ind > 0} {incr ind -1} {
                set curline [$win get "$ins linestart" "$ins lineend"]
                if [regexp {^[ 	]*$} $curline] {
                    # If there is an embedded window, the line is not blank.
                    if {[$win dump -window "$ins linestart" "$ins lineend"] \
                            == {}} {
                        incr spaces -1
                    }
                } {
                    break
                }
                set ins [$win index "$ins -1 line"]
            }
            while {$spaces > 0} {
                incr spaces -1
                $win insert $insert "\n" "space $var(font)"
            }
        }
    }
    # If we are in fill mode, trim the text.
    if [lindex $var(fill) end] {
        # If the current line contains only spaces, remove them.
        set curline [$win get "$insert linestart" "$insert lineend"]
        if [regexp {^ *$} $curline] {
            # Check for embedded windows
            if {[$win dump -window "$insert linestart" "$insert lineend"] \
                    == {}} {
                $win delete "$insert linestart" "$insert lineend"
            }
        }
        if [$win compare $insert == "$insert linestart"] {
            set text [string trimleft $text]
        }
        set text [HMzap_white $text]
    }
    
    # generic mark hook
    # NOTE: mod EAL
    # catch {HMmark $not$tag $win $param text} err
    
    # do any special tag processing
    # Need a ignore unrecognized HTML tags.  Here we check explictly.
    # Could use a catch alternatively, but that tends to hide errors.
    # FIXME: Change to a catch for release.
    if {[info proc HMtag_$not$tag] != {}} {
        HMtag_$not$tag $win $param text
    }
    
    # add the text with proper tags
    set tags [HMcurrent_tags $win]
    $win insert $var(S_insert) $text $tags
    
    # We need to do an update every so often to insure interactive response.
    # This can cause us to re-enter the event loop, and cause recursive
    # invocations of HMrender, so we need to be careful.
    if {!([incr var(tags)] % $var(S_update))} {
        update
    }
}

#######################################################################
#### HMset_image
# An image callback function, called by the HTML library when it encounters
# and image. Read in an image if we don't already have one and
# call back to library for display.
#
# HMtag_image calls this and passes a label as the handle.
# This function in turn calls HMgot_image
#
proc HMset_image {win handle src} {
    # Get the name of the HTML widget.
    set HTML [uplevel #0 info command [winfoMegawidget $win]]

    # If the slowNetwork misc preference is set, then don't display images.
    if {![$HTML isSlowNetwork]} {
        # Process the image given absolute&&remote path
        if {    [::tycho::url pathtype $src] == "absolute" && \
                [::tycho::url protocol $src] != ""} {
            set image $src
        } elseif {[string match \$* $src] || [string match ~* $src]} {
            # if it begins $PTOLEMY, $TYCHO, ~eal, etc.
            set image [::tycho::expandPath $src]
        } else {
            set image [::tycho::url join \
                    [uplevel #0 $HTML lastDirectory] $src]
        }

        # There is an update here so that the alt= text provided
	# for an image is displayed while the image is being converted.
	# Note that we use the safeUpdate procedure to ensure that the
	# widget still exists after this call returns.
        ::tycho::safeUpdate $HTML
        if {[string first " $image " " [image names] "] >= 0} {
            HMgot_image $handle $image
        } else {
            set ext [string tolower [::tycho::url extension $image]]
            set type photo
            if {$ext==".bmp" || $ext==".xbm"} {set type bitmap}
            # FIXME: The following is hacked because JPG isn't supported
            if {$ext==".jpg" || $ext==".jpeg"} {
                # when we don't have the "convert" utility, catch.
                catch {
                    # Fetch the file remotely if necessary, and cache on disk.
                    set oldcachefile [::tycho::resource cachefile $image]
                    set ext [string tolower \
                            [::tycho::url extension $oldcachefile]]
                    # If the cache has not been remapped to a GIF file,
                    # then convert, then remap.
                    if {$ext==".jpg" || $ext==".jpeg"} {
                        # Take out extension (.jpg, .jpeg, etc)...
                        regsub [::tycho::url extension $oldcachefile] \
                                $oldcachefile {} newcachefile
                        set newcachefile "$newcachefile.gif"
                        eval exec convert -quality 5 $oldcachefile $newcachefile
                        #file delete $cachefile
                        if ![::tycho::cache remap $image $newcachefile] {
                            error "Remapping error"
                        }
                    }
                }
            }
            
            # Put the image creation in a catch in case of 
            # unknown image type or corrupt image file.
            if { ! [catch {image create $type $image -file \
                    [::tycho::resource cachefile $image]} image] } {
                # If successful, load the image
                HMgot_image $handle $image
            }
	}
    }
}

#######################################################################
#### HMstack
# Push or pop tags to/from stack.
# Each orthogonal text property has its own stack, stored as a list.
# The current (most recent) tag is the last item on the list.
# Push is {} for pushing and {/} for popping.
# Fixed by EAL to not fail on popping empty stack.
#
proc HMstack {win push list} {
    upvar #0 HM$win var
    array set tags $list
    if {$push == ""} {
        foreach tag [array names tags] {
            lappend var($tag) $tags($tag)
        }
    } else {
        foreach tag [array names tags] {
            catch {set var($tag) [lreplace $var($tag) end end]}
        }
    }
}

#######################################################################
#### HMtag_applet
# If we are running tycho -java, then start up an AppletFrame with the 
# applet
# 
# This code is modified from the body code for"surfit".
#
proc HMtag_applet {win param text} {
    upvar #0 HM$win var
    global tyjavapresent appletFrame
    set name ""
    HMextract_param $param name
    HMextract_param $param code
    HMextract_param $param codebase
    HMextract_param $param width
    HMextract_param $param height

#    puts "HMtag_applet [info exists tyjavapresent] param='$param'\n\
#            name='$name' code='$code' codebase='$codebase' width='width' \
#            height='$height'"

}

#proc HMtag_/applet {win param text} {
#    if { "$name" != "" && [info exists tyjavapresent] } {
#	if [catch {set appletFrame [::java::new TclAppletFrame \
#		[::tycho::autoName .appletFrame]] } errMsg] {
#	    puts "::java::new failed to create a TclAppletFrame:\n$errMsg"
#            return
#	}
#
#	if [catch {$appletFrame run $name} errMsg] {
#	    puts "Failed to run applet $name\n$errMsg"
#	}
#    }
#}

#proc HMtag_param {win param text} {
#    HMextract_param $param name
#    HMextract_param $param value
#    puts "HMtag_param name='$name' value='$value'"
#
#}

#######################################################################
#### HMtag_body
# This code is modified from "surfit".
# HTML 3.2 introduces various attributes for the BODY tag.
# BACKGROUND (Tk 4.1 cannot support this), BGCOLOR, TEXT, LINK, VLINK, ALINK
#
proc HMtag_body {win param text} {
    upvar #0 HM$win var
    if {[HMextract_param $param bgcolor]} {
        set color [::tycho::color $bgcolor grey]
        $win configure -background $color
        set var(bgcolor) $color
        # Make the insertion cursor invisible
        $win configure -insertbackground $color
    }
    
    set savetext $text
    if {[HMextract_param $param text]} {
        set color [::tycho::color $text black]
        $win configure -foreground $color
        set var(fgcolor) $color
    }
    set text $savetext

    if {[HMextract_param $param link]} {
        set color [::tycho::color $link blue]
        set var(linkfg) $color
        $win tag configure link -foreground $color
    }
}

#######################################################################
#### HMtag_color
# This proc is directly from Stephen Uhler's sample, with only slight
# modifications. A new HTML tag, inserted just for fun. Change the
# color of the text. Use HTML tags of the form: <color value=blue> ...
# </color> The color has lower priority than all other tags.
# NOTE: This is not standard HTML.  Use <font color=foo> instead.
#
proc HMtag_color {win param text} {
	set value black
	HMextract_param $param value
	set value [::tycho::color $value black]
	$win tag configure $value -foreground $value
	$win tag lower $value
	HMstack $win "" "Tcolor $value"
}

proc HMtag_/color {win param text} {
	HMstack $win / "Tcolor {}"
}

# If you mess with the dl code, make sure that the javadoc output looks ok.
# See also $TYCHO/kernel/html/test/dltest.html
#
# Here's a summary of how the HTML dl code works.  This is a little
# long winded, but this code is very tricky.
#
# The variable HM$win is an array of stacks.  
# The indent is saved on a stack and gets pushed and popped depending
# on the level of indentation. 
# HMstack $win {} "indent 1" pushes 1 onto the stack.
# HMstack $win / "indent 1" pops the current value off the stack
# To read the stack, do:
# upvar $0 HM$win var; puts $var(indent)
#
# The HTMLcurrent_tag proc sets level which is also saved in HM$win.
# In general, level is derived from the length of indent, which is a list.
# level and indent are tightly coupled, if you change one, you have to
# consider the other.  level is also used in 
# $TYCHO/lib/html_library/html_library.tcl
#
# sawdd is a flag that is set to 1 once we have seen a dd.  sawdd is
# used to increment the indentation only once in the case of multiple dds
#
# When we see a dl flag, we savethe value of the indent stack as 'dlindent',
# which is in turn a stack.  
# To determine the level of indentation when we get a dt, dd or /dl
# we copy the saved value into indent and act accordingly.
# For dt, we decrement the indent stack
# For dd, we increment if this is the first dd, otherwise we leave it be
# For dl, we decrement the indent stack, and pop the dl stack.
#

#######################################################################
#### HMtag_dl
# When we see a dl, we save the current indent stack, and set sawdd to 0.
#
proc HMtag_dl {win param text} {
    upvar #0 HM$win var
    # Save the current indent level on the stack.
    HMstack $win {} "dlindent [list $var(indent)]"

    # For some reason, level is not keeping up with changes to indent.
    # Get the new level.
    set level [llength $var(indent)]
    incr level -1
    set var(level) $level

    # sawdd is 1 if we've seen dd.
    set var(sawdd) 0
}

#######################################################################
#### HMtag_/dl
# When we see a /dl, we restore our saved stack and set level accordingly.
#
proc HMtag_/dl {win param text} {
    upvar #0 HM$win var
    upvar $text data

    # Set the current indent to the indent we saved when we saw dl
    set var(indent) [lindex $var(dlindent) end]

    # Get the new level.
    HMstack $win / "indent {}"
    set level [llength $var(indent)]
    incr level -1
    set var(level) $level

    # Pop the saved value off the stack, we are done with it.
    HMstack $win / "dlindent {}"

    $win insert $var(S_insert) "$data" \
            "hi [lindex $var(list) end] indent$level $var(font)"
    set data {}
}

#######################################################################
#### HMtag_dt
# Modify the original to permanently remove the indent introduced by
# tag_dl.
# Pop the indent stack, set sawdd to 0, output the data, and push
# the indent stack.
#
proc HMtag_dt {win param text} {
    upvar #0 HM$win var
    upvar $text data
    # When we see a dd, we will set sawdd to 1.
    set var(sawdd) 0

    # Set the current indent to the indent we saved when we saw dl.
    set var(indent) [lindex $var(dlindent) end]

    # Pop an the indent stack.
    # The depth of the indent is determined by depth of the "indent" stack.
    HMstack $win {/} "indent {}"

    # Get the new level.
    set level [llength $var(indent)]
    incr level -1
    set var(level) $level

    # Note that we might have blank data at this point, since we could
    # have '<dt> <b>  <b>', so we need to leave the indent set at
    # the right place.
    $win insert $var(S_insert) "$data" \
            "hi [lindex $var(list) end] indent$level $var(font)"
    set data {}
}

#######################################################################
#### HMtag_dd
# Modify the original to reinsert the indent removed by
# tag_dt.  This indent will be removed later by tag_/dd.
# If we have not yet seen a dd, then push the indent stack.
#
proc HMtag_dd {win param text} {
    upvar #0 HM$win var
    upvar $text data
    # FIXME: This is a hack since this is crashing on some web sites
    # Sometimes var(sawdd) doesn't even exist!
    if {![info exists var(sawdd)]} {set var(sawdd) 0}
    if {$var(sawdd) == 0} {
        # If we have not yet seen a dd, then indent one level.
        set var(sawdd) 1

        # Set the current indent to the indent we saved when we saw dl.
        set var(indent) [lindex $var(dlindent) end]

        # Get the new level
        set level [llength $var(indent)]
        incr level -1
        set var(level) $level

        # Push something onto the "indent" stack.
        # The value "1" is irrelevant, but some value is needed.
        # The depth of the indent is determined by depth of the "indent" stack.
        #HMstack $win {} "indent 1"
	#incr var(level) 

    }
    set level $var(level)
    $win insert $var(S_insert) "$data" \
            "hi [lindex $var(list) end] indent$level $var(font)"
    set data {}
}

#######################################################################
#### HMtag_font
# The following is modified from surfit.
#
proc HMtag_font {win param text} {
    upvar #0 HM$win var
    if {[HMextract_param $param size]} {
        HMstack $win "" "size [expr [lindex $var(size) end] + $size]"
    } else {
        HMstack $win "" [list size [lindex $var(size) end]]
    }
    if {[HMextract_param $param color]} {
        set color [::tycho::color $color black]
        HMstack $win "" "Tcolor color$color"
        $win tag configure color$color -foreground $color
    } else {
        HMstack $win "" [list Tcolor black]
    }
}

proc HMtag_/font {win param text} {
    upvar #0 HM$win var
    HMstack $win "/" [list size {}]
    HMstack $win "/" [list Tcolor black]
}

#######################################################################
#### HMtag_img
# Like the original HMtag_img, but we don't barf on align=right or left
# 
#           Inline Images
# This interface is subject to change
# Most of the work is getting around a limitation of TK that prevents
# setting the size of a label to a widthxheight in pixels
#
# Images have the following parameters:
#    align:  top,middle,bottom
#    alt:    alternate text
#    ismap:  A clickable image map
#    src:    The URL link
# Netscape supports (and so do we)
#    width:  A width hint (in pixels)
#    height:  A height hint (in pixels)
#    border: The size of the window border
#
proc HMtag_img {win param text} {
	upvar #0 HM$win var

	# get alignment
	array set align_map {top top    middle center    bottom bottom}
        # The spec isn't clear what the default should be
        set align bottom		
	HMextract_param $param align
        # Convert to small right now for later comparisons
        set align [string tolower $align]
	catch {set align $align_map($align)}

        # The following are attempts to skip functionalities that
        # have not been implemented in Tycho yet.

	# FIXME: we can't handle left or right alignment of images.
        # Actually we can't handle anything that not Tk native
        if {    $align!="baseline" && $align!="bottom" && \
                $align!="center" && $align!="top"} {
	    set align bottom
	}

	# get alternate text
	set alt "<image>"
	HMextract_param $param alt
	set alt [HMmap_esc $alt]

	# get the border width
	set border 1
	HMextract_param $param border

	# see if we have an image size hint
	# If so, make a frame the "hint" size to put the label in
	# otherwise just make the label
	set item $win.$var(tags)
	# catch {destroy $item}
        if {[HMextract_param $param width] && [HMextract_param $param height]} {
            # FIXME: we can't specify the width by %
            if {[regexp {([0-9]+)%$} $width _ new_width]} {
                set width $new_width
            }
            if {[regexp {([0-9]+)%$} $height _ new_height]} {
                set width $new_height
            }
            frame $item -width $width -height $height
            pack propagate $item 0
            set label $item.label
            label $label
            pack $label -expand 1 -fill both
	} else {
            set label $item
            label $label 
	}
	$label configure -relief ridge -fg orange -text $alt
	catch {$label configure -bd $border}
        $win window create $var(S_insert) \
                -align $align -window $item -pady 2 -padx 2

	# add in all the current tags (this is overkill)
	set tags [HMcurrent_tags $win]
	foreach tag $tags {
		$win tag add $tag $item
	}

        # Get the name of the HTML widget.
	set HTML [uplevel #0 info command [winfoMegawidget $win]]

        if { [$HTML isa ::tycho::View] == 1} {
            # Add a binding for links to display the destination.
            bind $label <Enter> "$HTML linkEnter {} {} $item"
            
            # If we don't have a <Motion> tag for the link, then if we
            # have several links stacked on top of each other
            # horizontally, the status bar
            # is not updated as we move the mouse from link to link
            bind $label <Motion> "$HTML linkEnter {} {} $item"
            bind $label <Leave> "$HTML statusbar putMessage {}"
            bind $label <1> "$HTML linkHitSubWindow $item"
        }

	# set imagemap callbacks
	if {[HMextract_param $param ismap]} {
		# regsub -all {[^L]*L:([^ ]*).*}  $tags {\1} link
		set link [lindex $tags [lsearch -glob $tags L:*]]
		regsub L: $link {} link
		global HMevents
		regsub -all {%} $link {%%} link2
		foreach i [array names HMevents] {
			bind $item <$i> "catch \{%W configure $HMevents($i)\}"
		}
		bind $item <1> "+HMlink_callback $win $link2?%x,%y"
	} 

	# now callback to the application
	set src ""
	HMextract_param $param src
	HMset_image $win $label $src
	return $label	;# used by the forms package for input_image types
}

#######################################################################
#### HMtag_menu
# Use a simple "-" rather than "->".
#
proc HMtag_menu {win param text} {
	upvar #0 HM$win var
	set var(menu) -
	set var(compact) 1
}

#######################################################################
#### HMtag_tcl {win param text} 
# Set up an extension to HTML in which the delimiters <tcl> ... </tcl>
# are understood to enclose a section of Tcl code. This code is
# highlighted in the document, and double clicking on it causes the enclosed
# Tcl code to be executed. The code is executed at the global scope.
# Normally, this tag will be used together with the standard <pre>...</pre>
# HTML tag to prevent the text from filling and wrapping.

proc HMtag_tcl {win param text} {

    upvar #0 HM$win var

    # Get the name of the HTML window and widget command.
    set HTML [uplevel #0 info command [winfoMegawidget $win]]

    set color [::tycho::stylesheet get text activeColor]
    $win tag configure tcl -foreground $color
    $win tag bind tcl <Double-Button-1> \
		"uplevel #0 $HTML execTcl %x %y; break"

    if {[HMextract_param $param quiet]} {
        set var(Ttclq) tclq
    }

    # If we have <tcl java> and java is not present in the binary,
    # then print a better error message if the user mouses on the tag
    # It would be nice if we could just not color the text, but all
    # tcl tags have the same color.
    if {[HMextract_param $param java]} {
        set var(Ttcljava) tcljava
    }

    # We used to reduce the size here to compensate for the
    # difference in size of Courier and Times fonts. Now that
    # the size is set by user preferences we let the user
    # set it. Also tag the text "tcl".
    HMstack $win {} "Ttcl tcl size [lindex $var(size) end]"
}

proc HMtag_/tcl {win param text} {
    upvar #0 HM$win var
    if {[info exists var(Ttclq)]} {
        unset var(Ttclq)
    }
    if {[info exists var(Ttcljava)]} {
        unset var(Ttcljava)
    }
    HMstack $win / "Ttcl {} size {}"
}

#######################################################################
#### HMx_font
# Generate an X font name using the FontManager class in Tycho.
# Also, cache font requests locally for additional efficiency
# (this yields about an 18% speed improvement in rendering).
#
proc HMx_font {family size weight style {adjust_size 0}} {
    global HMx_font_cache
    set cachename "$family.$size.$weight.$style.$adjust_size"
    if [info exists HMx_font_cache($cachename)] {
        return $HMx_font_cache($cachename)
    }
    # The HTML library seems to call this with empty strings for arguments.
    # I don't know why.  We have to handle that situation.
    if {$size == {}} {return fixed}
    incr size $adjust_size
    set result [::tycho::FontManager::getXFont $family $size $weight $style]
    set HMx_font_cache($cachename) $result
    return $result
}

#######################################################################
#### HMtag_hmstart
# Modify to not depend on being in the HMtag_map array.
#
proc HMtag_hmstart {win param text} {
	upvar #0 HM$win var
        global HMinitialtag_map
        HMstack $win {} $HMinitialtag_map
	$win mark gravity $var(S_insert) left
	$win insert end "\n " last
	$win mark gravity $var(S_insert) right
}

#######################################################################
#### HMtag_hr
# Improve the horizontal rule a bit.
#
proc HMtag_hr {win param text} {
	upvar #0 HM$win var
	$win insert $var(S_insert) "\n" space "\n\n\n" \
		thin "\t" "thin hr" "\n\n\n" thin
	$win tag configure hr -background black
}

#######################################################################
#### HMtag_sub
# Subscripts.
#
proc HMtag_sub {win param text} {
    upvar #0 HM$win var
    HMstack $win "" \
            [list Tsubscript subscript size [expr [lindex $var(size) end] - 2]]
}

proc HMtag_/sub {win param text} {
    HMstack $win "/" [list Tsubscript {} size {}]
}

#######################################################################
#### HMtag_sup
# Superscripts.
#
proc HMtag_sup {win param text} {
    upvar #0 HM$win var
    HMstack $win "" \
            [list Tsuperscript superscript \
            size [expr [lindex $var(size) end] - 2]]
}

proc HMtag_/sup {win param text} {
    HMstack $win "/" [list Tsuperscript {} size {}]
}

#######################################################################
#### HMwent_to
# Override the library function to put the start of the named region
# at the top of the window and to temporarily change the background color.
#
proc HMwent_to {win where {count 0} {color {}}} {
    if {![winfo exists $win]} {return}
    if {$count >= 6} return
    if {$count == 0} {
        set range [$win tag nextrange "N:$where" 1.0]
        if {$range != {}} {
            # Put the start of the named region at the top of the window.
            # (The following sometimes puts the line we want to see one line
            # above the visible part of the window. Hence the correction after).
            set start [expr int([lindex $range 0])]
            set length [expr int([$win index end])]
            set fraction [expr "$start.0/$length"]
            $win yview moveto $fraction

            # The following ensures the item in question is in view.
            $win see [lindex $range 0]
        }
    }

    if {$color == {}} {
        set color [::tycho::stylesheet get text targetColor]
    }

    # Temporarily change the background color
    upvar #0 HM$win var
    $win tag configure "N:$where" -background $color -foreground black
    after 8000 [list catch [list \
            $win tag configure "N:$where" -background {} -foreground {}]]
    update
}

#######################################################################
#### Table handling
# FIXME: This code is temporary, pending proper table handling.
# It does not render the table, which is relatively hard to do, but
# tries to format the text in such a way that table entries are at least
# distinguished from one another.

#######################################################################
#### HMtag_/tr
# For a table item, if the text does not end in a period, add a period.
#
proc HMtag_/td {win param text} {
    upvar #0 HM$win var
    set line [$win get "$var(S_insert) linestart" $var(S_insert)]
    if {![regexp {\.[ 	]*$} $line]} {
        $win insert $var(S_insert) "."
    }
}

# Tags for the rudimentary table support:
set HMtag_map(tr) {indent 1}
set HMinsert_space_map(tr) 1

# Increase the tab stops from 1 to 1.5 cm.
HMset_state -tab 1.5

