#!/bin/csh -f
# Version $Id$
# Author:	T. M. Parks
#
# Copyright (C) 1994 The Regents of the University of California
# All rights reserved.
#
# Convert LaTeXinfo index and table-of-contents entries to MML.

set file=$argv[1]	# root file name, without extension
set chap=$argv[2]	# chapter number
set temp1=a.$$	# temporary file
set temp2=b.$$	# another temporary file
set temp3=c.$$	# yet another temporary file

# Create a file with the following format:
# <entry-type> <page> <item>
# Where <entry-type> is chapter, section, subsection, etc.
# or concept_def, concept_ref, function_def, etc.

# Extract LaTeXinfo table-of-contents entries.
# toc entry format:
# \contentsline {<entry-type>}{\numberline <item>}{<chapter>-<page>}

# Remove "\numberline {...}"
set numberline="s/\\numberline {[^}]*}//"

# Process "\contentsline {...}"
set contentsline="s/^\\contentsline {\([^}]*\)}/\1 /"

# Process other remaining commands: "\...{...}"
set command="s/\\[^{]*{\([^}]*\)}/\1/"

# Process section number, section name, chapter, and page number
set extract="s/{\([^}]*\)}{\($chap\)-\([^}]*\)}/\3 \1/p"

set ext=toc

onintr clean1

if (-r $file.$ext) then
	sed -n -e "$contentsline" -e "$numberline" -e "$command" -e "$extract" $file.$ext \
		> $temp1
endif

# Fix under-score characters.
set under="s/{\\ptt \\char '137}/_/"

# Replace ! by : for sub-items.
set sub="s/\!/:/"

# Find entries with bold page numbers.  Extract entry and page number.
set findBold="s/^\\entry{\([^}]*\)}{[^0-9][^0-9]*\(${chap}\)-\([^}]*\)}.*/"
set replaceBold="_def \3 \1/p"

# Find entries with normal page numbers. Extract entry and page number.
set find="s/^\\entry{\([^}]*\)}{[^0-9]*\(${chap}\)-\([^}]*\)}.*/"
set replace="_ref \3 \1/p"

onintr clean2

set ext=(cp pg fn vr tp ky)
set idx=(concept program function variable type key)
@ i = 1
rm -f $temp2
while ($i <= $#ext)
	if (-r $file.$ext[$i]) then
	sed -n	-e "$under" -e "$sub" \
		-e "$findBold$idx[$i]$replaceBold" \
		-e "$find$idx[$i]$replace" \
		$file.$ext[$i] >> $temp2
	endif
	@ i++
end

onintr clean3

# Sort the index file.
sort +1 -2n $temp2 > $temp3

# Merge the table of contents and index files.
sort +1 -2n -m $temp1 $temp3 > $temp2

# Generate an mml file.
cat << END-cat
<MML Automaticaly generated by tex2mml>
<Comment tex2mml filter (C) 1994 University of California>
<!DefineFont Class <Family Courier> <pts 11> <Bold> >
<!DefineFont Norm <Family Times> <pts 12> <Plain> >
<!DefineTag 1Heading>
<!DefineTag 2Heading>
<!DefineTag 3Heading>
<!DefineTag 4Heading>
<!DefineTag newpage>
<!DefineTag Affiliation>
<!DefineTag Author>
<!DefineTag Body>
<!DefineTag Bullet>
<!DefineTag Commands>
<!DefineTag CommandsCont>
<!DefineTag Definition>
<!DefineTag Display>
<!DefineTag Explanation>
<!DefineTag Footnote>
<!DefineTag Heading>
<!DefineTag LBody>
<!DefineTag ListElem>
<!DefineTag OtherContrib>
<!DefineTag Section>
<!DefineTag Title>
END-cat

awk -f - $temp2 << END-awk
BEGIN { OFS=""; ORS=""; page=1; }
# Insert page breaks when the page number changes.
\$2 > page { while (\$2 > page) { print "<newpage>\nNew Page\n" ; page++; } }
# Process table of contents entries.
/^chapter/ { print "<1Heading>\n"; }
/^section/ { print "<2Heading>\n"; }
/^subsection/ { print "<3Heading>\n"; }
/^subsubsection/ { print "<4Heading>\n"; }
/^paragraph/ { print "<Heading>\n"; }
\$1 ~ /chapter/ || \$1 ~ /section/ || \$1 ~ /paragraph/ { print \$3;
	for ( i = 4; i <= NF; i++ ) { print " ", \$i; } print "\n"; }
# Process index entries.
/^concept_ref/ { print "<Marker <MType 11>"; }
/^concept_def/ { print "<Marker <MType 13>"; }
/^program_ref/ { print "<Marker <MType 11>"; }
/^program_def/ { print "<Marker <MType 13>"; }
/^function_ref/ { print "<Marker <MType 11>"; }
/^function_def/ { print "<Marker <MType 13>"; }
/^variable_ref/ { print "<Marker <MType 11>"; }
/^variable_def/ { print "<Marker <MType 13>"; }
/^type_ref/ { print "<Marker <MType 14>"; }
/^type_def/ { print "<Marker <MType 16>"; }
/^key_ref/ { print "<Marker <MType 11>"; }
/^key_def/ { print "<Marker <MType 13>"; }
\$1 ~ /_def/ || \$1 ~ /_ref/ { print " <MText \`", \$3;
	for ( i = 4; i <= NF; i++ ) { print " ", \$i; } print "'> >\n"; }
END { print "<EndOfInput>\n"; }
END-awk

clean3:
rm -f $temp3

clean2:
rm -f $temp2

clean1:
rm -f $temp1
