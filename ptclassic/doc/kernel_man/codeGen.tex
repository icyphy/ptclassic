\comment Version $Id$
\begin{iftex}
\date{$Date$}
\end{iftex}
\node Overview
\chapter{Overview of Parallel Code Generation}

This chapter describes the overall procedure of parallel code generation
in Ptolemy. We start with an SDF program graph and a multiprocessor
target description. In the target definition, we specify the number of
processors and some information about the processors with target parameters.
If the number of processor is given 1, it is classified as a sequential
code generation problem: a chosen
SDF scheduler schedules the graph and code is generated based on the
scheduling result. Parallel code generation is a bit more complicated.

If the number of processor is greater than 1, we create an APEG (acyclic
precedence expanded graph) associated with the SDF program graph. The APEG
graph displays all precedence relations between invocations of the SDF
stars. All parallel schedulers take this APEG graph as an input graph
and generate the schedule. In Ptolemy, we can have many scheduling
algorithms (currently 3), and choose one by setting the appropriate
target parameters. There is a common framework all parallel scheduling
algorithm should be fit into (\pxref{Parallel Schedulers}). The scheduling
result indicates the assignment and the ordering of star invocations
in the processors. The next step is to generate code for each processor
based on the scheduling result.

We create an SDF \emph{sub-universe} for each processor. The sub-universe
consists of stars assigned to the processor and some other automatically
inserted stars, for example send and receive stars for interprocessor
communication. We apply the sequential code generation routine for
each processor with the associated sub-universe.

We may generate parallel code inside a wormhole so that the main
workstation can communicate with the target multiprocessor system. 
Then, the wormhole interface code should be added to the generated code.

The following chapter will explain each steps in significant detail with
code segments.
 
\node APEG generation
\chapter{APEG generation}

Since all code generation domains depends on the SDF domain, and 
the same routine is needed by a specialized loop scheduler in the SDF
domain ($(PTOLEMY)/src/domains/sdf/loopScheduler), the source of APEG 
generation is placed in $(PTOLEMY)/src/domains/sdf/kernel.

An APEG graph (an ExpandedGraph class) consists of EGNodes and 
EGGates. Class EGNode represents
an object corresponding to an invocation of a DataFlowStar (DataFlowStar
is a base class of SDFStar class). An EGNode has a list of EGGates.
EGGate class is similar to PortHole class in the respect that it
is an object for connection between EGNodes. Between two EGGates,
there exists an EGArc object. All connections in an APEG
graph is homogeneous. If there is a sample rate change on an arc in the
SDF program graph, the arc is mapped to several homogeneous arcs.
APEG generation routines are defined as member methods of the ExpandedGraph
class.

Refer to \nxref{class ExpandedGraph}, to see the main discussion of APEG
generation.

\node class EGArc
\section{Class EGArc}

Class EGArc contains the information of (1) sample rate
of the arc and (2) the initial delay on the arc.

\begin{example}
EGArc(int \var{arc_samples}, int \var{arc_delay});
\end{example}

The constructor requires two arguments for sample rate and the
number of initial delays on the arc.

\begin{example}
int samples();
int delay();
\end{example}

These functions return the sample rate of the arc, and the
initial delay on the arc. We can increase the sample rate of the
arc using the following method

\begin{example}
void addSamples(int \var{increments});
\end{example}

There is no protected members in Class EGArc.

\node class EGGate
\section{Class EGGate}

Class EGGate is a terminal in an EGNode for connection with other
EGNodes. A list of EGGates will become a member of EGNode, called
\code{ancestors} or \code{descendants} based on the direction of connection.

\node EGGate public members
\subsection{EGGate public members}

\begin{example}
EGGate(EGNode* \var{parent}, PortHole* \var{pPort});
\end{example}

Is a constructor. The first argument is the EGNode that this EGGate
belongs to, and the second argument is the corresponding porthole of
the original SDF graph.

\begin{example}
const PortHole* aliasedPort();
const char* name() const;
\end{example}

The above methods returns the corresponding porthole of the original
SDF graph, the name of the porthole.

\begin{example}
int isItInput();
\end{example}

Returns TRUE or FALSE based on whether the corresponding porthole is an
input or not.

\begin{example}
void allocateArc(EGGate* \var{dest}, int \var{no_samples}, int \var{no_delay});
\end{example}

The method creates a connection between this EGGate and the first
argument by allocating an arc with information from the second and 
the third arguments. It should be called once per connection.

\begin{example}
int samples();
int delay();
void addSamples(int \var{increments});
\end{example}

These methods call the corresponding methods of the EGArc class if
an arc was already allocated by \code{allocateArc}.

\begin{example}
EGGate* farGate();
EGNode* farEndNode();
DataFlowStar* farEndMaster();
int farEndInvocation();
\end{example}

The above methods query information about the other side of the connection:
EGGate, EGNode, the original DataFlowStar that the EGNode points to, and
the invocation number of the EGNode. 

\begin{example}
StringList printMe();
\end{example}

It prints the information of the arc allocated: the sample rate and
the initial delay.

\begin{example}
void setProperty(PortHole* \var{pPort}, int \var{index});
\end{example}

This method sets the pointer to the corresponding porthole of the original
SDF graph and the index of the EGGate. Since multiple EGGates in an
EGNode may be mapped to the same porthole in the original SDF graph,
we order the EGGates by indices.

\begin{example}
void setLink(EGGateLink* \var{p});
EGGateLink* getLink();
\end{example}

Since the list of EGGates is maintained as a derived class of DoubleLinkList,
an EGGate is assigned an EGGateLink that is derived from the DoubleLink class.
These methods set and get the assigned EGGateLink.

\begin{example}
void hideMe(int \var{flag});
\end{example}

If the initial delay is greater than or equal to the sample rate in an EGArc,
the precedence relationship between the source and the destination of
the arc disappears while not removing the arc from the APEG. This method
removes this EGGate from the access list of EGGates (\code{ancestors} or
\code{descendants}), and stores it in
the list of hidden EGGates (\code{hiddenGates}) of the parent 
EGNode (\pxref{class EGNode}). 
If the argument flag is NULL,
it calls the same method for the EGGate of the other side of connection.
By default, the flag is NULL.

\begin{example}
virtual ~EGGate();
\end{example}

Is a virtual destructor that deletes the allocated arc, removes itself
from the list of EGGates.

\node class EGGateList
\subsection{Class EGGateList}

This class, derived from DoubleLinkList, contains a list of EGGates.
An EGGate is assigned to an EGGateLink and the EGGateList class
accesses an EGGate through the assigned EGGateLink. 

The following ordering is maintained in the precedence list:
entries for the same far-end
EGNode occur together (one after another), and they occur in order of
increasing invocation number. Entries for the same invocation occur in
increasing order of the number of delays on the arc.

\node class EGGateLink
\subsubsection{class EGGateLink}

\begin{example}
EGGateLink(EGGate* \var{e});
\end{example}

The constructor has an argument for an EGGate. 

\begin{example}
EGGate* gate();
EGGateLink* nextLink();
\end{example}

These methods return the corresponding EGGate and the next link in the parent
list.

\begin{example}
void removeMeFromList();
\end{example}

Removes this link from the parent list.

\node EGGateList public members
\subsubsection{EGGateList public members}

Class EGGateList has a default constructor. 

\begin{example}
void initialize();
\end{example}

This method deletes all EGGates in the list and initialize the list.
It is called inside the destructor.

\begin{example}
DoubleLink* createLink(EGGate* \var{e});
\end{example}

Creates an EGGateLink for the argument EGGate.

\begin{example}
void insertGate(EGGate* \var{e}, int \var{update});
\end{example}

This method insert a new EGGate into the proper position in the precedence
list. The update parameter indicates whether or not to update the arc
data if an EGGate with the same far-end EGNode and delay, already exists.
If \var{update} is 0, the argument EGGate will be deleted if redundant.
If 1, the arc information of the existing EGGate will be updated (sample
rate will be increased). When we insert an EGGate to the
\code{descendants} list of the parent EGNode, we set \var{update} to be 1.
If the EGGate will be added to the \code{ancestors}, the variable is set 0.

\begin{example}
StringList printMe();
\end{example}

Prints the list of EGGates.

\node Iterator for EGGateList
\subsubsection{Iterator for EGGateList}

Class EGGateLinkIter is derived from class DoubleLinkIter. The constructor
has an argument of the reference to a constant EGGateList object. It returns
EGGates. This class has a special method to return the next EGGate connected
to a new \code{farEndMaster} that is different from the argument DataFlowStar.

\begin{example}
EGGate* nextMaster(DataFlowStar* \var{master});
\end{example}

\node class EGNode
\section{Class EGNode}

Class EGNode is a node in an APEG, corresponding to an invocation of a
DataFlowStar in the original SDF graph. The constructor has two arguments:
the first argument is the pointer to the original Star of which it is an
invocation, and the second argument represents the invocation number.
The default value for the invocation number is 1. It has a virtual
destructor that does nothing in this class.

An EGNode maintains three public lists of EGGates: \code{ancestors},
\code{descendants}, and \code{hiddenGates} (\pxref{class EGGate}).

\node other EGNode public members
\subsection{Other EGNode public members}

Invocations of the same DataFlowStar are linked together.

\begin{example}
void setNextInvoc(EGNode* \var{next});
EGNode* getNextInvoc();
EGNode* getInvocation(int \var{i});
void setInvocationNumber(int \var{i});
int invocationNumber();
\end{example}

The first two methods sets and gets the next invocation EGNode. The third
method searches through the linked list starting from the current EGNode
to return the invocation with the argument invocation number. If the
argument is less than the invocation number of the current EGNode, returns 0.
The other methods sets and gets the invocation number of the current EGNode.

\begin{example}
void deleteInvocChain();
\end{example}

Deletes all EGNodes linked together starting from the current EGNode.
This method is usually called at the EGNode of the first invocation. 

\begin{example}
StringList printMe();
StringList printShort();
\end{example}

These methods print the name and the invocation number. In the first method,
the \code{ancestors} and \code{descendants} lists are also printed.

\begin{example}
DataFlowStar* myMaster();
\end{example}

Returns the original DataFlowStar of which the current EGNode is an
invocation.

\begin{example} 
int root();
\end{example}

This method returns TRUE or FALSE, based on whether this node is a
root of the APEG. A node is a root if it either has no ancestors, or
if each arc in the ancestor list has enough delay on it.

\begin{example}
EGGate* makeArc(EGNode* \var{dest}, int \var{samples}, int \var{delay});
\end{example}

Create a connection from this node to the first argument node. A pair of
EGGates and an EGArc are allocated in this method. This EGNode
is assumed to be the source of the connection. 

\begin{example}
void resetVisit();
void beingVisited();
int alreadyVisited();
\end{example}

The above methods manipulates a flag for traversal algorithms: resets to 0,
sets to 1, or queries the flag.

\begin{example}
void claimSticky();
int sticky();
\end{example}

These methods manipulates another flag to indicate that the invocations
of the same DataFlowStar may not be scheduled into different processors
since there is a strong interdependency between them. The first method
sets the flag and the second queries the flag.

\node class EGNodeList
\subsection{EGNodeList}

Class EGNodeList is derived from class DoubleLinkList. 

\begin{example}
void append(EGNode* \var{node});
void insert(EGNode* \var{node});
\end{example}

These methods appends or inserts the argument EGNode to the list.

\begin{example}
EGNode* takeFromFront();
EGNode* headNode();
\end{example}

The above methods both returns the first EGNode in the list. The first method
removes the node from the list while the second method does not.

There is a iterator class for the EGNodeList class, called EGNodeListIter.
It returns the EGNodes.

\node class ExpandedGraph
\section{class ExpandedGraph}

Class ExpandedGraph has a constructor with no argument and a virtual
destructor that deletes all EGNodes in the graph. 

The major method to generate an APEG is 

\begin{example}
virtual int createMe(Galaxy& \var{galaxy}, int \var{selfLoopFlag});
\end{example}

The first argument is the original SDF galaxy of which the pointer will
be stored in a protected member \code{myGal}. The second argument
enforces to make arcs between invocations of the same star regardless
of the dependency. The procedure of APEG generation is as follows.
(1) initialize the APEG graph.

\begin{example}
virtual void initialize();
\end{example}

Does nothing here, but will be redefined in the derived class if necessary.

(2) Allocate all invocations (EGNodes) of the blocks in the original SDF
graph. Keep the list of the first invocations of all blocks in the protected
member \code{masters}. 

\begin{example}
virtual EGNode *newNode(DataFlowStar* \var{star}, int \var{invoc_index});
\end{example}

Is used to create an invocation of a DataFlowStar given as the first
argument. The second argument is the invocation number of the node.
This method is virtual since the derived ExpandedGraph class may have
derived classes from the EGNode class.

(3) For each star in the original SDF graph, 

(3-1) Make connections between invocations of the star if any one of the
conditions is met: \var{selfLoopFlag} is set in the second argument,
the star has internal states, the star accesses past values on its
portholes, or the star is a wormhole. The connection made in this
stage does not indicate the flow path of samples, but the
precedence relation of two EGNodes. Therefore, EGGates associated
with this connection are not associated with portholes in the
original SDF graph. If the connections are made, 
the \code{claimSticky} method of EGNode class is called for each
invocation EGNode. If any such connection is made, the APEG
is said not-parallelizable as a whole: A protected member,
\code{parallelizable}, is set FALSE.

(3-2) For each input porthole, get the far-side output porthole and make
connections between invocations of two DataFlowStars. A connection
in the original SDF graph may be mapped to several connections
in the APEG since the APEG is homogeneous. 

(4) Find the root nodes in the APEG and stored in its protected member
\code{sources}.

\begin{example}
void insertSource(EGNode* \var{node});
\end{example}

Inserts the argument EGNode into the source list, \code{sources}, of 
the graph.
 
All protected members are explained above.

\node other ExpandedGraph public members
\subsection{Other ExpandedGraph public members}

\begin{example}
int numNodes();
\end{example}

This method returns the number of total nodes in the APEG.

\begin{example}
virtual StringList display();
\end{example}

Displays all EGNodes by calling \code{printMe} method of EGNode class.

\begin{example}
virtual void removeArcsWithDelay();
\end{example}

This method hide all connections that have delays on them. When an APEG
is created, the number of initial delays on an arc, if exists, is 
always greater than or equal to the sample rate of the arc. Therefore,
this method is used to make the APEG actually acyclic.

\node Iterators for ExpandedGraph
\subsection{Iterators for ExpandedGraph}

There are three types of iterators associated with an ExpandedGraph:
EGMasterIter, EGSourceIter, and EGIter. As its name suggests, 
EGMasterIter returns  the EGNodes in \code{masters} list of the
graph. EGSourceIter returns the EGNodes in \code{sources} list of the 
graph. Finally, EGIter returns all EGNodes of the ExpandedGraph.

EGMasterIter and EGSourceIter are derived from EGNodeListIter. EGIter,
however, is not derived from any class. Instead, EGIter uses
EGMasterIter to get the first invocation of each DataFlowStar in the
original SDF graph and traverse the linked list of invocations. Thus
invocations are traversed master by master.

\node Parallel Schedulers
\chapter{Parallel Schedulers}

Base classes for parallel schedulers can be found in $(PTOLEMY)/src/domains/
cg/parScheduler. All parallel schedulers use an APEG as the input. The
APEG for parallel schedulers is called ParGraph, which is derived from
class ExpandedGraph. Class ParNode, derived from class EGNode, is a node
in a ParGraph.

The base scheduler object is ParScheduler. Since it is derived from class
SDFScheduler, it inherits many methods and members from the SDFScheduler
class. The ParScheduler class has a ParProcessors class that has
member methods to implement the main scheduling algorithm. The ParProcessors
class has an array of UniProcessor class. The UniProcessor class,
privately derived from class DoubleLinkList, is mapped to a
processing element in the target architecture.

Note that all parallel scheduling algorithms are retargettable:
they do not assume any specific topology while they take the effect
of topology into account to estimate the interprocessor communication
overhead. 

Refer to \nxref{class ParScheduler}, to see the overall procedure of parallel
scheduling. Refer to \nxref{class UniProcessor}, to see the procedure of
sub-universe generations.

\node class ParNode
\section{ParNode}

This class represents a node in the APEG for parallel schedulers, thus 
contains additional members for parallel scheduling besides what are
inherited from class EGNode. It has the same two-argument 
constructor as class EGNode.

\begin{example}
ParNode(DataFlowStar* \var{master}, int \var{invoc});
\end{example}

Initializes data members. If the argument star is at the wormhole
boundary, we do not parallelize the invocations. Therefore, we create
precedence relations between invocations by calling \code{claimSticky}
of EGNode class in the constructor. If this constructor is called,
the \code{type} protected member is set 0.

The ParNode class has another constructor with one argument.

\begin{example}
ParNode(int \var{t});
\end{example}

The scheduling result is stored in UniProcessor class as a list of
ParNodes. This constructor is to model idle time (\var{t} = 1), or
communication time(\var{t} = -1 for sending time, \var{t} = -2
for receiving time) as a ParNode. The \code{type} protected member
is set to \var{t}. It initializes data members.

\node ParNode protected members
\subsection{ParNode protected members}

\begin{example}
int StaticLevel;
\end{example}

Is set to the longest execution path to a termination node in the APEG.
It defines the static level (or priority) of the node in the 
Hu's scheduling algorithm. Initially it is set 0.

\begin{example}
int procId
\end{example}

Is the processor index on which this ParNode is scheduled. Initially it
is set 0.

\begin{example}
int scheduledTime;
int finishTime;
\end{example}

Indicates when the node is scheduled and finished. 

\begin{example}
int exTime;
\end{example}

Is the execution time of the node. If it is a regular node (\code{type} = 0),
it is set to the execution time of the original DataFlowStar. Otherwise,
it is set 0.

\begin{example}
int waitNum;
\end{example}

Indicates the number of ancestors to be scheduled before scheduling this node.
during the scheduling procedure. Initially it is set 0. 
At a certain point of scheduling procedure,
we can schedule a ParNode only when all ancestors are already assigned, or
\code{waitNum} is 0.

\begin{example}
EGNodeList tempAncs;
EGNodeList tempDescs;
\end{example}

These list members are copies of the ancestors and descendants of the node.
While EGGateLists, \code{ancestors} and \code{descendants}, may not
be modified during scheduling procedure, these lists can be modified.

\node other ParNode public members
\subsection{Other ParNode public members}

There are a group method to manipulate the member variables.

\begin{example}
void assignSL(int \var{sl});
int getSL();
virtual int getLevel();
\end{example}

The first two methods set and get the \code{StaticLevel} member.
The last one returns the priority of the node, which is just
\code{StaticLevel} by default. In the derived classes, this method
can be redefined, for example in Dynamic Level Scheduling
(\pxref{Dynamic Level Scheduler}) to return the dynamic level of the node.

\begin{example}
int getType();
\end{example}

Returns the type of the node.

\begin{example}
void setProcId(int \var{id});
int getProcId();
virtual int whichProc();
virtual void assignProc(int \var{id});
\end{example}

The first two methods set and get the \code{procId} member. The last
two methods are virtual methods to do the same thing as the first two
methods. In the Declustering algorithm (\pxref{Declustering Scheduler}),
they are redefined to store the temporary information of the processor
assignment.

\begin{example}
void setScheduledTime(int \var{t});
int getScheduledTime();
void setFinishTime(int \var{t});
int getFinishTime();
\end{example}

These methods are used to set or get the time when the node is
scheduled first and finished.

\begin{example}
void setExTime(int \var{t});
int getExTime();
\end{example}

These methods are used to set and get the execution time of the node.

\begin{example}
void resetWaitNum();
void incWaitNum();
\end{example}

Resets the \code{waitNum} variable to the number of ancestors, and
increases it by 1.

\begin{example}
int fireable();
\end{example}

This method decreases \code{waitNum} by one, and return TRUE or FALSE,
based on whether \code{waitNum} reaches zero or not. If it reaches 0,
the node is declared "fireable".

\begin{example}
void copyAncDesc(ParGraph* \var{g}, int \var{flag});
void removeDescs(ParNode* \var{n});
void removeAncs(ParNode* \var{n});
void connectedTo(ParNode* \var{n});
\end{example}

The first method initializes the lists of temporary ancestors and
descendants, \code{tempAncs} and \code{tempDescs}, from 
\code{ancestors} and \code{descendants} that are inherited members from
EGNode class. List \code{tempAncs} is sorted smallest \code{StaticLevel}
first while list \code{tempDescs} is sorted largest \code{StaticLevel}
first. The first argument is necessary to call the sorting routine which
is defined in the ParGraph class (\pxref{class ParGraph}). By virtue of
sorting, we can traverse descendant with larger \code{StaticLevel} first.
If the second argument is not 0, we switch the lists: copy 
\code{ancestors} to \code{tempDecsc} and \code{descendants} to
\code{tempAncs}.

The second and the third methods remove the argument node from the
temporary descendant list or from the temporary ancestor list. In the latter
case, we decrease \code{waitNum} by one.

The last method above is to make a temporary connection between the 
node as the source and the argument node as the destination. The temporary
descendant list of the current node is added the argument node while the
temporary ancestor list of the argument node is added the current node (also
increase \code{waitNum} of the argument node by 1).

\begin{example}
CGStar* myStar();
\end{example}

Returns the original DataFlowStar after casting the type to CGStar, star
class type of the CG domain.

\begin{example}
int atBoundary();
\end{example}

Returns TRUE or FALSE, based on whether \code{myStar} is at the wormhole
boundary or not.

\begin{example}
int amIBig();
Profile* profile();
void withProfile(Profile* \var{p});
\end{example}

The first method returns TRUE or FALSE, based on whether \code{myStar} is
a wormhole or not. 
Before the scheduling is performed in the top-level graph, the wormhole
executes scheduling the inside galaxy and stores the scheduling results
in the Profile object (\pxref{class Profile}). The ParNode keeps the pointer
to the Profile object if it is an invocation of the wormhole. The second
and the third methods gets and sets the pointer to the Profile. In the
general context, the node will be considered "Big" if the master star
can be scheduled onto more than one processors. Then, the star
is supposed to keep the Profile object to store the schedules on the
processors. A wormhole is a special case of those masters.

\begin{example}
void setOSOPflag(int \var{i});
int isOSOP();
\end{example}

After scheduling is performed, we set a flag to indicate whether all
invocations of a star are assigned to the same processor or not, using the
first method. The second method queries the flag. Note that only the
\emph{first} invocation has the valid information.

\begin{example}
void setCopyStar(DataFlowStar* \var{s}, ParNode* \var{prevNode});
DataFlowStar* getCopyStar();
ParNode* getNextNode();
ParNode* getFirstNode();
int numAssigned();
\end{example}

The above methods are used to create sub-universes 
(\pxref{Sub-Universe creation}). When we create a sub-universe, we make a
copy of the master star if some invocations are assigned to the processor.
Then, these invocations keep the pointer to the cloned star. Since
all invocations may not be assigned to the same processor, we maintain
the list of invocations assigned to the given processor. The first and
second methods set and get the pointer to the cloned star. The first method
also make a chain of the invocations assigned to the same processor.
The third method returns the next invocation chained from the current node,
while the fourth method returns the starting invocation of the chain. The
last method returns the total number of invocations in the chain. It should
be called at the starting invocation of the chain.

\begin{example}
void setOrigin(EGGate* \var{g});
EGGate* getOrigin();
void setPartner(ParNode* \var{n});
ParNode* getPartner();
\end{example}

These methods manipulate the connection information of communication nodes.
If two adjacent nodes in an APEG are assigned to two different processors,
we insert communication nodes between them: Send and Receive nodes. As
explained earlier, a communication node is created by one-argument
constructor. The
first two methods are related to which EGGate the communication node is
connected. The last two methods concerns the other communication node
inserted.

\node Iterators for ParNode
\subsection{Iterators for ParNode}

There are two types of iterators associated with ParNode class: 
ParAncestorIter, ParDescendantIter. As their names suggest, ParAncestorIter
class returns the ParNodes in the temporary ancestor list (\code{tempAncs}),
and ParDescendantIter class returns the ParNodes in the temporary
descendant list (\code{tempDescs}). 

\node class ParGraph
\section{Class ParGraph}

Class ParGraph, derived from class ExpandedGraph, is an APEG graph for
parallel schedulers. It has a constructor with no argument. 

\begin{example}
int createMe(Galaxy& \var{g}, int \var{selfLoopFlag});
\end{example}

Is the main routine to create and initialize the APEG of the
argument Galaxy. Using \code{createMe} method of the ExpandedGraph
class, it creates an APEG. After that, it resets the busy flags of
the ParNodes, and call

\begin{example}
virtual int initializeGraph();
\end{example}

This is a protected method. It performs 4 main tasks as follows.
(1) Call a protected method \code{removeArcsWithDelay} to remove 
the arcs with delays, and to store the source and the
destination nodes of each removed arc into the list of NodePairs
(\pxref{class NodePair}). The list is a protected member, named
\code{nodePairs} of SequentialList class.

\begin{example}
void removeArcsWithDelay();
SequentialList nodePairs;
\end{example}

(2) For each node, compute the static level (\code{StaticLevel}) by calling
a protected method \code{SetNodeSL}. 

\begin{example}
int SetNodeSL(ParNode* \var{n});
\end{example}

(3) Sum the execution times of all nodes and save the total execution time
to a protected member \code{ExecTotal}.

\begin{example}
int ExecTotal;
\end{example}

(4) Assign the larger static level than any other nodes to the nodes at
the wormhole boundary. This let the parallel scheduler schedules the
nodes at the wormhole boundary first.

\node other ParGraph protected members
\subsection{Other ParGraph protected members}

\begin{example}
EGNode* newNode(DataFlowStar* \var{s}, int \var{invoc});
\end{example}

Redefines the virtual method to create a ParNode associated with the
given invocation of the argument star.

\begin{example}
ostream* logstrm;
\end{example}

This is a stream object for logging information.

\node other ParGraph public members
\subsection{Other ParGraph public members}

\begin{example}
EGNodeList runnableNodes;
void findRunnableNodes();
\end{example}

The list of runnable (or fireable) nodes are stored in \code{runnableNodes}.
The above method is to initialize the list with all root ParNodes.

\begin{example}
int getExecTotal();
Galaxy* myGalaxy();
\end{example}

Returns the total execution time of the graph and the original graph.

\begin{example}
void setLog(ostream* \var{str});
\end{example}

Sets the stream object \code{logstrm}.

\begin{example}
void replenish(int \var{flag});
\end{example}

This method initialize the temporary ancestor list and descendant list
of all ParNodes in the graph.

\begin{example}
void sortedInsert(EGNodeList& \var{l}, ParNode* \var{n}, int \var{flag});
\end{example}

Insert a ParNode, \var{n}, into the EGNodeList, \var{l}, in sorted order.
It sorts nodes of highest \code{StaticLevel} first if \var{flag} = 1,
or lowest \code{StaticLevel} first if \var{flag} = 0.

\begin{example}
void restoreHiddenGates();
\end{example}

This method restores the hidden EGGates from \code{removeArcsWithDelay} 
method to the initial list, either \code{ancestors} or \code{descendants}
of the parent node.

\begin{example}
int pairDistance();
\end{example}

After scheduling is completed, it is supposed to return the
maximum scheduling distance between node pairs in \code{nodePairs} list.
Currently, however, it just returns -1, indicating the information
is not available.

\begin{example}
~ParGraph();
\end{example}

The destructor initializes the \code{nodePairs} list.

\node class NodePair
\subsection{Class NodePair}

Class NodePair saves the source and the destination ParNodes of an arc.

\begin{example}
NodePair(ParNode* \var{src}, ParNode* \var{dest});
ParNode* getStart();
ParNode* getDest();
\end{example}

The constructor requires two arguments of the source and the destination
nodes, while the next two methods return the node.

\node class ParScheduler
\section{Class ParScheduler}

Class ParScheduler is derived from class SDFScheduler, thus inherits the most
parts of \code{setup} method. They include initialization of galaxy and
computation of the repetition counters of all stars in the SDF graph.
It redefines the scheduling part of the set-up stage (\code{computeSchedule}).

\begin{example}
int computeSchedule(Galaxy& \var{g});
\end{example}

Is a protected method to schedule the graph with given number of processors.
The procedure is

(1) Let the target class do preparation steps if necessary before scheduling
begins.

(2) Check whether the number of processors is 1 or not. If it is 1, we use
the single processor scheduling (\code{SDFScheduler :: computeSchedule}).
After we set the target pointer of each star, return.

(3) Form the APEG of the argument galaxy, and set the total execution time
of the graph to a protected member \code{totalWork}.

(4) Set the target pointer of each UniProcessor class
(\pxref{class UniProcessor}).

\begin{example}
void mapTargets(IntArray* \var{array} = 0);
\end{example}

If no argument is given, assign the child targets to the UniProcessors
sequentially. If the IntArray argument maps the child targets to the
UniProcessors. If array[1] = 2, UniProcessor 1 is assigned Target 2.

(5) Before the main scheduling begins, complete the profile information of
wormholes. Since we may want to perform more tasks before scheduling, make
this protected method virtual. Be default, return TRUE to indicate no error
occurs.

\begin{example}
virtual int preSchedule();
\end{example}

(6) Perform scheduling by calling \code{mainSchedule}.

\begin{example} 
int mainSchedule();
\end{example}

This public method first checks whether manual assignment is requested or not.
If it is, do manual assignment. Otherwise, call an automatic scheduling 
routine which will be redefined in each derived class, actual scheduling
class. After scheduling is performed, set the \code{procId} parameter of
the stars in the original galaxy if all invocations are enforced to be
assigned to the same processor (\pxref{Target}).

\begin{example}
int assignManually();
\end{example}

Is a protected method to return TRUE if manual assignment is requested, or
return FALSE otherwise.

\begin{example}
virtual int scheduleManually();
\end{example}

Is a public virtual method. This method first checks whether all stars
are assigned to processors (\code{procId} parameter of a star should be
non-negative and smaller than the number of processors). If there is any
star unassigned, return FALSE. All invocations of a star is set the same
\code{procId} parameter. Based on that assignment, perform the
list scheduling (\pxref{class ParProcessors}). The \code{procId} of a Fork
star is determined by its ancestor. If the ancestor is a wormhole, the
\code{procId} of the Fork should be given explicitly as other stars.

\begin{example}
virtual int scheduleIt();
\end{example}

Is a public virtual method for automatic scheduling. Refer to the derived
schedulers. By default, it does nothing and return FALSE to indicate that
the actual scheduling is not done in this class.

\begin{example}
int OSOPreq();
\end{example}

Is a protected method to return TRUE or FALSE, based on whether all
invocations are enforced to be scheduled on the same processor.

Now, all methods necessary for step (5) are explained. Go back to the next
step.

(7) As the final step, we schedule the inside of wormholes based on the
main scheduling result if automatic scheduling option is taken. 
In the main scheduling routine, we will determine
how many processors will be assigned to a wormhole.

\begin{example}
int finalSchedule();
\end{example}

If scheduling of wormholes succeeds, return TRUE. Otherwise, return FALSE.

\node compileRun
\subsection{compileRun method}

\begin{example}
void compileRun();
\end{example}

Is a redefined public method of SDFScheduler class. It first checks the number
of processors. 
If the number is 0, it just calls \code{SDFScheduler :: compileRun}. This
case occurs inside a wormhole. Otherwise, 

(1) Set the target pointer of UniProcessors.

(2) Create sub-universes for each processors.

\begin{example}
int createSubGals(Galaxy& \var{g});
\end{example}

Is a public method. It first checks whether all invocations of stars are
scheduled on the same processor, and set the flag if it is the case.
After restoring all hidden EGGates of the APEG, create sub-universes.

(3) Prepare each processor (or UniProcessor class) for code generation.
It includes sub-universe initialization, and simulation of the schedule on
the processor obtained from the parallel scheduling.

(4) Let the target do something necessary, if any, before generating code.

(5) Generate code for all processors.

\node other ParScheduler protected members
\subsection{Other ParScheduler protected members}

\begin{example}
const char* logFile;
pt_ofstream logstrm_real;
ostream* logstrm;
\end{example}

These are for logging information. \code{logFile} indicates where to store
the logging information.

\begin{example}
MultiTarget* mtarget;
\end{example}

Is the pointer to the target object, which is MultiTarget type.

\begin{example}
int numProcs;
\end{example}

Is the total number of processors.

\begin{example}
ParGraph *exGraph
\end{example}

Is the pointer to the APEG used as the input graph to the scheduler.

\begin{example}
ParProcessors* parProcs;
\end{example}

This member points the actual scheduler object. It will be set up in the
\code{setUpProcs} method of the derived class.

\begin{example}
IntArray avail;
\end{example}

This array is to monitor the pattern of processor availability 
during scheduling.

\begin{example}
int inUniv;
\end{example}

This flag is set TRUE when it is the scheduler of a universe, not a wormhole.
In the latter case, it is set FALSE. By default, it is set TRUE.

\begin{example} 
int withParallelStar();
\end{example}

This method returns TRUE or FALSE, based on whether the galaxy contains 
any wormhole or data-parallel star, or not.

\begin{example}
int overrideSchedule();
\end{example}

If the user wants to override the scheduling result after automatic
scheduling, he can set the \code{adjustSchedule} parameter of the target
object. This method pokes the value of that parameter. This is one of
the future feature, not implemented yet in Ptolemy due to limitation of
the graphical interface, pigi.

\node other ParScheduler public members
\subsection{Other ParScheduler public members}

\begin{example}
ParScheduler(MultiTarget* \var{t}, const char* \var{log} = 0);
virtual ~ParScheduler();
\end{example}

The constructor has two arguments: the target pointer and the name of log
file name. The virtual destructor does nothing.

\begin{example}
virtual void setUpProcs(int \var{num});
\end{example}

The number of processors is given as an argument to this method. It
will initialize the \code{avail} array. In the derived class, this
method will create a ParProcessors class (set \code{parProcs} member).

\begin{example}
ParProcessors* myProcs();
UniProcessor* getProc(int \var{ix});
\end{example}

These methods will return the pointer to the ParProcessors object associated
with this scheduler and the UniProcessor object indexed by the argument.
The range of the index is 0 to \code{numProcs}-1.

\begin{example}
void ofWorm();
\end{example}

Resets \code{inUniv} flag to FALSE.

\begin{example}
int getTotalWork();
\end{example}

Returns the total execution time of the graph.

\begin{example}
void setProfile(Profile* \var{profile});
\end{example}

Copy the scheduling results to the argument Profile (\pxref{class Profile}).
If the scheduling is inside a wormhole, the scheduling results should be
passed to the outside of the wormhole by a Profile object.

\begin{example}
StringList displaySchedule();
\end{example}

This method displays the schedule of wormholes. Display of the
overall schedule is defined in the derived classes.

\node class ParProcessors
\section{class ParProcessors}

Class ParProcessors is the base class for all actual scheduler object.
Refer to derived classes to see how scheduling is performed. This class
just provide the set of common members and methods. Among them, there is
a list scheduling routine.

\begin{example}
int listSchedule(ParGraph* \var{graph});
\end{example}

This method performs the list scheduling with the input argument APEG.
It should be called after all nodes are assigned to the processors. It
is the last routine to be called for all parallel schedulers. It adds
communication nodes to the APEG (\code{findCommNodes}) and schedule 
them with the regular ParNodes. It returns the makespan of the schedule.

\begin{example}
void findCommNodes(ParGraph* \var{graph});
\end{example}

This method puts a pair of communication ParNodes, a send node and a
receive node, on the arc between two nodes assigned to the different 
processors. Note that we use \code{tempAncs} and \code{tempDescs}
list of ParNode class to insert these nodes instead of modifying the APEG. 
We store the newly created communication ParNodes
in \code{SCommNodes}. The procedure consists of
two stages. In the first stage, all regular arcs in the APEG are considered.
The \code{StaticLevel} of the send node is assigned to that of the source node
plus one to ensure that the send node is scheduled right after the source
node. The static level of the receive node is assigned to the same value
as the destination node.
In the second stage, all hidden arcs are considered. In this case, the
\code{StaticLevel} of communication nodes are assigned to 1, the minimum
value since they may be scheduled at the end of the schedule.
The number of interprocessor requirements are saved in a protected member,
\code{commCount}.

\begin{example}
int getMakespan();
\end{example}

Returns the longest scheduled time among all UniProcessors.

\node other ParProcessors protected members
\subsection{Other ParProcessors protected members}

\begin{example}
int numProcs;
MultiTarget* mtarget;
EGNodeList SCommNodes;
\end{example}

These members specify the number of processors, the pointer to the
multiprocessor target class, and the list of communication nodes added
during \code{listSchedule}.

\begin{example}
IntArray pIndex;
\end{example}

Is used to access the processors in the order of available time. 

\begin{example}
void scheduleParNode(ParNode* \var{node});
\end{example}

This method schedules a parallel node (a wormhole or a data-parallel star)
inside the \code{listSchedule} method. Note that the processors are
already assigned for the node.

\begin{example}
virtual ParNode* createCommNode(int \var{i});
\end{example}

Is a virtual method to create a ParNode with type given as an argument.
It is virtual since the derived scheduler may want to create a node of 
derived class of ParNode.

\begin{example}
void removeCommNodes();
\end{example}

Clears the \code{SCommNodes} list.

\begin{example}
void sortWithAvailTime(int \var{guard});
\end{example}

Sort the processors with their available times unless no node is assigned to
the processor. All idle processors are appended after the processors
that are available at \var{guard} time and before the processor busy at
\var{guard} time. Store the results to \code{pIndex} array.

\begin{example}
int OSOPreq();
\end{example}

Returns TRUE or FALSE, based on whether all invocations of a star are
enforced to be scheduled on the same processor or not.

\node other ParProcessors public members
\subsection{Other ParProcessors public members}

\begin{example}
ParProcessors(int \var{pnum}, MultiTarget* \var{t});
virtual ~ParProcessors();
\end{example}

The constructor has two arguments: the number of processors and the target
pointer. It creates \code{pIndex} array and initialize other data structures.
The destructor clears \code{SCommNodes}.

\begin{example}
void mapTargets(IntArray* \var{array});
void prepareCodeGen();
void createSubGals();
void generateCode();
\end{example}

The above methods perform the actual action defined in the ParScheduler class.
For description, refer to \nxref{class ParScheduler}. The last method
deliver the generate code from each processor to the target class.

\begin{example}
int size();
\end{example}

returns the number of processors.

\begin{example}
virtual UniProcessor* getProc(int \var{id});
\end{example}

This method returns the UniProcessor with a given index. It is virtual since
the derived class wants to return it own specific class derived from
UniProcessor class.

\begin{example}
void initialize();
\end{example}

Initializes \code{pIndex}, \code{SCommNodes}, and processors.

\begin{example}
StringList display(NamedObj* \var{gal});
StringList displaySubUnivs();
\end{example}

These methods return the StringList contains the scheduling result and
the sub-universe description.

\begin{example}
ParNode* matchCommNodes(DataFlowStar* \var{s}, EGGate* \var{g}, PortHole* \var{p};
\end{example}

This method is used in sub-universe generation. The first argument is a
communication star, either a send star or a receive star, that the
system automatically inserts for interprocessor communication.
The second argument is the EGGate that the interprocessor communication (IPC)
occurs. If the second argument is NULL, the third argument indicates
the porthole that the IPC occurs. In case all invocations of any star
are assigned to the same processor, the sub-universe creation procedure
is greatly simplified: we do not need to look at the APEG, rather look at
the original SDF graph to create the sub-universe. It is the case when
the second argument becomes NULL. This method sets the pointer of the
communication star to the corresponding ParNode that are inserted during
\code{listSchedule} method.

\node class UniProcessor
\section{UniProcessor}

Class UniProcessor simulates a single processing element (shortly processor).
It is derived from class DoubleLinkList to hold the list of ParNodes
from parallel scheduling. Class NodeSchedule is derived from class
DoubleLink to register a ParNode into the DoubleLinkList.

A UniProcessor keeps two target pointers: one for multiprocessor target
(\code{mtarget}), and the other for the processor
(\code{targetPtr}). They are both protected members.

\begin{example}
MultiTarget* mtarget;
CGTarget* targetPtr;
\end{example}

The pointer to the processor can be obtained by a public method:

\begin{example}
CGTarget* target();
\end{example}

The pointers to the multiprocessor target and to the ParProcessors class
that this UniProcessor belongs to, are set by the following method:

\begin{example}
void setTarget(MultiTarget* \var{t}, ParProcessors* \var{parent});
\end{example}

\node class NodeSchedule
\subsection{Class NodeSchedule}

A NodeSchedule is an object to link a ParNode to a linked list.
It indicates whether the node represents an idle time slot or not.
It also contains the duration of the node. There is no protected member
in this class.

\begin{example}
void resetMembers();
void setMembers(ParNode* \var{n}, int \var{dur});
\end{example}

These methods set the information for the associated node: the pointer to
the node, duration, and a flag to tell whether it is an idle node or not. 
In the first method, the idle flag is set FALSE. The constructor also 
resets all internal information of the class.

\begin{example}
ParNode getNode();
int getDuration();
int isIdleTime();
\end{example}

The above methods return the pointer to the node associated with this class,
its duration, and the flag to say TRUE if it represents an idle time slot.

\begin{example}
NodeSchedule* nextLink();
NodeSchedule* previousLink();
\end{example}

These methods return the next and the previous link in the linked list.

\node members for scheduling
\subsection{Members for scheduling}

Since a list scheduling (with fixed assignment) will be performed as the 
last stage of all scheduling algorithms in Ptolemy 
(\pxref{class ParProcessors}), basic methods for list scheduling are
defined in the UniProcessor class. In list scheduling, we need the
available time of the processor.

\begin{example}
int availTime;
\end{example}

Is a protected member to indicate the time when the processor available.
There are public methods to access this member:

\begin{example}
void setAvailTime(int \var{t});
int getAvailTime();
\end{example}

\begin{example}
NodeSchedule* curSchedule;
\end{example}

This protected member points to the NodeSchedule appended last to the
linked list. There are two public methods to access a NodeSchedule:

\begin{example}
NodeSchedule* getCurSchedule();
NodeSchedule* getNodeSchedule(ParNode* \var{n});
\end{example}

The first method just returns \code{curSchedule} member while the second one
returns the NodeSchedule associated with the argument ParNode.

When a ParNode is runnable earlier than the available time of the processor,
we want to check whether there is an idle slot before \code{availTime} to
fit the ParNode in the middle of the schedule:

\begin{example}
int filledInIdleSlot(ParNode* \var{n}, int \var{start}, int \var{limit} = 0);
\end{example}

The first two arguments are the pointer to the ParNode to be scheduled and
the earliest time when the node can be scheduled. Without the third argument
given explicitly, this method returns the earliest time that the processor
is available to schedule the node. If the third argument is given,
the available time of the processor should be less than \var{limit}.
If this method could not find an idle slot to schedule the node, it returns
-1. Otherwise, it returns the possible scheduling time of the node.

\begin{example}
int schedInMiddle(ParNode* \var{n}, int \var{when}, int \var{leng});
\end{example}

Schedule the node, \var{n}, at \var{when} inside an idle-time slot of the
processor. The third argument indicates the duration of the node.
This method returns the completion time of the schedule if scheduling
is succeeded. If it fails to find an idle-time slot at \var{when} to
accommodate the node, it returns -1.

If a node is to be appended at the end of the schedule in a processor,

\begin{example}
void appendNode(ParNode* \var{n}, int \var{leng});
\end{example}

Does that blindly. To schedule a non-idle node, we have to use

\begin{example}
int schedAtEnd(ParNode* \var{n}, int \var{start}, int \var{leng});
\end{example}

In case \var{start} is larger than the processor available time, this
method put an idle time slot in the processor and calls \code{appendNode}.
And, it sets the schedule information of the node, and increases
\code{availTime} of the processor.

\begin{example}
void addNode(ParNode* \var{n}, int \var{start});
\end{example}

This method is given a ParNode and its runnable time, and schedule the node
either inside an idle time slot if possible, or at the end of the schedule
list. The methods described above are used in this method.

\begin{example}
void scheduleCommNode(ParNode* \var{n}, int \var{start});
\end{example}

When we schedule the given communication node, \var{n}, available at
\var{start}, we also have to check the communication resource whether
the resources are available or not. For that purpose, we detect the time
slot in this processor to schedule the node, and check whether the
same time slot is available in the communication resources: we use
\code{scheduleComm} of the multiprocessor target to check it. If we find
a time slot available for this processor and the communication resources,
we schedule the communication node.

\begin{example}
int getStartTime();
\end{example}

Returns the earliest time when the processor is busy.

All methods described in this sub-section are public.

\node Sub-Universe creation
\subsection{Sub-Universe creation}

After scheduling is performed, a processor is given a set of assigned 
ParNodes. According to the scheduling result, we will generate a code
to the target processor. To generate code for the assigned nodes, we need
to allocate the resources for the nodes, and examine the connectivity of
the nodes in the original graph. These steps are common to the generic
routine for single processor code generation, in which a processor target
is given a galaxy. Therefore, we wants to create a sub-galaxy
that consists of stars of which any invocation is assigned to the processor.
Note that a sub-galaxy is NOT a subgraph of the original SDF graph.
Besides the stars in the original program graph, we include other
stars such as communication stars and spread/collect stars. This subsection
will explain some details of sub-universe creation.

\begin{example}
void createSubGal();
\end{example}

Is the main public method for sub-universe creation. It first creates
a galaxy data structure, \code{subGal} a private member. Then, it clones
stars at least one of whose invocations is assigned to the processor.
Make a linked list for all assigned invocations (nodes) of each star 
in order of increasing invocation number, and set the pointer of cloned
star. As for a wormhole, we create a CGWormStar (\pxref{class CGWormStar})
instead of cloning the wormhole. A CGWormStar class will replace a
wormhole in the sub-universe. If an original star is not supported by the
processor target (for example, heterogeneous scheduling case
(\pxref{Heterogeneous Support})), we create
a star with the same name as the original star in the target domain.

At next step, we connect the cloned stars by referring to the original
galaxy. If a star is at the wormhole boundary in the original graph,
we connect the cloned star to the same event horizon; by doing that
the wormhole in the original graph is connected to the sub-universe.
If the star at the wormhole boundary is scheduled on more than one
processors (or not all invocations are assigned to the same processor),
the wormhole in the original graph will be connected to the last
created sub-universe. 

If an arc connects two stars whose invocations are assigned to the same
processor respectively, we examine whether two stars are assigned to
the same processor or not. If they are, we just connect the cloned
stars in the sub-universe. If they aren't, we have a cloned star of
either one star whose invocations are assigned to the current sub-universe.
In this case, we create a send star (\code{createSend} method of
the multiprocessor target) or a receive star (\code{createReceive} of the
target), based on whether the cloned star is a source or destination of
the connection (\pxref{class CGMultiTarget}). We we create a
communication star, we set the communication star pointer of
the communication nodes in the APEG (\pxref{class ParProcessors}), 
by \code{matchCommNodes} method of ParProcessors class.
If the partner communication star was already created in another
sub-universe, we pair the send and the receive stars by
\code{pairSendReceive} method of the multiprocessor target
(\pxref{class CGMultiTarget}).

The last case is when an arc connects two stars whose invocations are
distributed over more than one processors. If no invocation of
the destination star is assigned to this processor, we call
\code{makeBoundary} method. Otherwise, we call \code{makeConnection} method.

\begin{example}
void makeBoundary(ParNode* \var{src}, PortHole* \var{orgP});
\end{example}

The first argument is the pointer to the earliest invocation of 
the star assigned to this processor and the second one is the pointer to
the output porthole in the original SDF graph as the source of the
connection. We examines all assigned invocations to check whether
the destination invocations are assigned to the same processor or not.
If they are, we create one send star and connect it to the cloned star.
Otherwise, we create a Spread star (\pxref{Spread and Collect stars})
to distribute the output samples
to more than one processors. We connect the cloned star and the Spread star, 
and the Spread star to multiple send stars.

\begin{example}
void makeConnection(ParNode* \var{dest}, ParNode* \var{src}, PortHole* \var{ref}, ParNode* \var{firstS});
\end{example}

The first argument is the pointer to the first assigned invocation 
of the destination star while the second one is the source node connected
to the first argument. The third argument is the pointer to the destination
porthole of the connection in the original graph. The last argument is
the pointer to the first invocation of the source star. Note that the last
argument node may not be assigned to the current processor.
This method examines all assigned invocations of the destination star 
to identify the sources of the samples to be consumed by the cloned star
in this processor. If the number of sources are more than one, we
create a Collect star (\pxref{Spread and  Collect stars}) and connect the
Collect star to the cloned destination star in the sub-universe. For
each source in the other processors, we create a receive star and 
connect it to the Collect star. Similarly, we examines all assigned
invocations of the source star to identify the destinations of the samples
to be produced by the source star in this processor. If the number of
destinations are more than one, we create a Spread star and connect it
to the source star. For each destination in the other processors, we create
a send star and connect it to the Spread star. As a result, it may occur
that to connect two stars in the sub-universe, we need to splice a Spread 
and a Collect star on that connection. 

\node Spread and Collect stars
\subsubsection{Spread and Collect stars}

A Spread or a Collect star is created by \code{createSpread} or
\code{createCollect} method of the multiprocessor target. The following
illustration will show when we need to create a Spread or a Collect star
in a sub-universe.

Suppose we have star A connected to star B in original graph. Star A
produces two samples and star B consumes one. Then, one invocation
of star A is connected to two invocations of star B. If one invocation of
star A and only one of invocation of star B are assigned to the
current processor. Then, we need to connect the cloned stars of A and B
in the sub-universe. We can not connect stars A and B in the sub-universe
directly since among two samples generated by star A, one sample should be
transferred to another processor through a send star. In this case, we
connect a Spread star to star A, and one send star and star B to the
Spread star in the sub-universe. Then, star A produces two samples to
the Spread star while the Spread star \emph{spread} the incoming two samples
to the send star and star B one sample each. The number of output portholes
and the sample rate of each porthole are determined during the
sub-universe creation. If there is no initial delay on the connection and
neither star A nor B needs to access the past samples, the Spread star
does not imply additional copying of data in the generated code.

Similarly, we need to put a Collect star to the destination star if
samples to that star come from more than one sources.

\node class CGWormStar
\subsection{class CGWormStar}

If the original galaxy has a wormhole,
costly to clone a wormhole in the sub-universe. Instead, we create
a CGWormStar as the image of the wormhole. CGWormStar class, derived from
CGStar class, has
a four-argument constructor:

\begin{example}
CGWormStar(CGStar* \var{worm}, int \var{pix}, int \var{invoc}, int \var{flag});
\end{example}

The first argument is the pointer to the wormhole. The second argument
specify the index of the inside processors. The inside of the wormhole
is scheduled possibly onto more than one processors. This index indicates
the mapping which inside processor is associated with this processor.
The third argument indicates which invocation of a wormhole this star
simulates. If the last argument \var{flag} is non-zero, we create
the portholes of the CGWormStar to insert it to the sub-universe.
If it is set zero, we do not create the portholes, instead we just map
one CGWormStar to one invocation of the wormhole. 

When we schedule a wormhole or a data-parallel star, we assume that
the communication to the inside of the wormhole occurs through one
processor. For example, we schedule a wormhole with three processors,
only one processor is involved in communication with the other
stars outside the wormhole. Even though the other two processors are assigned
the ParNodes associated with the wormhole, the sub-universe will not
contain any CGWormStar in the connection. When generating code for the
wormhole, however, we need to access the wormhole associated with the
ParNodes. Therefore, we create a CGWormStar for each ParNode associated with
the wormhole, but do not insert the star into the sub-universe.

The \code{go} method generate a code for the wormhole, by calling
\code{downLoadCode} of the wormhole class (\pxref{class CGWormBase}).

There are other three public methods.

\begin{example}
int isItWormhole() const;
\end{example}

Just returns TRUE.

\begin{example}
void initialize();
\end{example}

Does nothing. It is redefined to nullify what the base CGStar does.
 
\begin{example}
int run();
\end{example}

This method calls \code{Star::run} and advances the offset pointer of
CGPortHoles.

\node members for code generation
\subsection{Members for code generation}

\begin{example}
void prepareCodeGen();
\end{example}

This method performs the following tasks before generating code.

(1) Initialize the sub-universe, which also initialize the cloned stars.

(2) Replace CGWormStars in the sub-universe with the original wormholes.
And set the galaxy pointer of the processor target to the sub-universe.
Note that the wormholes are now detached from the original SDF graph.
They will be restored after code generation to be discussed below.

(3) Convert a schedule (or a linked list of ParNodes) obtained from the
parallel scheduler to a SDFSchedule class format (list of stars). The
code generation routine of the processor target assumes the SDFSchedule
class as the schedule output.

(4) Simulate the schedule to compute the maximum number of samples
to be collected at runtime if we follow the schedule. This information
is used to determine the buffer size to be allocated to the arcs.

\begin{example}
void simRunSchedule();
\end{example}

Performs the step (4). It is a protected member.

\begin{example}
StringList& generateCode();
\end{example}

This method generate code for the processor target by calling
\code{targetPtr->generateCode()} (\pxref{class CGTarget}).
After generating code, it
restores the wormholes into the original graph.

\begin{example}
int genCodeTo(Target* \var{t});
\end{example}

This method is used to insert the code of the sub-universe to the
argument target class. It performs the almost same steps as
\code{prepareCodeGen} and then calls \code{insertGalaxyCode}
of the processor target class instead of \code{generateCode} method.

\node other UniProcessor protected members
\subsection{Other UniProcessor protected members}

There are a set of methods to manage NodeSchedule objects to minimize
the runtime memory usage as well as execution time.

\begin{example}
void putFree(NodeSchedule* \var{n});
NodeSchedule* getFree();
void clearFree();
\end{example}

If a NodeSchedule is removed from the list, it is put into a pool of
NodeSchedule objects. When we need a NodeSchedule object, a NodeSchedule
in the pool is extracted and initialized. We deallocate all NodeSchedules in
the pool by the third method.

\begin{example}
void removeLink(NodeSchedule* \var{n});
\end{example}

Removes the argument NodeSchedule from the scheduled list.

\begin{example}
int sumIdle
\end{example}

Indicates the sum of the idle time slots after scheduling is completed.
The valid value is available only after \code{display} method is called.

\node other UniProcessor public members
\subsection{Other UniProcessor public members}

There are a constructor with no argument to initialize all data members and
a destructor to delete \code{subGal} and CGWormStars and to delete all
NodeSchedule objects associated with this processor.

\begin{example}
Galaxy* myGalaxy();
int myId();
DoubleLinkList :: size;
int getSumIdle();
\end{example}

The above methods return the pointer to the sub-universe, the index of
the current processor, the number of scheduled nodes, and the sum of idle
time after scheduling is completed (or \code{sumIdle}).

\begin{example}
void initialize();
\end{example}

This method puts all NodeSchedules in the list to the pool of free
NodeSchedules and initialize protected members.

\begin{example}
void copy(UniProcessor* \var{org});
\end{example}

Copies the schedule from the argument UniProcessor to the current processor.

\begin{example}
StringList displaySubUniv();
StringList display(int \var{makespan});
int writeGantt(ostream& \var{os});
\end{example}

The first method display the sub-universe. The second method displays the
schedule in the textual form while the third one forms a string to
be used by Gantt-chart display program.

\node Iterator for UniProcessor
\subsection{Iterator for UniProcessor}

Class ProcessorIter is the iterator for UniProcessor class.
A NodeSchedule object is returned by \code{next} and \code{++} operator.

\begin{example}
ParNode* nextNode();
\end{example}

Returns the ParNode in the list.

\node Dynamic Level Scheduler
\section{Dynamic Level Scheduler}

Dynamic Level Scheduling is one of the list scheduling algorithm where
the priority of a node is not fixed during scheduling proceeds
(\pxref{References}). The scheduling algorithm is implemented in
$(PTOLEMY)/src/domains/cg/dlScheduler. All classes in that directory
are derived from the base parallel scheduling classes described 
above in this chapter.
For example, DLNode class is derived from class ParNode, and redefines
\code{getLevel} method to compute the \emph{dynamic} level of the node.

\begin{example}
int getLevel();
\end{example}

This method returns the sum of the static node and the worst case
communication cost between its ancestors and this DLNode. 

Class DLNode has the same constructors as class ParNode.

The dynamic level scheduler maintains a list of runnable nodes sorted
by \code{getLevel} value of the DLNodes. It fetches a node of highest
priority and choose the best processor that can schedule the node earliest
taking interprocessor communication into account.

\node class DLGraph
\section{Class DLGraph}

Class DLGraph, derived from class ParGraph, is the input APEG graph to the
dynamic level scheduler. It consists of DLNode objects created by
redefining the following method:

\begin{example}
EGNode* newNode(DataFlowStar* \var{s}, int \var{invoc});
\end{example}

This method creates a node in the APEG graph. Here, it creates a DLNode.

The DLGraph has two protected members to maintain the number of
unscheduled nodes and the sum of unscheduled work.

\begin{example}
int unschedNodes;
int unschedWork;
\end{example}

We may check whether the scheduler is deadlocked or not by examining these
variables when the scheduler halts. We provide public methods to
manipulate them.

\begin{example}
void decreaseNodes();
void decreaseWork(int \var{val});
int numUnSchedNodes();
int sizeUnSchedWork();
\end{example}

The first two methods decrease the values of the variables by one and
\var{val}. The next two methods return the values of the variables.

The DLGraph class redefines \code{resetGraph} method.

\begin{example}
void resetGraph();
\end{example}

It makes the initial list of runnable nodes and set the variables described
above. This method internally calls the following protected method:

\begin{example}
virtual void resetNodes();
\end{example}

This method resets the busy flag and the \code{waitNum}
member of DLNodes.

There are three other public members.

\begin{example}
DLNode* fetchNode();
\end{example}

Fetches a DLNode from the head of the list of the runnable node.

\begin{example}
int workAfterMe(ParNode* \var{pd});
\end{example}

This method returns the total execution time of the descendants of
the argument node. 

\begin{example}
StringList display();
\end{example}

Displays the APEG graph and the list of source nodes.

\node class DLScheduler
\section{class DLScheduler}

Class DLScheduler is derived from class ParScheduler. It has a constructor
with three arguments.

\begin{example}
DLScheduler(MultiTarget* \var{t}, const char* \var{logFile}, int \var{flag});
\end{example}

The arguments are the pointer to the multiprocessor target, the name of the
logging file, and a flag to indicate whether the communication overhead
can be ignored or not. If the processor target has a special hardware for
communication separately from the CPU, most part of communication load
could be executed simultaneously with other computation load. In this case,
we do not reserve the communication time slot in the processor schedule
but in the access schedule of the communication resources only. This mode
of operation is select if \var{flag} is set TRUE. But, it is not
implemented yet since we haven't had that kind of architecture while
developing the code.

It has a protected member to point to a ParProcessors class.

\begin{example}
DLParProcs* parSched;
\end{example}

This pointer is set in the following redefined method:

\begin{example}
void setUpProcs(int \var{num});
\end{example}

This method first performs \code{ParScheduler::setUpProcs}, and then
create a DLParProcs object. While this class defines the overall
procedure of the dynamic level scheduling algorithm, the DLParProcs class
provides the details of the algorithm (\pxref{class DLParProcs}). 

\begin{example}
~DLScheduler();
\end{example}

Deallocate the DLParProcs object.

The main procedure of the dynamic level schedule is defined in

\begin{example}
int scheduleIt();
\end{example}

This method does the following:

(1) Initializes the DLParProcs and resets the DLGraph and
the communication resources of the multiprocessor target.

(2) Fetch a node from the list of runnable nodes until there is no more nodes
in the list.

(2-1) If the node is not a wormhole node, call \code{scheduleSmall} method
of the DLParProcs class to schedule the node.

(2-2) If the node is the first invocation of a wormhole or a parallel-star
node, we first determine the pattern of processor availability, and computes
the amount of work that can be done simultaneously with this node. With
this information and the number of processors, we determine how many
processors to be assigned the the node. Once we decide the number of the
processors, we get the profile of the wormhole (or the parallel star)
associated with that number, and schedule the node by \code{scheduleBig}
method of the DLParProcs class. Currently, we do not support parallel-stars
since we haven't had any example of parallel-stars.

(2-3) If the node is an invocation of a wormhole, but not the first invocation,
we use the same number of processors and the same profile as the first
invocation to schedule this node. We use \code{copyBigSchedule} method of
the DLParProcs class. 

(3) When there is no more runnable node, we check whether the graph is
deadlocked or normally completed. In case of normal completion, we
performs an additional list scheduling (\code{listSchedule} of 
the ParProcessors class), based on the processor assignment determined
by the above procedure.

\begin{example}
StringList displaySchedule();
\end{example}

Displays the final schedule results.

\node class DLParProcs
\section{Class DLParProcs}

Class DLParProcs, derived from the ParProcessors class,
defines a main object to perform the dynamic level scheduling algorithm. 
It has a constructor with two arguments:

\begin{example}
DLParProcs(int \var{num}, MultiTarget* \var{t});
\end{example}

The arguments are the number of processors and the pointer to the
multiprocessor target. This method creates \var{num} UniProcessors for
processing elements. These UniProcessors are deallocated in the destructor:

\begin{example}
~DLParProcs();
\end{example}

\begin{example}
UniProcessor* schedules;
UniProcessor* getProc(int \var{ix});
\end{example}

The first member is a protected member for the array of UniProcessors, while
the second is a public method to access the UniProcessor with a given index
as an argument.

Based on the type of node described in \code{scheduleIt} method of the
DLScheduler class, we call one of the following methods to schedule the node.
\code{scheduleSmall}, \code{scheduleBig}, \code{copyBigSchedule}.

\begin{example}
virtual void scheduleSmall(DLNode* \var{n});
\end{example}

This method is a public method to schedule an atomic node that will be
schedule on one processor. It is virtual since the HuParProcs class
(\pxref{class HuParProcs}) redefines this method.
The scheduling procedure is as follows:

(1) Obtain the list of processors that can schedule this node. Refer to
\code{candidateProcs} method of the CGMultiTarget
class (\pxref{class CGMultiTarget}).  Here, we
examine the resource restriction of the processor, as well as the type of
stars that a processor supports in case of heterogeneous target. If
all invocations of a star should be scheduled to the same processor and
another invocation of the star is already scheduled, we put that processor only
into the list of candidate processors to schedule this node.

(2) Among all candidate processors, we select the processor that can schedule
the node earliest. In this stage, we consider all communication overhead
if ancestors would be assigned to the different processors.

(3) Assign the node to that processor:

\begin{example}
void assignNode(DLNode* \var{n}, int \var{destP}, int \var{time});
\end{example}

Is a protected method to assign an atomic node (\var{n}) to the processor
of index \var{destP} at \var{time}. This method also schedules the
communication requirements in the communication resources.

(4) Indicate that the node was fired:

\begin{example}
virtual void fireNode(DLNode* \var{node});
\end{example}

It is a virtual and protected method. It fires the argument node and insert
its descendants into the list of runnable nodes if they become runnable 
after this node is fired.

(5) Finally, we decrease the number of unscheduled nodes and the total
remaining work of the DLGraph class.

\begin{example}
void scheduleBig(DLNode* \var{n}, int \var{when}, IntArray& \var{avail});
\end{example}

Schedules a non-atomic node, \var{n}, that may be scheduled on more than one
processors. The second argument and the third argument indicate when the
node will be scheduled and what is the pattern of processor availability at
that time. They are determined by \code{determinePPA} method before this
method is called from \code{scheduleIt} method of the DLScheduler class.

The DLNode class has the pointer to the Profile class that determines the
inside schedule of the node. We insert idle time slots to the
processors to match the pattern of processor availability with the starting
pattern of the profile and append the node at the end of the processors. 
We record the assignment of the profile to
the processors in \code{assignedId} array of the Profile class
(\pxref{class Profile}). We also save the scheduling information in the
DLNode: when the node is scheduled and completed, and on which processor
it is scheduled. To determine the latter, we select the processor that
the inside scheduler assumes the first processor it is assigned.

After appending the profile at the end of the available processors, we
fire the node and updates the variables of the DLGraph.

\begin{example}
virtual int determinePPA(DLNode* \var{n}, IntArray \var{array});
\end{example}

It is a public method to record the pattern of processor availability to
\var{array} to schedule a non-atomic node \var{n}.
This method first obtains the list of candidate processors and chooses
a processor that can execute the node earliest taking into account
all communication requirement. Next, it schedules the communication 
load in the communication resources. Finally, it sorts the processors
in order of available times (\code{ParProcessors :: sortWithAvailTime}), and
fill the \var{array} structure.

\begin{example}
void copyBigSchedule(DLNode* \var{n}, IntArray& \var{avail});
\end{example}

This method is called to schedule a wormhole node and the node does not
corresponds to the first invocation. When we schedule the first invocation,
we determine the assignment of the wormhole. For other invocations,
we use the same assignment. In this method, we prepare \code{pIndex} and
\code{avail} arrays, and call the \code{scheduleBig} method.

\begin{example}
void initialize(DLGraph* \var{graph});
\end{example}

This method calls \code{ParProcessors :: initialize} and resets the
\code{candidate} member to the index of the first UniProcessor, and
\code{myGraph} member to \var{graph} argument.

\begin{example}
IntArray* candidate;
DLGraph* myGraph;
\end{example}

These are protected members to store the array of candidate processors and
the pointer to the input APEG.

\begin{example}
int costAssignedTo(DLNode* \var{n}, int \var{destP}, int \var{start});
\end{example}

This method is a protected method to compute the earliest time when
the processor of index \var{destP} could schedule the node \var{n} that
is runnable at time \var{start}.

\node Hu Level Scheduler
\section{Hu Level Scheduler}

Hu's level scheduling algorithm is a simple list scheduling algorithm, in
which a node is assigned a fixed priority. No communication overhead is
considered in the scheduling procedure. 
The code lies in $(PTOLEMY)/src/domains/cg/HuScheduler. 
All classes except HuScheduler class in this directory 
are derived from the classes for the dynamic level schedulers.

\node class HuNode
\subsection{Class HuNode}

Class HuNode represents a node in the APEG for Hu's level scheduling algorithm.
It is derived from the DLNode class so that it has the same constructors.
The level (or priority) of a node is not dependent on the communication 
overhead.

\begin{example}
int getLevel();
\end{example}

Just returns \code{StaticLevel} of the node.

A HuNode has two private variables to indicate the available time of the node
(or the time the node becomes runnable)
and the index of the processor on which the node wants to be assigned. 
The latter is usually set to the index of the processor that its immediate
ancestor is assigned. There are five public methods to manipulate these
private variables.

\begin{example}
int availTime();
void setAvailTime(int \var{t});
void setAvailTime();
int getPreferredProc();
void setPreferredProc(int \var{i});
\end{example}

The first three methods get and set the available time of the node. If no
argument is given in \code{setAvailTime}, the available time is set to
the earliest time when all ancestors are completed. The last two methods
get and set the index of the processor on which
the node is preferred to be scheduled.

\node class HuGraph
\subsection{Class HuGraph}

Class HuGraph is the input APEG for Hu's level scheduler. It redefines
three virtual methods of its parent classes.

\begin{example}
EGNode* newNode(DataFlowStar* \var{s}, int \var{invoc});
\end{example}

Creates a HuNode as a node in the APEG.

\begin{example}
void resetNodes();
\end{example}

This method resets the variables of the HuNodes: visit flag, \code{waitNum},
the available time, and the index of the preferred processor.

\begin{example}
void sortedInsert(EGNodeList& \var{nlist}, ParNode* \var{n}, int \var{flag});
\end{example}

In the ParGraph class, this method sorts the nodes in order of decreasing
\code{StaticLevel} of nodes. Now, we redefine it to sort the nodes in order
of increasing available time first, and decreasing the static level next.

\node class HuScheduler
\subsection{Class HuScheduler}

Class HuScheduler, derived from the ParScheduler class, is parallel to the
DLScheduler class in its definition.

\begin{example}
HuScheduler(MultiTarget* \var{t}, const char* \var{log});
\end{example}

The constructor has two arguments: one for the multiprocessor target and the
other for the log file name.

The HuScheduler class has a pointer to the HuParProcs object that will
provide the details of the Hu's level scheduling algorithm.

\begin{example}
HuParProcs* parSched;
\end{example}

Is the protected member to point to the HuParProcs object.
That object is created in the following method:

\begin{example}
void setUpProcs(int \var{num});
\end{example}

This method first calls \code{ParScheduler::setUpProcs} and next creates
a HuParProcs object. The HuParProcs is deallocated in the destructor.

\begin{example}
int scheduleIt();
\end{example}

The scheduling procedure is exactly same as that of the Dynamic Level 
Scheduler except that the actual scheduling routines are provided
by the HuParProcs object rather than a DLParProcs object. 
Refer to \code{scheduleIt} method of class DLScheduler
(\pxref{class DLScheduler}). Also note that the runnable nodes in
this scheduling algorithm are sorted by their available time first.

\begin{example}
StringList displaySchedule();
\end{example}

Displays the scheduling result textually.

\node class HuParProcs
\subsection{Class HuParProcs}

Class HuParProcs is derived from class DLParProcs so that it has the
same constructor. While many scheduling methods defined in the
DLParProcs class are inherited, some virtual methods are redefined to
realize different scheduling decision. For example, it does not
consider the communication overhead to determine the processor that can
schedule a node earliest. And it does not schedule communication resources.
Another big difference is that the Hu's level scheduling algorithm has
a notion of global time clock. No node can be scheduled ahead of the global
time. At each scheduling step, the global time is the same as the
available time of the node at the head of the list of runnable nodes.

\begin{example}
void fireNode(DLNode* \var{n});
\end{example}

This protected method is redefined to set the available time and the index
of the preferred processor of the descendants if they are runnable after node
\var{n} is completed, before putting them into the list of runnable nodes
(\code{sortedInsert}) of the HuGraph method.

\begin{example}
void scheduleSmall(DLNode* \var{n});
\end{example}

When this method is called, the node \var{n} is one of the earliest
runnable nodes. We examine a processor that could schedule the node
at the same time as the available time of the node. If the node
is at the wormhole boundary, we examine the first processor only. If
the node should be assigned to the same processor on which any earlier
invocations were already assigned, we examine that processor whether
it can schedule the node at that time or not. If no processor is found,
we increase the available time of the node to the earliest time when
any processor can schedule it, and put the node back to the list of
runnable nodes. If we find a processor to schedule the node at
the available time of the node, we assign, and fire the node and
update the variables of the HuGraph. Recall that no communication
overhead is considered.

\begin{example}
int determinePPA(DLNode* \var{n}, IntArray& \var{avail});
\end{example}

Before computing the pattern of processor availability, we first check
whether any processor is available to schedule the node \var{n} at its
available time. If no processor is found, we increase the available time
of the node to the earliest time when a processor is able to schedule it,
and put the node back to the list of runnable nodes.
If we find a processor to schedule the node, we set the \var{avail} and
\var{pIndex} arrays with information of the pattern of processor availability.

\node Declustering Scheduler
\section{Declustering Scheduler}

Declustering scheduler is the most elaborate scheduler developed by Sih
(\pxref{References}). This algorithm only applies to the homogeneous
multiprocessor targets. And, it does not support wormholes 
nor parallel stars. Since it takes into account the global information
of the graph, it may overcome the weaknesses of list schedulers which
consider only local informations at each scheduling step. It turns out
that this scheduling algorithm is very costly since it involves
recursive executions of the list scheduling with various assignment
and choose the best scheduling result. The scheduling routine was
originally written in LISP in Gabriel system, and translated into
C++. Since the algorithm itself is very complicated, the reader of the code
is highly encouraged to read the Sih's paper on the scheduling algorithm.

Class DeclustScheduler is derived from class ParScheduler. It has a
constructor with two arguments as the ParScheduler class.
The type of the ParProcessors used for DeclustScheduler is the DCParProcs
class. The DeclustScheduler maintains two instances of DCParProcs classes:
one is to save the best scheduling result so far, and the other is to
try another list scheduling whose scheduling results will be compared with
the current best scheduling result. These two DCParProcs are created in

\begin{example}
void setUpProcs(int \var{num});
\end{example}

They are deleted in the destructor.

\begin{example}
StringList displaySchedule();
\end{example}

Displays the best scheduling result obtained so far.

The overall procedure of the declustering algorithm is following:

(1) Make elementary clusters of nodes. To make elementary clusters, we examine
the output arcs of all branch nodes (a branch node is a node with more than
one output arcs) and the input arcs of all merge nodes (a merge node is a
node with more than one input arcs). Those arcs or arcs connected to them
are candidates to be cut to make clusters. An arc is cut if the
introduced communication overhead can be compensated by exploiting
parallelism.

(2) We make a hierarchy of clusters starting from elementary clusters up
to one cluster which includes all nodes in the APEG. Clusters with
smallest work-load will be placed at the bottom level of the hierarchy.

The above two steps are performed in the following protected method:

\begin{example}
int preSchedule();
\end{example}

Before making clusters, it first checks whether the APEG has wormholes or
parallel stars. If it finds any, it returns FALSE.

(3) Now, we decompose the cluster hierarchy. We examine the hierarchy from
the top. We assign two processors to each branch (son cluster) of the top node 
at the next level. Then, we execute a list scheduling to save 
the scheduling result. Choose a son cluster with more work-load. 
Then, introduce another processor to schedule two branches of the son cluster.
Execute another list scheduling to compare the previously best scheduling
result to save the better result. Repeat this procedure until all processors
are consumed. It is likely to stop traversing the cluster hierarchy since
all processors are consumed. At this stage, we compare the loads of
processors and try to balance the loads within a certain
ratio by shifting some elementary clusters
from the most heavily loaded processor to a lightly loaded processor.

(4) In some cases, we can not achieve our goals by shifting clusters to
balance the loads of processors. We try to breakdown some elementary
clusters in heavily loaded processors to lightly loaded clusters. It is
called to "breakdown" the clusters.

(5) In each step of (3) and (4), we execute a list scheduling to compare the
previously best scheduling result. This is the reason why the declustering
algorithm is that computationally intensive. Finally, we get the
best scheduling result. Based on that scheduling results, we make
a final version of the APEG  including all communication nodes 
(\code{finalizeGalaxy} method of DCParProcs class). Note that we do not
call the list scheduling algorithm in the ParProcessors class after we find
out the best scheduling result since we already executed that routine for
that result.

Steps (3), (4), and (5) are performed in the following public method:

\begin{example}
int scheduleIt();
\end{example}

Many details of the scheduling procedure are hidden with private methods.
The remaining section will describe the classes used for Declustering
scheduling one by one.

\node class DCNode
\subsection{Class DCNode}

Class DCNode, derived from class ParNode, is an APEG node for declustering
scheduler. It has the same constructors with the ParNode class.
This class does not have any protected member.

\begin{example}
int amIMerge();
int amIBranch();
\end{example}

These methods return TRUE if this node is a merge node or a branch node.

\begin{example}
DCCluster* cluster;
DCCluster* elemDCCluster;
\end{example}

These pointers point to the highest-level cluster and the elementary
cluster this node currently belongs to.

\begin{example}
void assignProc(int \var{n});
int whichProc();
\end{example}

We redefine these methods to set and get the temporary processor index on
which this node is scheduled. Since we execute the list scheduling
multiple times, we need to distinguish the final assignment and the
temporary assignment.

\begin{example}
void saveInfo();
int getBestStart();
int getBestFinish();
\end{example}

The first method saves the scheduling information of this node in
the best scheduling result, which includes the processor assignment, the
scheduled time, and the completion time. The next two methods return
those scheduled time and the completion time of the current node.

\begin{example}
int getSamples(DCNode* \var{destN});
\end{example}

Returns the number of samples transferred from the current node to the
destination node \var{destN}. If no sample is passed, it returns 0 with
an error message.

\begin{example} 
DCNode* adjacentNode(DCNodeList& \var{nlist}, int \var{direction});
\end{example}

DCNodeList is derived from class EGNodeList just to perform the type
casting. This method returns an adjacent node of the current node
in the given node list. If \var{direction} is 1, look at the ancestors,
if -1, descendants.

\begin{example}
StringList print();
\end{example}

Prints the master star name and the invocation number of the node.

There are three iterators defined for DCNode class: \code{DCNodeListIter},
\code{DCAncestorIter}, and \code{DCDescendantIter}. As names suggest,
they return the DCNode in the list, in the ancestors of a node, and in
the descendants of a node.

\node class DCArcList
\subsection{Class DCArc and DCArcList}

Class DCArc represents an candidate arc in the APEG to be cut to make
elementary clusters. It has a constructor with five arguments.

\begin{example}
DCArc(DCNode* \var{src}, DCNode* \var{sink}, int \var{first}, int \var{second},int \var{third});
\end{example}

The first two arguments indicate the source and destination nodes of the arc.
The remaining three arguments define a triplet of information used to help
find arcs to be cut. We call these arcs ''cut-arcs''. 
We consider a pair
of a branch node and a merge node and two paths between them to find out
a pair of cut-arcs to parallelize these two paths if beneficial.
The \var{first} argument is the sum of execution times of
nodes preceding this arc starting from the branch node.
The \var{second} argument is the communication overhead for this arc.
The \var{third} argument is the sum of execution times of nodes following this
arc to the merge node.

The five arguments given to the constructor can be retrieved by the following
methods:

\begin{example}
DCNode* getSrc();
DCNode* getSink();
int getF();
int getS();
int getT();
\end{example}

They can be printed by

\begin{example}
StringList print();
\end{example}

The sink and the source nodes can be reversed, and can be copied from
an argument DCArc by the following methods:

\begin{example}
void reverse();
int operator==(DCArc& \var{a});
\end{example}

There are other public methods as follow:

\begin{example}
DCArcList* parentList();
\end{example}

A DCArc will be inserted to a list of DCArcs (class DCArcList to be discussed
below). This method return the pointer to the list structure.

\begin{example}
int betweenSameStarInvoc();
\end{example}

Returns TRUE or FALSE, based on whether this arc is between invocations of
the same star.

Class DCArcList is derived from class SequentialList to make a list of
DCArcs. It has a constructor with no argument and a copy constructor.
The destructor deletes all DCArcs in the list.

\begin{example}
void insert(DCArc* \var{arc});
void append(DCArc* \var{arc});
\end{example}

These methods to put the argument DCArc at the front and the back of the list.

\begin{example}
DCArc* head();
\end{example}

Returns the DCArc at the front of the list.

\begin{example}
int remove(DCArc* \var{arc});
\end{example}

Removes a DCArc from the list.

\begin{example}
int member(DCArc* \var{arc});
\end{example}

Returns TRUE if the given DCArc is a member of the list.

\begin{example}
int mySize();
\end{example}

Returns the number of DCArcs in the list.

\begin{example}
StringList print();
\end{example}

It prints a list of DCArcs in the list.

There is a iterator for DCArcList: DCArcIter. It returns a DCArc.

\node class DCGraph
\subsection{Class DCGraph}

Class DCGraph, derived from class ParGraph, is an input APEG for
DeclustScheduler. It has no explicit constructor.

\begin{example}
EGNode* newNode(DataFlowStar* \var{s}, int \var{invoc});
\end{example}

Creates a DCNode as an APEG node for DCGraph.

\begin{example}
DCNodeList BranchNodes;
DCNodeList MergeNodes;
\end{example}

These lists store the branch nodes and merge nodes.

\begin{example}
int initializeGraph();
\end{example}

This protected method initializes the DCGraph: set up the list of branch 
nodes and
the merge nodes (\code{BranchNodes}, \code{MergeNodes}), and the list of
initially runnable nodes. We sort these lists with static levels of nodes:
the branch nodes are sorted smallest static level first while the merge
nodes are sorted largest static level first. In this method, we also
initialize the DCNodes, which include the detection of the merge nodes
reachable from the node and the branch nodes reachable to the node.

The remaining methods are all public.

\begin{example}
const char* genDCClustName(int \var{type});
\end{example}

Generate a name of the cluster. If \var{type} = 0, we prefix ''ElemDCClust''
to represent an elementary cluster. Otherwise, we prefix ''MacroDCClust''.

\begin{example}
StringList display();
\end{example}

Displays the APEG with the lists of initially runnable nodes, the branch
nodes, and the merge nodes.

\begin{example}
DCNode* intersectNode(DCNode* \var{d1}, DCNode* \var{d2}, int \var{direction});
\end{example}

This method returns a merge nodes with smallest static level, reachable from
both \var{d1} and \var{d2} nodes if \var{direction} = 1. 
If \var{direction} = 0, it returns a branch nodes with smallest static level,
reachable to both \var{d1} and \var{d2} nodes.

\begin{example}
DCArcList* traceArcPath(DCNode* \var{branch}, DCNode* \var{src}, DCNode* \var{dest}, int \var{direction});
\end{example}

This method makes a list of candidate cut-arcs between \var{branch} and
\var{dest} nodes, and returns the pointer to the list. 
The second argument, \var{src}, is a immediate
descendant of the \var{branch} node on the path to the \var{dest} node.
If \var{direction} = 1, we reverse all arcs and find a cut-arcs from 
\var{dest} to \var{branch} nodes.

\begin{example}
void addCutArc(DCArc* \var{arc});
\end{example}

The DCGraph keeps a list of all cut-arcs. This method adds
a DCArc to that list.

\begin{example}
void formElemDCClusters(DCClusterList& \var{EClusts});
\end{example}

In this method, we remove all cut-arcs in the APEG, and make each
connected component as an elementary cluster. The argument \var{EClusts}
is the list of those elementary clusters. We connect these clusters at
the end.

\begin{example}
void computeScore();
\end{example}

In scheduling stage (3) of the DeclustScheduler, we may want to shift
clusters from heavily loaded processors to lightly loaded processors. To
prepare this step, we compute the ''score'' of top-level clusters at that
scheduling phase. The score of a cluster is the number of samples passed
to other processors minus the number of samples passed inside the same
processor along the cur-arcs that the cluster contains.
The information indicates the cost of shifting a cluster due to
communication.

\begin{example}
void commProcs(DCCluster* \var{clust}, int* \var{procs});
\end{example}

This method finds processors that the argument cluster communicates with.
We set the component of the second argument array to 1 if that processor
communicates with the cluster.

\begin{example}
void copyInfo();
\end{example}

Saves the scheduling information of the nodes in case the recentest
scheduling result is better than the previous best.

\node class DCCluster
\subsection{Class DCCluster}

Class DCCluster represents a cluster of nodes in Declustering algorithm.
There is no protected member in this class.
It consists of two DCClusters, called component clusters, to make 
a hierarchy of clusters. An elementary cluster has NULL component clusters.
It is constructed with the constructor with one argument.

\begin{example}
DCCluster(DCNodeList* \var{node-list});
\end{example}

The cluster contains all nodes from the list, and set the \code{elemDCCluster}
member of the nodes.

To make a macro cluster, we use the following constructor:

\begin{example}
DCCluster(DCCluster* \var{clust1}, DCCluster* \var{clust2});
\end{example}

The arguments clusters become the component clusters of this higher level
cluster. The cluster-arcs are established from the cluster-arcs of
two component clusters by calling the following method:

\begin{example}
void fixArcs(DCCluster* \var{clust1}, DCCluster* \var{clust2});
\end{example}

In this method, arcs put inside the same cluster are removed among the arcs
of two argument clusters.

In both constructors, we compute the sum of execution times of all nodes in
the cluster, which can be obtained by

\begin{example}
int getExecTime();
\end{example}

\begin{example}
DCCluster* getComp1();
DCCluster* getComp2();
\end{example}

These methods return two component clusters.

\begin{example}
void setName(const char* \var{name});
const char* readName();
\end{example}

The above methods set and get the name of the cluster.

\begin{example}
void addArc(DCCluster* \var{adj}, int \var{numSample});
\end{example}

This method adds a cluster-arc that is adjacent to the first argument cluster
with sample rate \var{numSample}.

\begin{example}
void setDCCluster(DCCluster* \var{clust});
\end{example}

Sets \code{cluster} pointer of the nodes in the cluster to the argument
cluster.

\begin{example}
void assignP(int \var{procNum});
int getProc();
\end{example}

These methods assign all nodes in the cluster to a processor, and returns
the processor that this cluster is assigned to.

\begin{example}
void switchWith(DCCluster* \var{clust});
\end{example}

Switchs the processor assignment of this cluster with the argument cluster.

\begin{example}
DCCluster* pullWhich();
\end{example}

Returns the cluster between two component clusters to be pulled out. Currently,
return the component cluster with smaller execution time.

\begin{example}
DCCluster* findCombiner();
\end{example}

This method returns the best cluster to be combined with by looking at
communication cost of cluster-arcs. We break ties by returning the 
cluster with smallest execution time.

\begin{example}
void broken();
int getIntact();
\end{example}

These methods indicate whether the cluster, or its subclusters, was broken
into its components in the scheduling stage (3) of DeclustScheduler.
The first method indicates that it happens while the second method
queries whether it happens or not.

\begin{example}
int getScore();
int setScore(int \var{score});
void resetMember();
\end{example}

These methods get and set the score of the cluster. Refer to
\code{computeScore} method of the DCGraph class to see what the score of
a cluster is. The last method resets the score to 0.

\begin{example}
StringList print();
\end{example}

Prints the name of this cluster and the names of component clusters.

\begin{example}
~DCCluster();
\end{example}

The destructor deletes the nodes in the cluster and cluster-arcs
if it is an elementary cluster.

\node class DCClusterList
\subsection{Class DCClusterList}

Class DCClusterList, derived from class DoubleLinkList, keeps a list of
clusters. It has no protected members. 
It has a default constructor and a copy constructor.

\begin{example}
void insert(DCCluster* \var{clust});
void append(DCCluster* \var{clust});
void insertSorted(DCCluster* \var{clust});
\end{example}

These methods put the argument cluster at the head and the back of the list.
The last method inserts the cluster in order of increasing execution time.

\begin{example}
DCClusterLink* firstLink();
DCCluster* firstDCClust();
DCCluster* popHead();
\end{example}

The above methods return the DCClusterLink and DCCluster at the head of the
list. The last method extracts the cluster from the list.
Class DCClusterLink is derived from class DoubleLink as a
container of DCCluster in the DCClusterList. It has a public method to
access the cluster:

\begin{example}
DCCluster* getDCClustp();
\end{example}

A DCClusterLink is created by

\begin{example}
DCClusterLink* createLink(DCCluster* \var{clust});
\end{example}

\begin{example}
void removeDCClusters();
\end{example}

Removes all clusters in the list.

\begin{example}
void resetList();
void resetScore();
void setDCClusters();
\end{example}

The first two methods reset the score of all clusters to 0. The first method
also declares that each cluster is not broken. The third method resets the
cluster pointer of the nodes of the clusters in the list.

\begin{example}
int member(DCCluster* \var{clust});
\end{example}

Returns TRUE or FALSE, based on whether the argument cluster is in the list or
not.

\begin{example}
void findDCClusts(DCNodeList& \var{nlist});
\end{example}

Add clusters that the nodes of the argument list belongs to, to the list.
If the number of clusters is 1, we break the cluster into two
component clusters and put them into the list.

\begin{example}
int listSize();
\end{example}

Returns the number of clusters in the list.

\begin{example}
StringList print();
\end{example}

Prints the list of clusters.

There is an iterator associated with the DCClusterList: DCClusterListIter.
It returns a DCCluster, while it can return a DCClusterLink by
\code{nextLink} method.

\node class DCClustArcList
\subsection{Class DCClustArc and class DCClustArcList}

Class DCClustArc represents a cluster-arc. It has a constructor with two
arguments:

\begin{example}
DCClustArc(DCCluster* \var{neighbor}, int \var{nsamples});
\end{example}

The first argument is the pointer to the neighbor cluster while the second
argument indicates the sample rate of the connection.

\begin{example}
DCCluster* getNeighbor();
void changeNeighbor(DCCluster* \var{clust});
\end{example}

These methods return the neighbor cluster and change it.

\begin{example}
void changeSamples(int \var{newsamps});
void addSamples(int \var{delta});
int getSamples();
\end{example}

The above methods modify, increment, and return the sample rate of the current
arc.

\begin{example}
StringList print();
\end{example}

Prints the name of the neighbor cluster and the sample rate.

Class DCClustArcList is derived from class SequentialList to make a list
of cluster-arcs. It has four public methods.

\begin{example}
DCClustArc* contain(DCCluster* \var{clust});
\end{example}

Returns the DCClustArc that is adjacent to the argument cluster. If no
cluster-arc is found in the list, return 0.

\begin{example}
void changeArc(DCCluster* \var{oldC}, DCCluster* \var{newC});
\end{example}

This method changes the pointer of neighbor cluster, \var{oldC},
in all cluster-arcs in the list to \var{newC}.

\begin{example}
void removeArcs();
\end{example}

Deletes all cluster-arcs in the list.

\begin{example}
StringList print();
\end{example}

Prints the list of DCClustArcs.

There is an iterator associated with the DCClustArcList: DCClustArcListIter.
It returns a DCClustArc.

\node class DCUniProc
\subsection{Class DCUniProc}

Class DCUniProc is derived from class UniProcessor to maintain a new
variable for the processor: the sum of the computation and the communication
load, called \emph{load} shortly. This variable can be set and got by 
the following methods:

\begin{example}
int computeLoad();
int getLoad();
\end{example}

Both methods return the load of the processor.

\node class DCParProcs
\subsection{Class DCParProcs}

Class DCParProcs is derived from class ParProcessors. It has the same
constructor and destructor with the ParProcessors class.

\begin{example}
UniProcessor* getProc(int \var{index});
DCUniProc* getSchedule(int \var{index});
\end{example}

The above methods return pointer to the component DCUniProc with given index.
The second method is a type-cast version of the first method.

There is one protected method:

\begin{example}
ParNode* createCommNode(int \var{i});
\end{example}

Creates a DCNode to represent a communication code. The argument indicates
the type of the node.

The other methods are all public, and support the main scheduling procedure
described in the DeclustScheduler class (\pxref{Declustering Scheduler}).

\begin{example}
int commAmount();
\end{example}

Returns the communication overhead of the current schedule.

\begin{example}
void saveBestResult(DCGraph* \var{graph});
\end{example}

This method saves the current scheduling information of the nodes as the best
scheduling result.

\begin{example}
void finalizeGalaxy(DCGraph* \var{graph});
\end{example}

After all scheduling is completed, we make a final version of the APEG
including all communication loads based on the best scheduling result
obtained.

\begin{example}
void categorizeLoads(int \var{procs});
\end{example}

This method categorizes each processor as being heavily or lightly loaded.
It sets an integer array, \var{nprocs}, 1 for heavy and -1 for light
processors. Initial threshold is 50% of the maximum load. We consider all
processors are heavily loaded if all processors are loaded beyond 75% of the
maximum load. We regard at most one idle processor as lightly loaded. 

\begin{example}
int findSLP(DCNodeList* \var{nlist});
\end{example}

This method finds the progression of nodes (regular or communication)
in the schedule which prevents the makespan from being any shorter. We call
this set of nodes and \emph{schedule limiting progression: SLP} (refer to
the Sih's paper). The SLP can span several processors and can not contain
idle time. If there are several schedule limiting progression, it will
return just one of them.

\node Base Classes for Code Generation
\chapter{Base Classes for Code Generation}

This chapter explains the basic classes for code generation in
$(PTOLEMY)/src/domains/cg/kernel directory. We do not cover all classes
in that directory. We will concentrate on how to organize the code by
which methods.

A segment of code is formed in a CodeStream class. Each target will have
a list of CodeStreams, and arrange them to generate the final code.
A star uses CodeBlock classes to form a code segment, which will be
copied to a CodeStream of the target class after some processing.

We define a set of macros that a star programmer may use to refer
variables without worrying about resource allocation. For example, we refer
the portholes of a star, not knowing which physical resource is allocated
to them. 

\node CodeStream
\section{CodeStream}

Class CodeStream is derived from class StringList to make a stream of code.
In class CGTarget, a base target class for code generation, we have
two CodeStreams: \code{myCode} and \code{procedures}.

\begin{example}
CodeStream myCode;
CodeStream procedures;
\end{example}

These are protected members of class CGTarget. They are the default members
of the list of code streams that a CGTarget maintains.

\begin{example}
CodeStreamList codeStringLists;
\end{example}

It is a protected member of the CGTarget class.
We can add a CodeStream to \code{codeStringLists} by the following protected
method of the CGTarget class.

\begin{example}
void addStream(const char* \var{name}, CodeStream* \var{slist});
\end{example}

The first argument is the name of the CodeStream which is the second argument.
This method will be called in the constructor of the target class. If a target
tries to add a CodeStream with existing name, error will be signaled.

\begin{example}
CodeStream* getStream(const char* \var{name});
\end{example}

This method returns the pointer of the CodeStream with the given name. If
a stream is not found, it returns NULL. It is a public method of the 
CGTarget class. The CGStar class has the same method to get the
CodeStream with the given name from the target class it belongs to.

The following methods allow stars to construct a new Stream and add it to
an existing target stream.  Some of the possible uses for this new class are:
* a group of cgstars can build a procedure together
* a cgstar can add control flow constructs at the end of the mainLoop code

\begin{example}
CodeStream* CGTarget::newStream(const char * name);
\end{example}

The CodeStreamList class now has two types of CodeStreams, CodeStreams that
it owns and those owned by the target.  Streams created with newStream
will be owned by the CodeStreamList.

\begin{example}
virtual void CGStar::frameCode
\end{example}

This method will Combine star generated CodeStreams to the Target-defined
CodeStreams.  This should be done with the addCode method and usually using
a unique name.

\begin{example}
int CGTarget::starFrameCode();
\end{example}

This method in CGTarget calls all of the star frameCode methods.

Now we will explain the public members of class CodeStream.

\begin{example}
int put(const char* \var{code}, const char* \var{name} = NULL);
\end{example}

This method puts a segment of code, \var{code}, to the list. We can give
the name of the code segment. If \var{name} is absent, we append the code
unconditionally. Otherwise, we check whether a code with the same name
already exists or not, by examining the \code{sharedNames} list. If no
code segment with the same name is found, append the code segment. This
method returns TRUE if code was successfully added to the stream, FALSE
otherwise.

\begin{example}
UniStringList sharedNames;
\end{example}

Is a protected member to store the names of code segments in the list.
Class UniqueStringList is privately derived from class StringList. It has
two public methods as follows:

\begin{example}
StringList :: initialize;
int isUnique(const char* \var{name});
\end{example}

The first method initialize the list. The second method returns FALSE or TRUE,
based on whether the argument string already exists in the StringList or not.

The CodeStream class has a method to initialize the string list and
\code{sharedNames}:

\begin{example}
void initialize();
\end{example}

Class CodeStreamList contains a list of CodeStreams. It is privately
derived from class NamedList since each CodeStream is assigned a name. 
There are four public methods in the CodeStreamList class:

\begin{example}
int append(CodeStream* \var{stream}, const char* \var{name});
int add(const char* \var{name}, CodeStream* \var{stream});
CodeStream* get(const char* \var{name}) const;
int remove(const char* \var{name});
\end{example}

The first two methods append a CodeStream to the list. They differ from
each other in the order of arguments. The third method returns a CodeStream
with the given name while the last method remove a CodeStream with the
given name from the list.

\node class NamedList
\subsection{Class NamedList}

Class NamedList is privately derived from class SequentialList to make
a list of objects with name. It has a default constructor. The destructor
deletes all objects in the list. There is no protected member in this class.

\begin{example}
int append(Pointer \var{object}, const char* \var{name});
void prepend(Pointer \var{object}, const char* \var{name});
\end{example}

Put an object, \var{object}, with name \var{name} at the end and the
beginning of the list. In the first method, we may not put multiple
objects with the same name. If an object with the same name exists, return
FALSE. On the other hand, the second method allows multiple objects with
the same name. Only the most recently prepended object will be visible.

\begin{example}
Pointer get(const char* \var{name} = NULL);
\end{example}

Returns the object with the given name. If no name is given, returns the
object at the head of the list. If no object is found, return NULL.

\begin{example}
int remove(const char* \var{name} = NULL);
\end{example}

Removes the object with the given name. If no name is given, remove the first
object at the head of the list. If no object is found return FALSE, else TRUE.

There is an iterator associated with the NamedList class: NamedListIter.
It returns a pointer to an object.

\node CodeBlock and Macros
\section{CodeBlock and Macros}

Class CodeBlock stores a pointer to a text in its constructor.

\begin{example}
CodeBlock(const char* \var{text});
\end{example}

We have to make sure that the argument text lives as long as the codeblock is
used. There are four public methods defined to access the text.

\begin{example}
void setText(char* \var{line});
const char* getText();
operator const char*();
void printCode();
\end{example}

The first method sets the text pointer in the class. The next two methods
return the text this class points to. The last method prints to the code to
the standard output.

A star programmer uses ''codeblock'' directive in the preprocessor language
file to put a text. In a CodeBlock, the programmer uses the following macros
to access the star variables without worrying about resource managements or
name conflicts:

$val(\var{name})			Value of a state
$size(\var{name})			Buffer size of a state or a porthole
$ref(\var{name})			Reference to a state or a porthole
$ref(\var{name},\var{offset})		Reference with offset
$label(\var{name})			Unique label inside a codeblock
$codeblockSymbol(\var{name})		Another name for $label
$starSymbol(\var{name})			Unique label inside a star
$sharedSymbol(\var{list},\var{name})	Unique label for set list, name pair

These macros are resolved after resources are allocated or unique symbols are
generated. A CodeBlock defined in a CGStar is put to a CodeStream of
the target by the following methods of the CGStar class:

\begin{example}
int addCode(const char* \var{code}, const char* \var{stream} = NULL, const char* \var{name} = NULL);
int addProcedure(const char* \var{code}, const char* \var{name});
\end{example}

These methods are protected.
The first method puts a code, \var{code}, to the CodeStream with 
name \var{stream}
of the target. If the name of the CodeStream is not given, it uses
\code{myCode} stream of the target. The second method uses \code{procedure}
CodeStream of the target. The argument \var{name} of both methods is 
optional to
specify the name of the code. If the code is successfully added, they return
TRUE, and FALSE otherwise. Before putting the code into the CodeStream,
we process the code to resolve the macros by \code{processCode} method.

\begin{example}
StringList processCode(CodeBlock& \var{cb});
StringList processCode(const char* \var{code});
\end{example}

These methods are all protected and basically equal since the first method
calls the second method. They scans the code word by word copy to a
StringList. If a macro is found, the macro is expanded (\code{expandMacro})
before copying to the StringList. We can check whether a word is a macro
or not by comparing the first character with

\begin{example}
virtual char substChar() const;
\end{example}

This method is a virtual protected method of the CGStar class to return the
special character that introduces a macro in a code block. In the CGStar
class, it returns ''$''. 

\begin{example}
virtual StringList expandMacro(const char* \var{func}, const StringList& \var{argList});
\end{example}

This is a virtual protected method to expand a macro named \var{func}. The
argument list must be passed by reference so that the StringList is not
consolidated. It is virtual since the derived classes can define more macros.
A macro is identified by

\begin{example}
int matchMacro(const char* \var{func}, const StringList& \var{argList}, const char* \var{name}, int \var{argc});
\end{example}

This protected method returns TRUE when the first argument matches with the
third argument and the number of argument in the second argument is the same
as the fourth argument.

Based on the type macro, we may use one of the following protected methods to 
expand the macro:

\begin{example}
virtual StringList expandVal(const char* \var{name});
StringList expandSize(const char* \var{name});
virtual StringList expandRef(const char* \var{name});
virtual StringList expandRef(const char* \var{name}, const char* \var{offset});
\end{example}

These methods expands $val, $size, $ref, and $ref2 macros. We will redefine
the virtual methods in the derived classes. Particularly, we have to redefine
the last two methods in the derived classes because in the CGStar class they
generate error messages. The other macros deal with unique symbols in a
code block, in a star, and in a set of symbols. Refer to the next subsection
(\pxref{Unique Symbol Generation}).

When we find an error when expanding macros or processing code blocks, we
call the following methods to generate error message:

\begin{example}
void macroError(const char* \var{func}, const StringList& \var{argList});
void codeblockError(const char* \var{p1},  const char* \var{p2} = "");
\end{example}

The arguments of the second method provide the text of error message.

\node Unique Symbol Generation
\section{Unique Symbol Generation}

To generate a unique symbol in a scope, we make a list of symbols in that
scope. For example, the CGStar class has two SymbolLists (protected
members): \code{starSymbol} and \code{codeblockSymbol}. 

\begin{example}
SymbolList starSymbol;
SymbolList codeblockSymbol;
\end{example}

Class SymbolList is derived from class BaseSymbolList. Class BaseSymbolList
is privately derived from class NamedList.
A BaseSymbolList keeps two private  members to give a unique name for 
each symbol in the list: a separator and a counter.

\begin{example}
BaseSymbolList(char \var{sep} = '_', int* \var{count} = NULL);
\end{example}

The first argument of the constructor sets the separator and the second 
argument sets the pointer of the count variable. These two variables can be
set by the following methods:

\begin{example}
void setSeparator(char \var{sep});
void setCounter(int* \var{count});
\end{example}

When we append or insert a symbol to the list, we give a unique 
name to that symbol by appending a separator followed by the counter value
to the argument symbol, and returns the unique name:

\begin{example}
const char* append(const char* \var{name});
const char* prepend(const char& \var{name});
\end{example}

\begin{example}
const char* get(const char* \var{name} = NULL);
\end{example}

Returns the unique symbol with the given name. If no name is given, return the
first symbol in the list.

\begin{example}
int remove(const char* \var{name} = NULL);
\end{example}

This method removes the unique symbol with the given name. If no name is given,
remove the first symbol in the list. It returns FALSE, if error occurs.

Symbols in the list are deletes in the destructor or in the following method:

\begin{example}
void initialize();
\end{example}

The public method

\begin{example}
Stringlist symbol(const char*)
\end{example}

makes a unique symbol from the supplied argument by adding the separator and
a unique number to the argument string.

Now, class SymbolList is privately derived from class BaseSymbolList with
the same constructor and a default destructor.
This class uncovers only three methods of the base class.

\begin{example}
BaseSymbolList::setSeparator;
BaseSymbolList::setCounter;
BaseSymbolList::initialize;
\end{example}

It has one additional method:

\begin{example}
const char* lookup(const char* \var{name});
\end{example}

If a unique symbol with the given name exists, this method returns that
unique symbol. Otherwise, it creates a unique symbol with that name and 
puts it into the list.

Recall that the CGStar class has two SymbolLists. The macros,
$codeblockSymbol, $label, and $starSymbol, are resolved by \code{lookUp}
method of the \code{codeblockSymbol} and \code{starSymbol}, based on
the scope of the symbol. If the symbol already exists in the SymbolList,
it returns that unique symbol. Otherwise, it creates a unique symbol
in the scope of interest.

If we want to generate a unique symbol in the file scope, we use a symbol
list defined in the target class.

\begin{example}
ScopedSymbolList sharedSymbol;
\end{example}

It is a protected member of the CGTarget class. ScopedSymbolList class is
privately derived from class NamedList to store a list of SymbolLists, 
It has the same constructor as the base class. 

\begin{example}
void setSeparator(char \var{set});
void setCounter(int* \var{count});
\end{example}

These methods in the ScopedSymbolList class set the separator and the counter
pointer of all SymbolLists in the list.

\begin{example}
const char* lookup(const char* \var{scope}, const char* \var{name});
\end{example}

In this method, the first argument determines the SymbolList in the list named
\var{scope}, and the second argument determines the unique symbol in the
SymbolList. If no SymbolList is found with that name, we creats a new
SymbolList and insert it in the list.

The SymbolLists in the list are deleted in the destructor and in the following
method:

\begin{example}
void initialize();
\end{example}

Now, we can explain how to expand the last macro defined in the CGStar class:
$sharedSymbol. The first argument of the macro determines the StringList
and the second argument accesses the unique string in that StringList. It is
done by calling the following protected method in the CGStar class.

\begin{example}
const char* lookupSharedSymbol(const char* \var{scope}, const char* \var{name});
\end{example}

This method calls the same method defined the CGTarget class.

The CGTarget class has another symbol list:

\begin{example}
SymbolStack targetNestedSymbol;
\end{example}

It is a protected method to generate a unique nested symbol.
Class SymbolStack is privately derived from class BaseSymbolList. It has the
same constructor as the base class and has a default destructor.

For stack operation, it defines the following two methods:

\begin{example}
const char* push(const char* \var{tag} = "L");
StringList pop();
\end{example}

These methods put the symbol with given name to the top of the list and
pop the symbol at the top of the list.

This class also exposes four methods of the base class:

\begin{example}
BaseSymbolList::get;
BaseSymbolList::setSeparator;
BaseSymbolList::setCounter;
BaseSymbolList::initialize;
\end{example}

In this section, we explain various symbol lists. The separator and the
counter are usually defined in the CGTarget class.

\begin{example}
char separator;
int symbolCounter;
\end{example}

These are private members in the CGTarget class. They are set in the
constructor. The methods

\begin{example}
virtual int* CGTarget::symbolCounter();
virtual char CGTarget::separator();
\end{example}

return symbolCounter and separator respectively.

\node Resource Management
\section{Resource Management}

When we generate an assembly code, we have to allocate memory for portholes
and states of each star. For a high level language generation, we assign
unique definitions to them. It is rather easy to allocate resources for states
since its requirements are visible from the star definition: size and
name. In this section, we will focus on how to determine the buffer 
size of the portholes.

We allocate a buffer for each connection. We do not assume in the base class,
however, the buffer is owned by the source or by the destination porthole.
Instead, we use methods of the CGGeodesic class. Before determining the buffer
size, we obtain the information how many samples are accumulated on each
CGGeodesic by simulating the schedule. 

\begin{example}
int getMaxNum();
\end{example}

This public method of the CGGeodesic class returns the maximum number of

samples accumulated during one iteration of the schedule.

\begin{example}
incCount(int \var{delta});
\end{example}

Increases the number of samples on the Geodesic by \var{delta}.

The minimum buffer requirement of a connection is the sum of 
\code{getMaxNum} and the number of old samples required
by the destination star.

\begin{example}
int minNeeded() const;
\end{example}

Returns that minimum buffer size. It is a protected member of the CGGeodesic
class. 

We do not want to allocate buffers for portholes if unnecessary. For example,
the output portholes of a Fork star can share the same resource with its
input. A Gain star with unity gain is another example. Therefore, we pay
special attention to stars of Fork type. Without confusion, we refer
a star a \emph{Fork} star if its outputs can share the same resource as
the input. In the CGStar class, we provide the following methods.

\begin{example}
void isaFork();
int isItFork();
virtual void forkInit(CGPortHole& input, MultiCGPortHole& output);
virtual void forkInit(CGPortHole& input, CGPortHole& output);
\end{example}

Only the second method is public while others are protected. The first two
methods declare and query that the star is a Fork star. If it is,
we call either one of the last two methods, based on whether the output
is a MultiPortHole or not. In those methods, we shift delays from a Fork's
input port to the output ports, and set the \code{forkSrc} pointer of
the output ports to the Fork's input port. The Fork's input port
keeps a list of the output ports in \code{forkDests} member. We apply
this procedure recursively in case of cascaded Forks.

\begin{example}
CGPortHole* forkSrc;
SequentialList forkDests;
\end{example}

These members are protected members of the CGPortHole class. They are set
by the following public method:

\begin{example}
void setForkSource(CGPortHole* \var{p});
\end{example}

The argument is the input porthole of the Fork star and this port is
an output porthole when we call this method. 

\begin{example}
int fork() const;
\end{example}

Is a public method of the CGPortHole class to return TRUE if it is an
input porthole of a Fork star.

Class CGGeodesic provides two methods to return the Fork input port
if it is at a Fork output port. Otherwise these methods return NULL.

\begin{example}
CGPortHole* src();
const CGPortHole* src() const;
\end{example}

These two methods are protected and differ from each other with the return
type. 

Now we will explain more methods of the CGGeodesic class.

\begin{example}
int forkType() const;
\end{example}

This public method indicates the type of the current CGGeodesic. If it
is at a Fork input, it is \code{F_SRC}. If it is at a Fork output, it is
\code{F_DEST}.

\begin{example}
int forkDelay() const;
\end{example}

This method returns the amount of delay from the current Geodesic up to
the fork buffer that this Geodesic refers to. If it is not associated
with a fork buffer, it returns 0.

We do not allocate a buffer to a CGGeodesic if it is \code{F_DEST}.

\begin{example}
int localBufSize() const;
int bufSize() const;
\end{example}

The above methods return the buffer size associated with this Geodesic.
While the first method returns 0 if the Geodesic is at a Fork output, the
second method returns the size of the fork buffer. The actual computation of
the buffer size is done by the following protected member.

\begin{example}
virtual int internalBufSize() const;
\end{example}

This method returns 0 with an error message if the schedule has not
yet been run. If this Geodesic is a \code{F_SRC}, the minimum size
is set to the maximum buffer requirements over all fork destinations.
If there are delays or old values are used, we may want to use a
larger size so that compile-time indexing is supportable. The buffer size
must divide the total number of tokens produced in one execution.
To avoid modulo addressing, we prefer to use the \emph{lcm} value of
the number of sample consumed and produced during one iteration of the
schedule. Since it may be wasteful, we check the extra buffer size required
for linear addressing with the \code{wasteFactor}. If the waste ratio is
larger then \code{wasteFactor}, we give up the linear addressing.

\begin{example}
virtual double wasteFactor();
\end{example}

In the CGGeodesic class, it is set to 2.0. If a derived class wants to
enforce linear addressing as much as possible, it should set the value
large.

\begin{example}
void initialize();
\end{example}

It initialize the Geodesic.

Refer to class CGPortHole (\pxref{class CGPortHole}) for more information
on resource managements.

\node Utility Functions
\section{Utility Functions}

There are three utility functions defined in the CG domain for code generation.

\begin{example}
char* makeLower(const char* \var{name});
int rshSystem(const char* \var{hostname}, const char* \var{command}, const char* \var{directory} = NULL);
\end{example}

The above functions are defined in file CGUtility.h.
The first method creates a new string, copies the argument
string changing all upper characters to lower characters, and returns the
string. The second method is used to execute a remote shell command,
\var{command}, at the \var{directory} in the machine \var{hostname}. We use
\code{xon} command instead of \code{rsh} to keep the X window environment
variables.

\begin{example}
int display(const StringList& \var{stuff}, const char* \var{filename} = NULL);
\end{example}

This method is defined in file CGDisplay.h. It displays a given string list
(usually a code), \var{stuff}, using an editor, which is determined by
an environment variable \code{PT_DISPLAY}. Two examples are \code{vi} and
\code{xedit}. The the file name is given, the code is written to that file.
If error occurs, return FALSE.

\node class CGStar
\section{Class CGStar}

In this section, we will explain other CGStar members not described above in
this chapter. Class CGStar has a constructor with no argument. It is derived
from class DataFlowStar, not SDFStar, to support BDF in the future.

There is an iterator to access a PortHole of a CGStar: CGStarPortIter. It
returns a CGPortHole.

\node CGStar protected members
\section{CGStar protected members}

Protected members related to CodeStream, SymbolList, and resource
managements can be found in earlier sections of this chapter.

\begin{example}
virtual void outputComment(const char* \var{msg}, const char* \var{stream} = NULL);
\end{example}

Adds a comment \var{msg} to the target \var{stream}. If no target stream is
specified, use \code{myCode} stream.

\begin{example}
StringList expandPortName(const char* \var{name});
\end{example}

If the argument specifies a name of a MultiPortHole, the index may be
indicated by a State. In this case, this method gets the value of the
State as the index to the MultiPortHole and return a valid MultiPortHole name.
This method is used in \code{expandSize} method.

\begin{example}
void advance();
\end{example}

This method updates or increases the offset variable of all PortHoles by
the number of samples consumed or produced. It calls \code{advance} method
of each porthole.

\begin{example}
IntState procId;
\end{example}

This is a integer state to indicate the processor assignment. By default,
the value is -1 to indicate the star is not assigned yet. If we assign
stars manually, we give a valid processor id to this state.

\begin{example}
int dataParallel
\end{example}

Is a flag to be set if this star is a wormhole or a parallel star.

\begin{example}
Profile* profile;
\end{example}

This is a pointer to a Profile object (or a Profile array). If it is not
a parallel star, this pointer is set NULL.

\begin{example}
int deferrable();
\end{example}

When constructing a schedule for a single processor, we defer a star
as late as possible to reduce the buffer requirement on every arc.
In this method, we never defer a Fork star, and always defer a non-Fork
star that feeds into a Fork. This prevents the resulting fork buffer
from being larger than necessary; new samples are not added until they must be.

\node CGstar public members
\subsection{CGstar public members}

\begin{example}
const char* domain() const;
int isA(const char* \var{class});
\end{example}

The first method returns ''CG''. The second method returns TRUE if
based on the argument class is CGStar or a base class of CGStar.

\begin{example}
int isSDF() const;
\end{example}

Returns TRUE if it is a SDF type star (default). For BDF stars, 
it will return FALSE.

\begin{example}
virtual void initCode();
\end{example}

This method allows a star to generate code outside the main loop.
This method will be called after scheduling is performed and before
scheduling is executed. On the other hand, \code{go} method is called
during scheduling is executed, to form a main loop body.

\begin{example}
int run();
\end{example}

This method in CG domain does not perform any data movement, but
execute \code{go} method followed by \code{advance} method (look at
protected members).

\begin{example}
CGTarget* myTarget();
void setTarget(Target* \var{t});
\end{example}

These methods get and set the target pointer this star is assigned to.
When we set the target pointer, we also initialize the SymbolLists and
the CodeStream pointers.

\begin{example}
virtual CGWormBase* myWormhole();
\end{example}

This method returns the pointer to itself if this star is a wormhole. 
It returns NULL if it is not a wormhole (default).

\begin{example}
int isParallel() const;
virtual Profile* getProfile(int \var{ix} = 0);
\end{example}

The first method returns TRUE if this star is a wormhole or a parallel 
star which needs more than one processor to generate code. If it is
\emph{parallel}, the second method returns the pointer to a Profile
indexed by the second argument. A parallel star stores the scheduling
results of the inside in Profile objects (\pxref{class Profile}).

\begin{example}
int maxComm();
\end{example}

Returns the communication overhead with its ancestors. It calls
\code{commTime} method of the target class to obtain the communication
cost.

\begin{example}
void setProcId(int \var{i});
int getProcId();
\end{example}

These methods set and get the processor id this star is assigned to.

\node class CGPortHole
\section{Class CGPortHole}

Class CGPortHole is derived from class DFPortHole to support non-SDF type
DataFlow stars as well as SDF stars. Methods related to a Fork star
are already described in a previous section, Resource Management
(\pxref{Resource Management}).

In this section, we will categorize the members of CGPortHole into 4
roles.

\node buffer management
\subsection{buffer management}

A CGPortHole is connected a buffer after resource allocation. A CGPortHole
maintains an offset index to the buffer to identify the current position
in the buffer which this porthole will put or get a new sample.

\begin{example}
int offset;
\end{example}

It is a protected member for indexing the buffer connected to this port.

Methods described in this subsection are all public.

\begin{example}
unsigned bufPos() const;
\end{example}

Returns \code{offset}, the offset position in the buffer.

\begin{example}
virtual int bufSize() const;
virtual int localBufSize() const;
\end{example}

Both methods returns the size of buffer connected to this porthole.
In this base class, they call the same methods of CGGeodesic
(\pxref{Resource Management}). Recall that the second method returns 0
when it is a Fork output. If a porthole is at the wormhole boundary,
both return the multiple of the sample rate and the repetition count of its
parent star. They are virtual so that the derived classes can redefine them.

\begin{example}
virtual void advance();
\end{example}

After its parent star is executed, we advance the offset by the number of
samples produced or consumed. The offset is wrapped around if it reaches
the boundary of the buffer.

\node embedding
\subsection{Embedding}

Let's consider a DownSample star. If we allocate separate buffers to
its input and output ports, the buffer size of input port will be
larger than the output port. Also, we perform unnecessary sample copy.
We can improve this situation by allocating one buffer at the input site
and indicating a special section of that buffer as the image of the output
buffer. We call this relationship \emph{embedding}: the input buffer
embeds the output buffer. Unlike the fork buffer, the size of input and
output buffers are different. Therefore, we have to specify which position
the embedded buffer starts in the embedding buffer. We use this embedding
relationship to implement Spread and Collect stars in the CGC domain, without
increasing the buffer requirements. For example, the output ports of
a Spread star are embedded in the input buffer of the star, starting from
the different offsets.

\begin{example}
CGPortHole* embeddedPort;
int embeddedLoc;
int embeddingFlag;
\end{example}

These are protected members to specify embedding relations. The first one
points to the embedding port which this PortHole is embedded in. The second
member indicates the starting offset of embedding. The last member indicates
whether this porthole is an embedding port or not.

The following are public methods related to embedding.

\begin{example}
CGPortHole* embedded();
int whereEmbedded();
int embedding();
\end{example}

These methods return the protected members described in the previous
paragraph in the same order.

\begin{example}
void embed(CGPortHole& \var{p}, int \var{i} = -1);
\end{example}

This method establishes an embedding relationship between this port and
the argument port \var{p}. This porthole becomes an embedding port.
The second argument specifies the starting offset.

\begin{example}
void embedHere(int \var{offset});
\end{example}

This method changes the starting offset of embedded buffer in the embedding
buffer.

\node switch Geodesic
\subsection{Switch Geodesic}

In the original graph, a PortHole is connected to a Geodesic. In code
generation domains, we usually allocate a resource to the Geodesic so that
the source and the destination port can share the same resource (Note that
it is not a must). After resource allocation, we may want to alias
a porthole to another porthole, that means another resource rather than
the allocated resource. To do that, we switch
the pointer to the Geodesic to another Geodesic.

\begin{example}
virtual void switchGeo(Geodesic* \var{g});
virtual void revertGeo(Geodesic* \var{g});
\end{example}

Both methods set the Geodesic pointer to the argument \var{g}. There is a flag
to indicate that this port switched Geodesic or not. The first method
sets the flag while the second method resets the flag. Both are virtual since
in the derived classes we may need to save the original Geodesic.
The flag is queried by

\begin{example}
int switched() const;
\end{example}

If Geodesic is switched in this port, we have to reset the geodesic
pointer of this port to 0 in the destructor to prevent deleting the
same Geodesic multiple times. Also, we have to make sure that
both ends of a Geodesic do not switch Geodesic to prevent memory leaking.

\node other members
\subsection{Other members}

Class CGPortHole has a constructor with no argument to reset the variables.
In the destructor, we clear \code{forkDests} list and remove the pointer
to this porthole from the \code{forkDests} list of \code{forkSrc} port.
All members described in the subsection are public.

\begin{example}
virtual Geodesic* allocateGeodesic();
CGGeodesic& cgGeo() const;
\end{example}

The first method allocates a CGGeodesic and give it a name.
The second method returns the reference of the Geodesic after type casting.

\begin{example}
void forceSendData();
void forceGrabData();
\end{example}

These methods put and get samples from the Geodesic at the wormhole
boundary. They are used when the inside code generation domain
communicate with the base workstation by wormhole mechanism.

\node derived classes
\subsection{Derived classes}

Class InCGPort and class OutCGPort are derived from CGPortHole to indicate
whether it is an input port or an output port.

Class MultiCGPort is derived from class MultiSDFPort. It has a protected
member \code{forkSrc} to point to the Fork input if its parent star
is a Fork star. It has a default destructor.

\begin{example}
CGPortHole* forkSrc;
\end{example}

There are two public methods related to this protected member.

\begin{example}
void setForkBuf(CGPortHole& \var{p});
void forkProcessing(CGPortHole& \var{p});
\end{example}

The first method sets \code{forkSrc} with the pointer to the argument port.
The second method sets \code{forkSrc} pointer of the argument port with
the \code{forkSrc} of this MultiPortHole.

Two methods are derived from MultiCGPort: MultiInCGPort and MultiOutCGPort.
They both have the following method:

\begin{example}
PortHole& newPort();
\end{example}

This method creates an InCGPort or an OutCGPort whether it is an input or an
output.

\node Target
\chapter{Target}

Target has a clear meaning in code generation domains, a model of
the target machine for which code will be generated. Class CGTarget is the
base class for all code generation targets whether it is a single
processor target or a multiprocessor target. Class MultiTarget,
derived from class CGTarget, serves as the base target for all
multiprocessor targets. 
For
single processor targets, we have AsmTarget and HLLTarget to distinguish
assembly code generation targets and high level language generation targets.
If we generate assembly code for a target, the target will be derived from
class AsmTarget. If we generate a high level language code, the target
will be derived from HLLTarget. For detailed discussion for Target
hierarchy, refer [4] in References (\pxref{References}).

In this chapter, we will describe class CGTarget and some base multiprocessor
targets since we focus on multiprocessor code generation. Refer to
other sources for AsmTarget and other high level language targets.
 
\node class CGTarget
\section{Class CGTarget}

Class CGTarget is derived from class Target. It has a four-argument
constructor.

\begin{example}
CGTarget(const char* \var{name}, const char* \var{starclass}, const char* \var{desc}, char \var{sep});
\end{example}

The first argument is the name of the target and the second argument is the
star class that this target can support. The third argument is the description
of this target. The last one is a separator character for unique symbol
generation.

There are two protected states in the CGTarget:

\begin{example}
StringState destDirectory;
IntState loopingLevel;
\end{example}

The first state indicates where to put the code file. The second state
determines which scheduler is used in case this target is a single
processor target. By default, \var{loopingLevel} = 0 and we do not
try looping. If \var{loopingLevel} = 1, we select Joe's loop scheduler.
Otherwise, we use the most complicated loop scheduler.

At the top level, three methods of the Target class are called in sequence:
\code{setup}, \code{run}, and \code{wrapup}. 

\begin{example}
void setup();
\end{example}

In this method, we do the following tasks:

(1) Initialize \code{myCode} and \code{procedure} code stream.

(2) Select a scheduler if no scheduler is selected yet.

At this stage, we check whether the galaxy is assigned or not. In
multiprocessor targets, a child target is not assigned a galaxy until
a sub-univers is created. If the galaxy is not assigned, return.

(3) Reset the symbol lists.

(4) Modify the galaxy if necessary by calling \code{modifyGalaxy}. In this
base class it does nothing. But, in AsmTarget, we insert some stars
(CircToLin, LinToCirc) at loop boundary to change the type of buffer
addressing in case a loop scheduling is performed. In this method,
the galaxy can not be initialized particularly if it is a child target.

\begin{example}
virtual int modifyGalaxy();
\end{example}

Is a protected method.

(5) If it is a child target, the schedule was already made at this stage
from a parallel scheduler of the parent multiprocessor target. Otherwise,
we initialize and schedule the graph.

(6) If it is a child target or it is not inside a wormhole, return.
Otherwise, we first adjust the sample rate of the wormhole portholes
(\code{adjustSampleRates}). Then, we generate and download code:
\code{generateCode} and \code{wormLoadCode}.

\begin{example}
void adjustSampleRates();
\end{example}

This method is a protected method to be called when this target is
inside a wormhole. After scheduling is performed, we need to multiply
the sample rate of wormhole portholes by the repetition
count of the stars inside the wormhole connected to the porthole.

\begin{example}
virtual void generateCode();
\end{example}

This method guides the overall procedure to generate code for single
processor targets. The procedure is as follows:

(1) If this target is a child target, call \code{setup} to initialize the
variables. Copy the symbol counter (\code{symbolCounter}) of the parent
target to the symbol counter of this target to achieve a unique symbol
in the system scope.

(2) We compute buffer sizes, allocate memory, etc: \code{allocateMemory}.

\begin{example}
virtual int allocateMemory();
\end{example}

This method is protected. It does nothing and returns TRUE in this
base class.

(3) Call the method \code{generateCodeStreams()}.  This method will be
described later.

(4) Organize the CodeStreams into a single code stream and save the result
to the \code{myCode} stream: \code{frameCode}.

\begin{example}
virtual void frameCode();
\end{example}

This method is a protected method. It does nothing in this base
class.

(5) If this target is not a child target, write the generated code
to a file: \code{writeCode}.

\begin{example}
virtual void writeCode(const char* \var{name} = NULL);
\end{example}

This is a public method to write the \code{myCode} stream to the argument
file. If no argument is given, use "code.output" as the default file
name.

(6) If it is a child target, copy the symbol counter to that of
the parent target.

The methods described above for code generation are all virtual
methods.  They will be redefined in the derived targets.

The method 
   
\begin{example}
void CGTarget::generateCodeStreams();
\end{example}
   
does the following things:

(1) Write initial code.

\begin{example}
virtual void headerCode();
\end{example}

In this base class, this protected method writes the  header comment
to the \code{myCode} CodeStream.

\begin{example}
virtual StringList headerComment(const char* \var{begin} = NULL, const char*
\var{end} = "", const char* \var{cont} = NULL);
\end{example}

This method is a public virtual method to generate the header
comment in the code. In this base class, the head comments include the
user id, code creation date, target name, and the galaxy name. The
arguments are passed to the \code{comment} method.

\begin{example}
virtual StringList comment(const char* \var{cmt}, const char* \var{begin} = 
NULL, const char* \var{end} = "", const char* \var{cont} = NULL);
\end{example}

This public method generates a comment from a specified string \var{cmt}.
We prepend \var{begin} and append \var{end} to the string. If \var{begin}
is NULL, we prepend '#' as a shell-stype comment. If \var{cont} is 
specified, multi-line comments are supported.

(2) We do initialization for code generation: for example, compute
offsets of portholes and call \code{initCode} methods of stars:
\code{codeGenInit}.

\begin{example}
virtual int codeGenInit();
\end{example}

is a protected method. It does nothing and returns TRUE in this
base class.

(3) Generate the code for the main loop: \code{mainLoopCode}.

\begin{example}
virtual void mainLoopCode();
\end{example}

In this method we first compute the number of iterations. If this
target is inside a wormhole, the number is -1 indicating an infinite
loop. Otherwise, the \code{stopTime} of the scheduler determines the number
of iteration.  In this base class, we call the following five methods
sequentially: \code{beginIteration}, \code{wormInputCode} if inside a 
wormhole, \code{compileRun}, \code{wormOutputCode} if inside a wormhole, and
\code{endIteration}. In the derived class, this sequence may be changed
(\pxref{class CGMultiTarget}).

\begin{example}
void beginIteration(int \var{numiter}, int \var{depth});
void endIteration(int \var{numiter}, int \var{depth});
\end{example}

These public methods form the head or ending of the main loop. The
arguments of both methods are the number of iteration and the depth of
the loop. In the main loop, the depth is set 0.

\begin{example}
virtual void wormInputCode();
virtual void wormOutputCode();
virtual void wormInputCode(PortHole& \var{p});
virtual void wormOutputCode(PortHole& \var{p});
\end{example}

The above methods are all public. They generate code at the wormhole
boundary if the target resides in a wormhole. The last two methods
generate code for the argument porthole that is at the wormhole
boundary. In this base class, put comments in \code{myCode} CodeStream
indicating that the methods are successfully executed. They should be
redefined in the derived classes to be useful. The first two methods
traverse all portholes at the wormhole boundary to use the last two
methods.

\begin{example}
virtual void compileRun(SDFScheduler* \var{sched});
\end{example}

This protected method calls \code{compileRun} of the argument scheduler. 
By default, this method calls \code{go} methods of all stars in the
scheduled order to generate code in \code{myCode} CodeStream.

(4) Call \code{wrapup} methods of stars to generate code after the main
loop, but still inside the main function.

(5) Add more code if necessary: \code{trailerCode}

\begin{example}
virtual void trailerCode();
\end{example}

This protected method does nothing in this base class.

The method

\begin{example}
virtual int wormLoadCode();
\end{example}

is protected. It downloads code to the target machine
and starts executing it if the target resides in a wormhole. In this
base class, we just display the code.

Now, we discuss the \code{run} method.

\begin{example}
int run();
\end{example}

If the target is not inside a wormhole, it generates code by calling
\code{generateCode} as explained above. Otherwise, we do the transfer of
data to and from the target since this method will be called when the
wormhole is executed: \code{sendWormData} and \code{receiveWormData}
in sequence.

\begin{example}
virtual int sendWormData();
virtual int receiveWormData();
virtual int sendWormData(PortHole& \var{p});
virtual int receiveWormData(PortHole& \var{p});
\end{example}

The above methods are all protected. They send and receive samples to this
target when run inside a wormhole. The argument is the porthole of the
interior star at the wormhole boundary. If no argument is given, send and
receive for all the appropriate portholes. In this base class, we generate
comments to indicate that these methods are successfully called.

\begin{example}
void wrapup();
\end{example}

In derived classes, wrapup will generate wrapup code to finalize the code,
download, and run the code. This CGTarget class just displays the code.

So far, we explain the three top level methods of the CGTarget class.
Methods related to the CodeStream and unique symbol generations can
be found in the previous chapter. We will describe the remaining members.

\node other CGTarget protected members
\subsection{Other CGTarget protected members}

\begin{example}
char* schedFileName;
\end{example}

The name of log file in case a loop scheduling is taken. By default, the name
is set ''schedule.log''.

\begin{example}
int noSchedule;
\end{example}

This is a flag to be set TRUE if scheduling is not needed in the setup stage.
This flag will be set when the schedule is copied from \code{copySchedule}
method in parallel code generation. By default, this flag is set FALSE.

\begin{example}
StringList indent(int \var{depth});
\end{example}

This method returns a list of spaces for indenting. The number of spaces
is 4 per each \var{depth}.

\begin{example}
void switchCodeStream(Block* \var{b}, CodeStream* \var{s});
\end{example}

This method is set the current \code{myCode} pointer of the argument block
\var{b} to \var{s} CodeStream. If \var{b} is a galaxy, perform this for
all component stars.

\node other CGTarget public members
\subsection{Other CGTarget public members}

\begin{example}
static int haltRequested();
\end{example}

Returns TRUE if error is signaled while Ptolemy is running.

\begin{example}
int inWormhole();
\end{example}

\begin{example}
int isA(const char* \var{class});
\end{example}

Is a standard \code{isA} method for type identification.

Returns TRUE or FALSE, based on whether the target is inside a wormhole or not.

\begin{example}
Block* makeNew() const;
\end{example}

Create a new, identical CGTarget. Internal variables are not copied.

\begin{example}
virtual int incrementalAdd(CGStar* \var{s}, int \var{flag} = 1);
\end{example}

This method is called when we add code for the argument star \var{s}
incrementally. If \var{flag} is 1 (default), we allocate memory for the star, 
and call \code{setup}, \code{initCode}, \code{go}, and \code{wrapup} of
the star. If \var{flag} is 0, we just call \code{go} method of that star.
In this base class, generate an error
message.

\begin{example}
virtual int insertGalaxyCode(galaxy* \var{g}, SDFScheduler* \var{sched});
\end{example}

This method inserts the code for the argument galaxy \var{g} incrementally.
We have to allocate resources and generate initialization, main loop, and
wrapup code. It is used to generate code for galaxy inside a dynamic
construct. A dynamic construct is a wormhole in the code generation domain.
When we call \code{go} method of the wormhole, we generate code
for the inside galaxy. 

\begin{example}
virtual int compileCode();
virtual int loadCode();
virtual int runCode();
\end{example}

These methods compile and load the code, and run the target. In this base
class, generate error messages.

\begin{example}
void writeFiring(Star& \var{s}, int \var{depth});
\end{example}

This method generate code for a firing of the argument star. In this base
class, simply execute \code{run} of the star.

\begin{example}
void genLoopInit(Star& \var{s}, int \var{reps});
void genLoopEnd(Star& \var{s});
\end{example}

In case a loop scheduling is taken, we may want to perform loop
initialization routines for stars inside each loop. There methods
call \code{beginLoop} and \code{endLoop} methods of the argument
star.

\begin{example}
void copySchedule(SDFSchedule& \var{sched});
\end{example}

If this is a child target, the schedule is inherited from the parallel
scheduling of the parent target. This method copies the argument
schedule to the schedule of this target and set \code{noSchedule} flag.

\begin{example}
virtual int systemCall(const char* \var{cmd}, const char* \var{error} = NULL, const char* \var{host} = ''localhost'');
\end{example}

This method makes a system call using \code{rshSystem} utility function.
If \var{error} is specified and the system call is unsuccessful, display the
error message.

\begin{example}
void amInherited();
\end{example}

This method declares that this target is inherited from other target.

\begin{example}
virtual int support(Star* \var{s});
\end{example}

Returns TRUE if this target allows the argument star, FALSE otherwise.

\begin{example}
virtual int execTime(DataFlowStar* \var{s}, CGTarget* \var{t} = 0);
\end{example}

We return the execution time of the argument star \var{s} in the argument
target \var{t}. In a heterogeneous system, execution time of a given
star may vary depending on which target execute the star. In this base
class, we just call \code{myExecTime} method of the star.

\node class HLLTarget
\subsection{Class HLLTarget}

Class HLLTarget, derived from CGTarget class, is a base class of
all high level language code generation targets. There is
AsmTarget class for the base target of all assembly code generation
targets. Since we will illustrate C code generation target, we will
explain the HLLTarget class only in this subsection.

HLLTarget class has a constructor with three arguments as CGTarget class.
In this base class, we provide some methods to generate C++ code.
The following three protected methods are defined to create a
C++ identifier, derived from the actual name.

\begin{example}
StringList sanitize(const char* \var{s}) const;
StringList sanitizedName(const NamedObj& \var{b}) const;
virtual StringList sanitizedFullName(const NamedObj& \var{b}) const;
\end{example}

The first method takes a string argument and modifies it with a valid
C++ identifier. If the string contains a non-alphanumeric character, it
will replace it with '_'. If the string stars with a numeral, it
prepends 'x' at the beginning. The second method calls the first method
with the name of the argument object. The third method generates
an identifier for the argument object that will be placed in \code{struct}
data structure. Therefore, we puts '.' between the object name and its
parent name.

Some public methods are defined.

\begin{example}
void beginIteration(int \var{repetitions}, int \var{depth});
void endIteration(int \var{repetitions}, int \var{depth});
\end{example}

If the \var{repetitions} is negative, we print a \code{while} loop
with infinite repetition. Otherwise, we generate a \code{for}
loop. The second argument \var{depth} determines the amount of indent
we put in front of the code.

\begin{example}
void wrapup();
\end{example}

Saves the generated code to "code.output" file name.

Since this target is not an actual target, it has a pure virtual method:
\code{makeNew}.

\node multiprocessor targets
\section{Multiprocessor Targets}

There are two base multiprocessor targets: MultiTarget and CGMultiTarget.
Class MultiTarget, derived from class CGTarget, serves a base multiprocessor
target for CG domain. On the other hand, CGMultiTarget
class is the base multiprocessor target for CG domain, thus derived from
MultiTarget class. Since the MultiTarget class is a pure virtual class,
the derived classes should redefine the pure virtual methods of the class.

Some members only meaningful for CG domain are split to MultiTarget
class and the CGMultiTarget class. If they are accessed from the parallel
scheduler, some members are placed in MultiTarget class. Otherwise, they
are placed in CGMultiTarget class (Note that this is the organization issue).
Refer to the CGMultiTarget class for detailed descriptions.

\node class MultiTarget
\subsection{Class MultiTarget}

Class MultiTarget, derived from CGTarget, has a constructor with three
arguments.

\begin{example}
MultiTarget(const char* \var{name}, const char* \var{starclass}, const char* \var{desc});
\end{example}

The arguments are the name of the target, the star class it supports, and the
description text. The constructor hides \code{loopingLevel} parameter
inherited from the CGTarget class since the parallel scheduler does not
looping as of now.

\begin{example}
IntState nprocs;
\end{example}

This state, as a protected member, represents the number of processors.
We can set this state, and also change the initial value, by the following 
public method:

\begin{example}
void setTargets(int \var{num});
\end{example}

After child targets are created, the number of child target is stored in
the following protected member:

\begin{example}
int nChildrenAlloc;
\end{example}

There are three states, which are all protected, to choose a scheduling option.

\begin{example}
IntState manualAssignment;
IntState oneStarOneProc;
IntState adjustSchedule;
\end{example}

If the first state is set YES, we assign stars manually by setting
\code{procId} state of all stars. If \code{oneStarOneProc} is set YES,
the parallel scheduler puts all invocations of a star into the same
processor. Note that if manual scheduling is chosen, \code{oneStarOneProc}
is automatically set YES. The last state, \code{adjustSchedule}, will be
used to override the scheduling result manually. This feature has not been
implemented yet. There are some public methods related to these states:

\begin{example}
int assignManually();
int getOSOPreq();
int overrideSchedule();
void setOSOPreq(int \var{i});
\end{example}

The first three methods query the current value of the states. The last
method sets the current value of \code{oneStarOneProc} state to the
argument value.

There are other two states that are protected:

\begin{example}
IntState sendTime;
IntState inheritProcessors;
\end{example}

The first state indicates the communication cost to send a unit sample
between nearest neighbor processors. If \code{inheritProcessors} is set YES,
we inherit the child targets from somewhere else by the following method.

\begin{example}
int inheritChildTargets(Target* \var{mtarget});
\end{example}

This is a public method to inherit child targets from the argument target.
If the number of processors is greater than the number of child targets
of \var{mtarget}, this method returns FALSE with error message. Otherwise,
it copies the pointer to the child targets of \var{mtarget} as its child
targets. If the number of processors is 1, we can use a single processor
target as the argument. In this case, the argument target becomes the child
target of this target.

\begin{example}
void enforceInheritance();
int inherited();
\end{example}

The first method sets the initial value of \code{inheritProcessors} state
while the second method gets the current value of the state.

\begin{example}
void initState();
\end{example}

Is a redefined public method to initialize the state and implements
the precedence relation between states.

\node other MultiTarget public members
\subsubsection{Other MultiTarget public members}

\begin{example}
virtual DataFlowStar* createSpread() = 0;
virtual DataFlowStar* createCollect() = 0;
virtual DataFlowStar* createReceive(int \var{from}, int \var{to}, int \var{num}) = 0;
virtual DataFlowStar* createSend(int \var{from}, int \var{to}, int \var{num}) = 0;
\end{example}

These methods are pure virtual methods to create Spread, Collect, Receive, and
Send stars that are required for sub-universe generation. The last two method
need three arguments to tell the source and the destination processors as well
as the sample rate.

\begin{example}
virtual void pairSendReceive(DataFlowStar* \var{snd}, DataFlowStar* \var{rcv});
\end{example}

This method pairs a Send, \var{snd}, and a Receive, \var{rcv}, stars. In this
base class, it does nothing.

\begin{example}
virtual IntArray* candidateProcs(ParProcessors* \var{procs}, DataFlowStar* \var{s});
\end{example}

This method returns the array of candidate processors which can schedule
the star \var{s}. The first argument is the current ParProcessors that tries to
schedule the star (\pxref{class CGMultiTarget}). In this class, do
nothing and returns NULL.

\begin{example}
virtual Profile* manualSchedule(int \var{count});
\end{example}

This method is used when this target is inside a wormhole. This method
determines the processor assignments of the Profile manually. The argument
indicates the number of invocation of the wormhole.

\begin{example}
virtual void saveCommPattern();
virtual void restoreCommPattern();
virtual void clearCommPattern();
\end{example}

These methods are used to manage the communication resources. In this base
class, do nothing. The first method saves the current resource schedule,
while the second method restores the saved schedule. The last method clears
the resource schedule.

\begin{example}
virtual int scheduleComm(ParNode* \var{node}, int \var{when}, int \var{limit} = 0);
\end{example}

This method schedules the argument communication node, \var{node}, available
at \var{when}. If the target can not schedule the node until \var{limit},
return -1. If it can, return the schedule time. In this base class, just return
the second argument, \var{when}, indicating that the node is scheduled
immediately after it is available to model a fully-connected interconnection of
processors.

\begin{example}
virtual ParNode* backComm(ParNode* \var{node});
\end{example}

For a given communication node, find a communication node scheduled just before
the argument node on the same communication resource. In this base class,
return NULL.

\begin{example}
virtual void prepareSchedule();
virtual void prepareCodeGen();
\end{example}

These two methods are called just before scheduling starts, and just
before code generation starts, to do necessary tasks in the target class.
They do nothing in this base class.

\node class CGMultiTarget
\subsection{Class CGMultiTarget}

While class CGMultiTarget is the base multiprocessor target for all 
code generation domains, either homogeneous or heterogeneous, it
models a fully-connected multiprocessor target. In the target list
in pigi, "FullyConnected" target refers to this target. It is defined in
$(PTOLEMY)/src/domains/cg/targets directory. It has a constructor with three
argument like its base class, MultiTarget. 

To specify child targets, this class has the following three states.

\begin{example}
StringArrayState childType;
StringArrayState resources;
IntArrayState relTimeScales;
\end{example}

The above states are all protected.
The first state, \code{childType}, specifies the names of the child
targets as a list of strings separated by a space. If the number of strings
is fewer than the number of processors specified by \code{nproc} parameter,
the last entry of \code{childType} is extended to the remaining processors.
For example, if we set \code{nproc} equal to 4 and \code{childType} to
be "default-CG56[2] default-CG96", then the first two child targets become
"default-CG56" and the next two child targets become "default-CG96".

The second state, \code{resources}, specifies special resources for child
targets. If we say "0 XXX ; 3 YYY", the first child target (index 0) has
XXX resource and the fourth child (index 3) has YYY resource. Here ';' is
a delimeter. If a child target (index 0) has \code{resources} state already,
XXX resource is appended to the state at the end. Note that we can not edit
the states of child targets in the current pigi. If a star needs a special
resource, the star designer should define \code{resources} StringArrayState
in the definition of the star. For example, a star S is created with
\code{resources} = YYY. Then, the star will be scheduled to the fourth child.
One special resource is the target index. If \code{resources} state of a
star is set to "2", the star is scheduled to the third target (index 2).

The third state indicates the relative computing speed of the processors.
The number of entries in this state should be equal to the number of
entries in \code{childType}. Since we specify the execution of a star
with the number of cycles in the target for which the star is defined,
we have to compensate the relative cycle time of processors in case of
heterogeneous target environment.

Once we specify the child targets, we select a scheduler with appropriate
options. States inherited from class MultiTarget are used to select
the appropriate scheduling options. In the CGMultiTarget class, we have
the following three states, all protected, to choose a scheduler unless
the manual scheduling option is taken.

\begin{example}
IntState ignoreIPC;
IntState overlapComm;
IntState useCluster;
\end{example}

The first state indicates whether we want to ignore communication overhead
in scheduling or not. If it says YES, we select the Hu's level scheduler
(\pxref{Hu Level Scheduler}). If it says NO, we use the next state,
\code{overlapComm}. If this state says YES, we use the dynamic level scheduler
(\pxref{Dynamic Level Scheduler}). If it says No, we use the last state.
\code{useCluster}. If it says YES, we use the declustering algorithm
(\pxref{Declustering Scheduler}). If it says NO, we again use the dynamic
level scheduler. By default, we use the dynamic level scheduler by setting
all states NO. Currently, we do not allow communication to be overlapped
with computation. If more scheduling algorithms are implemented, we may need
to introduce more parameters to choose those algorithms. 

There are other states that are also protected.

\begin{example}
StringState filePrefix;
\end{example}

Indicates the prefix of the file name generated for each processor.
By default, it is set "code_proc", thus creating code_proc0, code_proc1, etc
for code files of child targets.

\begin{example}
IntState ganttChart;
\end{example}

If this state says YES (default), we display the Gantt chart of the 
scheduling result. 

\begin{example}
StringState logFile;
\end{example}

Specifies the log file.

\begin{example}
IntState amortizedComm;
\end{example}

If this state is set YES, we provide the necessary facilities to packetize
samples for communication to reduce the communication overhead. These
has not been used nor tested yet.

Now, we discuss the three basic methods: \code{setup, run, wrapup}.

\begin{example}
void setup();
\end{example}

(1) Based on the states, we create child targets and set up them:
\code{prepareChildren}.

\begin{example}
virtual void prepareChildren();
\end{example}

This method is protected. If the children are inherited, it does nothing.
Otherwise, It clears the list of current child targets if exists. Then,
it creates new child targets by \code{createChild} method and give them
a unique name using \code{filePrefix} followed by the target index.
This method also adjusts the \code{resources} parameter of child targets
with the \code{resources} specified in this target: \code{resourceInfo}.
Finally. it initializes all child targets.

\begin{example}
virtual Target* createChild(int \var{index});
\end{example}

This protected method creates a child target, determined by
\code{childTypes}, of given \var{index}.

\begin{example}
virtual void resourceInfo();
\end{example}

This method parses the \code{resources} state of this class and adjust the
\code{resources} parameter of child targets. If no \code{resources} parameter
exists in a child target, it creates one.

(2) Choose a scheduler based on the states: \code{chooseScheduler}.

\begin{example}
virtual void chooseScheduler();
\end{example}

This is a protected method to choose a scheduler based on the states
related to scheduling algorithms.

(3) If it is a heterogeneous target, we flatten the wormholes:
\code{flattenWorm}. To represent a universe for heterogeneous targets,
we manually partition the stars using wormholes: which stars are assigned
to which target. 

\begin{example}
void flattenWorm();
\end{example}

This method flattens wormholes recursively if the wormholes have
a code generation domain inside.

(4) Set up the scheduler object. Clear \code{myCode} stream.

(5) Initialize the flattened galaxy, and perform the parallel scheduling:
\code{Target::setup}.

(6) If the child targets are not inherited, display the Gantt chart if
requested: \code{writeSchedule}.

\begin{example}
void writeSchedule();
\end{example}

This public method displays a Gantt chart.

(7) If this target is inside a wormhole, it adjusts the sample rate of the
wormhole ports (\code{CGTarget::adjustSampleRates}), generates code
(\code{generateCode}), and download and run code in the target
(\code{CGTarget::wormLoadCode}).

\begin{example}
void generateCode();
\end{example}

This is a redefined public method.  If the number or processors is 1,
just call \code{generateCode} of the child target and return. 
Otherwise, we first
set the stop time, or the number of iteration, for child targets
(\code{beginIteration}). If the target is inside a wormhole,
the stop time becomes -1 indicating it is an infinite loop.
The next step is to generate wormhole interface code
(\code{wormInputCode, wormOutCode} if the target is inside a wormhole.
Finally, we generate code for all child targets 
(\code{ParScheduler::compileRun}).
Note that we generate wormhole interface code before generating code
for child targets since  we can not intervene the code generation procedure of
each child target once started.

\begin{example}
void beginIteration(int \var{repetitions}, int \var{depth});
void endIteration(int \var{repetitions}, int \var{depth});
\end{example}

These are redefined protected methods. In the first method, we call
\code{setStopTime} to set up the stop time of child targets.
We do nothing in the second method.

\begin{example}
void setStopTime(double \var{val});
\end{example}

This method sets the stop time of the current target. If the child
targets are not inherited, it also sets the stop time of the
child targets.

\begin{example}
void wormInputCode();
void wormOutputCode();
void wormInputCode(PortHole& \var{p});
void wormOutputCode(PortHole& \var{p});
\end{example}

They are all redefined public methods. The first two methods traverse
the portholes of wormholes in the original graph, find out all
portholes in sub-universes matched to each wormhole porthole, and generate
wormhole interface code for the portholes.
The complicated thing is that
more than one ParNodes are associated with a star and these ParNodes
may be assigned to several processors.
The last two methods are used when the number of processors is 1 since we
then use \code{CGTarget::wormInputCode,wormOutputCode} instead of the first
two methods.
 
\begin{example}
int run();
\end{example}

If this target does not lie in a wormhole or it has only one processor,
we just use \code{CGTarget::run} to generate code.
Otherwise, we transfer data samples to and from the target:
\code{sendWormData} and \code{receiveWormData}.

\begin{example}
int sendWormData();
int receiveWormData();
\end{example}

These are redefined protected methods. They send data samples to the current
target and receive data samples from the current target. We traverse the
wormhole portholes to identify all portholes in the sub-universes 
corresponding to them, and call \code{sendWormData, receiveWormData} for them.

\begin{example}
void wrapup();
\end{example}

In this base class, we write code for each processor to a file.
 
\node other CGMultiTarget protected members
\subsubsection{Other CGMultiTarget protected members}

\begin{example}
ParProcessors* parProcs;
\end{example}

Is a pointer to the actual scheduling object associated with the current
parallel scheduler.

\begin{example}
IntArray canProcs;
\end{example}

This is an integer array to be used in \code{candidateProcs} to contain
the list of processor indices.

\begin{example}
virtual void resetResources();
\end{example}

This method clears the resources this target maintains such as communication
resources.

\begin{example}
void updataRM(int \var{from}, int \var{to});
\end{example}

This method updates a reachability matrix for communication amortization.
A reachability matrix is created if \code{amortizedComm} is set YES.
We can packetize communication samples only when packetizing does not
introduce deadlock of the graph. To detect the deadlock condition, we
conceptually cluster the nodes assigned to the same processors. If the
resulting graph is acyclic, we can packetize communication samples.
Instead of clustering the graph, we set up the reachability matrix and
update it in all send nodes. If there is a cycle of send nodes, we can
see the deadlock possibility.

\node other CGMultiTarget public members
\subsubsection{Other CGMultiTarget public members}

The destructor deletes all child targets, scheduler, and reachability matrix
if exists. There is a \code{isA} method defined for type identification.

\begin{example}
Block* makeNew() const;
\end{example}

Creates am object of CGMultiTarget class.

\begin{example}
int execTime(DataFlowStar* \var{s}, CGTarget* \var{t});
\end{example}

This method returns the execution time of a star \var{s} if scheduled on
the given target \var{t}. If the target does not support the star, return -1.
If it is a heterogeneous target, we consider the relative time scale of
processors. If the second argument is NULL or it is a homogeneous 
multiprocessor target, just return the execution time of the star in its
definition.

\begin{example}
IntArray* candidateProcs(ParProcessors* \var{par}, DataFlowStar* \var{s});
\end{example}

This method returns a pointer to an integer array of processor indices.
We search the processors that can schedule the argument star \var{s}
by checking the star type and the resource requirements. We include at most
one idle processor.

\begin{example}
int commTime(int \var{from}, int \var{to}, int \var{nSamples}, int \var{type});
\end{example}

This method returns the expected communication overhead when transferring
\var{nSamples} data from \var{from} processor to \var{to} processor. If
\var{type} = 2, this method returns the sum of receiving and sending
overhead.

\begin{example}
int scheduleComm(ParNode* \var{comm}, int \var{when}, int \var{limit} = 0);
\end{example}

Since it models a fully-connected multiprocessors, we can schedule
a communication star anytime without resource conflict, thus return the
second argument \var{when}.

\begin{example}
ParNode* backComm(ParNode* \var{rcv});
\end{example}

This method returns the corresponding send node paired with the argument
receive node, \var{rcv}. If the argument node is not a receive node, return
NULL.

\begin{example}
int amortize(int \var{from}, int \var{to});
\end{example}

This method returns TRUE or FALSE, based on whether communication can be
amortized between two argument processors.

\node class CGSharedBus
\subsection{Class CGSharedBus}

Class CGSharedBus, derived from class CGMultiTarget, is a base class for
shared bus multiprocessor targets. It has the same kind of constructor as
its base class.

This class has an object to model the shared bus.

\begin{example}
UniProcessor bus;
UniProcessor bestBus;
\end{example}

These are two protected members to save the current bus schedule and the
best bus schedule obtained so far. The \code{bus} and \code{bestBus}
are copied to each other by the following public methods.

\begin{example}
void saveCommPattern();
void restoreCommPattern();
\end{example}

\begin{example}
clearCommPattern();
void resetResources()
\end{example}

The first method is a public method to clear \code{bus} schedule, while the
second is a protected method to clear both \code{bus} and \code{bestBus}.

This classes redefines the following two public methods.

\begin{example}
int scheduleComm(ParNode* \var{node}, int \var{when}, int \var{limit} = 0);
\end{example}

This method schedules the argument node available at \var{when} on \code{bus}.
If we can schedule the node before \var{limit}, we schedule the node and
return the schedule time. Otherwise, we return -1. If \var{limit} = 0,
there is no limit when to schedule the node.

\begin{example}
ParNode* backComm(ParNode* \var{node});
\end{example}

For a given communication node, find a communication node scheduled just
before the argument node on \code{bus}.

\node Heterogeneous Support
\chapter{Heterogeneous Support}

In this chapter, we summarize the special routines to support
heterogeneous targets. They are already explained in earlier chapters.

(1) To specify the component targets (\pxref{class CGMultiTarget}), 
we first set \code{childTypes} state of
the target class that must be derived from class CGMultiTarget.
We may add special resources to the processors by setting \code{resources}
state, a list of items separated by ';'. An item starts with the target index
followed by a list of strings identifying resources. The relative computing
speed of processors are specified by \code{relTimeScales} state.

(2) An application program for a heterogeneous target uses wormholes. In
pigi, all stars in a universe should be in the same domain. To overcomm this
restriction, we use wormhole representation to distinguish stars for
different targets, or domains, but still in the same universe.
Once the graph is read into the Ptolemy kernel, all wormholes of code
generation domain are flattened to make a single universe:
\code{flattenWorm} method of CGMultiTarget class. Currently, we
manually partition the stars to different kinds of processors. For
example, if we have three "default-CG96" targets and one "default-CG56"
target, we partition the stars to two kinds: CG96 or CG56. This
partitioning is based on the original wormhole representation. 
If we ignore this partitioning, we can apply an automatic scheduling with
the flattened graph. This feature has not been tested yet even though
no significant change is required in the current code. 

(3) When we schedule a star in the scheduling phase, we first obtain the
list of processors that can schedule the star: \code{candidateProcs} method
of CGMultiTarget class. The execution time of the star to a processor is
computed in \code{execTime} method of CGMultiTarget class considering the
relative speed of processors. 

(4) After scheduling is performed, we create sub-universes for child targets.
In case manual partitioning is performed, we just clone the stars from the
original graph in the sub-universes. In case we use automatic partitioning,
we need to create a star in the current target with the same name as the
corresponding star in the original graph: \code{cloneStar} private method
of UniProcessor class. We assume that we use the same name for a star
in all domains.

\node CGC Domain
\chapter{CGC Domain}

In this chapter, we will explain the current implementation of C code
generation domain. The source code can be found 
$(PTOLEMY)/src/domains/cgc/kernel
directory. We follow the general framework for code generation defined in
CG kernel directory. 

In the CGC domain, the resource we have is the name space. We have to avoid
name conflicts by guaranteeing unique names for different variables.
The most complicated task is to determine the dimension, or buffer size,
of each variable, and the method how to access them; static buffering,
linear indexing, or modulo addressing.

We use the CGC domain to test new functionalities in code generation:
buffer embedding for example. We have tested some
simple demos to verify the design.

\node buffer allocation
\section{Buffer Allocation}

In the CGC domain, we allocate one buffer for each connection in principle.
We have to determine the required size of buffers first.
If a porthole is \emph{embedded} (\pxref{embedding}), and the buffer
size requirement is equal to the sample rate of the embedded port, we
do NOT allocate a buffer on that connection.
We will use static buffering for all \emph{embedded} and \emph{embedding}
portholes. If the buffer requirement of an embedded(or embedding) porthole
is not equal to the sample rate of the porthole, we actually need to have
two buffers on that connection and copy data between these buffers.
In this case, we splice a Copy star on the arc and schedule the Copy star
appropriately to generate code for copying data. After inserting the Copy
star, we will end up with one buffer per connection.
Another cause of copy requirement is type conversion from complex to
float/int or from float/int to complex. Then, we splice a type-conversion
star on the arc.
  
Class CGCTarget redefines the
following protected method for buffer allocation (\pxref{class CGTarget}).

\begin{example}
int allocateMemory();
\end{example}

In this method, we first merge cascaded forks into a single fork whose
input keeps the list of all fork destinations. We will allocate only one
buffer for each fork. All fork destinations will refer to the same
fork input buffer. Then. this method do the following tasks:

(1) Determine the buffer requirements for all portholes.

(2) Splice Copy stars or type conversion stars if necessary.

(3) Set the buffer type for each output porthole: either OWNER or EMBEDDED.
If the output porthole is embedded, or the corresponding input porthole is
embedded, it is called EMBEDDED. Otherwise, it is OWNER.

\begin{example}
void setBufferType();
\end{example}

This is a public method of CGCPortHole class to determine the buffer type of
an output.

(4) We assign unique names for buffers.

(5) We initialize the offset pointer for each porthole which is associated
with a buffer of size greater than 0 (\code{initOffset} method of CGCPortHole
method). This offset pointer indicates from which offset of the buffer the
porthole starts reading or writing samples.

\begin{example}
int initOffset();
\end{example}

This is a public method of CGCPortHole class to initialize the offset pointer.
If there are delays, or initial samples, on the arc, these samples are placed
at the end of the buffer. The offset pointer of a
porthole indicates the location of the last sample the next firing of its
parent star will produce or consume. It is compatible with the SDF simulation
domain: \code{$ref(porthole,num)} in CGC stars is now
equivalent to \code{porthole%num} in SDF stars. 
We can set the offset pointer of an output porthole manually by the following
public method of CGCPortHole class. 

\begin{example}
void setOffset(int \var{v});
\end{example}
 
Now, we will explain steps (1), (2), and (4) in more details.

\node buffer requirement
\subsection{Buffer requirement}

To determine the buffer requirements of portholes, we traverse portholes 
of all stars, and call \code{finalBufSize} method of CGCPortHole class.

\begin{example}
void finalBufSize(int \var{statBuf});
\end{example}

This is a public method of CGCPortHole class to determine the buffer
size for this porthole. The argument indicates whether
we try to use static buffering or not. We allocate one buffer for each
connection. Therefore, we do nothing if this porthole is an input porthole.
If this porthole is disconnected, we set the buffer size equal to the
number of samples produced for each firing. If it lies at wormhole
boundary, we use \code{localBufSize} method of CGPortHole class to determine
the size of buffer and return. Otherwise, we do the following:

(1) We can manually assign the buffer size by calling \code{requestBufSize}
for an output porthole of interest in the setup stage of a star:

\begin{example}
void requestBufSize(int \var{sz});
\end{example}

This method sets the buffer size manually. The argument size should not be
smaller than the minimum size determined by the scheduler. The minimum size
determined by the scheduler is the sum of maximum number of samples
accumulated on the arc during the schedule and the number of old samples
to be access from the destination port. If \var{sz} is smaller than this
minimum value, we generate a warning message and give up manual allocation.

(2) We set the initial buffer size by calling \code{localBufSize} method
of CGPortHole class. If argument \var{statBuf} = 1, we set the buffer
size as a smallest multiple of the sample rate of this porthole, which is
not less than the initial buffer size. By doing this, we increase the chance
of using linear buffering. We also set the waste factor 
(\pxref{Resource Management}) in CGCGeodesic
class to a huge number by calling the following public method in CGCGeodesic
class:

\begin{example}
void preferLinearBuf(int \var{i})
\end{example}

The waste factor set by the above method can be obtained by the following
redefined protected method of the CGCGeodesic class.

\begin{example}
double wasteFactor() const;
\end{example}

(3) We set two flags for this porthole to indicate we can use static buffering
and/or linear buffering: \code{hasStaticBuf} and \code{asLinearBuf}. These two
flags are all private. If static buffering flag is set, we use direct
addressing in the generated code to access the buffer. If linear
buffering flag is set, we will use indirect addressing and no modulo addressing
will be required. Otherwise, we will use indirect addressing and modulo
addressing in the generated code to access the allocated buffer.
Initially both flags are set TRUE. If this porthole needs to access past
samples, we reset both flags to FALSE. When the argument \var{statBuf} is
given 0, we give up static buffering in case the buffer size determined
in (2) is greater than the sample rate of this porthole. Note that
if a loop scheduler is used, \var{statBuf} becomes 0 and some
possibilities of static buffering are sacrificed as the cost of
code compaction. The following method is called to adjust the flags further.

\begin{example}
void setFlags();
\end{example}

Is a protected member of CGCPortHole class. If the final buffer size is
not a multiple of the sample rate, we reset \code{asLinearBuf} flag to 0.
We have to use modulo addressing in the generated code. If the
product of the sample rate and the repetition count of its parent star is
not a multiple of the final buffer size, we give up static buffering, setting
\code{hasStaticBuf} to 0. If an output porthole is embedded or embedding,
we set both flags TRUE since we enforce static buffering.

(4) As the final step, we set the flags for destination portholes. If this
porthole is connected to a fork input, all fork destinations will be
the destination portholes of this porthole. We first check whether
\var{statBuf} argument is 0 and the buffer size is greater than the sample
rate of the porthole. And, we call \code{setFlags} method for that porthole.
If the porthole needs to access past samples, or the number of initial
samples on the connection is not a multiple of the sample rate, we give up
linear buffering.

The final buffer size can be obtained by the following two public methods
of CGCPortHole class.

\begin{example}
int maxBufReq() const;
int bufSize() const \{ return maxBufReq(); \}
\end{example}

The above methods return the final buffer size associated with this porthole.
If it is a fork destination, it returns the size of the fork input buffer.
If the porthole is switched its Geodesic (\pxref{switch Geodesic}), it returns
the size of buffer associated with the switched Geodesic.

The flags for static buffering and linear buffering can be obtained by
the following public methods of CGCPortHole class:

\begin{example}
int linearBuf() const;
int staticBuf() const;
\end{example}

We give up static buffering for a CGPortHole by calling the following public
method of CGCPortHole class.

\begin{example}
void giveUpStatic();
\end{example}

\node splice stars
\subsection{Splice stars}

After buffer requirements for all portholes are determined, we can detect
the arcs which can not have only one buffer. For instance, if we need
to convert data types from complex to float/int or vice versa automatically,
we need two buffers on the arc: one for complex variables and the other
for float/int variables. This copying operation is required since C language
does not provide built-in "complex" type variable. Therefore, we define
"complex" type data in the generated code as follows;

\begin{example}
static char* complexDecl =
"\back n#if !defined(COMPLEX_DATA)\back n#define COMPLEX_DATA 1"
"\back n typedef struct complex_data \{ double real; double imag; \} complex; \back n"
"#endif\back n";
\end{example}

Another case is when an embedded or embedding porthole requires a buffer
whose size is greater than the sample rate of the porthole. Recall that
an embedded or embedding porthole will assume static buffering for
each execution when we generate code for that porthole. If the buffer 
size is larger than the sample rate, we may not use static buffering. 
We need two buffers for the embedded or embedding porthole.

Rather than assigning two buffers on an arc and letting the target
generating code to copy data between these two buffers, we splice
a star on the arc. The spliced star will separate two buffers on one arc
into one buffer on its input and the other buffer on its output arc.
When this spliced star is scheduled before the destination star of after
the source star,
it will generate code to copy data from the input buffer to the output buffer.

Stars are spliced in the following protected method of CGCTarget class.

\begin{example}
void addSpliceStars();
\end{example}

This method traverses all portholes of stars in the galaxy. For an input
porthole, it first checks whether type conversion is necessary or not:
\code{isConverted} method of CGCPortHole class.

\begin{example}
int isConverted();
\end{example}

This is a public method of CGCPortHole class. If no type conversion between
complex and float/int data is required, it returns 0. If we need to convert
from complex to float/int (or vice versa), it returns 1 (or -1). This 
method should be called for an output porthole (or source porthole of a
connection).

If type conversion is required, we splice a CxToFloat star or a FloatToCx
star at the input porthole of the arc. If the input porthole is embedded or
embedding and the buffer requirement is larger than the sample rate, 
we need to splice a Copy star. If we already spliced a type conversion
star, we do not splice a Copy star since the spliced type conversion star
performs the task of copying already. Otherwise, we splice a Copy star at
the input porthole.

When we splice a star at an input porthole (destination porthole), we
initialize the spliced star and set the target pointer. A spliced star should
have one "input" and one "output". We set the sample rate of these portholes
equal to the sample rate of the input porthole. The buffer size of the input
porthole of the spliced star is determined by the original source porthole.
The buffer size of the output porthole is set the sample rate of the
input porthole. And, we check whether static or linear buffering can be used
for the portholes. The input porthole of a spliced Copy star gives up
static buffering while the output porthole of the spliced Copy star and
the original destination porthole can use static and linear buffering.
In case we spliced a type conversion star, we need to change the type of the
original source porthole.

We splice a Copy star at the output (source porthole) when the output 
is an embedded or
embedding porthole and the buffer size is larger than the sample rate of
the output porthole. We initialize the spliced star and set the target
pointer. The sample rate of the input and output porthole of
the spliced Copy star is equal to the sample rate of the output porthole.
The buffer size of the output porthole of the spliced star is set to the
buffer size of the arc. We give up static buffering for this output
porthole. On the other hand, we change the buffer size of
the source porthole to the sample rate of the porthole. 

We need to pay special attention to Collect (or Spread) stars. A Collect
(or Spread) star is not a regular SDF star so that it is not 
scheduled when all input data are available. Actually, we do not execute 
the spliced Collect (or Spread) stars.
But, the output porthole of a Collect (or Spread) star is an embedding
(or embedded) porthole. And
its buffer size can be larger than the sample rate of the porthole.
In this case, we splice a Copy star at the destination porthole, not
at the source porthole. We schedule this Copy star before the destination
star. The sample rate of portholes of the spliced Copy star is equal to
the sample rate of the destination porthole. The output buffer size
of the spliced star is set the the buffer size of the arc while the input
buffer size now becomes the sample rate of the source porthole. The
trickest part here is to determine the offset pointers. We copy data 
when the destination porthole requires it. Therefore, the offset pointers of
the input porthole and the output porthole of the spliced Copy star
depends on the initial delay on the arc. We manually set the offset by
\code{setOffset} method of CGCPortHole class.

There is another case we need data copying between two buffers: when
two embedded portholes are connected together. Suppose, an output porthole
of a Spread star is connected to an input porthole of a Collect star.
Since the output porthole of a Spread star is embedded to the input buffer
and the input porthole of a Collect star is embedded to the output buffer,
we need to copy data from the input buffer of the Spread star to the output
buffer of the Collect star. Since we do not schedule neither Spread nor
Collect star, we may not splice a Copy star either at the source porthole
not at the destination porthole. Therefore, we leave it as a special case
so that we generate code to copy data between two buffers in
\code{moveDataBetweenShared} method of CGCStar class after executing the
star connected to the input porthole of the Spread star. So, we do not
splice star when two embedded portholes are connected together.

\begin{example}
void moveDataBetweenShared();
\end{example}

This is a protected method of CGCStar class. This method is called inside
\code{runIt} method after generating code for a star. If the star is
connected to an embedding porthole of a star of which an embedded output 
porthole is connected to an embedded porthole. Since we meet the case
when two embedded portholes are connected, we generate code for copying
data between two embedding buffers.

\node scheduling spliced stars
\subsubsection{Scheduling spliced stars}

When we splice a star at the input port of a star, we want to
schedule the spliced star before the star. On the other hand, we want
to schedule the spliced star after a star if we splice a star at the
output porthole of the star. When we splice stars, we are already given
the schedule. Therefore, we need to insert spliced stars into the
schedule. An intuitive approach is to insert them into the schedule list.

Currently, we use a simpler method. We use the fact that the spliced
star and the star connected to the spliced star can be regarded as a
cluster and schedule of that cluster is well known. Our idea is to
actually execute the cluster when we execute a star if the star is connected
to spliced stars. CGCStar class has a private member to keep the
list of stars: \code{spliceClust}. Initially, the star itself is
inserted to the list. If we splice a star at the input porthole, we
prepend the spliced star to the list. If we splice a star at the output
porthole, we append the spliced star to the list. And, we redefine
\code{run} method.

\begin{example}
int run();
\end{example}

If there are spliced stars, or the list size is greater than 1, we
traverse the list and execute \code{runIt} method for each star. Otherwise,
we execute \code{runIt} method.

\begin{example}
int runIt();
\end{example}

It is a protected method of CGCStar class to generate main code for this
star. If generates a comment regarding this star and main code. It updates
offset pointers of the star. Finally, it calls \code{moveDataBetweenShared}
method to generate code to copy data between two embedding portholes if
necessary.

\node buffer naming
\subsection{Buffer naming}

One major task for resource assignment in the CGC domain is to give
a unique name for each variable. In the setup stage of the CGCTarget,
we assign an unique index value to each star starting from 1 to the number
of stars in the galaxy. The CGCTarget has two protected members to
give a unique index for galaxy. 

\begin{example}
int galId;
int curId;
\end{example}

The second member is used to give unique indices for galaxies while the
first member indicates the index of the current galaxy.

Now, the CGCTarget can generate a unique name for each variable,
portholes and states, by the following protected method.

\begin{example}
StringList sanitizedFullName(const NamedObj& \var{b}) const;
\end{example}

In this method, the argument object is a porthole or a state of a star.
We prefix 'g' followed by the galaxy index, followed by "_", followed
by the name of the star, followed by another '_', followed by the star
index, followed by yet another '_' to the name of the object. For example,
if star A has a state xx and the star index is 2 and the galaxy index is 1,
the name of the state becomes "g1_A_2_xx".

\begin{example}
StringList correctName(const NamedObj& \var{b});
\end{example}

Is a public version of \code{sanitizedFullName} method.

Now, we are ready to generate unique names for portholes.

\begin{example}
void setGeoName(char* \var{name});
\end{example}

Is a public method of CGCPortHole class. If this porthole is disconnected
and no Geodesic is assigned, we store the name in the porthole. Otherwise,
we store the name in the Geodesic by calling the following public method
of CGCGeodesic class.

\begin{example}
void setBufName(char* \var{name});
\end{example}

The buffer name of a porthole can be obtained by the following public
method of CGCPortHole class.

\begin{example}
const char* getGeoName() const;
\end{example}

This method returns the buffer name stored in this object if it is
disconnected, or call \code{getBufName} method of CGCGeodesic class.
If it is a fork destination, it returns the name of the fork input buffer.

\node data structure
\section{Data structure for galaxy and stars}

In the global declaration section of the generated code, we declare
data structures for stars. At early design stage of CGC domain, we use
\code{struct} construct of C language to declare the data structure of
the program. This way, we could assign unique memory locations to variables
very easily. But, the length of a variable gets large as the hierarchy of
the graph grows. Furthermore, we reduce significant amount of
compiler optimization possibility. Therefore, we invented a scheme to generate
unique symbols for variables (\code{sanitizedFullName} of CGCTarget class)
without using "struct" construct.

\begin{example}
virtual void galDataStruct(Galaxy& \var{galaxy}, int \var{level} = 0);
virtual void starDataStruct(CGCStar* \var{block}, int \var{level} = 0);
\end{example}

The above methods are protected methods of CGCTarget class to be called
in \code{frameCode} method to declare data structures of galaxy and stars.
The second argument of both methods indicates the depth of hierarchy which
the first argument block resides in, thus advising the amount of indents
in the generated code. By default, it is set 0. The first method calls
the second method for each component star if it is not a Fork star. We do
not generate code nor declare data structure for Fork stars.

The data structure for a star consists of four fields:

(1) Comments to indicate that the following declarations corresponds to what
star: \code{sectionComment} method.

\begin{example}
StringList sectionComment(const char* \var{string});
\end{example}

This is a protected method of CGCTarget class to generate a comment line,
\var{string} in the generated code.

(2) Declare buffers associated with portholes. We do not declare input
portholes. If an output porthole is EMBEDDED, we declare a pointer to 
the embedding buffer, by prepending '*' in front of the buffer name. 
Otherwise, it declare a regular buffer. 

(3) Declare index pointers to the buffer if static buffering
is not used and the size of buffer is greater than 1 . Portholes
will use these index pointers to locate the buffer position. For a regular
buffer, we declare an index pointer, named after the buffer name appended by
"_ix". The name of index porthole is given by \code{offsetName} method 
of CGCTarget class.

\begin{example}
StringList offsetName(const CGCPortHole* \var{p});
\end{example}

This is a public method to assign an index pointer to the argument porthole.
It appends '_' followed by "ix" at the end of the porthole name, by calling
the following public method of CGCTarget class:

\begin{example}
StringList appendedName(const NamedObj& \var{p}, const char* \var{add});
\end{example}

This  method is used to append '_' followed by
\var{add} to the name of the object \var{p}.

(4) Finally, we declare referenced states. A State is called \emph{referenced}
only when we use $ref macro for the state at most once. CGCStar class
has the following members for referenced states:

\begin{example}
StateList referencedStates;
void registerState(const char* \var{name});
\end{example}

The first is a public member to store the list of referenced states in this
Star. The second is a protected method to add the state with given name to
the list of referenced states if not inserted.

We traverse the list of referenced states to declare variables. Unlike
portholes, the size of a state variable is given. If the size of state is 1,
we both declare and initialize the state. If the state is an array state,
we both declare and initialize the state using array initialization unless
the state is declared inside a function. If we are declare an array state
inside a function, we have to write explicit initialization code.
Class CGCTarget has the following public method to tell whether we are
working inside a function or not.

\begin{example}
int makingFunc();
\end{example}

Returns TRUE if we are defining a function.

\node buffer initialization
\subsection{buffer initialization}

We initialize buffers and index pointers as follows.

(1) If the buffer is EMBEDDED, we assign a pointer to the embedded 
buffer and set the pointer
to the starting address of the embedding buffer, from which the buffer
is embedded. If the size of the embedding
buffer is 1, we assign the pointer of the embedding buffer.

(2) For the regular buffer, we initialize with 0s in case the buffer size is
greater than 1.

(3) We initialize an index pointer of a buffer to the offset pointer of
the porthole associated with that index pointer.

\node code streams
\section{CGC code streams}

Besides two code streams inherited from CGTarget class, \code{myCode} and
\code{procedures}, CGCTarget class maintains 9 more code streams (all
protected). These
code streams will be stitched together to make the final code in
\code{frameCode} method. There are two schemes to organize a code in general.
One scheme would be to put code strings to a single CodeStream in order.
For example, we put global declarations, main function declaration, 
initialization, and main loop into a single \code{myCode} stream in order.
For single processor code generation, it would be feasible. For
multiprocessor case, however, the parent target may add some extra code
strings. Therefore, we assign different code streams to different
section of code. On the other hand, if we have too many code streams,
it would be arduous to remember all. 

\begin{example}
CodeStream globalDecls;
CodeStream galStruct;
CodeStream include;
\end{example}

These three code streams will be placed in the global scope of the final code.
The galaxy declaration (\code{galStruct}) is separated from \code{globalDecls}
because we need to put galaxy declaration inside a function if we want to
define a function from a galaxy (for example, recursion construct).
A programmer can provide strings to \code{globalDecls} and \code{include}
by using the following protected CGCStar methods in a star definition:

\begin{example}
int addGlobal(const char* \var{decl}, const char* \var{name} = NULL);
int addInclude(const char* \var{decl});
\end{example}

In the first method, we use \var{decl} strings as the name if the second
argument is given NULL, to make a global declaration unique.
The argument of the second method is the name of a file to be included, for
example <stream.h> or "DataStruct.h".

\begin{example}
CodeStream mainDecls;
CodeStream mainInit;
CodeStream commInit;
\end{example}

These three code streams will be placed in the main function before the
main loop: declaration in the main function, initialization code, and
initialization code for communication stars. We separated \code{commInit}
from \code{mainInit} since communication stars are inserted by the parent
multiprocessor target.
A programmer can provide strings to the first
two code streams by using the following protected CGCStar methods.

\begin{example}
int addDeclaration(const char* \var{decl}, const char* \var{name} = NULL);
int addMainInit(const char* \var{decl}, const char* \var{name} = NULL);
\end{example}

The first method uses \var{decl} string as the name of the string if
\var{name} is given NULL.

\begin{example}
CodeStream wormIn;
CodeStream wormOut;
CodeStream mainClose;
\end{example}

The first two streams contain code sections to support wormhole interface
to the host machine. They will be placed at the beginning of the main loop and
at the end of the main loop. The last code stream will be placed after the
main loop in the main function.

Recall that using \code{addCode} method defined in CGStar class, we can
put code strings to any code stream (\pxref{CodeBlock and Macros}).

These nine code streams are initialize by the following protected method
of CGCTarget class.

\begin{example}
virtual void initCodeStrings();
\end{example}

Note that code streams are not initialized in \code{setup} method of 
the target since the parent target may put some code before calling
the \code{setup} method of the target. We initialize code streams after
we stitch them together and copy the final code in \code{myCode} stream
in \code{frameCode} method. We do not initialize \code{myCode} stream in
the above method.

\begin{example}
void frameCode();
\end{example}

This method put all code streams together and copy the resulting code to
\code{myCode} stream. 

\node other CGCPortHole members
\section{Other CGCPortHole members}

CGCPortHole is derived from CGPortHole class. It has a constructor with no
argument. In the constructor, we initialize the default properties of a
CGCPortHole: static buffering and linear buffering flags are set TRUE, buffer
size is set 1. These properties are also initialized in \code{initialize}
method. In the destructor, it deallocates the name of the buffer if stored
in this class (when this porthole is disconnected). All members described in
this section are public.

\begin{example}
CGCPortHole* getForkSrc();
const CGCPortHole* getForkSrc() const;
\end{example}

These methods return the fork input porthole (\code{forkSrc}) if this porthole
is a fork destination. The second method is the \emph{const} version of the 
first method.

\begin{example}
CGCPortHole* realFarPort();
const CGCPortHole* realFarPort() const;
\end{example}

These method return the far side porthole. If the far side porthole is a fork
destination, they return the far side porthole of the fork input, thus
bypassing fork stars. The second is the \emph{const} version of the 
first method.

\begin{example}
CGCGeodesic& geo();
const CGCGeodesic& geo() const;
\end{example}

Return the geodesic connected to this PortHole, type cast.
The second is the \code{const} version of the first method.

\begin{example}
Geodesic* allocateGeodesic();
\end{example}

Allocates a CGCGeodesic.

\begin{example}
void setupForkDests();
\end{example}

If this method is called for a fork input porthole, make a complete list of
\code{forkDests} considering all cascaded forks.

\begin{example}
int inBufSize() const;
\end{example}

This method returns the \code{bufferSize} of this porthole.

CGCPortHole has an iterator called \code{ForkDestIter}. It returns 
fork destinations one at a time. The return type is CGCPortHole.

The derived classes of CGCPortHole in the CGC domain are \code{InCGCPort},
\code{OutCGCPort}, \code{MultiCGCPort}, \code{MultiInCGCPort}, and
\code{MultiOutCGCPort}.

\node other CGCStar members
\section{Other CGCStar members}

Class CGCStar is derived from CGStar class. It has a constructor with no
argument. CGCTarget class is a friend class. It has a method to return
the domain it lies in (\code{domain}) and a method for class identification
(\code{isA}). In \code{initialize} method, we initialize 
\code{referencedStates} list. All other members described in this section
are all protected.

\begin{example}
CGCTarget* targ();
\end{example}

Returns the target pointer, type cast to CGCTarget.

\begin{example}
StringList expandRef(const char* \var{name});
StringList expandRef(const char* \var{name}, const char* \var{offset});
\end{example}

The above methods resolve macro $ref. The \var{name} argument is a
state name or a porthole name. If it is a state name, we put the state
in the \code{referencedStates} list. In the second method, the second 
argument is the offset of the first argument (state or porthole). It can
be a numeral, an IntState name, or a string. If it is an IntState, the
current value of the state is taken. 

There are various ways to referring to a porthole. If the buffer size is
1, we use the buffer name or the pointer version depending on the type,
EMBEDDED or OWNER. If the buffer size is larger than 1, we use direct
addressing if static buffering is used. If static buffering can not
be used, we use indirect addressing. The following method generates
indirect addressing:

\begin{example}
virtual StringList getActualRef(CGCPortHole* \var{p}, const char* \var{ix});
\end{example}

This method generates an indirect addressing for the argument porthole \var{p}
with offset \var{ix}. If we may not use linear addressing, we generate
modulo addressing, in which the index is modulo the buffer size.

\begin{example}
virtual int amISpreadCollect();
\end{example}

Returns TRUE or FALSE, based on whether this star is a Spread or a Collect
star or not. We need to take special care for Spread and Collect stars.

\node other CGCTarget members
\section{Other CGCTarget members}

CGCTarget is derived from HLLTarget class (\pxref{class HLLTarget})
that is the base target class for high level language code generation. 
It has a constructor with three argument like its base target classes.
In the constructor, we initialize code streams and put them into the
\code{codeStringLists} by \code{addStream} method.
It has \code{makeNew} method defined.

\node other CGCTarget protected members
\subsection{Other CGCTarget protected members}

CGCTarget class has many states guiding the compilation procedure.

\begin{example}
IntState doCompile;
\end{example}

If this state is set NO, we only generate code, not compiling the code.

\begin{example}
StringState hostMachine;
StringState funcName;
StringState compileCommand;
StringState compileOptions;
StringState linkOptions;
\end{example}

The \code{hostMachine} state indicates where the generated code is compiled
and run. If this state does not indicate the current host,, we will use
remove shell command for compilation and execution. The \code{funcName}
state is by default set "main". For multiprocessor code generation case,
we may want to give different function name for the generated code.
The next three states determines the compilation command:

\code{compileCommand} \code{compileOptions} fileName \code{linkOptions}

There are some other states defined in this class.

\begin{example}
IntState staticBuffering;
\end{example}

If this state is set YES, we increase the \code{wasteFactor} of geodesics
to use static buffering as much as possible, which is default.

\begin{example}
StringState saveFileName;
\end{example}

We save the generated code in this file if the file name is given.

\begin{example}
StringArrayState resources;
\end{example}

This state displays which resources this target has. By default, the
CGCTarget has the standard I/O (\var{STDIO}) resource. If a derived
target does not support the standard I/O, it should clear this state.

\begin{example}
int codeGenInit();
\end{example}

This method generate initialization code: buffer initialization, and
\code{initCode} method of all stars. Before generating initialization code,
we switch the \code{myCode} pointer of stars to the \code{mainInit} code
stream so that \code{addCode} method called inside the \code{initCode}
method puts the string into the \code{mainInit} code stream.

\begin{example}
void compileRun(SDFScheduler* \var{s});
\end{example}

Before calling \code{compileRun} method of the SDFScheduler, which will
call \code{run} method of stars in the scheduled order, we switch the
\code{myCode} pointer of stars back to the \code{myCode} code stream
of the target. After code generation, we switch the pointer of stars to
the \code{mainClose} code stream for wrapup stage.

\begin{example}
int wormLoadCode();
\end{example}

If the \code{doCompile} state is set NO, we just return TRUE, doing nothing.
Otherwise, we compile and run the generated code. Return FALSE if any
error occurs.

\begin{example}
StringList sectionComment(const char* \var{s});
\end{example}

This method makes a comment statement with the given string in C code.

\begin{example}
void wormInputCode(PortHole& \var{p});
void wormOutputCode(PortHole& \var{p});
\end{example}

The above methods just print out comments. We haven't supported
wormhole interface for CGC domain yet (Sorry!).

\node other CGCTarget public members
\subsection{Other CGCTarget public members}

\begin{example}
void setup();
\end{example}

This method initialize \code{galId, curId} indices for unique symbol
generation. It also generate indices for stars and portholes.
Then, it calls \code{CGTarget :: setup} for normal setup procedure.

\begin{example}
void wrapup();
\end{example}

This method displays the generated code stored in \code{myCode} stream.
If the galaxy is not inside a wormhole, it calls \code{wormLoadCode}
method to compile and run the code.

\begin{example}
int compileCode();
\end{example}

This method compiles the generated code. The compile command is generated
by the following method:

\begin{example}
virtual StringList compileLine(const char* \var{fName});
\end{example}

The argument for this method is the file name to be compiled. If the
\code{hostMachine} does not indicate the local-host, we use remote
shell.

\begin{example}
int runCode();
\end{example}

This method runs the code. If the \code{hostMachine} is not the
local-host, we use \code{rshSystem} function.

\begin{example}
void headerCode();
\end{example}

Is redefined to generate a valid C comment with the target name.

\begin{example}
void beginIteration(int \var{repetitions}, int \var{depth});
void endIteration(int \var{repetitions}, int \var{depth});
\end{example}

The first method generates the starting line of \code{while} loop
(if \var{repetitions} is negative) or \code{for} loop (otherwise).
After that it appends the \code{wormIn} code stream to the \code{myCode}
stream before stars fill the loop body. The \code{wormIn} code stream
is already filled. The second method close the loop. Just before closing
the loop, it appends the \code{wormOut} code stream to the \code{myCode}
at the end of the loop body.

\begin{example}
void setHostName(const char* \var{s});
const char* hostName();
\end{example}

The above methods set and get the \code{hostName} state.

\begin{example}
void writeCode(const char* \var{name} = NULL);
\end{example}

If the argument is NULL, we use the galaxy name as the file name.
This method saves the code to the file.

\begin{example}
void wantStaticBuffering();
int useStaticBuffering();
\end{example}

These methods set and get the \code{statisBuffering} state.

\begin{example}
int incrementalAdd(CGStar* \var{s}, int \var{flag} = 1);
\end{example}

We add the code for the argument star, \var{s},  during code generation step.
If \var{flag} is 0,
we add the main body of the star (\code{go} method only). Otherwise,
we initialize the star, allocate memory, and generate initialization code,
main body, and wrapup code.

\begin{example}
int insertGalaxyCode(Galaxy* \var{g}, SDFScheduler* \var{s});
\end{example}

We insert the code for the argument galaxy during code generation procedure.
We give the unique index for the galaxy and set the indices of stars inside
the galaxy. Then, it calls \code{CGTarget :: insertGalaxyCode} to generate
code. After all, we declare the galaxy.

\begin{example}
void putStream(const char* \var{n}, CodeStream* \code{cs});
CodeStream* removeStream(const char* \var{n});
\end{example}

The above methods put and remove a code stream named \var{n}.

\node class CGCMultiTarget
\section{Class CGCMultiTarget}

Class CGCMultiTarget, derived from CGSharedBus class, models multiple
Unix machines connected together via Ethernet. We use socket mechanism
for interprocessor communication. Since the communication overhead is
huge, we do not gain any speed up for small examples. Nonetheless, we
can test and verify the procedure of multiprocessor code generation.

This class has five private states as follows.

\begin{example}
IntState doCompile;
IntState doRun;
\end{example}

If these states are set YES, we compile and run the generated code.

\begin{example}
StringState machineNames;
StringState nameSuffix;
\end{example}

We list the machine names separated by commas. If all machines names listed
have the same suffix, we separate that suffix in the second state. For
example, if \code{machineName} is "ohm" and \code{nameSuffix} 
is ".berkeley.edu", we mean machine named "ohm.berkeley.edu".

\begin{example}
IntState portNumber;
\end{example}

To make socket connections, we assign port numbers that are available.
For now, we set the starting port number with this state. We will
increase this number by one every time we add a new connection. Therefore,
it should be confirmed that these assigned port numbers should be available.
If the Ptolemy program is assigned a port number in the future, then we will
be able to let the system choose the available port number for each
connection.

With the given list of machine names, we prepare a data structure called
\code{MachineInfo} that pairs the machine name and internet address.

\begin{example}
class MachineInfo \{
friend class CGCMultiTarget;
	const char* inetAdddrr;		// internet address
	const char* nm;			// machine name
public:
	MachineInfo: inetAddr(0), nm(0) \{ \}
\}
\end{example}

This class has a constructor with three argument like its base classes. The
destructor deallocates \code{MachineInfo} arrays if allocated. It has
\code{makeNew} method and \code{isA} method redefined.

\node CGCMultiTarget protected members
\subsection{CGCMultiTarget protected members}

\begin{example}
void setup();
\end{example}

If the child targets are inherited, we also inherit the machine information.
Otherwise, we set up the machine information. The number of processors and
the number of machines names should be equal. Then, we call
\code{CGMultiTarget::setup} for normal setup operation 
(\pxref{class CGMultiTarget}). At last, we set the \code{hostName} state
of child targets with the machine names.

\begin{example}
int wormLoadCode();
\end{example}

This method do nothing if \code{doCompile} state is NO. Otherwise, it
compile the code for all child targets (\code{compileCode}). Then, it
checks whether \code{doRun} state is YES or NO. If it is YES, we execute
the code.

\begin{example}
int sendWormData(PortHole& \var{p});
int receiveWormData(PortHole& \var{p});
int sendWormData();
int receiveWormData();
\end{example}

These method should be redefined in the future to support
wormhole interface. Currently, they do same tasks with the base Target
classes.

\node CGCMultiTarget public members
\subsection{CGCMultiTarget public members}

\begin{example}
MachineInfo* getMachineInfo();
int* getPortNumber();
\end{example}

These methods return the current machine information and the next port number
to be assigned.

\begin{example}
DataFlowStar* createSend(int \var{from}, int \var{to}, int \var{num});
DataFlowStar* createReceive(int \var{from}, int \var{to}, int \var{num});
\end{example}

The above methods create CGCUnixSend and CGCUnixReceive stars for
communication stars with TCP protocol.

\begin{example}
void pairSendReceive(DataFlowStar* \var{snd}, DataFlowStar* \var{rcv});
\end{example}

This method pairs a UnixSend star and a UnixReceive star to make a
connection. We assign a port number to the connection. More important
task is to generate function calls in the initialization code (\code{commInit}
stream) of two child targets which these communication stars belong to.
These functions will make a TCP connection between two child targets with
the assigned port number. The UnixSend star will call \code{connect}
function while the UnixReceive star will call \code{listen} function.

\begin{example}
void setMachineAddr(CGStar* \var{snd}, CGStar* \var{rcv});
\end{example}

This method informs the \var{snd} star about the internet address of 
the machine that the \var{rcv} star is scheduled on. The address is needed in
\code{connect} function. 

\begin{example}
void signalCopy(int \var{flag});
\end{example}

By giving a non-zero value as the argument, we indicate that the code
will be duplicated in different set of processors so that we need to
adjust the machine information of communication stars.

\begin{example}
void prepCode(Profile* \var{pf}, int \var{nP}, int \var{numChunk});
\end{example}

This method is also used to allow code replication into different set of
targets. 

\begin{example}
DataFlowStar* createCollect();
DataFlowStar* createSpread();
\end{example}

These methods create CGCCollect and CGCSpread stars.

\node Status
\chapter{Status}

Here are some points about the current status.

(1) Data Parallel star is not supported yet. 

(2) Execution times of CGC stars are not well defined. They will vary
processor to processor. We estimate them by looking at CG96 stars, or
by counting the number of elementary operations. For heterogeneous
multiprocessor case, we have to design a clean way of specifying these numbers.

(3) Spread/Collect stars and buffer embedding are not supported in ASM domain.
Since Spread/Collect stars are not supported, all ASM multiprocessor
targets should set the \code{oneStarOneProc} state TRUE.

(4) The scheduling option, \code{adjustSchedule} is not implemented yet since
the current graphical editor does not support "cont" function.

(5) Overlapped communication is not supported since we haven't had any
machine of that sort.

\node References
\chapter{References}

[1] G.C.Sih and E.A.Lee, "Dynamic-level scheduling for heterogeneous processor networks," Second IEEE Symposium on Parallel and Distributed Processing, pp. 42-49, 1990

[2] G.C.Sih and E.A.Lee, "Declustering: A New Multiprocessor Scheduling Technique," IEEE Transactions on Parallel and Distributed Systems, 1992.

[3] S. Ha, Compile-time Scheduling of Dataflow Program Graphs with Dynamic Constructs, Ph.D. dissertation, U.C.Berkeley, 1992.
 
[4] J.L.Pino, S.Ha, E.A.Lee, J.T.Buck, "Software Synthesis for DSP 
Using Ptolemy," invited paper, Journal of VLSI Signal Processing, 1993.

[5] W.S.Wang, et al, "Assignment of Chain-Structured Tasks onto
Chain-structured Distributed Systems," source unknown.

