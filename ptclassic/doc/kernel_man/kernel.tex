\input texinfo.tex      @c -*-texinfo-*-
@c %**start of header
@setfilename ptk.info
@settitle The Ptolemy Kernel
@setchapternewpage off
@c version: $Id$
@c %**end of header

@iftex
@finalout
@titlepage
@title The Ptolemy Kernel
@subtitle A programmer's companion for Ptolemy 0.5
@subtitle August 24, 1992
@author by Joseph T. Buck
@end iftex

@node Top, Basic concepts, (dir), (dir)

This document describes the Ptolemy kernel.  The principal audience for
this document is programmers who seek to extend Ptolemy in major ways
(e.g. write a new domain or a new parallel scheduler), or who seek a
deeper understanding of how the kernel works.  A detailed knowledge of
C++ is assumed.

@iftex
@vskip 0pt plus 1filll
@end iftex

Copyright @copyright{} 1992, 1993 The Regents of the University of
California.  All rights reserved.

Permission is hereby granted, without written agreement and without
license or royalty fees, to use, copy, modify, and distribute this
software and its documentation for any purpose, provided that the above
copyright notice and the following two paragraphs appear in all copies of
this software.

IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY FOR
DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING
OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF THE
UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
DAMAGE.

THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANT ABILITY
AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE PROVIDED HEREUNDER IS
ON AN ``AS IS'' BASIS, AND THE UNIVERSITY OF CALIFORNIA HAS NO OBLIGATION
TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.

@iftex
@end titlepage
@end iftex

@menu
* Basic concepts::  Basic concepts, classes, and facilities
* Support for multithreading::  
* Block and related classes::  
* Control of execution::  Control of execution and error reporting
* Interfacing domains::  Wormholes and related classes
* connection classes::  Classes for connections between blocks
* Particles and Messages::  
* The incremental linker::  
* Parameters and States::  
* known lists::     Support for known lists and such
* I/O classes::     
* Misc::            Miscellaneous classes

The Detailed Node Listing:

Basic concepts, classes, and facilities

* Language subset::  The C++ Subset Used In Ptolemy
* Iterators::       Iterators
* utility functions::  Non-class utility functions
* Generic Data Structures::  Generic Data Structures
* class SequentialList::  class SequentialList
* Doubly linked lists::  Doubly linked lists
* Other containers::  Other generic container classes
* class NamedObj::  class NamedObj
* class NamedObjList::  class NamedObjList
* Attributes::      Attributes

Class SequentialList

* SequentialList information functions::  
* other SequentialList functions::  
* class ListIter::  

Doubly linked lists

* class DoubleLink::  Class DoubleLink
* class DoubleLinkList::  Class DoubleLinkList
* class DoubleLinkIter::  Class DoubleLinkIter

Other generic container classes

* class Queue::     class Queue
* class Stack::     class Stack

Class NamedObj

* NamedObj constructors::  NamedObj constructors and destructors
* NamedObj public members::  NamedObj public members
* NamedObj protected members::  NamedObj protected members

Class NamedObjList

* NamedObjList information::  NamedObjList information functions
* other NamedObjList functions::  
* NamedObjList iterators::  

Attributes

* Attribute member functions::  

Support for multithreading

* class PtGate::    
* class CriticalSection::  
* class GateKeeper::  
* class KeptGate::  

Block and related classes

* class Block::     class Block
* class Star::      class Star
* class Galaxy::    class Galaxy
* class DynamicGalaxy::  class DynamicGalaxy
* class InterpGalaxy::  class InterpGalaxy
* class Runnable::  class Runnable
* class Universe::  class Universe
* class InterpUniverse::  class InterpUniverse

Class Block

* Block constructors and destructors::  
* Block public "information" members::  
* other Block public members::  
* Block protected members::  
* Block iterator classes::  

Class Star

* Star public members::  Star public members
* Star protected members::  Star protected members

Class Galaxy

* Galaxy public members::  Galaxy public members
* Galaxy protected members::  Galaxy protected members
* Galaxy iterators::  Galaxy iterators

Class InterpGalaxy

* building structures::  building structures with InterpGalaxy
* deleting InterpGalaxy structures::  
* InterpGalaxy and cloning::  
* other InterpGalaxy functions::  

Control of Execution and Error Reporting

* class Target::    class Target
* class Scheduler::  class Scheduler
* class Error::     class Error
* class SimControl::  class SimControl

Class Target

* Target public members::  Target public members
* Target protected members::  Target protected members

Class Scheduler

* Scheduler public members::  Scheduler public members
* Scheduler protected members::  Scheduler protected members

Class SimControl

* SimControl status flags::  Access to SimControl status flags.
* pre- and postactions::  Preactions and Postactions
* SimControl interrupts and polling::  

Interfacing domains -- wormholes and related classes

* class Wormhole::  class Wormhole
* class EventHorizon::  class EventHorizon
* class ToEventHorizon::  class ToEventHorizon
* class FromEventHorizon::  class FromEventHorizon
* class WormMultiPort::  class WormMultiPort

Class Wormhole

* Wormhole public members::  Wormhole public members
* Wormhole protected members::  Wormhole protected members

Class EventHorizon

* How EventHorizons are used::  
* EventHorizon public members::  
* EventHorizon protected members::  

How EventHorizons are used

* EventHorizon public members::  EventHorizon public members
* EventHorizon protected members::  EventHorizon protected members

Classes for connections between blocks

* class GenericPort::  class GenericPort
* class PortHole::  class PortHole
* class MultiPortHole::  class MultiPortHole
* AutoFork and AutoForkNode::  AutoFork and AutoForkNode
* class ParticleStack::  class ParticleStack
* class Geodesic::  class Geodesic
* class Plasma::    class Plasma
* class ParticleQueue::  class ParticleQueue
* classes for Galaxy ports::  classes for Galaxy ports

Class GenericPort

* GenericPort query functions::  
* other GenericPort public members::  
* GenericPort protected members::  

Class PortHole

* PortHole public members::  
* PortHole protected members::  
* class CircularBuffer::  a class used to implement PortHole

Class MultiPortHole

* MultiPortHole public members::  
* MultiPortHole protected members::  

AutoFork and AutoForkNode

* class AutoFork::  class AutoFork
* class AutoForkNode::  class AutoForkNode

Class Geodesic

* Geodesic public members::  Geodesic public members
* Geodesic protected members::  Geodesic protected members

Particles and Messages

* class Particle::  class Particle
* Particle public members::  Particle public members
* Arithmetic Particle classes::  Arithmetic Particle classes
* Messages::        The Heterogeneous Message Interface
* Example Message types::  Example Message types

The Heterogeneous Message Interface

* class Envelope::  class Envelope
* class Message::   class Message
* class MessageParticle::  class MessageParticle

The incremental linker

* types of links::  Temporary vs. Permanent Incremental Linking
* Linker public members::  Linker public members
* Linker implementation::  Linker implementation

Parameters and States

* class State::     class State
* types of states::  types of states

Class State

* State public members::  State public members
* The State parser::  The State parser and protected members

types of states

* scalar states::   class IntState and class FloatState
* class ComplexState::  class ComplexState
* class StringState::  class StringState
* numeric array states::  numeric array states
* class StringArrayState::  class StringArrayState

Support for known lists and such

* class KnownBlock::  class KnownBlock
* class KnownTarget::  class KnownTarget
* class Domain::    class Domain
* class KnownState::  class KnownState

Class Domain

* Domain virtual functions::  Domain virtual functions

I/O classes

* class StringList::  StringList, a list of strings
* class InfString::  InfString, a class supporting unbounded strings
* class Tokenizer::  Tokenizer, a simple lexical analyzer class
* augmented fstreams::  classes pt_ifstream and pt_ofstream
* class XGraph::    Xgraph, an interface to the xgraph program
* Histogram classes::  Histogram classes

StringList, a kind of String class

* StringList constructors::  constructors and assignment operators
* adding to StringLists::  adding to StringLists
* StringList info functions::  StringList information functions
* StringList conversion::  StringList conversion to const char *
* StringList destruction::  StringList destruction and zeroing
* class StringListIter::  class StringListIter

Tokenizer, a simple lexical analyzer class

* Initializing Tokenizers::  Initializing Tokenizer objects
* reading from Tokenizers::  Reading from Tokenizers
* Tokenizer include files::  Tokenizer include files

Histogram classes

* class Histogram::  Class Histogram
* class XHistogram::  Class XHistogram

Miscellaneous classes

* Mathematical classes::  Mathematical classes
* class IntervalList::  Class IntervalList
* Clock and TimeVal::  Classes for interacting with the system clock

Mathematical classes

* class Complex::   class Complex
* class Fraction::  class Fraction

Class IntervalList

* class Interval::  class Interval and methods
* IntervalList public members::  
* IntervalList iterators::  IntervalList iterator classes.
@end menu

@node Basic concepts, Support for multithreading, Top, Top
@chapter Basic concepts, classes, and facilities

This section describes some basic classes and low-level concepts that
are used throughout Ptolemy.  There are a number of iterator classes,
all with the same interface.  Several important non-class library
functions are provided.  A basic linked list class called
SequentialList is heavily used.  States (@pxref{class State})
and Portholes (@pxref{class PortHole}) can have
@emph{attributes}; these are particularly important in code generation.
Finally, many of the significant classes in Ptolemy -- functional
blocks, portholes to implement connections, parameters -- are derived
from NamedObj, the basic object for implementing a named object that
lives in a hierarchy.

@menu
* Language subset::  The C++ Subset Used In Ptolemy
* Iterators::       Iterators
* utility functions::  Non-class utility functions
* Generic Data Structures::  Generic Data Structures
* class SequentialList::  class SequentialList
* Doubly linked lists::  Doubly linked lists
* Other containers::  Other generic container classes
* class NamedObj::  class NamedObj
* class NamedObjList::  class NamedObjList
* Attributes::      Attributes
@end menu

@node Language subset, Iterators,  , Basic concepts
@section The C++ Subset Used In Ptolemy

The Ptolemy system has grown up with the C++ language, so it does not
use all the latest features in the newest compilers or every nook and
cranny of Ellis and Stroustrup's Annotated Reference Manual, because
of unimplemented features or lack of stability of implementation.
Instead, we focused on stability.  Accordingly, Ptolemy builds under
the Gnu C++ compiler, version 2.2.2, with version 2.2 of the library
@code{libg++}; it also build under Sun C++ 2.1, a port of the AT&T
@file{cfront} compiler to the Sun.

Ptolemy also builds under the (at the time of writing) latest versions
of g++ (2.4.5) and libg++ (2.4), but it is important that the same
version of compiler and libraries be used for compilation of all of
Ptolemy.

This means, for one thing, that templates are not used.  In addition,
some features that do not work that well yet under g++, such as
nested classes, are also avoided.  Nested enumerations, however,
are used in several places.

@node Iterators, utility functions, Language subset, Basic concepts
@section Iterators

Iterators are a very basic and widely used concept in Ptolemy, and are
used repeatedly in Ptolemy programming in almost any situation where a
composite object contains other objects.  We have chosen to use a
consistent interface for all iterator objects.  The typical iterator
class has the following basic interface (some iterators provide additional
functions as well):

@example
class MyIterator @{
public:
    // constructor: argument is associated outer object
    MyIterator(OuterObject&);
    // next: return a pointer to the next object,
    // or a null pointer if no more
    InnerObject* next();
    // operator form: a synonym for next
    InnerObject* operator++(POSTFIX_OP) @{ return next(); @}
    // reset the iterator to point to the first object
    void reset();
@}
@end example

@code{POSTFIX_OP} is a macro that is defined to be an empty string on
older compilers (such as cfront 2.1 and versions of g++ before 2.4) and
to the string "int" with newer compilers.  This conditional behavior is
required because of the evolution of the C++ language; previously,
postfix and prefix forms of the operators ++ and -- were not
distinguished when overloaded; now, a dummy int argument indicates that
the postfix form is intended.

A typical programming application for iterators might be something like

@example
// print the names of all objects in the container
ListIter nextItem(myList);
Item *itemP;
while ((itemP = nextItem++) != 0)
    cout << itemP->name() << "\n";
@end example

It is, as a rule, not safe to modify most container classes in parallel
with the use of an iterator, as the iterator may attempt to access an
object that does not exist any more.  However, the @code{reset} member
function will always make the iterator safe to use even if the list has
been modified (user-written iterators should preserve this property).

@node utility functions, Generic Data Structures, Iterators, Basic concepts
@section Non-class utility functions

The kernel provides several useful ordinary (non-class) functions,
primarily for manipulating strings and pathnames.  Some are defined
in @file{miscFuncs.h}, others in @file{paths.h}.

@example
char* savestring(const char* @var{text});
@end example

The @code{savestring} function creates a copy of the @var{text} argument
with @code{new} and returns a pointer to it.  It is the caller's
responsibility to assure that the string is eventually deleted.  The
argument must not be a null pointer.

@example
const char* hashstring(const char* @var{text});
@end example

This function enters a copy of @var{text} into a hash table and returns
a pointer to the entry.  If two strings compare equal when passed to
@code{strcmp}, then if both are passed to @code{hashstring}, the return
values will be the same pointer.

@example
const char* expandPathName(const char* @var{fileName});
@end example

This function accepts a string and interprets it as a Unix pathname.
If the string does not begin with a @code{~} or @code{$} character,
the string itself is returned.  A leading ``@code{~/}'' is replaced
by the user's home directory; a leading ``@code{~@var{user}/}'' is
replaced by the home directory for @var{user}, unless there is no
such user, in which case the original string is returned.  Finally,
a leading ``@code{$@var{env}}'' is replaced by the value of the
environment variable @var{env}; if there is no such environment
variable, the original string is returned.

If any substitutions are made, the return value is actually a pointer
into a static buffer.  This means that a second call to this function
may write on top of a value returned by a previous call.

@example
const char* pathSearch(const char* @var{file},const char* @var{path}=0);
@end example

For this function, @var{path} is a series of Unix-style directory names,
separated by colons.  If no second argument is supplied or if the value
is null, the value of the PATH environment variable is used instead.
For each of the colon-separated directory strings, the function checks
to see whether @var{dir}/@var{file} exists.  If it finds a match, it
returns a pointer to an internal buffer containing the full path of the
match.  If it does not find a match, it returns a null pointer.

@example
int progNotFound(const char* @var{program},const char* @var{extra}=0);
@end example

This function searches for @var{program} in the user's PATH using the
@code{pathSearch} function.  If a match is found, the function returns
false (0).  Otherwise it returns true (1) and also generates an error
message with the @code{Error::abortRun} function.  If the @var{extra}
argument is given, it forms the second line of the error message.

@node Generic Data Structures, class SequentialList, utility functions, Basic concepts
@section Generic Data Structures

As Ptolemy does not use templates, our generic lists use the generic pointer
technique, with

@example
typedef void * Pointer;
@end example

The most commonly used generic data structure in Ptolemy is
@code{SequentialList}.  Other lists are, as a rule, privately inherited
from this class, so that type safety can be preserved.  It is possible
to insert and retrieve items at either the head or the tail of the list.

@node class SequentialList, Doubly linked lists, Generic Data Structures, Basic concepts
@section Class SequentialList

This class implements a single linked list with a count of the number of
elements.  The constructor produces a properly initialized empty list,
and the destructor deletes the links.  However, the destructor does
not delete the items that have been added to the list; this is not
possible because it has only @code{void *} pointers and would not know
how to delete the items.

There is an associated iterator class for SequentialList called ListIter.

@menu
* SequentialList information functions::  
* other SequentialList functions::  
* class ListIter::  
@end menu

@node SequentialList information functions, other SequentialList functions,  , class SequentialList
@subsection SequentialList information functions

These functions return information about the SequentialList but do not
modify it.

@example
int size() const;
@end example

Return the size of the list.

@example
Pointer head() const;
@end example

Return the first item from the list (0 if the list is empty).  The
list is not changed.

@example
Pointer tail() const;
@end example

Return the last item from the list (0 if the list is empty).  The
list is not changed.

@example
Pointer elem(int @var{n}) const;
@end example

Return the @var{n}th item on the list (0 if there are fewer than @var{n} items).
Note that the time required is proportional to @var{n}.

@example
int empty() const;
@end example

Return 1 if the list is empty, 0 if it is not.

@example
int member(Pointer @var{arg}) const;
@end example

Return 1 if the list has a Pointer that is equal to @var{arg}, 0 if not.

@node other SequentialList functions, class ListIter, SequentialList information functions, class SequentialList
@subsection other SequentialList functions

These functions modify the list they are applied to.

@example
void prepend(Pointer @var{p});
@end example

Add an item at the beginning of the list.

@example
void append(Pointer @var{p});
@end example

Add an item at the end of the list.

@example
int remove(Pointer @var{p});
@end example

Remove the pointer @var{p} from the list if it is present (the test is pointer
equality).  Return 1 if present, 0 if not.

@example
Pointer getAndRemove();
@end example

Return and remove the head of the list.  If the list is empty, return
a null pointer (0).

@example
Pointer getTailAndRemove();
@end example

Return and remove the last item on the list.

@example
void initialize();
@end example

Remove all links from the list.  This does not delete the items pointed
to by the pointers that were on the list.

@node class ListIter,  , other SequentialList functions, class SequentialList
@subsection Class ListIter

ListIter is a standard iterator class for use with objects of class
SequentialList.  The constructor takes an argument of type

@example
const SequentialList
@end example

and the ++ operator (or @code{next} function) returns a @code{Pointer}.
Class ListIter is a friend of class SequentialList.
In addition to the standard iterator functions @code{next} and
@code{reset}, this class also provides a function

@example
void reconnect(const SequentialList& @var{newList});
@end example

that attaches the ListIter to a different SequentialList.

@node Doubly linked lists, Other containers, class SequentialList, Basic concepts
@section Doubly linked lists

Support for doubly linked lists is found in @file{DoubleLink.h}.  The class
DoubleLink implements a baseclass for nodes in the list, class
DoubleLinkList implements the list itself, and class DoubleLinkIter forms an
iterator.

We consider this class to have serious design flaws, so it may be
reworked quite a bit in subsequent Ptolemy releases.

@menu
* class DoubleLink::  Class DoubleLink
* class DoubleLinkList::  Class DoubleLinkList
* class DoubleLinkIter::  Class DoubleLinkIter
@end menu

@node class DoubleLink, class DoubleLinkList,  , Doubly linked lists
@subsection Class DoubleLink

Class DoubleLink is the base type for links in DoubleLinkList objects.
There are two constructors:

@example
DoubleLink(Pointer @var{p}, DoubleLink* @var{next}, DoubleLink* @var{prev}):
DoubleLink(Pointer @var{p});
@end example

The first form initializes the @var{next} and @var{prev} pointers of the
node as well as the contents.  The second form sets these pointers to null.

@example
Pointer content();
@end example

Returns the content pointer of the node.

@example
virtual ~DoubleLink();
@end example

This is a do-nothing destructor, but making it virtual makes the right
thing happen for derived classes.

@example
void unlinkMe();
@end example

This method deletes the node from the list it is contained in, by
connecting together the elements pointed to by the @var{prev} and
@var{next} pointers.

The following data members are protected:

@example
DoubleLink *next; // next node in the list
DoubleLink *prev; // previous node in the list
Pointer e;        // contents of this node
@end example

@node class DoubleLinkList, class DoubleLinkIter, class DoubleLink, Doubly linked lists
@subsection Class DoubleLinkList

@example
DoubleLinkList();
DoubleLinkList(Pointer* @var{e});
@end example

The first form creates an empty list.  The second creates a one
node list containing @var{e}; the node is on the heap.

@example
virtual ~DoubleLinkList();
@end example

The destructor FIXME.

@example
DoubleLink* createLink(Pointer @var{p});
@end example

Create a new DoubleLink containing @var{p} on the heap.
This is a design error: it has nothing to do with DoubleLinkList
and should not be a member of this class.

@example
void insertLink(DoubleLink *x);
void insert(Pointer e);
@end example

These functions insert at the beginning of the list.  The first inserts
a DoubleLink; the second creates a DoubleLink with @code{createLink}
and inserts that.

@example
void appendLink(DoubleLink *x);
void append(Pointer e);
@end example

These functions append at the end of the list.  The first appends
a DoubleLink; the second creates a DoubleLink with @code{createLink}
and appends that.

@example
void insertAhead(DoubleLink *y, DoubleLink *x);
void insertBehind(DoubleLink *y, DoubleLink *x);
@end example

The first one inserts y immediately ahead of x; the second
inserts y immediately after x.  Both these functions assume
that x is in the list; disaster may result otherwise.

@example
DoubleLink* unlink(DoubleLink *x);
@end example

Unlink the link x from the list and return a pointer to it.
Make sure that x is in the list before calling this method,
or disaster may result.

@example
void removeLink(DoubleLink *x);
@end example

This is the same as @code{unlink}, except that x is deleted
as well.  The same cautions apply.

@example
void remove(Pointer e);
@end example

The list is searched for a DoubleLink whose contents match e.  If
a match is found, the node is deleted.  The search is made in the
``forward'' direction.

@example
int find(Pointer e);
@end example

The list is searched for a DoubleLink whose contents match e.  If
a match is found, 1 (true) is returned; otherwise 0 (false) is
returned.

@example
virtual void initialize();
@end example

This function deletes all links of the list and makes the list empty.

@example
void reset();
@end example

This function resets the fields of the DoubleLinkList object without
doing anything to the nodes (why is this here?).

@example
int size();
@end example

Return the number of elements in the list.  Should be const.

@example
DoubleLink *head();
DoubleLink *tail();
@end example

Return a pointer to the head, or to the tail, of the list.  If
the list is empty both will return a null pointer.

@example
DoubleLink *getHeadLink();
Pointer takeFromFront();
@end example

The former function gets and removes the head link from the list,
returning a pointer to it.  The second function calls the first
to obtain the head node; it gets the node, saves the contents,
deletes the node, and returns the contents.  If the list is empty,
both functions return a null pointer.

@example
DoubleLink *getTailLink();
Pointer takeFromBack();
@end example

These functions are identical to the previous pair except that
they remove the last node rather than the first.

The following two data members are protected:

@example
DoubleLink *myHead;
DoubleLink *myTail;
@end example

@node class DoubleLinkIter,  , class DoubleLinkList, Doubly linked lists
@subsection Class DoubleLinkIter

DoubleLinkIter is an iterator for DoubleLinkList.  It is only capable
of moving ``forward'' through the list (following the ``next'' links,
not the ``prev'' links).

Its @code{next} operator returns the Pointer values contained within
the nodes; it is also possible to use the non-standard @code{nextLink}
function to return successive DoubleLink pointers.

@node Other containers, class NamedObj, Doubly linked lists, Basic concepts
@section Other generic container classes

The file @code{DataStruct.h} defines two other generic container classes
that are privately derived from SequentialList: Queue and Stack.

Class Queue may be used to implement a FIFO or a LIFO queue, or a
mixture.

Class Stack implements a stack.

@menu
* class Queue::     class Queue
* class Stack::     class Stack
@end menu

@node class Queue, class Stack,  , Other containers
@subsection Class Queue

The constructor for class Queue builds an empty queue.  The following
four functions move pointers into or out of the queue:

@example
void putTail(Pointer @var{p});
void putHead(Pointer @var{p});
Pointer getHead();
Pointer getTail();
@end example

@code{put} is a synonym for @code{putTail}, and @code{get} is a synonym
for @code{getHead}.  All these functions are implemented on top of the
(hidden) SequentialList functions.  The SequentialList functions
@code{size} and @code{initialize} are re-exported (that is, are
accessible as public member functions of class Stack).

@node class Stack,  , class Queue, Other containers
@subsection Class Stack

The constructor for class Stack builds an empty stack.  The following
functions move pointers onto or off of the stack:

@example
void pushTop(Pointer @var{p});
Pointer popTop();
pushBottom(Pointer @var{p});
@end example

@code{pushTop} and @code{popTop} are the functions traditionally
associated with a stack; @code{pushBottom} adds an item at the bottom,
which is non-traditional.  The following non-destructive function
also exists:

@example
Pointer accessTop() const;
@end example

It accesses but does not remove the element from the top of the stack.

All these functions are implemented on top of the (hidden)
SequentialList functions.  The SequentialList functions @code{size} and
@code{initialize} are re-exported.

@node class NamedObj, class NamedObjList, Other containers, Basic concepts
@section Class NamedObj

NamedObj is the baseclass for most of the common Ptolemy objects.  A
NamedObj is, simply put, a named object; in addition to a name, a
NamedObj has a pointer to a parent object, which is always a Block (a
type of NamedObj).  This pointer can be null.  A NamedObj also has a
descriptor.

Warning!  NamedObj assumes that the name and descriptor ``live'' as long
as the NamedObj does.  They are not deleted by the destructor, so
that they can be compile-time strings.

Important derived types of NamedObj include
Block (@pxref{class Block}),
GenericPort (@pxref{class GenericPort}),
State (@pxref{class State}), and
Geodesic (@pxref{class Geodesic}).

@menu
* NamedObj constructors::  NamedObj constructors and destructors
* NamedObj public members::  NamedObj public members
* NamedObj protected members::  NamedObj protected members
@end menu

@node NamedObj constructors, NamedObj public members,  , class NamedObj
@subsection NamedObj constructors and destructors

All constructors and destructors are public.

NamedObj has a default constructor, which sets the name and
descriptor to empty strings and the parent pointer to null, and a
three-argument constructor:

@example
NamedObj(const char* @var{name},Block* @var{parent},const char* @var{descriptor})
@end example

NamedObj's destructor is virtual and does nothing.

@node NamedObj public members, NamedObj protected members, NamedObj constructors, class NamedObj
@subsection NamedObj public members

@example
virtual const char* className() const;
@end example

className returns the name of the class.  It should have a new
implementation supplied for every derived class (except for abstract
classes, where this is not necessary).

@example
const char* name() const;
@end example

name returns the local portion of the name of the class.

@example
const char* descriptor() const;
@end example

descriptor returns the descriptor.

@example
Block* parent() const;
@end example

parent returns a pointer to the parent block.

@example
virtual StringList fullName() const;
@end example

@code{fullName} returns the full name of the object.  This has no
relation to the class name; it specifies the specific instance's place
in the universe-galaxy-star hierarchy.  The default
implementation returns names that might look like

@example
universe.galaxy.star.port
@end example

for a porthole; the output is the fullName of the parent, plus a period,
plus the name of the NamedObj it is called on.

@example
void setNameParent (const char* @var{my_name},Block* @var{my_parent})
@end example

This method changes the name and parent pointer of the object.

@example
virtual void initialize() = 0;
@end example

initialize is a pure virtual method.  Its function is to initialize the
object to prepare for system execution.

@example
virtual StringList print (int @var{verbose}) const;
@end example

print returns a verbose description of the object.  If verbose is 0, a
somewhat more compact form is printed than if verbose is 1.

@example
virtual int isA(const char* @var{cname}) const;
@end example

The isA method should be redefined for all classed derived from
NamedObj.  Its function is to return TRUE if the argument is the name
either of the class or of one of the baseclasses.  To make this easy to
implement, a macro @code{ISA_FUNC} is provided; for example, in the
file @code{Block.cc} we see the line

@example
ISA_FUNC(Block,NamedObj);
@end example

since NamedObj is the base class from which Block is derived.  This
macro creates the function definition

@example
int Block::isA(const char* cname) const @{
        if (strcmp(cname,"Block") == 0) return TRUE;
        else return NamedObj::isA(cname);
@}
@end example

Methods @code{isA} and @code{className} are overriden in derived
classes; the redefinitions will not be described for each individual
class.

@node NamedObj protected members,  , NamedObj public members, class NamedObj
@subsection NamedObj protected members

@example
void setDescriptor(const char* @var{desc});
@end example

The descriptor is set to @var{desc}.  The string pointed to by
@var{desc} must live as long as the NamedObj does.

@node class NamedObjList, Attributes, class NamedObj, Basic concepts
@section Class NamedObjList

Class NamedObjList is simply a list of objects of class NamedObj.
It is privately inherited from class SequentialList
(@pxref{class SequentialList}), and, as a rule,
other classes privately inherit from it.  It supports only a subset
of the operations provided by SequentialList; in particular, objects
are added only to the end of the list.  It provides extra operations,
like searching for an object by name and deleting objects.

This object enforces the rule that only const pointers to members can
be obtained if the list is itself const; hence, two versions of some
functions are provided.

@menu
* NamedObjList information::  NamedObjList information functions
* other NamedObjList functions::  
* NamedObjList iterators::  
@end menu

@node NamedObjList information, other NamedObjList functions,  , class NamedObjList
@subsection NamedObjList information functions

The @code{size} and @code{initialize} functions of SequentialList
are re-exported.  Note that @code{initialize} removes only the links
to the objects and does not delete the objects.

Here's what's new:

@example
const NamedObj* objWithName(const char* @var{name}) const;
NamedObj* objWithName(const char* @var{name});
@end example

Find the first NamedObj on the list whose name is equal to @var{name},
and return a pointer to it.  Return 0 if it is not found.

@example
NamedObj* head();
const NamedObj* head() const;
@end example

Return a pointer to the first object on the list (0 if none).  There
are two forms, one of which can be applied to const NamedObjList objects.

@node other NamedObjList functions, NamedObjList iterators, NamedObjList information, class NamedObjList
@subsection other NamedObjList functions

@example
void put(NamedObj& @var{obj})
@end example

Add a pointer to @var{obj} to the list, at the end.

@example
void initElements();
@end example

Apply the @code{initialize} method to each NamedObj on the list.

@example
int remove(NamedObj* @var{obj});
@end example

Remove @var{obj} from the list, if present (this does not delete
@var{obj}).  Return 1 if it was present, 0 if not.

@example
void deleteAll();
@end example

Delete all elements from the list, and reset it to be an empty list.
WARNING: this assumes that the members of the list are on the heap
(allocated by @code{new}, so that deleting them is valid)!

@node NamedObjList iterators,  , other NamedObjList functions, class NamedObjList
@subsection NamedObjList iterators

There are two different iterators associated with NamedObjList;
class NamedObjListIter and class CNamedObjListIter.  The latter may
be applied to const NamedObjList objects and returns const NamedObj
pointers; the former requires non-const NamedObjList objects and
returns non-const NamedObj pointers.  They obey the standard iterator
interface and are privately derived from class ListIter.

@node Attributes,  , class NamedObjList, Basic concepts
@section Attributes

Attributes represent logical properties that an object may or may
not have.  A parameter may or may not be settable by the user;
an assembly-language buffer may be allocated in ROM or RAM, fast
memory or slow memory, etc.

The set of attributes of an object is stored in an entity called
a bitWord.  At present, a bitWord is represented as an unsigned
long, which restricts the number of distinct attributes to 32;
this may be changed in future releases.

An Attribute object represents a request to turn certain attributes of
an object off, and to turn other attributes on.  As a rule, constants of
class Attribute are used to represent attributes, and users have no need
to know whether a given property is represented by a true or false
bit in the bitWord.

Although we would prefer to have a constructor for Attribute objects
of the form

@example
Attribute(bitWord @var{bitsOn}, bitWord @var{bitsOff});
@end example

it has turned out that doing so presents severe problems with order of
construction, since a number of global Attribute objects are used and
there is no simple, portable way of guaranteeing that these objects
are constructed before any use.  As a result, the @code{bitsOn} and
@code{bitsOff} members are public, but we forbid use of that fact
except in one place: constant Attribute objects can be initialized
by the C ``aggregate form'', as in the following example:

@example
extern const Attribute P_HIDDEN = @{PB_HIDDEN, 0@};
@end example

The first word specified is the @code{bitsOn} field, and the second
word specified is the @code{bitsOff} field.  Other than to initialize
objects, we pretend that these data members are private.

@menu
* Attribute member functions::  
@end menu

@node Attribute member functions,  ,  , Attributes
@subsection Attribute member functions

@example
Attribute& operator |= (const Attribute& @var{arg});
Attribute& operator &= (const Attribute& @var{arg});
@end example

These operations combine attributes, by applying the @code{|=} and
@code{&=} operators to the bitsOn and bitsOff fields.  The first
operation, as attributes are commonly used, represents a requirement
that two sets of attributes be met, so it has been argued that it
really should be the ``and'' operation.   However, the current scheme
has the virtue of consistency.

@example
bitWord eval(bitWord @var{defaultVal}) const;
@end example

Evaluate an attribute given a default value.  Essentially, bits
corresponding to bitsOn are turned on, and then bits corresponding
to bitsOff are turned off.

@example
bitWord clearAttribs(bitWord @var{defaultVal}) const;
@end example

This method essentially applies the attribute backwards, reversing
the roles of bitsOn and bitsOff in @code{eval}.

@example
bitWord on() const;
bitWord off() const;
@end example

Retrieve the bitsOn and bitsOff values, respectively.

Inline definitions of operators @code{&} and @code{|} are also defined
to implement nondestructive forms of the @code{&=} and @code{|=}
operations.

@node Support for multithreading, Block and related classes, Basic concepts, Top
@chapter Support for multithreading

Multithreading means that there are multiple @emph{threads of control},
or @emph{lightweight processes}, in the same Ptolemy process.  The
principal consequence of the existence of multithreading is that it is
necessary to provide mechanisms that guarantee exclusive access to
resources.

The Ptolemy kernel does not provide a multithreading library, as this
is currently a very OS and CPU-specific operation.  There are a variety
of such libraries that might be used; Sun's lightweight processes
library and the University of Colorado's Awesime package are two
examples.  What the kernel does provide is a locking mechanism for
implementing @emph{critical regions}, noninterruptable regions of code
in which only one thread can be active at a time.  This facility is used
to protect critical resources in the kernel that might be accessed by
multiple threads.

@menu
* class PtGate::    
* class CriticalSection::  
* class GateKeeper::  
* class KeptGate::  
@end menu

@node class PtGate, class CriticalSection,  , Support for multithreading
@section Class PtGate

Objects of classes derived from PtGate are used as semaphores to obtain
exclusive access to some resource.  PtGate is an abstract base class: it
specifies certain functionality but does not provide an implementation.
Derived classes typically provide the desired semantics for use with a
particular threading library.

PtGate has three virtual functions that must be implemented by each
derived class.  The first is a public method:

@example
virtual PtGate* makeNew() const = 0;
@end example

The @code{makeNew} method returns a new object of the same class as the
object it is called for, which is created on the heap.  For example, a
hypothetical SunLWPGate object would return a new SunLWPGate.

The other two methods are protected.  They are:

@example
virtual void lock() = 0;
virtual void unlock() = 0;
@end example

The first call requests access for a resource; the second call releases
access.  If code in another thread calls @code{lock()} on the same
PtGate after @code{lock()} has already been called on it, the second
call will block until the first thread does an @code{unlock()} call.
Note that two successive calls to @code{lock()} on the same PtGate from
the same thread will cause that thread to hang.  It is for this reason
that these calls are protected, not public.  Access to PtGates by user
code is accomplished by means of another class, CriticalSection.  The
CriticalSection class is a friend of class PtGate.

@node class CriticalSection, class GateKeeper, class PtGate, Support for multithreading
@section Class CriticalSection

CriticalSection objects exploit the properties of constructors and
destructors in C++ to provide a convenient way to implement
@emph{critical sections}: sections of code whose execution can be
guaranteed to be atomic.  Their use ensures that data structures can be
kept consistent even when accessed from multiple threads.  The
CriticalSection class implements no methods other than constructors and
a destructor.  There are three constructors:

@example
CriticalSection(PtGate *);
CriticalSection(PtGate &);
CriticalSection(GateKeeper &);
@end example

The function of all of these constructors is to optionally set a lock.
The first constructor will set the lock on the given PtGate unless it
gets a null pointer; the second form always sets the lock.  The third
form takes a reference to an object known as a GateKeeper (discussed in
the next section) that, in a sense, may "contain" a PtGate.  If it
contains a PtGate, a lock is set; otherwise no lock is set.  The lock
is set by calling @code{lock()} on the PtGate object.

The CriticalSection destructor frees the lock by calling @code{unlock()}
on the PtGate object, if a lock was set.

CriticalSection objects are used only for their side effects.  For
example:

@example
PtGate& MyClass::gate;
...
void MyClass::updateDataStructure() @{
        CriticalSection region(MyClass::gate);
        code;
        ...
@}
@end example

The code between the declaration of the CriticalSection and the end
of its scope will not be interrupted.

@node class GateKeeper, class KeptGate, class CriticalSection, Support for multithreading
@section class GateKeeper

The GateKeeper class provides a means of registering a number of PtGate
pointers in a list, together with a way of creating or deleting a series
of PtGate objects all at once.  The motivation for this is that most
Ptolemy applications do not use multithreading, and we do not wish to
pay the overhead of locking and unlocking where it is not needed.  We
also want to have the ability to create a number of fine-grain locks
all at once.

GateKeeper objects should be declared only at file scope (never as
automatic variables or on the heap).

The constructor takes the form

@example
GateKeeper(PtGate *& gateToKeep);
@end example

The argument is a reference to a pointer to a GateKeeper, and the
function of the constructor is to add this reference to a master list.
It will later be possible to ``enable'' the pointer, by setting it to
point to a newly created PtGate of the appropriate type, or ``disable''
it, by deleting the PtGate object and setting the pointer to null.

The GateKeeper destructor deletes the reference from the master list and
also deletes any PtGate object that may be pointed to by the PtGate
pointer.

The public method

@example
int enabled() const;
@end example

returns 1 if the GateKeeper's PtGate pointer is enabled (points to a
PtGate) and 0 otherwise (the pointer is null).

There are two public static functions:

@example
static void enableAll(const PtGate& master);
@end example

This function creates a PtGate object for each GateKeeper on the list,
by calling @code{makeNew()} on the master object.

@example
static void disableAll();
@end example

This function destroys all the PtGate objects and sets the pointers to
be null.  This function must never be called from within a block
controlled by a CriticalSection, or while multithreading operation is
in progress.

A GateKeeper may be used as the argument to a CriticalSection
constructor call; the effect is the same as if the PtGate pointer were
passed to the constructor directly.

@node class KeptGate,  , class GateKeeper, Support for multithreading
@section Class KeptGate

A KeptGate object is simply a GateKeeper that contains its own PtGate
pointer.  It is derived from GateKeeper, has a private PtGate pointer
member, and a constructor with no arguments.  Like a GateKeeper, it
should be declared only at file scope and may be used as an argument
to a CriticalSection constructor call.

@node Block and related classes, Control of execution, Support for multithreading, Top
@chapter Block and related classes

This section describes Block, the basic functional block class, and
those objects derived from it.  It is Blocks more than anything else
that a user of Ptolemy deals with.  Actors as well as collections of
actors are Blocks.

Although the Target class is derived from class Block, it is documented
elsewhere, as it falls under control of execution (@pxref{class Target}).

@menu
* class Block::     class Block
* class Star::      class Star
* class Galaxy::    class Galaxy
* class DynamicGalaxy::  class DynamicGalaxy
* class InterpGalaxy::  class InterpGalaxy
* class Runnable::  class Runnable
* class Universe::  class Universe
* class InterpUniverse::  class InterpUniverse
@end menu

@node class Block, class Star,  , Block and related classes
@section Class Block

Block is the basic object for representing an actor in Ptolemy.
It is derived from NamedObj (@pxref{class NamedObj}).

Important derived types of Block are Star (@pxref{class Star}),
representing an atomic actor;
Galaxy (@pxref{class Galaxy}),
representing a collection of actors that can be thought of as
one actor, and Universe (@pxref{class Universe}),
representing an entire runnable system.

A Block has portholes (connections to other blocks
--- @pxref{class PortHole}),
states (parameters and internal states --- @pxref{class State}),
and multiportholes (organized collections of portholes
--- @pxref{class MultiPortHole}).

While the exact data structure used to represent each is a secret of
class Block, it is visible that there is an order to each list, in that
iterators return the contained states, portholes, and multiportholes in
this order.  Iterators (@pxref{Iterators}) are a set of helper classes
that step through the states, portholes, or multiportholes that belong
to the Block, see the menu entry.

Furthermore, Blocks can be cloned, an operation that produces a
duplicate block.  There are two cloning functions: @code{makeNew},
which resembles making a new block of the same class, and @code{clone},
which makes a more exact duplicate (with the same values for states,
for example).  This feature is used by the KnownBlock class
(@pxref{class KnownBlock}) to create blocks on demand.

@menu
* Block constructors and destructors::  
* Block public "information" members::  
* other Block public members::  
* Block protected members::  
* Block iterator classes::  
@end menu

@node Block constructors and destructors, Block public "information" members,  , class Block
@subsection Block constructors and destructors

Block has a default constructor, which sets the name and
descriptor to empty strings and the parent pointer to null, and a
three-argument constructor:

@example
Block(const char* @var{name},Block* @var{parent},const char* @var{descriptor});
@end example

Block's destructor is virtual and does nothing, except for the standard
action of destroying the Block's data members.

In addition, Block possesses two types of ``virtual constructors'', the
public member functions @code{makeNew} and @code{clone}.

@node Block public "information" members, other Block public members, Block constructors and destructors, class Block
@subsection Block public ``information'' members

@example
int numberPorts() const;
int numberMPHs() const;
int numberStates() const;
@end example

The above functions return the number of ports, the number of
multiports, or the number of states in the Block.

@example
virtual int isItAtomic() const;
virtual int isItWormhole() const;
@end example

These functions return TRUE or FALSE, based on whether the Block is
atomic or not, or a wormhole or not.  The base implementations return
TRUE for isItAtomic, FALSE for isItWormhole.

@example
virtual StringList print(int @var{verbose}) const;
@end example

Overrides @code{NamedObj::print}.  This function gives a basic printout of
the information in the block.

@example
GenericPort* genPortWithName(const char* @var{name});
PortHole* portWithName(const char* @var{name});
MultiPortHole* multiPortWithName(const char* @var{name});
virtual State *stateWithName(const char* @var{name});
@end example

These functions search the appropriate list and return a pointer
to the contained object with the matching name.  @code{genPortWithName}
searches both the multiport and the regular port lists (multiports
first).  If a match is found, it returns a pointer to the matching
object as a @code{GenericPort} pointer.

@example
int multiPortNames (const char** @var{names}, const char** @var{types},
                    int* @var{io}, int @var{nMax}) const;
@end example

Get a list of multiport names.

@example
StringList printPorts(const char* @var{type}, int @var{verbose}) const;
@end example

Print portholes as part of the info-printing method.

@example
virtual Scheduler* scheduler() const;
@end example

Return the controlling scheduler (@pxref{class Scheduler})
for this block.  The default
implementation simply recursively calls the @code{scheduler()} function on the parent, or returns 0
if there is no parent.  The intent is that eventually a block with
a scheduler will be reached (the top-level universe has a scheduler,
and so do wormholes).

@example
virtual Star& asStar();
virtual const Star& asStar() const;
@end example

Return reference to me as a Star, if I am one.  Warning: it is a
fatal error (the entire program will halt with an error message)
if this method is invoked on a Galaxy!  Check with @code{isItAtomic}
before calling it.

@example
virtual Galaxy& asGalaxy();
virtual const Galaxy& asGalaxy() const;
@end example

Return reference to me as a Galaxy, if I am one.  Warning: it is a
fatal error (the entire program will halt) if this method is invoked
on a Star!  Check with @code{isItAtomic} before calling it.

@example
virtual const char* domain() const;
@end example

Return my domain (e.g. SDF, DE, etc.)

@node other Block public members, Block protected members, Block public "information" members, class Block
@subsection other Block public members

@example
virtual void initialize();
@end example

overrides NamedObj::initialize.  Block::initialize initializes the
portholes and states belonging to the block, and calls @code{setup()}, which
is intended to be the ``user-supplied'' initialization function.

@example
virtual int run();
@end example

This function is intended to ``run'' the block.  The default
implementation does nothing.

@example
virtual void wrapup();
@end example

This function is intended to be run after the completion of execution
of a universe, and provides a place for wrapup code.  The default does
nothing.

@example
virtual Block& setBlock(const char* @var{name},Block* @var{parent}=0);
@end example

Set the name and parent of a block.

@example
virtual Block* makeNew() const
@end example

This is a very important function.  It is intended to be overloaded in
such a way that calling it produces a newly constructed object of the
same type.  The default implementation causes an error.  Every derived
type should redefine this function.  Here is an example implementation
of an override for this function:

@example
Block* MyClass::makeNew() const @{ return new MyClass;@}
@end example

@example
virtual Block* clone() const
@end example

The distinction between @code{clone} and @code{makeNew} is that the
former does some extra copying.  The default implementation calls
@code{makeNew} and then @code{copyStates}; it may be overridden to
copy more information.  The intent is that @code{clone} should produce
an identical object.

@example
void addPort(PortHole& @var{port})
void addPort(MultiPortHole& @var{port})
@end example

Add a porthole, or a multiporthole, to the block's list of known ports
or multiports.

@example
int removePort(PortHole& @var{port})
@end example

Remove @var{port} from the Block's port list, if it is present.
1 is returned if @var{port} was present and 0 is returned if it
was not.  Note that @var{port} is not deleted.  The destructor
for class PortHole calls this function on its parent block.

@example
void addState(State& @var{s});
@end example

Add the state @var{s} to the Block's state list.

@example
virtual void initState();
@end example

Initialize the States contained in the Block's state list.

@example
StringList printStates(const char* @var{type},int @var{verbose}) const;
@end example

Return a printed representation of the states in the Block.  This
function is used as part of the Block's @code{print} method.

@example
int setState(const char* @var{stateName}, const char* @var{expression});
@end example

Search for a state in the block named @var{stateName}.  If not found,
return 0.  If found, set its initial value to @var{expression} and
return 1.

@node Block protected members, Block iterator classes, other Block public members, class Block
@subsection Block protected members

@example
virtual void setup();
@end example

User-specified additional initialization.  By default, it does nothing.
It is called by Block::initialize (and should also be called if
initialize is redefined).

@example
Block* copyStates(const Block& @var{src});
@end example

method for copying states during cloning.  It is designed for use
by clone methods, and it assumes that the src argument has the same
state list as the @code{this} object.

@node Block iterator classes,  , Block protected members, class Block
@subsection Block iterator classes

There are three types of iterators that may be used on Blocks:
BlockPortIter, BlockStateIter, and BlockMPHIter.
Each takes one argument for its constructor, a reference to Block.
They step through the portholes, states, or multiportholes, of the
Block, respectively, using the standard iterator interface.

There are also variant versions with a ``C'' prefix (CBlockPortIter, etc)
defined in the file @file{ConstIters.h} that take a reference to a const Block
and return a const pointer.

@node class Star, class Galaxy, class Block, Block and related classes
@section Class Star

Class Star represents the basic executable atomic version of Block.
It is derived from Block (@pxref{class Block}).

Stars have an associated Target (@pxref{class Target}), an index value,
and an indication of whether or not there is internal state.

The default constructor sets the target pointer to null, sets the internal
state flag to TRUE, and sets the index value to -1.

@menu
* Star public members::  Star public members
* Star protected members::  Star protected members
@end menu

@node Star public members, Star protected members,  , class Star
@subsection Star public members

@example
int run();
@end example

Execute the Star.  This method also interfaces to the SimControl
class to provide for control over simulations.  All derived classes
that override this method must invoke @code{Star::run}.

@example
StringList print (int @var{verbose} = 0) const;
@end example

Print out info on the star.

@example
Star& asStar();
const Star& asStar() const;
@end example

These simply return a reference to @code{this}, overriding @code{Block::asStar}.

@example
int index() const;
@end example

Return the index value for this star.  Index values are a feature
that assists with certain schedulers; the idea is to assign a numeric
index to each star at any level of a particular Universe or Galaxy.

@example
virtual void setTarget(Target* @var{t});
@end example

Set the target associated with this star.

@example
void noInternalState();
@end example

Declare that this star has no internal state (This function may
change to protected in future Ptolemy releases).

@example
int hasInternalState();
@end example

Return TRUE if this star has internal state, false if it doesn't.
Useful in parallel scheduling.

@node Star protected members,  , Star public members, class Star
@subsection Star protected members

@example
virtual void go();
@end example

This is a method that is intended to be overriden to provide the
principal action of executing this block.  It is protected and is
intended to be called from the @code{run()} member function.  The
separation is so that actions common to a domain can be provided
in the run function, leaving the writer of a functional block to
only implement @code{go()}.

@example
Target* targetPtr;
@end example

This is a protected data member, set by the setTarget public member
function.

@node class Galaxy, class DynamicGalaxy, class Star, Block and related classes
@section Class Galaxy

A Galaxy is a type of Block (@pxref{class Block})
that has an internal hierarchical structure.
In particular, it contains other Blocks (some of which may also be
galaxies).  It is possible to access only the top-level blocks or to
flatten the hierarchy and step through all the blocks, by means
of the various iterator classes associated with Galaxy.

While we generally define a different derived type of Star for each
domain, the same kinds of Galaxy (and derived classes such as
InterpGalaxy --- @pxref{class InterpGalaxy})
are used in each domain.  Accordingly,
a Galaxy has a data member containing its associated domain (which
is set to null by the constructor).

PortHoles belonging to a Galaxy are, as a rule, aliased so that they
refer to PortHoles of an interior Block, although this is not a
requirement.

@menu
* Galaxy public members::  Galaxy public members
* Galaxy protected members::  Galaxy protected members
* Galaxy iterators::  Galaxy iterators
@end menu

@node Galaxy public members, Galaxy protected members,  , class Galaxy
@subsection Galaxy public members

@example
void initialize();
@end example

System initialize method.  Derived Galaxies should not redefine
initialize; they should write a @code{setup()} method to do any
class-specific startup.

@example
void wrapup();
@end example

System wrapup method.  Recursively calls wrapup in subsystems

@example
void addBlock(Block& @var{b},const char* @var{bname});
@end example

Add block to the galaxy and set its name.

@example
int removeBlock(Block& @var{b});
@end example

Remove the block @var{b} from the galaxy's list of blocks, if it is in
the list.  The block is not deleted.  If the block was present, 1 is
returned; otherwise 0 is returned.

@example
virtual void initState();
@end example

Initialize states.

@example
int numberBlocks() const;
@end example

Return the number of blocks in the galaxy.

@example
StringList print(int @var{verbose}) const;
@end example

Print a description of the galaxy.

@example
int isItAtomic () const;
@end example

Returns FALSE (galaxies are not atomic blocks).

@example
Galaxy& asGalaxy();
const Galaxy& asGalaxy() const;
@end example

These return myself as a Galaxy, overriding @code{Block::asGalaxy}.

@example
const char* domain () const;
@end example

Return my domain.

@example
void setDomain(const char* @var{dom});
@end example

Set the domain of the galaxy (this may become a protected member
in the future).

@node Galaxy protected members, Galaxy iterators, Galaxy public members, class Galaxy
@subsection Galaxy protected members

@example
void addBlock(Block& @var{b})
@end example

Add @var{b} to my list of blocks.

@example
void connect(GenericPort& @var{source}, GenericPort& @var{destination},
             int @var{numberDelays} = 0)
@end example

Connect sub-blocks with a delay (default to zero delay).


@example
void alias(PortHole& @var{galPort}, PortHole& @var{blockPort});
void alias(MultiPortHole& @var{galPort}, MultiPortHole& @var{blockPort});
@end example

Connect a Galaxy PortHole to a PortHole of a sub-block, or same for
a MultiPortHole.


@example
Block* blockWithName (const char* @var{name});
@end example

Support blockWithName message to access internal block list.

@example
void initSubblocks();
void initStateSubblocks();
@end example

Former: Initialize subblocks only.  Latter: initialize states in
subblocks only.

@node Galaxy iterators,  , Galaxy protected members, class Galaxy
@subsection Galaxy iterators

There are three types of iterators associated with a Galaxy:
GalTopBlockIter, GalAllBlockIter, and GalStarIter.  The first
two iterators return pointers to Block; the final one returns
a pointer to Star.

As its name suggests, GalTopBlockIter returns only the Blocks
on the top level of the galaxy.  GalAllBlockIter returns
Blocks at all levels of the hierarchy, in depth-first order;
if there is a galaxy inside the galaxy, first it is returned,
then its contents are returned.  Finally, GalStarIter returns
only the atomic blocks in the Galaxy, in depth-first order.

There is also a const form of GalTopBlockIter, called CGalTopBlockIter.

Here is a function that prints out the names of all stars at any
level of the given galaxy onto a given stream.

@example
void printNames(Galaxy& g,ostream& stream) @{
    GalStarIter nextStar(g);
    Star* s;
    while ((s = nextStar++) != 0)
        stream << s->fullName() << "\n";
@}
@end example

@node class DynamicGalaxy, class InterpGalaxy, class Galaxy, Block and related classes
@section Class DynamicGalaxy

A DynamicGalaxy is a type of Galaxy for which all blocks, ports, and
states are allocated on the heap.  When destroyed, it destroys all of
its blocks, ports, and states in a clean manner.  There's not much
more to it than that: it provides a destructor, class identification
functions @code{isA} and @code{className}, and little else.

@node class InterpGalaxy, class Runnable, class DynamicGalaxy, Block and related classes
@section Class InterpGalaxy

InterpGalaxy is derived from DynamicGalaxy.  It is the key workhorse
for interfacing between user interfaces, such as ptcl or pigi, and
the Ptolemy kernel, because it has commands for building structures
given commands specified in the form of text strings.  These commands
add stars and galaxies of given types and build connections between
them.  InterpGalaxy interacts with the KnownBlock class
(@pxref{class KnownBlock}) to create stars and galaxies,
and the Domain class (@pxref{class Domain}) to create wormholes.

InterpGalaxy differs from other classes derived from Block in that
the ``class name'' (the value returned by @code{className()}) is a
variable; the class is used to create many different ``derived classes''
corresponding to different topologies.

In order to use InterpGalaxy to make a user-defined galaxy type,
a series of commands are executed that add stars, connections, and
other features to the galaxy.  When a complete galaxy has been
designed, the @code{addToKnownList} member function adds the complete
object to the known list, an action that has the effect of adding a
new ``class'' to the system.

InterpGalaxy methods that return an int return 1 for success and 0
for failure.  On failure, an appropriate error message is generated
by means of the Error class.


@menu
* building structures::  building structures with InterpGalaxy
* deleting InterpGalaxy structures::  
* InterpGalaxy and cloning::  
* other InterpGalaxy functions::  
@end menu

@node building structures, deleting InterpGalaxy structures,  , class InterpGalaxy
@subsection building structures with InterpGalaxy

The no-argument constructor creates an empty galaxy.  There is a
constructor that takes a single @code{const char *} argument
specifying the class name (the value to be returned by @code{className()}.
The copy constructor creates another InterpGalaxy with the identical
internal structure.  There is also an assignment operator that does
much the same.

@example
void setDescriptor(const char* @var{dtext})
@end example

Set the descriptor.  Note that this is public, though the NamedObj
function is protected. @var{dtext} must live as long as the InterpGalaxy
does.

@example
int addStar(const char* @var{starname}, const char* @var{starclass});
@end example

Add a new star or galaxy with classname @var{starclass} to this
InterpGalaxy, naming the new instance @var{starname}.  The known block
list for the current domain is searched to find @var{starclass}.
Returns 1 on success, 0 on failure.  On failures, an error message
of the form

@example
No star/galaxy named '@var{starclass}' in domain '@var{current-domain}'
@end example

will be produced.  The name is a misnomer since @var{starclass} may
name a galaxy or a wormhole.

@example
int connect(const char* @var{srcblock}, const char* @var{srcport},
            const char* @var{dstblock}, const char* @var{dstport},
            const char* @var{delay} = 0);
@end example

This method creates a point-to-point connection between the port
@var{srcport} in the subblock @var{srcblock} and the port @var{dstport}
in the subblock @var{dstblock}, with a delay value represented by
the expression @var{delay}.
If the delay parameter is omitted there is no delay.

The delay expression has the same form as an initial value for an
integer state (class IntState), and is parsed in the same way as
an IntState belonging to a subblock of the galaxy would be.

1 is returned for success, 0 for failure.
A variety of error messages relating to nonexistent blocks or ports
may be produced.

@example
int busConnect(const char* @var{srcblock}, const char* @var{srcport},
               const char* @var{dstblock}, const char* @var{dstport},
               const char* @var{width}, const char* @var{delay} = 0);
@end example

This method creates a point-to-point bus connection between the multiport
@var{srcport} in the subblock @var{srcblock} and the multiport @var{dstport}
in the subblock @var{dstblock}, with a width value represented by the
expression @var{width} and delay value represented by
the expression @var{delay}.  If the delay parameter is omitted there is
no delay.

A bus connection is a series of parallel connections: each multiport
contains @var{width} portholes and all are connected in parallel.

The delay and width expressions have the same form as an initial value for an
integer state (class IntState), and are parsed in the same way as
an IntState belonging to a subblock of the galaxy would be.

1 is returned for success, 0 for failure.
A variety of error messages relating to nonexistent blocks or multiports
may be produced.

@example
int alias(const char* @var{galport}, const char* @var{block}, const char *@var{blockport});
@end example

Create a new port for the galaxy and make it an alias for the porthole
@var{blockport} contained in the subblock @var{block}.  Note that this
is unlike the Galaxy @code{alias} method in that this method creates
the galaxy port.

@example
int addNode(const char* @var{nodename});
@end example

Create a node for use in netlist-style connections and name it
@var{nodename}.

@example
int nodeConnect(const char* @var{blockname}, const char* @var{portname},
                const char* @var{node}, const char* @var{delay} = 0);
@end example

Connect the porthole named @var{portname} in the subblock named
@var{blockname} to the node named @var{node}.  Return 1 for success,
0 and an error message for failure.

@example
int addState(const char* @var{statename}, const char* @var{stateclass},
             const char* @var{statevalue});
@end example

Add a new state named @var{statename}, of type @var{stateclass},
to the galaxy.  Its default initial value is given by @var{statevalue}.

@example
int setState(const char* @var{blockname}, const char* @var{statename},
             const char* @var{statevalue});
@end example

Change the initial value of the state named @var{statename} that belongs
to the subblock @var{blockname} to the string given by @var{statevalue}.
As a special case, if @var{blockname} is the string @code{this}, the
state belonging to the galaxy, rather than one belonging to a subblock,
is changed.

@example
int setDomain(const char* @var{newDomain});
@end example

Change the inner domain of the galaxy to @var{newDomain}.  This is the
technique used to create wormholes (that are one domain on the outside
and a different domain on the inside).  It is not legal to call this
function if the galaxy already contains stars.

@example
int numPorts(const char* @var{blockname}, const char* @var{portname}, int @var{numP});
@end example

Here @var{portname} names a multiporthole and @var{blockname} names the
block containing it.  @var{numP} portholes are created within the
multiporthole; these become ports of the block as a whole.  The names of
the portholes are formed by appending @code{#1}, @code{#2}, etc. to the
name of the multiporthole.

@node deleting InterpGalaxy structures, InterpGalaxy and cloning, building structures, class InterpGalaxy
@subsection deleting InterpGalaxy structures

@example
int delStar(const char* @var{starname});
@end example

Delete the instance named @var{starname} from the current galaxy.
Ports of other stars that were connected to ports of @var{starname}
will become disconnected.  Returns 1 on success, 0 on failure.  On
failure an error message of the form

@example
No instance of ``@var{starname}'' in ``@var{galaxyname}''
@end example

will be produced.  The name is a misnomer since @var{starclass} may
name a galaxy or a wormhole.

@example
int disconnect(const char* @var{block}, const char* @var{port});
@end example

Disconnect the porthole @var{port}, in subblock @var{block}, from
whatever it is connected to.  This works for point-to-point or netlist
connections.

@example
int delNode(const char* @var{nodename});
@end example

Delete the node @var{nodename}.

@node InterpGalaxy and cloning, other InterpGalaxy functions, deleting InterpGalaxy structures, class InterpGalaxy
@subsection InterpGalaxy and cloning

@example
Block *makeNew() const;
Block *clone() const;
@end example

For InterpGalaxy the above two functions have the same implementation.
An identical copy of the current object is created on the heap.

@example
void addToKnownList(const char* @var{outerDomain},Target* @var{innerTarget} = 0);
@end example

This function adds the galaxy to the known list, completing the
definition of a galaxy class.  The ``class name'' is determined by
the name of the InterpGalaxy (as set by @code{Block::setBlock} or
in some other way).  This class name will be returned by the
@code{className} function, both for this InterpGalaxy and for any
others produced from it by cloning.

If @var{outerDomain} is different from the system's current domain (read
from class KnownBlock), a wormhole will be created.  A wormhole will
also be created if @var{innerTarget} is specified, or if galaxies for
the domain @var{outerDomain} are always wormholes (this is determined by
asking the Domain class).

Once @code{addToKnownList} is called on an InterpGalaxy object,
that object should not be modified further or deleted.  The KnownBlock
class (@pxref{class KnownBlock})
will manage it from this point on.  It will be deleted if a second
definition with the same name is added to the known list, or when the
program exits.


@node other InterpGalaxy functions,  , InterpGalaxy and cloning, class InterpGalaxy
@subsection other InterpGalaxy functions

@example
const char* className() const
@end example

Return the current class name (which can be changed).  Unlike most
other classes, where this function returns the C++ class name, we
consider the class name of galaxies built by InterpGalaxy to be
variable; it is set by @code{addToKnownList} and copied from one
galaxy to another by the copy constructor or by cloning.

@example
void initialize();
@end example

Overrides @code{Block::initialize()}.  The main extra work is to do
variable-parameter initializations, such as delays and bus connections
for which the delay value or bus width is an expression with variables.

@example
Block* blockWithDottedName(const char* @var{name});
@end example

Returns a pointer to an inner block, at any depth, whose name matches
the specification @var{name}.  For example, @code{blockWithDottedName("a.b.c")}
would look first for a subgalaxy named @code{"a"}, then within that
for a subgalaxy named @code{"b"}, and finally with that for a subgalaxy
named @code{"c"}, returning either a pointer to the final Block or a
null pointer if a match is not found.

@node class Runnable, class Universe, class InterpGalaxy, Block and related classes
@section Class Runnable

The Runnable class is a sort of mixin class intended to be used with
multiple inheritance to create runnable universes and wormholes.  It
is defined in the file @code{Universe.h}.

Constructors:
@example
Runnable(Target* @var{tar}, const char* @var{ty}, Galaxy* @var{g});
Runnable(const char* @var{targetname}, const char* @var{dom}, Galaxy* @var{g});
@end example

@example
void initTarget();
@end example

This function initializes target and/or generates the schedule.

@example
int run();
@end example

This function causes the object to run, until the stopping condition is reached.

@example
virtual void setStopTime(double @var{stamp});
@end example

This function sets stop time.  The default implementation just
calls the identical function in the target.

@example
StringList displaySchedule();
@end example

Display schedule, if appropriate (some types of schedulers will return a
string saying that compile-time scheduling is not performed, e.g. DE
and DDF schedulers).

@example
virtual ~Runnable();
@end example

The destructor deletes the Target.

A Runnable object has the following protected data members:

@example
const char* type;
Target* target;
Galaxy* galP;
@end example

As a rule, when used as one of the baseclasses for multiple inheritance,
the @code{galP} pointer will point to the galaxy provided by the other
half of the object.

@node class Universe, class InterpUniverse, class Runnable, Block and related classes
@section Class Universe

Class Universe is inherited from both Galaxy and Runnable.  It is
intended for use in standalone Ptolemy applications.  For applications
that use a user interface to dynamically build universes, class
InterpUniverse is used instead.

In addition to the Runnable and Galaxy functions, it has:

@example
Universe(Target* @var{s},const char* @var{typeDesc});
@end example

The constructor specifies the target and the universe type.

@example
Scheduler* scheduler() const;
@end example

Returns the scheduler belonging to the universe's target.

@example
int run();
@end example

Return Runnable::Run.

@node class InterpUniverse,  , class Universe, Block and related classes
@section Class InterpUniverse

Class InterpUniverse is inherited from both InterpGalaxy and Runnable.
Ptolemy user interfaces build and execute InterpUniverses.

In addition to the standard InterpGalaxy functions, it provides:

@example
InterpUniverse (const char* @var{name} = "mainGalaxy");
@end example

This creates an empty universe with no target and the given name.
If no name is specified, @code{mainGalaxy} is the default.

@example
int newTarget(const char* @var{newTargName} = 0);
@end example

This creates a target of the given name (from the KnownTarget list),
deleting any existing target.

@example
const char* targetName() const;
@end example

Return the name of the current target.

@example
Scheduler* scheduler() const;
@end example

Return the scheduler belonging to the current target (0 if none).

@example
Target* myTarget() const;
@end example

Return a pointer to the current target.

@example
int run();
@end example

Invokes Runnable::run.

@example
void wrapup();
@end example

Invokes wrapup on the target.

@node Control of execution, Interfacing domains, Block and related classes, Top
@chapter Control of Execution and Error Reporting

The principal classes responsible for control of the execution of the
universe are the Target and the Scheduler.  The Target has high-level
control over what happens when a user types ``run'' from the interface;
Targets take on particular importance in code generation domains where
they describe all the features of the target of execution, but they
are used to control execution in simulation domains as well.

Targets use Schedulers to control the order of execution of Blocks under
their control.  In some domains, the Scheduler does almost everything;
the Target simply starts it up.  In others, the Scheduler determines
an execution order and the Target takes care of a many other
details, such as generating code in accordance with the schedule,
downloading the code to an embedded processor, and executing it.

The Error class provides a means to format error messages and optionally
to halt execution.  The interface is always the same, but different
user interfaces typically provide different implementations of the
methods of this class.

The SimControl class provides a means to register actions for execution
during a simulation, as well as facilities to cleanly halt execution
on an error.

@menu
* class Target::    class Target
* class Scheduler::  class Scheduler
* class Error::     class Error
* class SimControl::  class SimControl
@end menu

@node class Target, class Scheduler,  , Control of execution
@section Class Target

Class Target is derived from class Block (@pxref{class Block});
as such, it can have states
and a parent (the fact that it can also have portholes is not currently
used).  A Target is capable of supervising the execution of only certain
types of Stars; the @var{starClass} argument in its constructor
specifies what type.  A Universe or InterpUniverse is run by executing
its Target.  Targets have Schedulers, which as a rule control order of
execution, but it is the Target that is ``in control''.

A Target can have children that are other Targets; this is used, for
example, to represent multi-processor systems for which code is being
generated (the parent target represents the system as a whole, and
child targets represent each processor).

@menu
* Target public members::  Target public members
* Target protected members::  Target protected members
@end menu

@node Target public members, Target protected members,  , class Target
@subsection Target public members

@example
Target(const char* @var{name}, const char* @var{starClass},const char* @var{desc} = "");
@end example

This is the signature of the Target constructor. @var{name} specifies
the name of the Target and @var{desc} specifies its descriptor (these
fields end up filling in the corresponding NamedObj fields).

The @var{starClass} argument specifies the class of stars that can be
executed by the Target.  For example, specifying @code{DataFlowStar}
for this argument means that the Target can run any type of star of
this class or a class derived from it.  The @code{isA} function is
used to perform the check.

See the description of @code{auxStarClass} below.

@example
const char* starType() const;
@end example

Return the supported star class (the @var{starClass} argument from
the constructor).

@example
Scheduler* scheduler() const;
@end example

Return a pointer to my scheduler.

@example
Target* cloneTarget() const;
@end example

This simply returns the result of the @code{clone} function as a Target.
It is used by the KnownTarget class, for example to create a Target
object corresponding to a name specified from a user interface.

@example
virtual StringList displaySchedule();
@end example

The default implementation simply passes this call along to the
scheduler; derived classes may modify this.

@example
Target* child(int @var{n});
@end example

Return the @var{n}th child Target, null if no children or if
@var{n} exceeds the number of children.

@example
Target* proc(int @var{n});
@end example

This is the same as @code{child} if there are children.  If
there are no children, an argument of 0 will return a pointer
to the object on which it is called, otherwise a null pointer
is returned.

@example
int nProcs() const;
@end example

Return the number of processors (1 if no children, otherwise the
number of children).

@example
virtual int hasResourcesFor(Star& @var{s},const char* @var{extra}=0);
@end example

Determine whether this target has the necessary resources to run the
given star.  It is virtual in case later necessary.  The default implementation
uses ``resources'' states of the target and the star.

@example
virtual int childHasResources(Star& @var{s},int @var{childNum});
@end example

Determine whether a particular child target has resources
to run the given star.  It is virtual in case later necessary.

@example
virtual void setGalaxy(Galaxy& @var{g});
@end example

Associate a Galaxy with the Target.  The default implementation
just sets its galaxy pointer @code{gal} to point to @var{g}.

@example
virtual void setStopTime(double @var{when});
@end example

Set the stopping condition.  The default implementation just passes
this on to the scheduler.

@example
virtual void resetStopTime(double @var{when});
@end example

Reset the stopping condition for the wormhole containing this Target.
The default implementation just passes this on to the scheduler.  In
addition to the action performed by @code{setStopTime}, this function
also does any synchronization required by wormholes.

@example
virtual void setCurrentTime(double @var{now});
@end example

Set the current time to @var{now}.

@example
virtual int run();
@end example

@example
virtual void wrapup();
@end example

The following methods are provided for code generation; schedulers may
call these.  They may move to class CGTarget in a future Ptolemy release.

@example
virtual void beginIteration(int @var{repetitions}, int @var{depth});
@end example

Function called to begin an iteration (default version
does nothing).

@example
virtual void endIteration(int @var{repetitions}, int @var{depth});
@end example

Function called to end an iteration (default version
does nothing).

@example
virtual void writeFiring(Star& @var{s}, int @var{depth});
@end example

Function called to generate code for the star, with any modifications
required by this particular Target (the default version does nothing).

@example
virtual int commTime(int @var{sender},int @var{receiver},int @var{nUnits}, int @var{type});
@end example

Return the number of time units required to send @var{nUnits} units of
data whose type is the code indicated by @var{type} from the child Target
numbered @var{sender} to the child target numbered @var{receiver}.
The default implementation returns 0 regardless of the parameters.
No meaning is specified at this level for the type codes, as different
languages have different types; all that is required is that different
types supported by a particular target map into distinct type codes.

@example
Galaxy* galaxy();
@end example

Return my galaxy pointer (0 if it has not been set).

@node Target protected members,  , Target public members, class Target
@subsection Target protected members

@example
virtual void setup();
@end example

This is the main initialization function for the target.  It is called
by the @code{initialize} function, which by default initializes the
Target states.

The default implementation does the following.  The halt flag of
SimControl is cleared.  Each star is checked to see if its type is
supported by the target (because the @code{isA} function reports
that it is one of the supported star classes).  If a star does not
match this condition an error is reported.  If all goes well, then
the @code{setup} member function of the target's Scheduler object
is called.

@example
void setSched(Scheduler* @var{sch});
@end example

The target's scheduler is set to @var{sch}, which must either point to a
scheduler on the heap or be a null pointer.  Any preexisting scheduler
is deleted.  Also, the scheduler's @code{setTarget} member is called,
associating the Target with the Scheduler.

@example
void delSched();
@end example

This function deletes the target's scheduler and sets the scheduler
pointer to null.

@example
void addChild(Target& @var{child});
@end example

Add @var{child} as a child target.

@example
void inheritChildren(Target* @var{parent}, int @var{start}, int @var{stop});
@end example

This method permits two different Target objects to share child Targets.
The child targets numbered @var{start} through @var{stop} of the Target
pointed to by @var{parent} become the children of this Target (the one
on which this method is called).  Its primary use is in multi-processor
scheduling or code generation, in which some construct is assigned to
a group of processors.  It has a big disadvantage; the range of child
targets must be continuous.

@example
void remChildren();
@end example

Remove the ``children'' list.  This does not delete the child targets.

@example
void deleteChildren();
@end example

Delete all the ``children''.  This assumes that the child Targets
were created with @code{new}.

@example
virtual const char* auxStarClass() const;
@end example

Auxiliary star class: permits a second type of star in addition
to supportedStarClass.  The default implementation returns a
null pointer, indicating no auxiliary star class.

Sorry, there is no present way to support yet a third type.

@example
const char* writeDirectoryName(const char* @var{dirName} = 0);
@end example

This method returns a directory name that is intended for
use in writing files, particularly for code generation targets.
If the directory does not exist, it attempts create it.
Returns the fully expanded pathname (which is saved by
the target).

@example
const char* workingDirectory() const;
@end example

Return directory name previously set by @code{writeDirectoryName}.

@example
char* writeFileName(const char* @var{fileName} = 0);
@end example

Method to set a file name for writing.  @var{writeFileName} prepends
dirFullName (which was set by @code{writeDirectoryName}) to
@var{fileName} with ``/'' between.  Always returns a pointer to a string
in new memory.  It is up to the user to delete the memory when no longer
needed.  If dirFullName or @var{fileName} is NULL then it returns a pointer to
a new copy of the string ``/dev/null''.

@node class Scheduler, class Error, class Target, Control of execution
@section Class Scheduler

Scheduler objects determine the order of execution of Stars.  As a rule,
they are created and managed by Targets.  Some schedulers, such as those
for the SDF domain, completely determine the order of execution of
blocks before any blocks are executed; others, such as those for the
DE domain, supervise the execution of blocks at run time.

The Scheduler class is an abstract base class; you can't have an object
of class Scheduler.

All schedulers have a pointer to the Target that controls them as well
as to a Galaxy.  Usually the Galaxy will be the same one that the
Target points to, but this is not a requirement.

The Scheduler constructor just zeros its target, galaxy pointers.  The
destructor is virtual and do-nothing.

@menu
* Scheduler public members::  Scheduler public members
* Scheduler protected members::  Scheduler protected members
@end menu

@node Scheduler public members, Scheduler protected members,  , class Scheduler
@subsection Scheduler public members

@example
virtual void setGalaxy(Galaxy& @var{g});
@end example

This function sets the galaxy pointer to point to @var{g}.

@example
Galaxy* galaxy();
@end example

This function returns the galaxy pointer.

@example
virtual void setup() = 0;
@end example

This function (in derived classes) sets up the schedule.  In
compile-time schedulers such as those for SDF, a complete schedule is
computed; others may do little more than minimal checks.

@example
virtual void setStopTime(double @var{limit}) = 0;
@end example

Set the stop time for the scheduler.  Schedulers have an abstract
notion of time; this determines how long the scheduler will run for.

@example
virtual double getStopTime() = 0;
@end example

Retrieve the stop time.

@example
virtual void resetStopTime(double @var{limit});
@end example

Reset the stopping condition for the wormhole containing this Scheduler.
The default implementation simply calls @code{setStopTime} with
the same argument.  For some derived types of schedulers, additional
actions will be performed as well by derived Scheduler classes.

@example
virtual int run() = 0;
@end example

Run the scheduler until the stop time is reached, an error condition
occurs, or it stops for some other reason.

@example
virtual void setCurrentTime(double @var{val});
@end example

Set the current time for the scheduler.

@example
virtual StringList displaySchedule();
@end example

Return the schedule, if this makes sense.

@example
double now() const;
@end example

Return the current time (the value of the protected member
@code{currentTime}).

@example
int stopBeforeDeadlocked() const;
@end example

Return the value of the @code{stopBeforeDeadFlag} protected member.
It is set in timed domains to indicate that a scheduler inside a
wormhole was suspended even though it had more work to do.

@example
virtual const char* domain() const;
@end example

Return the domain for this scheduler.  This method is no longer used and
will be removed from future releases; it dates back to the days
in which a given scheduler could only be used in one domain.

@example
void setTarget(Target& @var{t});
@end example

Set the target pointer to point to @var{t}.

@example
Target& target ();
@end example

Return the target.

@example
virtual void compileRun();
@end example

Call code-generation functions in the Target to generate
code for a run.
In the base class, this just causes an error.

The following functions now forward requests to SimControl,
which is responsible for controlling the simulation.

@example
static void requestHalt();
@end example

Calls @code{SimControl::declareErrorHalt}.

NOTE: @code{SimControl::requestHalt} only sets the halt bit,
not the error bit.

@example
static int haltRequested();
@end example

Calls @code{SimControl::haltRequested}.  Returns TRUE if the
execution should halt.

@example
static void clearHalt();
@end example

Calls @code{SimControl::clearHalt}.  Clears the halt and error
bits.

@node Scheduler protected members,  , Scheduler public members, class Scheduler
@subsection Scheduler protected members

The following two data members are protected.

@example
// current time of the scheduler
double currentTime;

// flag set if stop before deadlocked.
// for untimed domain, it is always FALSE.
int stopBeforeDeadlocked;
@end example

@node class Error, class SimControl, class Scheduler, Control of execution
@section Class Error

Class Error is used for error reporting.  While the interfaces to
these functions are always the same, different user interfaces provide
different implementations: @file{ptcl} connects to the Tcl error
reporting mechanism, @file{pigi} pops up windows containing error
messages, and @file{interpreter} simply prints messages on the standard
error stream.  All member functions of Error are static.

There are four ``levels'' of messages that may be produced by the error
facility: @code{Error::abortRun} is used to report an error and cause execution
of the current universe to halt.
@code{Error::error} reports an error.
@code{Error::warn} reports a warning, and @code{Error::message} prints
an information message that is not considered an error.

Each of these four functions is available with two different signatures.
For example:

@example
static void abortRun (const char*, const char* = 0, const char* = 0);
static void abortRun (const NamedObj& @var{obj}, const char*, const char* = 0,
                      const char* = 0);
@end example

The first form produces the error message by simply concatenating its
arguments (the second and third arguments may be omitted); no space is
added.

The second form prepends the full name of the @var{obj} argument, a
colon, and a space to the text provided by the remaining arguments.
If the implementation provides a marking facility, the object named
by @var{obj} is marked by the user interface (at present, the interface
associated with @file{pigi} will highlight the object if its icon
appears on the screen).

The remaining static Error functions @code{error}, @code{warn}, and
@code{message} have the same signatures as does @code{abortRun} (there
are the same two forms for each function).

In addition, the Error class provides access to the marking facility,
if it exists:

@example
static int canMark();
@end example

This function returns TRUE if the interface can mark NamedObj objects
(generally true for graphic interfaces), and FALSE if it cannot
(generally true for text interfaces).

@example
static void mark (const NamedObj& @var{obj});
@end example

This function marks the object @var{obj}, if marking is implemented for
this interface.  It is a no-op if marking is not implemented.

@node class SimControl,  , class Error, Control of execution
@section Class SimControl

The SimControl class controls execution of the simulation.  It has
some global status flags that indicate whether there has been an
error in the execution or if a halt has been requested.  It also
has mechanisms for registering functions to be called before or
after star executions, or in response to a particular star's execution,
and responding to interrupts.

This class interacts with the Error class (which sets error and halt
bits) and the Star class (to permit execution of registered actions when
stars are fired).  Schedulers and Targets are expected to monitor
the SimControl halt flag to halt execution when errors are signaled
and halts are requested.  Once exceptions are commonplace in C++
implementations, a cleaner implementation could be produced.

@menu
* SimControl status flags::  Access to SimControl status flags.
* pre- and postactions::  Preactions and Postactions
* SimControl interrupts and polling::  
@end menu

@node SimControl status flags, pre- and postactions,  , class SimControl
@subsection Access to SimControl status flags.

SimControl currently has four global status bits: the error bit,
the halt bit, the interrupt bit, and the poll bit.  These functions
set, clear, or report on these bits.

@example
static void requestHalt ();
@end example

This function sets the halt bit.  The effect is to cause schedulers
and targets to cease execution.  It is important to note that this
function does not alter flow of control; it only sets a flag.

@example
static void declareErrorHalt ();
@end example

This is the same as @code{requestHalt} except that it also sets the
error bit.  It is called, for example, by @code{Error::abortRun}.

@example
static int haltRequested ();
@end example

This function returns true if the halt bit is set, false otherwise.
If the poll or interrupt bits are set, it calls handlers for them
(see the subsection describing these).

@example
static void clearHalt ();
@end example

This function clears the halt and error flags.

@node pre- and postactions, SimControl interrupts and polling, SimControl status flags, class SimControl
@subsection Preactions and Postactions

SimControl can register a function that will be called before
or after the execution of a particular star, or before or after
the execution of all stars.  A function that is called before
a star is a @emph{preaction}; on that is called after a star is
a @emph{postaction}.

The functions that can be registered have take two arguments: a
pointer to a Star (possibly null), and a @code{const char*} pointer
that points to a string (possibly null).  The type definition

@example
typedef void (*SimActionFunction)(Star*,const char*);
@end example

gives the name SimActionFunction to functions of this type;
several SimControl functions take arguments of this form.

@example
static SimAction* registerAction(SimActionFunction action, int pre,
 const char* textArg = 0, Star* which = 0);
@end example

Register a preaction or postaction.  If "pre" is TRUE it is a preaction.
If @var{textArg} is given, it is passed as an argument when the
action function is called.  If @var{which} is 0, the function will
be called unconditionally by @code{doPreActions} (if it is a preaction)
or @code{doPostActions} (if it is a postaction; otherwise it will
only be called if the star being executed has the same address as
@code{which}.

The return value represents the registered action; class SimAction
is treated as an ``opaque class'' (I'm not telling you what is in it)
which can be used for @code{cancel} calls.

@example
static int doPreActions(Star * which);
static int doPostActions(Star * which);
@end example

Execute all pre-actions, or post-actions, for a the particular Star
@var{which}.  The @var{which} pointer is passed to each action
function, along with any text argument declared when the action
was registered.

Return TRUE if no halting condition arises, FALSE if we are to halt.

@example
static int cancel(SimAction* @var{action});
@end example

Cancel @var{action}.  Warning: argument is deleted.

Future versions will provide more ways of cancelling actions.

@node SimControl interrupts and polling,  , pre- and postactions, class SimControl
@subsection SimControl interrupts and polling

Features in this section will be used in a new graphic interface;
they are mostly untested at this point.

The SimControl class can handle interrupts and can register a
polling function that is called for every star execution.
It only provides one handler.

@example
static void catchInt(int signo = -1, int always = 0);
@end example

This static member function installs a simple
interrupt handler for the signal with
Unix signal number @var{signo}.  If @var{always} is true, the
signal is always caught; otherwise the signal is not caught
if the current status of the signal is that it is ignored
(for example, processes running in the background ignore
interrupt signals from the keyboard).  This handler simply sets
the SimControl interrupt bit; on the next call to @code{haltRequested},
the user-specified interrupt handler is called.

@example
static SimHandlerFunction setInterrupt(SimHandlerFunction @var{f});
@end example

Set the user-specified interrupt handler to @var{f}, and return
the old handler, if any.  This function is called in response to
any signals specified in @code{catchInt}.

@example
static SimHandlerFunction setPoll(SimHandlerFunction f);
@end example

Register a function to be called by @code{haltRequested} if the poll
flag is set.  Returns old handler if any.

@node Interfacing domains, connection classes, Control of execution, Top
@chapter Interfacing domains -- wormholes and related classes

This section describes the classes that implement the mechanism that
allows different domains to be interfaced.  It is this ability to
integrate different domains that sets Ptolemy apart from other systems.

@menu
* class Wormhole::  class Wormhole
* class EventHorizon::  class EventHorizon
* class ToEventHorizon::  class ToEventHorizon
* class FromEventHorizon::  class FromEventHorizon
* class WormMultiPort::  class WormMultiPort
@end menu

@node class Wormhole, class EventHorizon,  , Interfacing domains
@section Class Wormhole

A wormhole for a domain is much like a star belonging to that domain,
but it contains pointers to a subsystem that operates in a different
domain.  The interface to that other domain is through a ``universal
event horizon''.  The wormhole design, therefore, does not depend on the
domain it contains, but only on the domain in which it is used as a
block.  It must look like a star in that outer domain.

The base Wormhole class is derived from
class Runnable (@pxref{class Runnable}), just like the
class Universe (@pxref{class Universe}).
Every member of the Runnable class has a pointer to a
component Galaxy (@pxref{class Galaxy}) and a Target (@pxref{class
Target}).

Like a Universe, a Wormhole can perform
the scheduling actions on the component Galaxy. A Wormhole is different
from a Universe in that it is not a stand-alone object.  Instead, it is
triggered from the outer domain to initiate the scheduling.  Also, since
Wormhole is an abstract baseclass, you cannot create an object of class
Wormhole; only derived Wormholes can be created.

Each domain has a derived Wormhole class.  For example, the SDF domain
has class SDFWormhole.  This domain-specific Wormhole is derived from
not only the base Wormhole class but also from the domain-specific star
class, SDFStar.  This multiple inheritance realizes the inherent nature
of the Wormhole.  First, the Wormhole behaves exactly like a Star from
the outer domain (SDF) since it is derived from SDFStar.  Second,
internally it can encapsulate an entire foreign domain with a separate
Galaxy and a separate Target and Scheduler.

@menu
* Wormhole public members::  Wormhole public members
* Wormhole protected members::  Wormhole protected members
@end menu

@node Wormhole public members, Wormhole protected members,  , class Wormhole
@subsection Wormhole public members

@example
void setup();
@end example

The default implementation calls @code{initTarget}.

@example
int run();
@end example

This function executes the inside of the wormhole for the appropriate
amount of time.

@example
const char* insideDomain() const;
@end example

This function returns the name of the inside domain.

@example
void setStopTime(double @var{stamp});
@end example

This function sets the stop time for the inner universe.

@example
Wormhole(Star& @var{self}, Galaxy& @var{g}, const char* @var{targetName} = 0);
Wormhole(Star& @var{self}, Galaxy& @var{g}, Target* @var{innerTarget} = 0);
@end example

The above two signatures represent the constructors provided for class
Wormhole.  We never use plain Wormholes; instead we always have objects derived
from Wormhole and some kind of Star.  For example:

@example
class SDFWormhole : public Wormhole, public SDFStar @{
public:
    SDFWormhole(Galaxy& g,Target* t) : Wormhole(*this,g,t) @{
        buildEventHorizons();
    @}
@};
@end example

The first argument to the constructor should always be a reference to
the object itself, and represents ``the wormhole as a star''.  The second
argument is the inner galaxy.  The third argument describes the target
of the Wormhole, and may be provided either as a Target object or by
name, in which case it is created by using the KnownTarget class.

@example
Scheduler* outerSched();
@end example

This returns a pointer to the scheduler for the outer domain (the one
that lives above the wormhole).  The scheduler for the inner domain
for derived wormhole classes can be obtained from the @code{scheduler()}
method.

@node Wormhole protected members,  , Wormhole public members, class Wormhole
@subsection Wormhole protected members

@example
void buildEventHorizons ();
@end example

This function creates the EventHorizon objects that connect the inner
galaxy ports to the outside.  A pair of EventHorizons is created for
each galaxy port.  It is typically called by the constructor for
the XXXWormhole, where XXX is the outer domain name.

@example
void freeContents();
@end example

This function deletes the event horizons and the inside galaxy.  It
is intended to be called from XXXWormhole destructors.  It cannot be
part of the Wormhole constructor due to an ordering problem (we want
to assure that it is called before the destructor for either of
XXXWormhole's two baseclasses is called).

@example
virtual double getStopTime() = 0;
@end example

Get the stopping condition for the inner domain.  This is a pure
virtual function and must be redefined in the derived class.

@example
virtual void sumUp();
@end example

This function is called by @code{Wormhole::run} after running the
inner domain.  The default implementation does nothing.  Derived
wormholes can redefine it to put in any ``summing up'' work that is
required after running the inner domain.

@example
Galaxy& gal;
@end example

The member @code{gal} is a reference to the inner galaxy of the Wormhole.

@node class EventHorizon, class ToEventHorizon, class Wormhole, Interfacing domains
@section Class EventHorizon

Class EventHorizon is another example of a mixin class; EventHorizon has
the same relationship to PortHoles as Wormhole has to Stars.  The name
is chosen from cosmology, representing the point at which an object
disappears from the outside universe and enters the interior of a black
hole, which can be thought of as a different universe entirely.

As for wormholes, we never consider objects that are ``just an
EventHorizon''.  Instead, all objects that are actually used are multiply
inherited from EventHorizon and from some type of PortHole class.  For
each type of domain we require two types of EventHorizon.  The first, derived
from ToEventHorizon, converts from a format suitable for a particular
domain to the ``universal form''.  The other, derived from FromEventHorizon,
converts from the universal form to the domain-specific form.

@menu
* How EventHorizons are used::  
* EventHorizon public members::  
* EventHorizon protected members::  
@end menu

@node How EventHorizons are used, EventHorizon public members,  , class EventHorizon
@subsection How EventHorizons are used

Generally, EventHorizons are used in pairs to form a connection
across a domain boundary between domain XXX and domain YYY.  An object
of class XXXToUniversal (derived from XXXPortHole and ToEventHorizon)
and an object of class YYYFromUniversal (derived from YYYPortHole and
FromEventHorizon) are inserted between the ordinary, domain-specific
PortHoles.  The @code{far()} member of the XXXToUniversal points
to the XXXPortHole; the @code{ghostAsPort()} member points to
the YYYFromUniversal object.  Similarly, for the YYYFromUniveral
object, @code{far()} points to the YYYPortHole and @code{ghostAsPort()}
points to the XXXToUniversal object.

These pairs of EventHorizons are created by the
@code{buildEventHorizons} member function of class Wormhole.

@menu
* EventHorizon public members::  EventHorizon public members
* EventHorizon protected members::  EventHorizon protected members
@end menu

@node EventHorizon public members, EventHorizon protected members, How EventHorizons are used, class EventHorizon
@subsection EventHorizon public members

@example
EventHorizon(PortHole* @var{self});
@end example

The constructor for EventHorizon takes one argument, representing (for
derived classes that call this constructor from their own), ``myself'' as
a PortHole (a pointer to the PortHole part of the object).

The destructor is declared virtual and does nothing.

@example
PortHole* asPort();
@end example

This returns ``myself as a PortHole''.

@example
PortHole* ghostAsPort();
@end example

This returns a pointer to the ``matching eventhorizon'' as a porthole.

@example
virtual void ghostConnect(EventHorizon& @var{to} );
@end example

This connects another EventHorizon to myself and makes it my ``ghost
port''.

@example
virtual int isItInput() const;
virtual int isItOutput() const;
@end example

Say if I am an input or an output.

@example
virtual int onlyOne() const;
@end example

Derived EventHorizon classes should redefine this method to return TRUE
for domains in which only one particle may cross the event horizon
boundary per execution.  The default implementation returns FALSE.

@example
virtual void setEventHorizon(inOutType @var{inOut}, const char* @var{portName},
     Wormhole* @var{parentWormhole}, Star* @var{parentStar},
     DataType @var{type} = FLOAT, unsigned @var{numTokens} = 1 );
@end example

Sets parameters for the EventHorizon.

@example
double getTimeMark();
void setTimeMark(double @var{d});
@end example

Get and set the time mark.  The time mark is an internal detail used for
bookkeeping by schedulers.

@example
virtual void initialize();
@end example

@example
Scheduler *innerSched();
Scheduler *outerSched();
@end example

These methods return a pointer to the scheduler that lives inside the
wormhole, or outside the wormhole, respectively.

@node EventHorizon protected members,  , EventHorizon public members, class EventHorizon
@subsection EventHorizon protected members

@example
void moveFromGhost(EventHorizon& @var{from}, int @var{numParticles});
@end example

Move @var{numParticles} from the buffer of @var{from}, another
EventHorizon, to mine (the object on which this function is called).
This is used to implement @code{ToEventHorizon::transferData}.

@example
CircularBuffer* buffer();
@end example

Access the myBuffer of the porthole.

@example
EventHorizon* ghostPort;
@end example

This is the peer event horizon.

@example
Wormhole* wormhole;
@end example

This points to the Wormhole I am a member of.

@example
int tokenNew;
@end example

@example
double timeMark;
@end example

TimeMark of the current data, which is necessary for interface
of two domains.  This may become a private member in future versions
of Ptolemy.

@node class ToEventHorizon, class FromEventHorizon, class EventHorizon, Interfacing domains
@section Class ToEventHorizon

A ToEventHorizon is responsible for converting from a domain-specific
representation to a universal representation.  It is derived from
EventHorizon.

@example
ToEventHorizon(PortHole* @var{p});
@end example

The constructor simply calls the baseclass constructor, passing along
its argument.

@example
void initialize();
@end example

The initialize function prepares the object for execution.

@example
void getData();
@end example

This protected member transfers data from the outside to the universal
eventhorizon (myself).

@example
void transferData();
@end example

This protected member transfers data from myself to my peer
FromEventHorizon (the ghostPort).

@node class FromEventHorizon, class WormMultiPort, class ToEventHorizon, Interfacing domains
@section Class FromEventHorizon

A FromEventHorizon is responsible for converting from a universal
representation to a domain-specific representation.  It is derived from
EventHorizon.

@example
FromEventHorizon(PortHole* @var{p});
@end example

The constructor simply calls the EventHorizon constructor.

@example
void initialize();
@end example

The initialize function prepares the object for execution.

@example
void putData();
@end example

This protected member transfers data from Universal EventHorizon to outside.

@example
void transferData();
@end example

This protected member transfers data from peer event horizon to me.

@example
virtual int ready();
@end example

This is a protected member.  By default, it always returns TRUE (1).
Derived classes have it return TRUE if the event horizon is ``ready''
(there is enough data for execution to proceed), and false otherwise.

@node class WormMultiPort,  , class FromEventHorizon, Interfacing domains
@section Class WormMultiPort

The class WormMultiPort, which is derived from MultiPortHole
(@pxref{class MultiPortHole}), exists to
handle the case where a galaxy with a multiporthole is embedded in a
wormhole.  Its @code{newPort} function correctly creates a pair of
EventHorizon objects when a new port is created in the multiporthole.
Instances of this object are created by Wormhole::buildEventHorizons
when the inner galaxy has one or more MultiPortHole objects.

@node connection classes, Particles and Messages, Interfacing domains, Top
@chapter Classes for connections between blocks

This chapter describes the classes that implement connections between
blocks.  For simulation domains, these classes are responsible for
moving objects called Particles (@pxref{class Particle})
from one Block to another.  For code
generation domains, the Particles typically only move during scheduling
and these objects merely provide information on the topology.

@menu
* class GenericPort::  class GenericPort
* class PortHole::  class PortHole
* class MultiPortHole::  class MultiPortHole
* AutoFork and AutoForkNode::  AutoFork and AutoForkNode
* class ParticleStack::  class ParticleStack
* class Geodesic::  class Geodesic
* class Plasma::    class Plasma
* class ParticleQueue::  class ParticleQueue
* classes for Galaxy ports::  classes for Galaxy ports
@end menu

@node class GenericPort, class PortHole,  , connection classes
@section Class GenericPort

The class GenericPort is a base class that provides common elements
between class PortHole (@pxref{class PortHole})
and class MultiPortHole (@pxref{class MultiPortHole}).
Any GenericPort object
can be assumed to be either one or the other; we recommend avoiding
deriving any new objects directly from GenericPort.

GenericPort is derived from class NamedObj (@pxref{class NamedObj}).

GenericPort provides several basic facilities: aliases, which specify
that another GenericPort should be used in place of this port, types,
which specify the type of data to be moved by the port, and typePort,
which specifies that this port has the same type as another port.
When a GenericPort is destroyed, any alias or typePort pointers are
automatically cleaned up, so that other GenericPorts are never left
with dangling pointers.

@menu
* GenericPort query functions::  
* other GenericPort public members::  
* GenericPort protected members::  
@end menu

@node GenericPort query functions, other GenericPort public members,  , class GenericPort
@subsection GenericPort query functions

@example
virtual int isItInput () const;
virtual int isItOutput () const;
virtual int isItMulti () const;
@end example

Each of the above functions returns TRUE (1) or FALSE (0).

@example
StringList print (int @var{verbose} = 0) const;
@end example

Print human-readable information on the GenericPort.

@example
DataType type () const;
@end example

Return my DataType.  This may be one of the DataType values associated
with Particle classes, or the special type @code{ANYTYPE}, which
indicates that the type will be resolved by the @code{setPlasma}
function using information from connected ports and @code{typePort} pointers.

@example
GenericPort* alias() const;
@end example

Return my alias, or a null pointer if I have no alias.  Generally,
Galaxy portholes have aliases and Star portholes do not, but this
is not a strict requirement.

@example
GenericPort* aliasFrom() const;
@end example

Return the porthole that I am the alias for (a null pointer if none).
It is guaranteed that if @code{gp} is a pointer to GenericPort and if
@code{gp->alias()} is non-null, then the boolean expression

@example
gp->alias()->aliasFrom() == gp
@end example

is always true.

@example
bitWord attributes() const;
@end example

Return my attributes.  Attributes are a series of bits.

@example
GenericPort& realPort();
const GenericPort& realPort() const;
@end example

Return the real port after resolving any aliases.  If I have no alias,
then a reference to myself is returned.

@example
GenericPort* typePort() const;
@end example

Return another generic port that is constrained to have the same type as
me (0 if none).  If a non-null value is called, successive calls will
form a circular linked list that always returns to its starting point;
that is, the loop

@example
void printLoop(GenericPort& g) @{
        if (g->typePort()) @{
                GenericPort* gp = g;
                while (gp->typePort() != g) @{
                        cout << gp->fullName() << "\n";
                        gp = gp->typePort();
                @}
        @}
@}
@end example

is guaranteed to terminate and not to dereference a null pointer.

@example
inline int hidden(const GenericPort& @var{p})
@end example

IMPORTANT: @code{hidden} is not a member function of GenericPort,
but is a ``plain function''.  It returns TRUE if the port in question
has the HIDDEN attribute.

@node other GenericPort public members, GenericPort protected members, GenericPort query functions, class GenericPort
@subsection other GenericPort public members

@example
virtual PortHole& newConnection();
@end example

Return a reference to a porthole to be used for new connections.
Class PortHole uses this one unchanged; MultiPortHole has to create
a new member PortHole.

@example
GenericPort& setPort(const char* @var{portName}, Block* @var{blk}, DataType @var{typ}=FLOAT);
@end example

Set the basic PortHole parameters: the name, parent, and datatype.

@example
void inheritTypeFrom(GenericPort& @var{p});
@end example

Set up a port for determining the type of @code{ANYTYPE} connections.
typePort pointers form a circular loop.

@example
virtual Plasma* setPlasma(Plasma *@var{useType} = NULL) = 0;
@end example

This function associates the appropriate pool of particles, called a
Plasma, with the PortHole or MultiPortHole.  The effect is also to
determine how type conversion will be performed, since the type of
a porthole is determined by its associated Plasma.

@example
virtual void connect(GenericPort& @var{destination},int @var{numberDelays});
@end example

Connect me with the indicated peer.

@example
bitWord setAttributes(const Attribute& @var{attr});
@end example

Set my attributes (some bits are turned on and others are turned off).

@example
void setAlias (GenericPort& @var{gp});
@end example

Set gp to be my alias.  The aliasFrom pointer of gp is set to
point to me.

@node GenericPort protected members,  , other GenericPort public members, class GenericPort
@subsection GenericPort protected members

@example
GenericPort* translateAliases();
@end example

The above is a protected function.  If this function is called on
a port with no alias, the address of the port itself is returned;
otherwise, @code{alias()->translateAliases()} is returned.

@node class PortHole, class MultiPortHole, class GenericPort, connection classes
@section Class PortHole

PortHole is the means that Blocks use to talk to each other.  It is
derived from GenericPort; as such, it has a type, an optional alias,
and is optionally a member of a ring of ports of the same type connected
by @code{typePort} pointers.  It guarantees that @code{alias()} always
returns a PortHole.

In addition, a PortHole has a peer (another port that it is connected
to, which is returned by @code{far()}), a Geodesic (a path along which
particles travel between the PortHole and its peer), and a Plasma (a
pool of particles, all of the same type).  In simulation domains,
during the execution of the simulation objects known as Particles
traverse a circular path: from an output porthole through a Geodesic to
an input porthole, and finally to a Plasma, where they are recirculated
back to the input porthole.

Like all NamedObj-derived objects, a PortHole has a parent Block.  It
may also be a member of a MultiPortHole, which is a logical group of
PortHoles.

@menu
* PortHole public members::  
* PortHole protected members::  
* class CircularBuffer::  a class used to implement PortHole
@end menu

@node PortHole public members, PortHole protected members,  , class PortHole
@subsection PortHole public members

The constructor sets just about everything to null pointers.

The destructor disconnects the PortHole, and if there is a parent Block,
removes itself from the parent's porthole list.

@example
PortHole& setPort(const char* @var{portName}, Block* @var{parent},
                 DataType @var{type} = FLOAT);
@end example

This function sets the name of the porthole, its parent, and
its type.

@example
void initialize();
@end example

This function is responsible for initializing the internal buffers
of the porthole in preparation for a run.

@example
virtual void disconnect(int @var{delGeo} = 1);
@end example

Remove a connection, and optionally attempt to delete the geodesic.  The
is set to zero when the geodesic must be preserved for some reason (for
example, from the Geodesic's destructor).  The Geodesic is deleted only
if it is ``temporary''; we do not delete ``persistent'' geodesics when
we disconnect them.

@example
PortHole* far() const;
@end example

Return the PortHole we are connected to.

@example
void setAlias (PortHole& @var{blockPort});
@end example

Set my alias to @var{blockPort}.

@example
int atBoundary() const;
@end example

Return TRUE if this PortHole is at the wormhole boundary (if its peer is
an inter-domain connection); FALSE otherwise.

@example
virtual EventHorizon* asEH();
@end example

Return myself as an EventHorizon, if I am one.  The baseclass returns
a null pointer.  EventHorizon objects (objects multiply inherited from
EventHorizon and some type of PortHole) will redefine this
appropriately.

@example
virtual void receiveData();
@end example

Used to receive data in derived classes.  The default implementation
does nothing.

@example
virtual void sendData();
@end example

Used to send data in derived classes.  The default implementation
does nothing.

@example
Particle& operator % (int @var{delay});
@end example

This operator returns a reference to a Particle in the PortHole's
buffer.  A @var{delay} value of 0 returns the ``newest'' particle.
In dataflow domains, the argument represents the delay associated
with that particular particle.

@example
void setMaxDelay(int @var{delay});
@end example

Set the maximum delay that past Particles can be accessed -- defaults to
zero if never called.

@example
DataType resolvedType () const;
@end example

Return the datatype computed by @code{PortHole::initialize} to resolve
type conversions.  For example, if an INT output porthole is connected
to a FLOAT input porthole, the resolved type (the type of the Particles
that travel between the ports) will be FLOAT.  A null pointer will be
returned if the type has not been set, e.g. before initialization.

@example
int numXfer() const;
@end example

Returns the nominal number of tokens transferred per execution of the
PortHole.  It returns the value of the protected member @code{numberTokens}.

@example
int numTokens() const;
@end example

Returns the number of particles on my Geodesic.

@example
int numInitDelays() const;
@end example

Returns the number of initial delays on my Geodesic (the initial tokens,
strictly speaking, are only delays in dataflow domains).

@example
Geodesic* geo();
@end example

Return a pointer to my Geodesic.

@example
Plasma* setPlasma(Plasma *@var{useType} = NULL);
@end example

Initialize the Plasma, which has the effect of resolving the type, since
the Particles provided by the Plasma determine the type of data that can
be transferred.  This function should be protected.

@example
int index() const;
@end example

Return the index value.  This is a mechanism for assigning all the
portholes in a universe a unique integer index, for use in table-driven
schedulers.

@example
MultiPortHole* getMyMultiPortHole() const;
@end example

Return the MultiPortHole that spawned this PortHole, or NULL
if there is no such MultiPortHole.

@example
virtual void setDelay (int @var{newDelayValue});
@end example

Set the delay value for the connection.

@example
void adjustDelays(int @var{numNewDelays});
@end example

Adjust the number of delays on the Geodesic: change the number to
@var{numNewDelays} by using @code{setDelay} and re-initialize to
put the change into effect (name could be better).

@example
virtual Geodesic* allocateGeodesic();
@end example

Allocate a return a Geodesic compatible with this type of PortHole.
This may become a protected member in future Ptolemy releases.

@node PortHole protected members, class CircularBuffer, PortHole public members, class PortHole
@subsection PortHole protected members

@example
Geodesic* myGeodesic;
@end example

My geodesic, which connects to my peer.  Initialized to NULL.

@example
PortHole* farSidePort;
@end example

The port on the far side of the connection.  NULL for disconnected ports.

@example
Plasma* myPlasma;
@end example

Pointer to the Plasma where we get our Particles or replace unused
Particles.  Initialized to NULL.

@example
CircularBuffer* myBuffer;
@end example

Buffer where the Particles are stored.  This is actually a buffer of
pointers to Particles, not to Particles themselves.

@example
int bufferSize;
@end example

This gives the size of the CircularBuffer to allocate.

@example
void getParticle();
@end example

Get @code{numberTokens} particles from the Geodesic and move them into
my CircularBuffer.  Actually, only Particles move.  The same number of
existing Particles are returned to their Plasma, so that the total
number of Particles contained in the buffer remains constant.

@example
void putParticle();
@end example

Move @code{numberTokens} particles from my CircularBuffer to the
Geodesic.  Replace them with the same number of Particles from the Plasma.

@example
void clearParticle();
@end example

Clear @code{numberTokens} particles in the CircularBuffer.  Leave the
buffer position pointing to the last one.

@node class CircularBuffer,  , PortHole protected members, class PortHole
@subsection CircularBuffer -- a class used to implement PortHole

This class is misnamed; it is not a general circular buffer but
rather an array of pointers to Particle that is accessed in a
circular manner.  It has a pointer representing the current position.
This pointer can be advanced or backed up; it wraps around the end
when this is done.  The class also has a facility for keeping
track of error conditions.

The constructor takes an integer argument, the size of the buffer.
It creates an array of pointers of that size and sets them all to
null.  The destructor returns any Particles in the buffer to their
Plasma and then deletes the buffer.

@example
void reset();
@end example

Set the access pointer to the beginning of the buffer.

@example
Particle** here() const;
@end example

Return the access pointer.  Note the double indirection; since the
buffer contains pointers to Particles, the buffer pointer points
to a pointer.

@example
Particle** next();
@end example

Advance the pointer one position (circularly) and return the new value.

@example
Particle** last();
@end example

Back up the pointer one position (circularly) and return the new value.

@example
void advance(int @var{n});
@end example

Advance the buffer pointer by @var{n} positions.  This will not work correctly
if @var{n} is larger than the buffer size.  @var{n} is assumed positive.

@example
void backup(int @var{n});
@end example

Back up the buffer pointer by @var{n} positions.  This will not work correctly
if @var{n} is larger than the buffer size.  @var{n} is assumed positive.

@example
Particle** previous(int @var{offset}) const;
@end example

Find the position in the buffer @var{offset} positions in the past
relative to the current position.  The current position is unchanged.
@var{offset} must not be negative, and must be less than the buffer
size, or a null pointer is returned an an appropriate error message
is set; this message can be accessed by the @code{errMsg} function.

@example
int size() const;
@end example

Return the size of the buffer.

@example
static const char* errMsg();
@end example

Return the last error message (currently, only @code{previous()} sets
error messages).

@node class MultiPortHole, AutoFork and AutoForkNode, class PortHole, connection classes
@section Class MultiPortHole

A MultiPortHole is an organized connection of related PortHoles.  Any
number of PortHoles can be created within the PortHole; their names have
the form @code{@var{mphname}#1}, @code{@var{mphname}#2}, etc., where
@var{mphname} is replaced by the name of the MultiPortHole.  When a
PortHole is added to the MultiPortHole, it is also added to the porthole
list of the Block that contains the MultiPortHole.  As a result, a Block
that contains a MultiPortHole has, in effect, a configurable number of
portholes.

A pair of MultiPortHoles can be connected by a ``bus connection''.  This
technique creates @var{n} PortHoles in each MultiPortHole and connects
them all ``in parallel''.

The MultiPortHole constructor sets the ``peer MPH'' to 0.  The destructor
deletes any constituent PortHoles.

@menu
* MultiPortHole public members::  
* MultiPortHole protected members::  
@end menu

@node MultiPortHole public members, MultiPortHole protected members,  , class MultiPortHole
@subsection MultiPortHole public members

@example
void initialize();
@end example

Does nothing.

@example
void busConnect (MultiPortHole& @var{peer}, int @var{width}, int @var{delay} = 0);
@end example

Makes a bus connection with another multiporthole, @var{peer}, with
width @var{width} and delay @var{delay}.  If there is an existing bus
connection, it is changed as necessary; an existing bus connection may
be widened, or, if connected to a different peer, all constituent
portholes are deleted and a bus is made from scratch.

@example
int isItMulti() const;
@end example

Returns TRUE.

@example
MultiPortHole& setPort(const char* @var{portName},
                       Block* @var{parent},DataType @var{type} = FLOAT);
@end example

@example
int numberPorts() const;
@end example

Return the number of PortHoles in the MultiPortHole.

@example
virtual PortHole& newPort();
@end example

Add a new physical port to the MultiPortHole list.

@example
MultiPortHole& realPort();
@end example

Return the real MultiPortHole associated with me, translating any
aliases.

@example
void setAlias (MultiPortHole &@var{blockPort});
@end example

Set my alias to @var{blockPort}.

@example
virtual PortHole& newConnection();
@end example

Return a new port for connections.  If there is an unconnected porthole,
return the first one; otherwise make a new one.

@example
Plasma* setPlasma(Plasma *@var{useType} = NULL);
@end example

Sets the Plasma for all the portholes in the multiporthole.

@node MultiPortHole protected members,  , MultiPortHole public members, class MultiPortHole
@subsection MultiPortHole protected members

@example
PortList ports;
@end example

The list of portholes (should be protected).

@example
const char* newName();
@end example

This function generates names to be used for contained PortHoles.  They
are saved in the hash table provided by the @code{hashstring} function
(@pxref{utility functions}).

@example
PortHole& installPort(PortHole& @var{p});
@end example

This function adds a newly created port to the multiporthole.  Derived
MultiPortHole classes typically redefine @code{newPort} to create a
porthole of the appropriate type, and then use this function to register
it and install it.

@example
void delPorts();
@end example

This function deletes all contained portholes.

@node AutoFork and AutoForkNode, class ParticleStack, class MultiPortHole, connection classes
@section AutoFork and AutoForkNode

AutoForks are a method for implementing netlist-style connections.
An AutoForkNode is a type of Geodesic built on top of AutoFork.
The classes are separate to allow a ``mixin approach'', so that if
a domain requires special actions in its Geodesics, these special
actions can be written only once and be implemented in both
temporary and permanent connections.

The implementation technique used is to automatically insert a Fork
star to allow the n-way connection; this Fork star is created by
invoking @code{KnownBlock::makeNew("Fork")}, which works only for
domains that have a fork star.

@menu
* class AutoFork::  class AutoFork
* class AutoForkNode::  class AutoForkNode
@end menu

@node class AutoFork, class AutoForkNode,  , AutoFork and AutoForkNode
@subsection Class AutoFork

An AutoFork object has an associated Geodesic and possibly an associated
Fork star (which it creates and deletes as needed).  It is normally used
in a multiply inherited object, inherited from AutoFork and some kind
of Geodesic; hence the associated Geodesic is the object itself.

The constructor for class AutoFork takes a single argument, a reference
to the Geodesic.  It sets the pointer to the fork star to be null.

The destructor removes the fork star, if one was created.

There are two public member functions, @code{setSource} and
@code{setDest}.

@example
PortHole* setSource(GenericPort& @var{port}, int @var{delay} = 0);
@end example

If there is already an originating port for the geodesic, this method
returns an error.  Otherwise it connects it to the node.

@example
PortHole* setDest(GenericPort& @var{port}, int @var{alwaysFork} = 0);
@end example

This function may be used to add any number of destinations to the
port.  Normally, when there is more than one output, a Fork star is
created and inserted to support the multi-way connection, but if there
is only one output, a direct connection is used.  However, if
@var{alwaysFork} is true, a Fork is inserted even for the first output.
When the fork star is created, it is inserted in the block list for
the parent galaxy (the parent of the geodesic).

@node class AutoForkNode,  , class AutoFork, AutoFork and AutoForkNode
@subsection Class AutoForkNode

Class AutoForkNode is multiply inherited from Geodesic and AutoFork.

This class redefines @code{isItPersistent} to return TRUE, and redefines
the @code{setSourcePort} and @code{setDestPort} functions to call the
@code{setSource} and @code{setDest} functions of AutoFork.
The exact same form could be used to generate other types of
auto-forking nodes (that is, this class could have been done with
a template).

@node class ParticleStack, class Geodesic, AutoFork and AutoForkNode, connection classes
@section Class ParticleStack

ParticleStack is an efficient baseclass for the implementation of
structures that organize Particles.  As Particles have a link field,
ParticleStack is simply implemented as a linked list of Particles.

Strictly speaking, a dequeue is implemented; particles can be inserted
from either end.  ParticleStack has some odd attributes; it is designed
for very efficient implementation of Geodesic and Plasma to move around
large numbers of Particle objects very efficiently.

@example
ParticleStack(Particle* @var{h});
@end example

The constructor takes a Particle pointer.  If it is a null pointer an
empty ParticleStack is created.  Otherwise the stack has one particle.
Adding a Particle to a ParticleStack modifies that Particle's link
field; therefore a Particle can belong to only one ParticleStack at a
time.

@example
~ParticleStack();
@end example

The destructor deletes all Particles EXCEPT for the last one; we do not
delete the last one because it is the ``reference'' particle (for
Plasma) and is normally not dynamically created (this code may be moved
in a future release to the Plasma destructor, as this behavior is needed
for Plasma and not for other types of ParticleStack).

@example
void put(Particle* @var{p});
@end example

Push @var{p} onto the top (or head) of the ParticleStack.

@example
Particle* get();
@end example

Pop the particle off the top (or head) of the ParticleStack.

@example
void putTail(Particle* @var{p});
@end example

Add @var{p} at the bottom (or tail) of the ParticleStack.

@example
int empty() const;
@end example

Return TRUE (1) if the ParticleStack is empty, otherwise 0.

@example
int moreThanOne() const;
@end example

Return TRUE (1) if the ParticleStack has two or more particles,
otherwise 0.  This is provided to speed up the derived class Plasma a
bit.

@example
void freeup();
@end example

Returns all Particles on the stack to their Plasma (the allocation pool
for that particle type).

There is one protected data member:

@example
Particle* head;
@end example

This is the head of the list (or the top of the stack).

@node class Geodesic, class Plasma, class ParticleStack, connection classes
@section Class Geodesic

A Geodesic implements the connection between a pair, or a larger
collection, of PortHoles.  A Geodesic may be temporary, in which case it
is deleted when the connection it implements is broken, or it can be
permanent, in which case it can live in disconnected form.  As a rule,
temporary geodesics are used for point-to-point connections and
permanent geodesics are used for netlist connections.  In the latter
case, the Geodesic has a name and is a member of a galaxy; hence,
Geodesic is derived from NamedObj (@pxref{class NamedObj}).

The baseclass Geodesic, which is temporary, suffices for most simulation
and code generation domains.  In fact, in a number of these domains it
contains unused features, so it is perhaps too ``heavyweight'' an object.
A Geodesic contains a ParticleStack member which is used as a queue for
movement of Particles between two portholes; it also has an originating
port and a destination port.

A Geodesic can be asked to have a specific number of initial particles.
When initialized, it creates that number of particles in its
ParticleStack; these particles are obtained from the Plasma of the
originating port (so they will be of the correct type).

@menu
* Geodesic public members::  Geodesic public members
* Geodesic protected members::  Geodesic protected members
@end menu

@node Geodesic public members, Geodesic protected members,  , class Geodesic
@subsection Geodesic public members

@example
virtual PortHole* setSourcePort (GenericPort &@var{src}, int @var{delay} = 0);
@end example

Set the source port and the number of initial particles.  The actual
source port is determined by calling @code{newConnection} on @var{src};
thus if @var{src} is a MultiPortHole, the connection will be made to
some port withing that MultiPortHole, and aliases will be resolved.
The return value is the ``real porthole'' used.

In the default implementation, if there is already a destination port,
any preexisting connection is broken and a new connection is completed.


@example
virtual PortHole* setDestPort (GenericPort &@var{dest});
@end example

Set the destination port to @code{@var{dest}.newConnection()}.  The
return value is the ``real porthole'' used.

In the default implementation, if there is already a source port,
any preexisting connection is broken and a new connection is completed.

@example
virtual int disconnect (PortHole & @var{p});
@end example

In the default implementation, if @var{p} is either the source port or
the destination port, both the source port and destination port are set
to null.  This is not enough to break a connection; as a rule,
@code{disconnect} should be called on the porthole, and that method
will call this one as part of its work.

@example
virtual void setDelay (int @var{newDelay});
@end example

Modify the delay (number of initial tokens) of a connection.  The
default implementation simply changes a count.

@example
virtual int isItPersistent() const;
@end example

Return true if the Geodesic is persistent (may exist in a disconnected
state) and false otherwise.  The default implementation returns false.

@example
PortHole* sourcePort () const;
PortHole* destPort () const;
@end example

Return my source and destination ports, respectively.

@example
virtual void initialize();
@end example

In the default implementation, this function initializes the number of
Particles to that given by the numInitialParticles field (the value
returned by @code{numInit()}; these Particles are obtained from the
Plasma (allocation pool) for the source port.  The particles will
have zero value for numeric particles, and will hold the ``empty message''
for message Particles.

@example
void put(Particle* @var{p});
@end example

Put a particle into the Geodesic (using a FIFO discipline).

@example
Particle* get();
@end example

Retrieve a particle from the Geodesic (using a FIFO discipline).
Return a null pointer if the Geodesic is empty.

@example
void pushBack(Particle* @var{p});
@end example

Push a Particle back into the Geodesic (onto the front of the queue,
instead of onto the back of the queue as @code{put} does).

@example
int size() const;
@end example

Return the number of Particles on the Geodesic at the current time.

@example
int numInit() const;
@end example

Return the number of initial particles.  This call is valid at any
time.  Immediately after @code{initialize}, @code{size} and
@code{numInit} return the same value (and this should be true for
any derived Geodesic as well), but this will not be true during
execution (where @code{numInit} stays the same and @code{size}
changes).

@example
StringList print(int verbose) const;
@end example

Print information on the Geodesic, overrides NamedObj function.

@example
virtual void incCount(int);
virtual void decCount(int);
@end example

These methods are available for schedulers such as the SDF scheduler to
simulate a run and keep track of the number of particles on the
geodesic.  @code{incCount} increases the count, @code{decCount}
decreases it, They are virtual to allow additional bookkeeping in
derived classes.

@node Geodesic protected members,  , Geodesic public members, class Geodesic
@subsection Geodesic protected members

@example
void portHoleConnect();
@end example

This function completes a connection once the originating and
destination ports are set up.

@example
PortHole *originatingPort;
PortHole *destinationPort;
@end example

These protected members point to my neighbors.

@node class Plasma, class ParticleQueue, class Geodesic, connection classes
@section Class Plasma

Class Plasma is a pool for particles.  It is derived from ParticleStack
(@pxref{class ParticleStack}).
Rather than allocating Particles as needed with @code{new} and freeing
them with @code{delete}, we instead provide an allocation pool for each
type of particle, so that very little dynamic memory allocation activity
will take place during simulation runs.

All Plasma objects known to the system are linked together.  As a rule,
there is one Plasma for each type of particle; however, each of these
objects is of type Plasma, not a derived type.  At all times, a Plasma
has at least one Particle in it; that Particle's virtual functions are
used to clone other particles as needed, determine the type, etc.

The constructor takes one argument, a reference to a Particle.  It
creates a one-element ParticleStack, and links the Plasma into a linked
list of all Plasma objects.

The @code{put} function (for putting a particle into the Plasma) adds a
particle to the Plasma's ParticleStack.  As a rule, it should not be
used directly; the Particle's @code{die} method will automatically add
it to the right Plasma (future releases may protect this method to
prevent its general use).

@example
Particle* get();
@end example

This function gets a Particle from the Plasma, creating a new one if
the Plasma has only one Particle on it (we never give away the last
Particle).

@example
DataType type();
@end example

Returns the type of the particles on the list (obtained by asking the
head Particle).

@example
static Plasma* getPlasma(DataType @var{type});
@end example

Searches the list of Plasmas for one whose type matches the argument,
and returns a pointer to it.  A null pointer is returned if there is
no match.

@node class ParticleQueue, classes for Galaxy ports, class Plasma, connection classes
@section Class ParticleQueue

Class ParticleQueue implements a queue of Particles.  It uses a member
of class ParticleStack to store the particles; it is not implemented
by deriving from ParticleStack.  It can implement a queue with finite
or unlimited capacity.

Rather than placing user-supplied Particles on the queue and removing
them directly, it takes over the responsibility for memory management
by allocating its own Particles from the Plasma and returning them
as needed.  When a user puts a Particle into the queue, the value of
the Particle is copied (with the Particle @code{clone} method);
similarly, when a user gets a Particle from the queue, he or she
supplies a Particle to received the copied value.  The advantage of
this is that the user need not worry about lifetimes of Particles --
when to create them, when it is safe to return them to the Plasma
or delete them.

The ParticleQueue default constructor forms an empty, unlimited capacity
queue.  There is also a constructor of the form

@example
ParticleQueue(unsigned int @var{cap});
@end example

This creates a queue that can hold at most @var{cap} particles.

The destructor returns all Particles in the queue to their Plasma.

@example
int empty() const;
@end example

Return TRUE if the queue is empty, else FALSE.

@example
int full() const;
@end example

Return TRUE if the length equals the capacity, else FALSE.

@example
unsigned int capacity() const;
@end example

Return the queue's capacity.  If unlimited, the largest possible
unsigned int on the machine will be returned.

@example
unsigned int length() const;
@end example

Return the number of particles in the queue.

@example
int putq(Particle& @var{p});
@end example

Put a copy of particle @var{p} into the queue, if there is room.
Returns TRUE on success, FALSE if the queue is already at capacity.

@example
int getq(Particle& @var{p});
@end example

Get a particle from the queue, and copy it into the user-supplied
particle @var{p}.  This returns TRUE on success, FALSE (and @var{p}
is unaltered) if the queue is empty.

@example
void setCapacity(int @var{sz});
@end example

Modify the capacity to @var{sz}, if @var{sz} is positive or zero.  If
negative, the capacity becomes infinite.

@example
void initialize();
@end example

Free up the queue contents.  Particles are returned to their pools and
the queue becomes empty.

@example
void initialize(int @var{n});
@end example

Equivalent to @code{initialize()} followed by @code{setCapacity(@var{n})}.

@node classes for Galaxy ports,  , class ParticleQueue, connection classes
@section Classes for Galaxy ports

Class GalPort is derived from class PortHole (@pxref{class PortHole}).

Class GalMultiPort is derived from class MultiPortHole
(@pxref{class MultiPortHole}).

These classes are used by InterpGalaxy (@pxref{class InterpGalaxy}),
and in other places, to create
galaxy ports and multiports that are aliased to some port of a member
block.  The constructor for each of these classes takes one argument,
the interior port that is to be the alias.  The @code{isItInput} and
@code{isItOutput} functions are implemented by forwarding the request
to the alias.

@node Particles and Messages, The incremental linker, connection classes, Top
@chapter Particles and Messages

@menu
* class Particle::  class Particle
* Particle public members::  Particle public members
* Arithmetic Particle classes::  Arithmetic Particle classes
* Messages::        The Heterogeneous Message Interface
* Example Message types::  Example Message types
@end menu

@node class Particle, Particle public members,  , Particles and Messages
@section Class Particle

A Particle is a little package that contains data; they represent the
principal communication technique that blocks use to pass results
around.  They move through PortHoles and Geodesics; they are allocated
in pools called Plasmas.  The class Particle is an abstract base class;
all real Particle objects are really of some derived type.

All Particles contain a link field that allows queues and stacks of
Particles to be manipulated efficiently (class ParticleStack is a base
class for everything that does this).

Particles also contain virtual operators for loading and accessing the
data in various forms; these functions permit automatic type conversion
to be easily performed.

@node Particle public members, Arithmetic Particle classes, class Particle, Particles and Messages
@section Particle public members

@example
virtual DataType type() const = 0;
@end example

Return the type of the particle.  DataType is actually just a typedef
for @code{const char*}, but when we use DataType, we treat it as an
abstract type.  Furthermore, two DataType values are considered the
same if they compare equal, which means that we must assure that
the same string is always used to represent a given type.

@example
virtual operator int () const = 0;
virtual operator float () const = 0;
virtual operator double () const = 0;
virtual operator Complex () const = 0;
@end example

These are the virtual casting functions, which convert the data in
the Particle into the desired form.  The arithmetic Particles support
all these functions cleanly.  Message particles may return errors for
some of these functions (they must return a value, but may also call
@code{Error::abortRun}.

@example
virtual StringList print () const = 0;
@end example

Return a printable representation of the Particle's data.

@example
virtual void initialize() = 0;
@end example

This function zeros the Particle (where this makes sense), or
initializes it to some default value.

@example
virtual void operator << (int @var{arg}) = 0;
virtual void operator << (double @var{arg}) = 0;
virtual void operator << (const Complex& @var{arg}) = 0;
@end example

These functions are, in a sense, the inverses of the virtual casting
operators.  They load the particle with data from @var{arg}, performing
the appropriate type conversion.

@example
virtual Particle& operator = (const Particle& @var{arg}) = 0;
@end example

Copy a Particle.  As a rule, we permit this only for Particles of the
same type, and otherwise assert an error.

@example
virtual int operator == (const Particle&) = 0;
@end example

Compare two particles.  As a rule, Particles will be equal only if
they have the same type, and, in a sense that is separately determined
for each type, the same value.

@example
virtual Particle* clone() const = 0;
@end example

Produce a second, identical particle (as a rule, one is obtained from
the Plasma for the particle if possible).

@example
virtual Particle* useNew() const = 0;
@end example

This is similar to @code{clone}, except that the particle is allocated
from the heap rather than from the Plasma.

@example
virtual void die() = 0;
@end example

Return the Particle to its Plasma.

@example
virtual void getMessage (Envelope&);
virtual void accessMessage (Envelope&) const;
virtual void operator << (const Envelope&);
@end example

These functions are used to implement the Message interface.  The
default implementation returns errors for them; it is only if the
Particle is really a MessageParticle that they successfully send or
receive a Message from the Particle.

@node Arithmetic Particle classes, Messages, Particle public members, Particles and Messages
@section Arithmetic Particle classes

There are three standard arithmetic Particle classes: IntParticle,
FloatParticle, and ComplexParticle.  As their names suggest, each
class adds to Particle a private data member of type int, double (not
float!), and class Complex, respectively.

When a casting operator or ``<<'' operator is used on a particle of one of
these types, a type conversion may take place.  If the type of the
argument of cast matches the type of the particle's data, the data is
simply copied.  If the requested operation involves a ``widening''
conversion (int to float, double, or Complex; float to double or
Complex; double to Complex), the ``obvious'' thing happens.  Conversion
from double to int rounds to the nearest integer; conversion from
Complex to double returns the absolute value (not the real part!),
and Complex to int returns the absolute value, rounded to the nearest
integer.

@code{initialize} for each of these classes sets the data value to
zero (for the appropriate domain).

The DataTypes returned by these Particle types are the global symbols
INT, FLOAT, and COMPLEX, respectively.  They have the string values
``INT'', ``FLOAT'', and ``COMPLEX''.

@node Messages, Example Message types, Arithmetic Particle classes, Particles and Messages
@section The Heterogeneous Message Interface

The heterogeneous message interface is a mechanism to permit messages of
arbitrary type (objects of some derived type of class Message) to be
transmitted by blocks.  Because these messages may be very large,
facilities are provided to permit many references to the same Message;
Message objects are ``held'' in another class called Envelope.  As the
name suggests, Messages are transferred in Envelopes.  When Envelopes
are copied, both Envelopes refer to the same Message.  A Message will
be deleted when the last reference to it disappears; this means that
Messages must always be on the heap.

So that Messages may be transmitted by portholes, there is a class
MessageParticle whose data field is an Envelope.  This permits it to
hold a Message just like any other Envelope object.

@menu
* class Envelope::  class Envelope
* class Message::   class Message
* class MessageParticle::  class MessageParticle
@end menu

@node class Envelope, class Message,  , Messages
@subsection Class Envelope

class Envelope has two constructors.  The default constructor constructs
an ``empty'' Envelope (in reality, the envelope is not empty but contains
a special ``dummy message'' -- more on this later).  There is also a
constructor of the form

@example
Envelope(Message& @var{data});
@end example

This constructor creates an Envelope that contains the Message
@var{data}, which MUST have been allocated with @code{new}.

Message objects have reference counts; at any time, the reference count
equals the number of Envelope objects that contain (refer to) the
Message object.  When the reference count drops to zero (because of
execution of a destructor or assignment operator on an Envelope object),
the Message will be deleted.

Class Envelope defines an assignment operator, copy constructor, and
destructor.  The main work of these functions is to manipulate reference
counts.  When one Envelope is copied to another, both Envelopes refer
to the same message.

@example
int empty() const;
@end example

Return TRUE if the Envelope is ``empty'' (points to the dummy message),
FALSE otherwise.

@example
const Message* myData() const;
@end example

Return a pointer to the contained Message.  This pointer must not be
used to modify the Message object, since other Envelopes may refer to
the same message.

@example
Message* writableCopy();
@end example

This method produces a writable copy of the contained Message, and
also zeros the Envelope (sets it to the empty message).  If this
Envelope is the only Envelope that refers to the message, the
return value is simply the contained message.  If there are multiple
references to the message, the @code{clone} method is called on the
Message, making a duplicate, and the duplicate is returned.

The user is now responsible for memory management of the resulting
Message.  If it is put into another Envelope, that Envelope will
take over the responsibility, deleting the message when there is
no more need for it.  If it is not put into another Envelope, the
user must make sure it is deleted somehow, or else there will be
a memory leak.

@example
int typeCheck(const char* @var{type}) const;
@end example

This member function asks the question ``is the contained Message
of class @var{type}, or derived from @var{type}''?  It is implemented by
calling @code{isA} on the Message.  Either TRUE or FALSE is returned.

@example
const char* typeError(const char* @var{expected}) const;
@end example

This member function may be used to format error messages for when
one type of Message was expected and another was received.  The
return value points to a static buffer that is wiped out by subsequent
calls.

@example
const char* dataType() const;
int asInt() const;
double asFloat() const;
Complex asComplex() const;
StringList print() const;
@end example

All these methods are ``passthrough methods''; the return value is the
result of calling the identically named function on the contained
Message object.

@node class Message, class MessageParticle, class Envelope, Messages
@subsection Class Message

Message objects can be used to carry data between blocks.  Unlike
Particles, which must all be of the same type on a given connection,
connections that pass Message objects may mix message objects of
many types on a given connection.  The tradeoff is that blocks that
receive Message objects must, as a rule, type-check the received
objects.

The baseclass for all messages, named Message, contains no data, only
a reference count (accordingly, all derived classes have a reference
count and a standard interface).  The reference count counts how many
Envelope objects refer to the same Message object.

The constructor for Message creates a reference count that lives on
the heap.  This means that the reference count is non-const even when
the Message object itself is const.

The copy constructor for Message ignores its argument and creates a
new Message with a new reference count.  This is necessary so that no
two messages will share the same reference count.

The destructor, which is virtual, deletes the reference count.

The following Message functions must be overriden appropriately in any
derived class:

@example
virtual const char* dataType() const;
@end example

This function returns the type of the Message.  The default
implementation returns ``DUMMY''.

@example
virtual Message* clone() const;
@end example

This function produces a duplicate of the object it is called on.
The duplicate must be ``good enough'' so that applications work the
same way whether the original Message or one produced by @code{clone()}
is received.  A typical strategy is to define the copy constructor
for each derived Message class and write something like

@example
Message* MyMessage::clone() const @{ return new MyMessage(*this);@}
@end example

@example
virtual int isA(const char*) const;
@end example

The @code{isA} function returns true if given the name of the class
or the name of any baseclass.  Exception: the baseclass function returns
FALSE to everything (as it has no data at all).  A macro @code{ISA_FUNC}
is defined to automate the generation of implementations of derived
class @code{isA} functions; it is the same one as that used for the
NamedObj class.

The following methods may optionally be redefined.

@example
virtual StringList print() const;
@end example

This method returns a printable representation of the Message.
The default implementation returns a message like

@example
Message class <@var{type}>: no print method
@end example

where @var{type} is the message type as returned by the @code{dataType}
function.

@example
virtual int asInt() const;
virtual double asFloat() const;
virtual Complex asComplex() const;
@end example

These functions represent conversions of the Message data to an integer,
a floating point value, and a complex number, respectively.  Usually
such conversions do not make sense; accordingly, the default
implementations generate an error message (using the protected member
function @code{errorConvert}) and return a zero of the appropriate type.
If a conversion does make sense, they may be overriden by a method that
does the appropriate conversion.  These methods will be used by the
MessageParticle class when an attempt is made to read a MessageParticle
in a numeric context.

One protected member function is provided:

@example
int errorConvert(const char* @var{cvttype}) const;
@end example

This function invokes @code{Error::abortRun} with a message of the
form

@example
Message class <@var{msgtype}>: invalid conversion to @var{cvttype}
@end example

where @var{msgtype} is the type of the Message, and @var{cvttype} is
the argument.

@node class MessageParticle,  , class Message, Messages
@subsection Class MessageParticle

MessageParticle is a derived type of Particle (@pxref{class Particle})
whose data field is an
Envelope; accordingly, it can transport Message objects.

MessageParticle defines no new methods of its own; it only provides
behaviors for the virtual functions defined in class Particle.
The most important such behaviors are as follows:

@example
void operator << (const Envelope& @var{env});
@end example

This method loads the Message contained in @var{env} into the Envelope
contained in the MessageParticle.  Since the Envelope assignment
operator is used, after execution of this method both @var{env} and
the MessageParticle refer to the message, so its reference count is at
least 2.

@example
void getMessage(const Envelope& @var{env});
@end example

This method loads the message contained in the MessageParticle into the
Envelope @var{env}, and removes the message from the MessageParticle
(so that it now contains the dummy message).  If @var{env} previously
contained the only reference to some other Message, that previously
contained Message will be deleted.

@example
void accessMessage(const Envelope& @var{env});
@end example

@code{accessMessage} is the same as @code{getMessage} except that the
message is not removed from the MessageParticle.  It can be used in
situations where the same Particle will be read again.  We recommend
that @code{getMessage} be used where possible, especially for very
large message objects, so that they are deleted as soon as possible.

@node Example Message types,  , Messages, Particles and Messages
@section Example Message types

The kernel provides two simple sample message types for transferring
arrays of data.  They are almost identical except that one holds an
array of integers and the other holds an array of single precision
floating point data.  The array contents live on the heap.  Each is
derived from class Message.

Each provides a public data member that points to the data.  As a rule,
we recommend against public data members for classes, but an exception
was made in this case, perhaps unwisely.

This section will describe the interface of the FloatVecData class.
The interface for IntVecData is almost identical.

Three constructors are provided:

@example
FloatVecData(int @var{len});
@end example

This form creates an uninitialized array of length @var{len} in the
FloatVecData object.  Since the pointer to the data is public the
array may easily be filled in.

@example
FloatVecData(int @var{len},const float *@var{srcData});
@end example

This form creates an array of length @var{len} and initializes it with
@var{len} elements from @var{srcData}.

@example
FloatVecData(int @var{len},const double *@var{srcData});
@end example

This form is the same, except that the source data is double precision
(it is converted to single precision).  This is the only function for
which an analogous function does not exist in IntVecData (an IntVecData
can only be initialized from an integer array).

An appropriate copy constructor, assignment operator, and destructor
are defined.

@example
int length() const;
@end example

Return the length of the array.

@example
float *data;
@end example

Public data member; points to the array.  It is permissible to read or
assign the @var{len} elements starting at @code{data}; the effect of
altering the @code{data} pointer itself is undefined.

@example
const char* dataType() const;
@end example

Returns the string @code{"FloatVecData"}.

@example
int isA(const char* @var{type}) const;
@end example

TRUE for @var{type} equal to @code{"FloatVecData"}, otherwise false.

@example
StringList print() const;
@end example

Returns a comma-separated list of elements enclosed in curly braces.

@example
Message* clone() const;
@end example

Creates an identical copy with @code{new}.

@node The incremental linker, Parameters and States, Particles and Messages, Top
@chapter The incremental linker

The incremental linker permits user written code to be added to the
system at runtime.  Two different mechanisms are provided, called
a temporary link and a permanent link.

In either case, code is linked using the incremental linking facilities
of the Unix linker, the new code is read into the Ptolemy executable,
and symbols corresponding to C++ global constructors are located and called.
This means that such code is expected to register objects on Ptolemy's
known lists (e.g. KnownBlock, KnownState, or KnownTarget) so that new
classes become usable.

@emph{Warning:} if the executable containing the Linker class is
stripped, the incremental linker will not work!

@menu
* types of links::  Temporary vs. Permanent Incremental Linking
* Linker public members::  Linker public members
* Linker implementation::  Linker implementation
@end menu

@node types of links, Linker public members,  , The incremental linker
@subsection Temporary vs. Permanent Incremental Linking

Code that is linked in by the ``temporary link'' technique does not
alter the symbol table in use.  For that reason, subsequent incremental
links, whether temporary or permanent, cannot ``see'' any code that
was linked in by previous temporary links.  The advantage is that the
same symbols (for example, a Ptolemy star definition) may be redefined,
which is useful in code development, as buggy star definitions can be
replaced by valid ones without exiting Ptolemy.

Code that is linked in by the ``permanent link'' method has the same
status as code that was linked into the original executable.  A
permanent link creates or replaces the @file{.pt_symtable} file in
the directory in which Ptolemy was started.  This file contains the
current symbol table for use by subsequent links, temporary or
permanent.  This file is deleted when the Ptolemy process exits
normally.  It is left around when the process crashes, as it is useful
for debugging (as it contains symbols for object files that were
incrementally linked using the permanent method as well as those in
the original executable).

@node Linker public members, Linker implementation, types of links, The incremental linker
@subsection Linker public members


@example
static void init(const char* @var{execName});
@end example

This function initializes the linker module by telling it where the
executable for this program is.  For most purposes, passing it the
value of @code{argv[0]} passed to the @code{main} function will
suffice.

@example
static int linkObj(const char* @var{objName});
@end example

Link in a single object module using the temporary link mechanism
(this entry point is provided for backward compatibility).

@example
static int multiLink(const char* @var{args}, int @var{permanent});
static int multiLink(int @var{argc}, char** @var{argv});
@end example

Both of these functions give access to the main function for doing
an incremental link.  They permit either a temporary or a permanent
link of multiple files; flags to the Unix linker such as @code{-l}
to specify a library or @code{-L} to specify a search directory for
libraries are permitted.  For the first form, @var{args} are passed
as part of a linker command that is expanded by the Unix shell.  A
permanent link is performed if @var{permanent} is true (nonzero);
otherwise a temporary link is performed.

The second form is provided for ease of interfacing to the Tcl
interpreter, which likes to pass arguments to commands in this
style.  In this case, @code{@var{argv}[0]} indicates the type of
link: if it begins with the character @code{p}, a permanent link
is performed; otherwise a temporary link is performed.  The remaining
arguments are concatentated (separated by spaces) and appear in the
argument to the Unix linker.

@example
static int isActive();
@end example


This function returns TRUE if the linker is currently active (so objects
can be marked as dynamically linked by the known list classes).
Actually the flag it returns is set while constructors or other
functions that have just been linked are being run.

@example
static int enabled();
@end example

Returns true if the linker is enabled (it is enabled by calling
@code{Linker::init} if that function returns successfully).

@example
static const char* imageFileName();
@end example

Return the fully-expanded name of the executable image file (set by
@code{Linker::init}).

@example
static void setDefaultOpts(const char* @var{newValue});
static const char* defaultOpts();
@end example

These functions set or return the linker's default options, a set of
flags appended to the end of the command line by all links.

@node Linker implementation,  , Linker public members, The incremental linker
@subsection Linker implementation

This section is intended to assist those that attempt to port the
Linker module to other platforms.

The Linker class is implemented in three files: @file{Linker.h},
specifying the class interface, @file{Linker.cc}, specifying the
implementation, and @file{Linker.sysdep.h}, specifying all the machine
dependent parts of the implementation.

The Linker class currently works on the Sun-3 or Sun-4 running
@code{g++}, the Sun-4 running Sun's @code{cfront} port, and
Vaxes and DecStations running Ultrix.  Some work has been done to
port it to the HP-PA architecture; this is not yet complete.

The intent is to structure the code in such a way that no @code{#ifdef}s
appear in @file{Linker.cc}; they should all be in @file{Linker.sysdep.h}.

The linker reads all new code into a pre-existing large array, rather
than creating blocks of the right size with @code{new}, because the
right size is not known in advance but a starting location must, as a
rule, be passed to the loader in advance.  This means that there is a
wired-in limit to how much code can be linked in.  The symbol
@code{LINK_MEMORY}, which is set to one megabyte by default, is easily
changed if required.

Here are the steps taken by the linker to do its work:

Align the memory as required.

Form the command line and execute the Unix linker.  Only certain flags
in the command line will be system-dependent.

Read in the object file.  This is heavily system-dependent.

Make the read-in text executable.  On most systems this is a do-nothing
step.

Invoke constructors in the newly read in code.  Constructors are found
by use of the @file{nm} program; the output is parsed to search for
constructor symbols, whose form depends on the compiler used.

If this is a permanent link, copy the linker output to file
@file{.pt_symtable}; otherwise delete it.

@node Parameters and States, known lists, The incremental linker, Top
@chapter Parameters and States

A State is a data-structure associated with a block, used to remember
data values from one invocation to the next.
For example, the gain of an automatic gain control is a state.
A state need not be dynamic; for instance, the gain of fixed
amplifier is a state.  A parameter is the initial value of a state.

A State actually has two values: the initial value, which is always
a character string, and a current value, whose type is different for
each derived class of State: integer for IntState, an array of real
values for FloatArrayState, etc.

In addition, states have attributes, which represent logical properties
the state either has or does not have.

@menu
* class State::     class State
* types of states::  types of states
@end menu

@node class State, types of states,  , Parameters and States
@section Class State

Class State is derived from class NamedObj (@pxref{class NamedObj}).

The State baseclass is an abstract class; you cannot create a plain
State.  The baseclass contains the initial value, which is always
a @code{const char*}; the derived classes are expected to provide
current values of appropriate type.

The constructor for class State sets the initial value to a null
pointer, and sets the state's attributes to a value determined by
the constant AB_DEFAULT.  The destructor does nothing extra.

@menu
* State public members::  State public members
* The State parser::  The State parser and protected members
@end menu

@node State public members, The State parser,  , class State
@subsection State public members

@example
State& setState(const char* @var{stateName}, Block* @var{parent},
               const char* @var{initValue}, const char* @var{desc} = NULL);
@end example

This function sets the name, parent, initial value, and optionally the
descriptor for a state.  The character strings representing the initial
value and descriptor must outlive the State.

@example
State& setState(const char* @var{stateName}, Block* @var{parent},
               const char* @var{initValue}, const char* @var{desc},
               Attribute @var{attr});
@end example

This function is the same as the other @code{setState}, but it also
sets attributes for the state.  The Attribute object represents a
set of attribute bits to turn on or off.

@example
void setInitValue(const char* @var{valueString});
@end example

This function sets the initial value to @var{valueString}.  This
string must outlive the State.

@example
const char* initValue () const;
@end example

Return the initial value.

@example
virtual const char* type() const = 0;
@end example

Return the type name (for use in user interfaces, for example).
When states are created dynamically (by the KnownState or InterpGalaxy
class), it is this name that is used to specify the type.

@example
virtual int size() const;
@end example

Return the size (number of distinct values) in the state.  The
default implementation returns 1.  Array state types will return the
number of elements.

@example
virtual int isArray() const;
@end example

Return TRUE if this state is an array, false otherwise.  The default
implementation returns false.

@example
virtual void initialize() = 0;
@end example

Initialize the state.  The @code{initialize} function for a state is
responsible for parsing the initial value string and setting the current
value appropriately; errors are signaled using the
@code{Error::abortRun} mechanism.

@example
virtual StringList currentValue() const = 0;
@end example

Return a string representation of the current value.

@example
void setCurrentValue(const char* @var{newval});
@end example

Modify the current value, in a type-independent way.  Notice that this
function is not virtual.  It exploits the semantics of @code{initialize}
to set the current value using other functions; the initial value is
not modified (it is saved and restored).

@example
virtual State* clone() const = 0;
@end example

Derived state classes override this method to create an identical
object to the one the method is called on.

@example
StringList print(int @var{verbose}) const;
@end example

Output all info.  This is NOT redefined for each type of state.

@example
bitWord attributes() const;
@end example

Return my attribute bits.

@example
bitWord setAttributes(const Attribute& @var{attr});
bitWord clearAttributes(const Attribute& @var{attr});
@end example

Set or clear attributes.

@node The State parser,  , State public members, class State
@subsection The State parser and protected members

Most of class State's protected interface consists of a simple
recursive-descent parser for parsing integer and floating expressions
that appear in the initial value string.

class ParseToken represents tokens for this parser; it contains a
token type (an integer code) and a token value, which is a
union that represents either a character value, a string value, an
integer value, a double value, a Complex value, or a State value
(for use when the initializer references another state).  Token
types are equal to the ASCII character value for single-character
tokens; other possible token values are:

@code{T_EOF} for end of file, @code{T_ERROR} for error, @code{T_Float}
for a floating value, @code{T_Int} for an integer value, @code{T_ID}
for a reference to a state, and @code{T_STRING} for a string value.
For most of these, the token value holds the appropriate value.

Most derived State classes use this parser to provide uniformity
of syntax and error reporting; however, it is not a requirement to
use it.

Derived State classes are expected to associate a Tokenizer object
with their initial value string; the functions provided here can
then be used to parse expressions appearing in that string.

@example
ParseToken getParseToken(Tokenizer& @var{tok}, int @var{wantedType}= T_Float);
@end example

This function obtains the next token from the input stream associated
with the Tokenizer.  If there is a pushback token, that token is
returned instead.  If it receives a '<' token, it assumes that the
next whitespace-delimited string is a file and uses Tokenizer's include
file capability to cause it to read from that file.

It returns a T_EOF token on end of file.  The characters in @code{,[]+*-/()^}
are considered special and the lexical value is equal to the character
value.

Integer and floating values are recognized and evaluated to produce
either T_Int or T_Float tokens.  However, the decision is based on
the value of @var{wantedType}; if it is T_Float, all numeric values
are returned as T_Float; if it is T_Int, all numeric values are returned
as T_Int.

Names that take the form of a
C or C++ identifier are assumed to be names of states defined at a
higher level (states belonging to the parent galaxy or some ancestor
galaxy).  They are searched for using @code{lookup}; if not found,
an error is reported using @code{parseError} and an error token is
returned.  If a State is found, a token of type T_ID is returned if
it is an array state or COMPLEX; otherwise the state's current value
is substituted and reparsed as a token.  This means, for example, that
a name of an IntState will be replaced with a T_Int token with the
correct value.

@example
const State* lookup(const char* @var{name}, Block* @var{b});
@end example

This method searches for a state named @var{name} in Block @var{b} or
one of its ancestors, and either returns it or a null pointer if
not found.

@example
void parseError (const char* @var{part1}, const char* @var{part2} = "");
@end example

This method produces an appropriately formatted error message with
the name of the state and the arguments and calls @code{Error::abortRun}.

@example
static ParseToken pushback();
static void setPushback(const ParseToken&);
static void clearPushback();
@end example

These functions manipulate the pushback token, for use in parsing.
The first function returns the current pushback token, the second
sets it to be a copy of the argument, the third clears it.
There is only one such token, so the state parser is not reentrant.

@example
ParseToken evalIntExpression(Tokenizer& @var{lexer});
ParseToken evalIntTerm(Tokenizer& @var{lexer});
ParseToken evalIntFactor(Tokenizer& @var{lexer});
ParseToken evalIntAtom(Tokenizer& @var{lexer});
@end example

These four functions implement a simple recursive-descent expression
parser.

An expression is either a term or a series of terms with intervening '+'
or '-' signs.

A term is either a factor or a series of factors with interventing '*'
or '/' signs.

A factor is either an atom or a series of atoms with intervening '^'
signs for exponentiation.  (Note, C fans!  ^ means exponentiation, not
exclusive-or!).

An atom is any number of optional unary minus signs, followed either
by a parenthesized expression or a T_Int token.

If any of these methods reads too far, the pushback token is used.
All @code{getParseToken} calls use @var{wantedType} T_Int, so any
floating values in the expression are truncated to integer.

The token types returned from each of these methods will be one of
T_Int, T_EOF, or T_ERROR.

@example
ParseToken evalFloatExpression(Tokenizer& @var{lexer});
ParseToken evalFloatTerm(Tokenizer& @var{lexer});
ParseToken evalFloatFactor(Tokenizer& @var{lexer});
ParseToken evalFloatAtom(Tokenizer& @var{lexer});
@end example

These functions have the identical structure as the corresponding
Int functions.

The token types returned from each of these methods will be one of
T_Float, T_EOF, or T_ERROR.

@node types of states,  , class State, Parameters and States
@section types of states

@menu
* scalar states::   class IntState and class FloatState
* class ComplexState::  class ComplexState
* class StringState::  class StringState
* numeric array states::  numeric array states
* class StringArrayState::  class StringArrayState
@end menu

@node scalar states, class ComplexState,  , types of states
@subsection Class IntState and class FloatState

Class IntState, derived from State, has an integer current value.
Its @code{initialize()} function uses the @code{evalIntExpression}
function to read an integer expression from the initial value
string.  If successful, it attempts to read another token from
the string; if there is another token, it reports the error
``extra text after valid expression''.

An assignment operator is provided that accepts an integer value
and loads it into the current value.  A cast to integer is also
defined for accessing the current value.  The virtual function
@code{currentValue} is overloaded to return a printed version of
the current value.

In addition to the @code{setInitValue} from class State, a second
form is provided that takes an integer argument.

Standard overrides for @code{isA}, @code{className}, and @code{clone}
are provided.

Class FloatState is almost identical to class IntState except that
its data field is a double precision value; where IntState functions
have an argument or return value of @code{int}, FloatState has a
corresponding argument or return value of @code{double}.  Both are
generated from the same pseudo-template files.

The @code{type()} function for IntState returns @code{"INT"}.
For FloatState, @code{"FLOAT"} is returned.  For both implementations, a
prototype object is added to the KnownState list.

@node class ComplexState, class StringState, scalar states, types of states
@subsection Class ComplexState

ComplexState is much like FloatState and IntState, except in the
expressions it accepts for initial values.  Its data member is
Complex and it accordingly defines an assignment operator that takes a
complex value and a conversion operator that returns one.

The initial value string for a ComplexState takes one of three forms:
it may be the name of a galaxy ComplexState, a floating expression
(of the form accepted by @code{State::evalFloatExpression}), or a
string of the form

@example
( @var{floatexp1} , @var{floatexp2} )
@end example

where both @var{floatexp1} and @var{floatexp2} are floating expressions.
For the second form, the imaginary part will always be zero.  For the
third form, the first expression gives the real part and the second
gives the imaginary part.

@node class StringState, numeric array states, class ComplexState, types of states
@subsection Class StringState

A StringState's current value is a string (more correctly, of type
@code{const char*}).  The current value is created by the
@code{initialize()} function by scanning the initial value string.
This string is copied literally, except that curly braces are special.
If a pair of curly braces surrounds the name of a galaxy state, the
printed representation of that state's current value (returned by
the @code{currentValue} function) is substituted.  To get a literal
curly brace in the current value, prefix it with a backslash.

Class StringState defines assignment operators so that different
string values can be copied to the current value; the value is
copied with @code{savestring} (@pxref{utility functions})
and deleted by the destructor.

@node numeric array states, class StringArrayState, class StringState, types of states
@subsection numeric array states

Classes IntArrayState and FloatArrayState are produced from the same
pseudo-template.  Class ComplexArrayState has a very similar design.
All return TRUE to @code{isArray}, provide an array element selection
operator (@code{operator[](int)}), and an operator that converts
the state into a pointer to the first element of its data (much like
arrays in C).

The expression parser for FloatArrayState accepts a series of ``subarray
expressions'', which are concatenated together to get the current value
when @code{initialize()} is called.  Subarray expressions may specify
a single element, some number of copies of a single element, or a
galaxy array state of the same type (another FloatArrayState).  A
single element specifier may either be a floating point value, a
scalar (integer or floating) galaxy state name, or a general floating
expression enclosed in parentheses.  A number of copies of this
single element can be specified by appending an integer expression
enclosed in square brackets.

The expression parsers for IntArrayState and ComplexArrayState differ
only that where FloatArrayState wants a floating expression,
IntArrayState wants an integer expression and ComplexArrayState
wants a complex expression (an expression suitable for initializing
a ComplexState).

@node class StringArrayState,  , numeric array states, types of states
@subsection Class StringArrayState

As its name suggests, the current value for a StringArrayState is
an array of strings.  Whitespace in the initial value string separates
``words''; each word is assigned by @code{initialize()} into a
separate array element.  Quotes can be use to permit ``words''
to have whitespace.

Current values of galaxy states can be converted into single elements
of the StringArrayState value by surrounding their names with curly
braces in the initial value.  Galaxy StringArrayState names will
be translated into a series of values.

There is currently no provision for modifying the current value of
a StringArrayState other than calling of @code{initialize} to parse
the current value string.

@node known lists, I/O classes, Parameters and States, Top
@chapter Support for known lists and such

Ptolemy is an extensible system, and in quite a few places it must
create objects given only the name of that object.  There are therefore
several classes that are responsible for maintaining lists: the list of
all known domains, of all known blocks, states, targets, etc.  As a
general rule, these classes support a @code{clone} or @code{makeNew}
method to create a new object based on its name (you cannot clone a
domain, however).

@menu
* class KnownBlock::  class KnownBlock
* class KnownTarget::  class KnownTarget
* class Domain::    class Domain
* class KnownState::  class KnownState
@end menu

@node class KnownBlock, class KnownTarget,  , known lists
@section Class KnownBlock

The KnownBlock class is responsible for keeping a master list of all
known types of Block objects in the system.  All member functions of
KnownBlock are static; the only non-static function of KnownBlock is
the constructor.

The KnownBlock constructor has the form

@example
KnownBlock(Block& @var{block},const char* @var{name});
@end example

The only reason for constructing a KnownBlock object is for the side
effects; the side effect is to add @var{block} to the known block list
for its domain under the name @var{name}, using @code{addEntry}.

The reason for using a constructor for this purpose is that constructors
for global objects are called before execution of the main program;
constructors therefore serve as a mechanism for execution of arbitrary
initialization code for a module (as used here, ``module'' is an object
file).  Hence @file{ptlang}, the Ptolemy star preprocessor, generates
code like the following for star definitions:

@example
static XXXMyClass proto;
static KnownBlock entry(proto,"MyClass");
@end example

This code adds a prototype entry of the class to the known list.

@example
static void addEntry (Block &@var{block}, const char* @var{name}, int @var{onHeap});
@end example

This function actually adds the block to the list.  If @var{onHeap} is true,
the block will be destroyed when the entry is removed or replaced from
the list.  Separate lists are maintained for each domain; the block
is added to the list corresponding to @code{@var{block}.domain()}.

@example
static const char* domain();
@end example

Return the current domain name.

@example
static int setDomain (const char* @var{newDom});
@end example

Change the current domain.  Return TRUE if it worked, FALSE for an
unknown domain.  This affects which sublist of blocks is searched by
subsequent @code{find} and @code{clone} calls.

@example
static const Block* find (const char* @var{name});
@end example

The find method returns a pointer the appropriate block in
the current domain.  A null pointer is returned if no match
is found.

@example
static Block* clone (const char* @var{name});
static Block* makeNew (const char* @var{name});
@end example

The @code{clone} method takes a string, finds the appropriate block in
the current domain, and returns a clone of that block (the
@code{clone} method is called on the block.  This method, as
a rule, generates a duplicate of the block.

The @code{makeNew} function is similar except that @code{makeNew}
is called on the found block.  As a rule, @code{makeNew} returns
an object of the same class, but with default initializations
(for example, with default state values).

For either of these, an error message is generated (with
@code{Error::abortRun}) and a null pointer is returned if there is no
match.

@example
static StringList nameList();
static StringList nameList (const char* @var{domain});
@end example

Return the names of known blocks in the current domain (first form) or
the given domain (second form).  Names are
separated by newline characters.

@example
static int isDynamic (const char* @var{type});
@end example

Return true if the named block is dynamically linked.

There is an iterator associated with KnownBlock, called
KnownBlockIter.  It takes as an argument the name of a domain.  The
argument may be omitted, in which case the current domain is used.
Its @code{next} function returns the type @code{const Block *}; it
steps through the blocks on the known list for that domain.

@node class KnownTarget, class Domain, class KnownBlock, known lists
@section Class KnownTarget

The KnownTarget class keeps track of targets in much the same way
that KnownBlock keeps track of blocks.  There are some differences:
there is only a single list of targets, not one per domain as for
blocks.

The constructor works exactly the same way that the constructor for
KnownBlock works; the code

@example
static MyTarget proto(@var{args});
static KnownTarget entry(proto,"MyTarget");
@end example

adds the prototype instance to the known list with a call to
@code{addEntry}.

@example
static void addEntry (Target &@var{target}, const char* @var{name}, int @var{onHeap});
@end example

This function actually adds the Target to the list.  If @var{onHeap} is true,
the target will be destroyed when the entry is removed or replaced from
the list.  There is only one list of Targets.

@example
static const Target* find (const char* @var{name});
@end example

The find method returns a pointer the appropriate target.
A null pointer is returned if no match
is found.

@example
static Target* clone (const char* @var{name});
@end example

The @code{clone} method takes a string, finds the appropriate target on
the known target list, and returns a clone of that block (the
@code{cloneTarget} method is called on the target).  This method, as
a rule, generates a duplicate of the target.
An error message is generated (with @code{Error::abortRun}) and
a null pointer is returned if there is no match.

@example
static int getList (const Block& @var{b}, const char** @var{names}, int @var{nMax});
@end example

This function returns a list of names of targets that are compatible
with the Block @var{b}.  The return value gives the number of matches.
The @var{names} array can hold @var{nMax} strings; if there are more,
only the first @var{nMax} are returned.

@example
static int getList (const char* @var{dom}, const char** @var{names}, int @var{nMax});
@end example

This function is the same as above, except that it returns names of
targets that are compatible with stars of a particular domain.

@example
static int isDynamic (const char* @var{type});
@end example

Return true if there is a target on the known list named @var{type}
that is dynamically linked; otherwise return false.

@example
static const char* defaultName(const char* @var{dom} = 0);
@end example

Return the default target name for a domain (default: current domain).

There is an iterator associated with KnownTarget, called
KnownTargetIter.  Since there is only one known target list, it is
unusual for an iterator in that it takes no argument for its constructor.
Its @code{next} function returns the type @code{const Target *}; it
steps through the targets on the known list.

@node class Domain, class KnownState, class KnownTarget, known lists
@section Class Domain

The Domain class represents the information that Ptolemy needs to know
about a particular domain so that it can create galaxies, wormholes,
nodes, event horizons, and such for that domain.  For each domain,
the designer creates a derived class of Domain and one prototype object.
Thus the Domain class has two main parts: a static interface, which
manages access to the list of Domain objects, and a set of virtual
functions, which provides the standard interface for each domain to
describe its requirements.

@menu
* Domain virtual functions::  Domain virtual functions
@end menu

@node Domain virtual functions,  ,  , class Domain
@subsection Domain virtual functions

@example
virtual Star& newWorm(Galaxy& @var{innerGal},Target* @var{innerTarget} = 0);
@end example

This function creates a new wormhole with the given inner galaxy and
inner target.  The default implementation returns an error.

XXXDomain might override this as follows:

@example
Star& XXXDomain::newWorm(Galaxy& innerGal,Target* innerTarget)  @{
        LOG_NEW; return *new XXXWormhole(innerGal,innerTarget);
@}
@end example

@example
virtual EventHorizon& newFrom();
virtual EventHorizon& newTo();
@end example

These functions create event horizon objects to represent the
XXXfromUniversal and XXXtoUniversal functions.  The default
implementations return an error.

XXXDomain might override these as

@example
EventHorizon& XXXDomain::newFrom() @{
    LOG_NEW; return *new XXXfromUniversal;
@}

EventHorizon& XXXDomain::newTo() @{
    LOG_NEW; return *new XXXtoUniversal;
@}
@end example

@example
virtual Geodesic& newNode() = 0;
@end example

This function creates a new permanent node appropriate for netlist
connections for the domain.  There is no default implementation.

@example
virtual int isGalWorm();
@end example

This function returns FALSE by default.  If overridden by a function
that returns TRUE, a wormhole will be created around every galaxy
for this domain.

@node class KnownState,  , class Domain, known lists
@section Class KnownState

KnownState manages two lists of states, one to represent the types of
states known to the system (integer, string, complex, array of floating,
etc), and one to represent certain predeclared global states.

It is very much like KnownBlock (@pxref{class KnownBlock})
in internal structure.  Since it manages
two lists, there are two kinds of constructors.

@example
KnownState (State &@var{state}, const char* @var{name});
@end example

This constructor adds an entry to the state type list.  For example,

@example
static IntState proto;
static KnownState entry(proto,"INT");
@end example

permits IntStates to be produced by cloning.  The @var{type} argument
must be in uppercase, because of the way @code{find} works (see below).

The second type of constructor takes three arguments:

@example
KnownState (State &@var{state}, const char* @var{name}, const char* @var{value});
@end example

This constructor permits names to be added to the global state symbol
list, for use in state expressions.  For example, we have

@example
static FloatState pi;
KnownState k_pi(pi,"PI","3.14159265358979323846");
@end example

@example
static const State* find (const char* @var{type});
@end example

The @code{find} method returns a pointer the appropriate prototype
state in the state type list.  The argument is always changed to
uppercase.  A null pointer is returned if there is no match.

@example
static const State* lookup (const char* @var{name});
@end example

The lookup method returns a pointer to the appropriate state in
the global state list, or null if there is no match.

@example
static State* clone (const char* type);
@end example

The clone method takes a string, finds the appropriate state using
@code{find}, and returns a clone of that block.  A null pointer is
returned if there is no match, and @code{Error::error} is also called.

@example
static StringList nameList();
@end example

Return the names of all the known state types, separated by newlines.

@example
static int nKnown();
@end example

Return the number of known states.

@node I/O classes, Misc, known lists, Top
@chapter I/O classes

@menu
* class StringList::  StringList, a kind of String class
* class InfString::  InfString, a class supporting unbounded strings
* class Tokenizer::  Tokenizer, a simple lexical analyzer class
* augmented fstreams::  classes pt_ifstream and pt_ofstream
* class XGraph::    Xgraph, an interface to the xgraph program
* Histogram classes::  Histogram classes
@end menu

@node class StringList, class InfString,  , I/O classes
@section StringList, a kind of String class

Class StringList provides a mechanism for organizing a list
of strings.  It can also be used to construct strings
of unbounded size, but the class InfString is preferred
for this (@pxref{class InfString}).
It is privately
derived from SequentialList (@pxref{class SequentialList}).

Its internal implementation is as a
list of @code{char *} strings, each on the heap.  A StringList
object can be treated either as a single string or as a list of
strings; the individual substrings retain their separate identity
until the conversion operator to type @code{const char *} is invoked.
There are also operators that add numeric values to the StringList;
there is only one format available for such additions.

WARNING: if a function or expression returns a StringList, and
that value is not assigned to a StringList variable or reference,
and the @code{(const char*)} cast is used, it is possible (likely under
g++) that the StringList temporary will be destroyed too soon,
leaving the @code{const char*} pointer pointing to garbage.  Always
assign a temporary StringList to a StringList variable or reference
before using the @code{const char*} conversion.  Thus, instead of

@example
function_name(@var{xxx}, (const char*)functionReturningStringList(), @var{yyy});}
@end example

one should use

@example
StringList @var{temp_name} = (const char*)functionReturningStringList();
function_name(@var{xxx},  @var{temp_name}, @var{yyy});}
@end example

This includes code like

@example
strcpy(destBuf,functionReturningStringList());
@end example

which uses the @code{const char*} conversion implicitly.

@menu
* StringList constructors::  constructors and assignment operators
* adding to StringLists::  adding to StringLists
* StringList info functions::  StringList information functions
* StringList conversion::  StringList conversion to const char *
* StringList destruction::  StringList destruction and zeroing
* class StringListIter::  class StringListIter
@end menu

@node StringList constructors, adding to StringLists,  , class StringList
@subsection StringList constructors and assignment operators

The default constructor makes an empty StringList.  There is also
a copy constructor and five single-argument constructors that can
function as conversions from other types to type StringList; they
take arguments of the types
@code{char}, @code{const char *}, @code{int}, @code{double}, and
@code{unsigned int}.

There are also six assignment operators corresponding to these
constructors: one that takes a @code{const StringList&} argument and
also one for each of the five standard types:
@code{char}, @code{const char *}, @code{int}, @code{double}, and
@code{unsigned int}.

The resulting object has one piece, unless initialized from another
StringList in which case it has the same number of pieces.

@node adding to StringLists, StringList info functions, StringList constructors, class StringList
@subsection adding to StringLists

There are six functions that can add a printed representation of an
argument to a StringList: one each for arguments of type
@code{const StringList&}, @code{char}, @code{const char *}, @code{int},
@code{double}, and @code{unsigned int}.  In each case, the function
can be accessed in either of two equivalent ways:

@example
StringList& operator += (@var{type} @var{arg});
StringList& operator << (@var{type} @var{arg});
@end example

The second ``stream form'' is considered preferable; the ``+='' form is
there for backward compatibility.  If a StringList object is added,
each piece of the added StringList is added separately (boundaries
between pieces are preserved); for the other five forms, a single
piece is added.

@node StringList info functions, StringList conversion, adding to StringLists, class StringList
@subsection StringList information functions

@example
const char* head() const;
@end example

Return the first substring on the list (the first ``piece'').  A null
pointer is returned if there are none.

@example
int length() const;
@end example

Return the length in characters.

@example
int numPieces() const;
@end example

Return the number of substrings in the StringList.

@node StringList conversion, StringList destruction, StringList info functions, class StringList
@subsection StringList conversion to const char *

@example
operator const char* ();
@end example

This function joins all the substrings in the StringList into a
single piece, so that afterwards @code{numPieces} will return 1.
A null pointer is always returned if there are no characters.

Warning: if this function is called on a temporary StringList, it
is possible that the compiler will delete the StringList object
before the last use of the returned @code{const char *} pointer.
The result is that the pointer may wind up pointing to garbage.
The best workaround for such problems is to make sure that any
StringList object ``has a name'' before this conversion is applied
to it; e.g. assign the results of functions returning StringList
objects to local StringList variables or references before trying
to convert them.

@example
char* newCopy() const;
@end example

This function makes a copy of the StringList's text in a single piece
as a @code{char *} in dynamic memory.  The object itself is not modified.
The caller is responsible for deletion of the returned text.

@node StringList destruction, class StringListIter, StringList conversion, class StringList
@subsection StringList destruction and zeroing

@example
void initialize();
@end example

This function deallocates all pieces of the StringList and changes
it to an empty StringList.

@example
~StringList();
@end example

The destructor calls the @code{initialize} function.

@node class StringListIter,  , StringList destruction, class StringList
@subsection Class StringListIter

Class StringListIter is a standard iterator that operates on
StringLists.  Its @code{next()} function returns a pointer of type
@code{const char *} to the next substring of the StringList.
It is important to know that the operation of converting a
StringList to a @code{const char *} string joins all the substrings into
a single string, so that operation should be avoided if extensive
use of StringListIter is planned.

@node class InfString, class Tokenizer, class StringList, I/O classes
@section InfString, a class suporting unbounded strings

Class InfString provides a mechanism for building strings
of unbounded size.  It provides a subset of the functions in a
typical C++ String class.  Strings can be built up piece by piece.
As segments are added, they are copied, so the caller
need not keep the segments around.
Upon casting to @code{(char*)}, the strings are collapsed into
one continuous string, and a pointer to that string is returned.
The calling function can treat this as an ordinary pointer to an ordinary
array of characters, and can modify the characters.
But the length of the string should not be changed, nor
should the string be deleted.
The InfString destructor is responsible for freeing the allocated memory.

InfString is privately
derived from SequentialList (@pxref{class SequentialList}),
and is very similar to StringList in internal implementation
(@pxref{class StringList}).  Its internal implementation is as a
list of @code{char *} strings, each on the heap.
The individual substrings retain their separate identity
until the conversion cast to type @code{char *} is invoked,
although if access to the individual strings is needed, then StringList
should be used (@pxref{class StringList}).
There are also operators that add numeric values to the StringList;
there is only one format available for each such addition.

WARNING: if a function or expression returns an InfString, and
that value is not assigned to an InfString variable or reference,
and the @code{(char*)} cast is used, it is possible (likely under
g++) that the InfString temporary will be destroyed too soon,
leaving the @code{char*} pointer pointing to garbage.  Always
assign temporary InfStrings to InfString variables or references
before using the @code{char*} conversion.  Thus, instead of

@example
function_name(@var{xxx}, (char*)functionReturningInfString(), @var{yyy});}
@end example

one should use

@example
InfString @var{temp_name} = (char*)functionReturningInfString();
function_name(@var{xxx},  @var{temp_name}, @var{yyy});}
@end example

This includes code like

@example
strcpy(destBuf,functionReturningInfString());
@end example

which uses the @code{char*} conversion implicitly.

@menu
* InfString constructors::  constructors and assignment operators
* adding to InfStrings::  adding to InfStrings
* InfString info functions::  InfString information functions
* InfString conversion::  InfString conversion to char *
* InfString destruction::  InfString destruction and zeroing
* class InfStringIter::  class InfStringIter
@end menu

@node InfString constructors, adding to InfStrings,  , class InfString
@subsection InfString constructors and assignment operators

The default constructor makes an empty InfString.  There is also
a copy constructor and six single-argument constructors that can
function as conversions from other types to type InfString; they
take arguments of the types
@code{char}, @code{const char *}, @code{int}, @code{double}, 
@code{unsigned int}, and @code{const StringList&}.

There are also seven assignment operators corresponding to these
constructors: one that takes a @code{const InfString&} argument and
also one for each of the six standard types:
@code{char}, @code{const char *}, @code{int}, @code{double},
@code{unsigned int}, and @code{const StringList&}.

@node adding to InfStrings, InfString info functions, InfString constructors, class InfString
@subsection adding to InfStrings

There are seven functions that can add a printed representation of an
argument to a InfString: one each for arguments of type
@code{const InfString&}, @code{char}, @code{const char *}, @code{int},
@code{double}, @code{unsigned int}, and @code{const StringList&}.
In each case, the function
can be accessed in either of two equivalent ways:

@example
InfString& operator += (@var{type} @var{arg});
InfString& operator << (@var{type} @var{arg});
@end example

The second ``stream form'' is considered preferable; the ``+='' form is
there for backward compatibility.  If a InfString object is added,
each piece of the added InfString is added separately (boundaries
between pieces are preserved); for the other five forms, a single
piece is added.

@node InfString info functions, InfString conversion, adding to InfStrings, class InfString
@subsection InfString information functions

@example
int length() const;
@end example

Return the length in characters.

@node InfString conversion, InfString destruction, InfString info functions, class InfString
@subsection InfString conversion to char *

@example
operator char* ();
@end example

This function joins all the substrings in the InfString into a
single piece, a returns a pointer to the resulting string.
A null pointer is always returned if there are no characters.

Warning: as pointed out above,
if this function is called on a temporary InfString, it
is possible that the compiler will delete the InfString object
before the last use of the returned @code{char *} pointer.
The result is that the pointer may wind up pointing to garbage.
The best workaround for such problems is to make sure that any
InfString object ``has a name'' before this conversion is applied
to it; e.g. assign the results of functions returning InfString
objects to local InfString variables or references before trying
to convert them.

@example
char* newCopy() const;
@end example

This function makes a copy of the InfString's text in a single piece
as a @code{char *} in dynamic memory.  The InfString object itself is
not modified.
This is useful when
the caller wishes to be responsible for deletion of the returned text.

@node InfString destruction, class InfStringIter, InfString conversion, class InfString
@subsection InfString destruction and zeroing

@example
void initialize();
@end example

This function deallocates all pieces of the InfString and changes
it to an empty InfString.

@example
~InfString();
@end example

The destructor calls the @code{initialize} function.

@node class InfStringIter,  , InfString destruction, class InfString
@subsection Class InfStringIter

Class InfStringIter is a standard iterator that operates on
InfStrings.  However, the InfString class is not intended for
use when access to the individual components of the string is
desired.  Use StringList for this.

@node class Tokenizer, augmented fstreams, class InfString, I/O classes
@section Tokenizer, a simple lexical analyzer class

The Tokenizer class is designed to accept input for a string or file
and break it up into tokens.  It is similar to the standard istream
class in this regard, but it has some additional facilities.  It
permits character classes to be defined to specify that certain
characters are whitespace and others are ``special'' and should be
returned as single-character tokens; it permits quoted strings to
override this, and it has a file inclusion facility.  In short, it
is a simple, reconfigurable lexical analyzer.


Tokenizer has a public const data member named @code{defWhite}
that contains the default whitespace characters: space, newline,
and tab.  It is possible to change the definition of whitespace
for a particular constructor.

@menu
* Initializing Tokenizers::  Initializing Tokenizer objects
* reading from Tokenizers::  Reading from Tokenizers
* Tokenizer include files::  Tokenizer include files
@end menu

@node Initializing Tokenizers, reading from Tokenizers,  , class Tokenizer
@subsection Initializing Tokenizer objects

Tokenizer provides three different constructors:

@example
Tokenizer();
@end example

The default constructor creates a Tokenizer that reads from the
standard input stream, @code{cin}.  Its special characters are
simply @key{(} and @key{)}.

@example
Tokenizer(istream& @var{input},const char* @var{spec},
          const char* @var{w} = defWhite);
@end example

This constructor creates a Tokenizer that reads from the stream named
by @var{input}.  The other arguments specify the special characters
and the whitespace characters.

@example
Tokenizer(const char* @var{buffer},const char* @var{spec},
          const char* @var{w} = defWhite);
@end example

This constructor creates a Tokenizer that reads from the null-terminated
string in @var{buffer}.

Tokenizer's destructor closes any include files associated with the
constructor and deletes associated internal storage.

The following operations change the definition of whitespace and of
special characters, respectively:

@example
const char* setWhite(const char* w);
const char* setSpecial(const char* s);
@end example

In each case, the old value is returned.

By default, the line comment character for Tokenizer is @key{#}.
It can be changed by

@example
char setCommentChar(char n);
@end example

Use an argument of 0 to disable the feature.  The old comment character
is returned.

@node reading from Tokenizers, Tokenizer include files, Initializing Tokenizers, class Tokenizer
@subsection Reading from Tokenizers

The next operation is the basic mechanism for reading tokens from
the Tokenizer:

@example
Tokenizer& operator >> (char * @var{pBuffer});
@end example

Here @var{pBuffer} points to a character buffer that reads the token.
There is a design flaw: there isn't a way to give a maximum buffer
length, so overflow is a risk.

By analogy with streams, the following operation is provided:

@example
operator void* ();
@end example

It returns null if EOF has already been reached and non-null otherwise.
This permits loops like

@example
Tokenizer tin;
while (tin) @{ ... do stuff ... @}
@end example

@example
int eof() const;
@end example

Returns true if the end of file or end of input has been reached on
the Tokenizer.  It is possible that there is nothing left in the input
but write space, so in many situations @code{skipwhite} should be called
before making this test.

@example
void skipwhite();
@end example

Skip whitespace in the input.

@example
void flush();
@end example

If in an include file, the file is closed.  If at the top level,
discard the rest of the current line.

@node Tokenizer include files,  , reading from Tokenizers, class Tokenizer
@subsection Tokenizer include files

Tokenizer can use include files, and can nest them to any depth.
It maintains a stack of include files, and as EOF is reached in each
file, it is closed and popped off of the stack.

The method

@example
int fromFile(const char* @var{name});
@end example

opens a new file and the Tokenizer will then read from that.  When that
file ends, Tokenizer will continue reading from the current point in
the current file.

@example
const char* current_file() const;
int current_line() const;
@end example

These methods report on the file name and line number where Tokenizer is
currently reading from.  This information is maintained for include
files.  At the top level,  @code{current_file} returns a null pointer,
but @code{current_line} returns one more than the number of line feeds
seen so far.

@example
int readingFromFile() const;
@end example

Returns true (1) if the Tokenizer is reading from an include file,
false (0) if not.

@node augmented fstreams, class XGraph, class Tokenizer, I/O classes
@section pt_ifstream and pt_ofstream: augmented fstream classes

The classes pt_ifstream and pt_ofstream are derived from the standard
stream classes ifstream and ofstream, respectively.  They are defined
in the header file @file{pt_fstream.h}.  They add the
following features:

First, certain special ``filenames'' are recognized.  If the filename used in
the constructor or an @code{open} call is @code{<cin>}, @code{<cout>},
@code{<cerr>}, or @code{<clog>} (the angle brackets must be part of
the string), then the corresponding standard stream of the same name
is used for input (pt_ifstream) or output (pt_ofstream).  In addition,
C standard I/O fans can specify @code{<stdin>}, @code{<stdout>}, or
@code{<stderr>} as well.

Second, the Ptolemy @code{expandPathName} is applied to the filename
before it is opened, permitting it to start with @code{~user} or
@code{$VAR}.

Finally, if a failure occurs when the file is opened,
@code{Error::abortRun} is called with an appropriate error message,
including the Unix error condition.

Otherwise these classes are identical to the standard ifstream and
ofstream classes and can be used as replacements.

@node class XGraph, Histogram classes, augmented fstreams, I/O classes
@section XGraph, an interface to the xgraph program

The XGraph class provides an interface for the @file{xgraph} program for
plotting data on an X window system display.  The modified @file{xgraph}
program provided with the Ptolemy distribution should be used, not the
contributed version from the X11R5 tape.

The constructor for XGraph does not completely initialize the object;
initialization is completed by the @code{initialize()} method:

@example
void initialize(Block* @code{parent}, int @code{noGraphs},
     const char* @code{options}, const char* @code{title},
     const char* @code{saveFile} = 0, int @code{ignore} = 0);
@end example

The @var{parent} argument is the name of a Block that is associated
with the XGraph object; this Block is used in @code{Error::abortRun}
messages to report errors.

@var{noGraphs} specifies the number of data sets that the graph will
contain.  Each data set is a separate stream and is plotted in a
different color (a different line style for B/W displays).

@var{options} is a series of command line options that will be passed
unmodified to the xgraph program.  It is subject to expansion by the
Unix shell.

@var{title} is the title for the graph; it can contain special
characters (it is @emph{not} subjected to expansion by the Unix shell).

@var{saveFile} is the name of a file to save the graph data into, in
ASCII form.  If it is not given, the data are not saved, and a faster
binary format is used.

@var{ignore} specifies the number of initial points to ignore from
each data set.

@example
void setIgnore(int @var{n});
@end example

Reset the ``ignore'' parameter to @var{n}.

@example
void addPoint(float @var{y});
@end example

Add a single point to the first data set whose X value is
automatically generated (0, 1, 2, 3... on successive calls)
and whose Y value is @var{y}.

@example
void addPoint(float @var{x}, float @var{y});
@end example

Add the point (@var{x}, @var{y}) to the first data set.

@example
void addPoint(int @var{dataSet}, float @var{x}, float @var{y});
@end example

Add the point (@var{x}, @var{y}) to the data set indicated by
@var{dataSet}.  Data sets start with 1.

@example
void newTrace(int @var{dataSet} = 1);
@end example

Start a new trace for the nth dataset.  This means that there will be
no connecting line between the last point plotted and the next point
plotted.

@example
void terminate();
@end example

This function flushes the data out to disk, closes the files, and
invokes the xgraph program.

If the destructor is called before @code{terminate}, it will close and
delete the temporary files.

@node Histogram classes,  , class XGraph, I/O classes
@section Histogram classes

The Historgram class accepts a stream of data and accumulates a
histogram.  The XHistogram class uses a Histogram to collect the
data and an XGraph to display it.

@menu
* class Histogram::  Class Histogram
* class XHistogram::  Class XHistogram
@end menu

@node class Histogram, class XHistogram,  , Histogram classes
@subsection Class Histogram

The Histogram class accumulates data in a histogram.  Its constructor
is as follows:

@example
Histogram(double @var{width} = 1.0, int @var{maxBins} = HISTO_MAX_BINS);
@end example

The default maximum number of bins is 1000.  The bin centers will be at
integer multiples of the specified bin width.  The total width of the
histogram depends on the data; however, there will always be a bin that
includes the first point.

@example
void add(double @var{x});
@end example

Add the point @var{x} to the histogram.

@example
int numCounts() const;
double mean() const;
double variance() const;
@end example

Return the number of counts, the mean, and the variance of the data
in the histogram.

@example
int getData(int @var{binno}, int& @var{count}, double& @var{binCenter});
@end example

Get counts and bin centers by bin number, where 0 indicates the smallest
bin.  Return TRUE if this is a valid bin.  Thus the entire histogram
data can be retrieved by stepping from 0 to the first failure.

@node class XHistogram,  , class Histogram, Histogram classes
@subsection Class XHistogram

An XHistogram object has a private XGraph member and a private Histogram
member.  The functions

@example
int numCounts() const;
double mean() const;
double variance();
@end example

@noindent
simply pass through to the Histogram object, and

@example
void addPoint(float y);
@end example

adds a point to the histogram and does other bookkeeping.  There
are two remaining methods:

@example
void initialize(Block* parent, double binWidth,
   const char* options, const char* title,
   const char* saveFile, int maxBins = HISTO_MAX_BINS);
@end example

This method initializes the graph and histogram object.  @var{parent}
is the parent Block, used for error messages.  @var{binWidth} and
@var{maxBins} initialize the Histogram object.  @var{options} is a
string that is included in the command line to the xgraph program;
other options, including @code{-bar -nl -brw @var{value}}, are passed as
well.  @var{title} is the graph title, and @var{saveFile}, if non-null,
gives a file in which the histogram data is saved (this data is the
histogram counts, not the data that was input with @code{addPoint}).

@example
void terminate();
@end example

This method completes the histogram, flushes out the temporary files,
and executes xgraph.

@node Misc,  , I/O classes, Top
@chapter Miscellaneous classes

This section includes classes that did not fit elsewhere.

@menu
* Mathematical classes::  Mathematical classes
* class IntervalList::  Class IntervalList
* Clock and TimeVal::  Classes for interacting with the system clock
@end menu

@node Mathematical classes, class IntervalList,  , Misc
@section Mathematical classes

@menu
* class Complex::   class Complex
* class Fraction::  class Fraction
@end menu

@node class Complex, class Fraction,  , Mathematical classes
@subsection class Complex

Class Complex is a simple subset of functions provided in the Gnu and
AT&T complex classes.  The standard arithmetic operators are
implemented, as are the assignment arithmetic operators @code{+=},
@code{-=}, @code{*=}, and @code{/=}, and equality and inequality
operators @code{==} and @code{!=}.  There is also @code{real()} and
@code{imag()} methods for accessing real and imaginary parts.

It was originally written when libg++ was subject to the GPL.
The current licensing for libg++ does not prevent us from using it
and still distributing Ptolemy the way we want, but having it makes
ports to other compilers (e.g. cfront) easier.

The following non-member functions take Complex arguments:

@example
Complex conj(const Complex& @var{arg});
double real(const Complex& @var{arg});
double imag(const Complex& @var{arg});
double abs(const Complex& @var{arg});
@end example

Return the conjugate, real part, imaginary part, or absolute value,
respectively.

@example
double arg(const Complex& @var{arg});
@end example

Return the angle between the X axis and the vector made by the argument.
The expression

@example
abs(z)*exp(Complex(0.,1.)*arg(z))
@end example

is in theory always equal to z.

@example
double norm(const Complex& @var{arg});
@end example

return the absolute value squared.

@example
Complex sin(const Complex& @var{arg});
Complex cos(const Complex& @var{arg});
Complex exp(const Complex& @var{arg});
Complex log(const Complex& @var{arg});
Complex sqrt(const Complex& @var{arg});
@end example

Standard mathematical functions.  @code{log} returns the principal
logarithm.

@example
Complex pow(double @var{base},const Complex& @var{expon});
Complex pow(const Complex& @var{base}, const Complex& @var{expon});
@end example

Raise base to expon power.

There is also an << operator to print a Complex on an ostream.

@node class Fraction,  , class Complex, Mathematical classes
@subsection class Fraction

Class Fraction represents fractions.  The header @file{Fraction.h}
also provides declarations for the @code{lcm} (least common multiple)
and @code{gcd} (greatest common divisor) functions, as these functions
are needed for Fraction but are generally useful.

@example
Fraction ();
Fraction (int @var{num}, int @var{den}=1);
@end example

The default constructor produces a fraction with numerator 0 and
denominator 1.  The other constructor allows the numerator and
denominator to be specified arbitrarily.

@example
int num() const;
int den() const;
@end example

Return the numerator or denominator.

@example
operator double() const;
@end example

Return the value of the fraction as a double.

Class Fraction implements the basic binary math operators
@code{+}, @code{-}, @code{*}, @code{/}; the assignment
operators @code{=}, @code{+=}, @code{-=}, @code{*=},
and @code{/=}, and the equality test operators @code{==}
and @code{!=}.

The method

@example
Fraction& simplify();
@end example

reduces the fraction to lowest terms, and returns a reference
to the fraction.

There is also an << operator to print a Fraction on an ostream.

@node class IntervalList, Clock and TimeVal, Mathematical classes, Misc
@section Class IntervalList

The IntervalList class represents a set of unsigned integers, represented
as a series of intervals of integers that belong to the set.

It is built on top of a class Interval that represents a single
interval.

There is also a text representation for IntervalLists.  This
representation can be used to read or write IntervalList objects
to streams, and also can be used in the IntervalList constructor.
This text representation looks exactly like the format the ``rn''
newsreader uses to record which articles have been read in a
Usenet newsgroup (which is where we got it from; thank you, Larry
Wall).

In the text representation, an IntervalList is specified as one
or more Intervals, separated by commas.  An Interval is either
an unsigned integer or two unsigned intervals with an intervening
minus sign.  Here is one possible IntervalList specification:

1-1003,1006,1008-1030,1050

Whitespace is not permitted in this representation.

IntervalList specifiers do not have to be in increasing order,
but if they are not, they are changed to "canonical form", in which
any overlapping intervals are merged and the intervals are sorted
to appear in increasing order.

An IntervalList is best thought of as a set of unsigned integers.
Its methods in many cases perform set operations: forming the
union, intersection, or set difference of two IntervalLists.

@menu
* class Interval::  class Interval and methods
* IntervalList public members::  
* IntervalList iterators::  IntervalList iterator classes.
@end menu

@node class Interval, IntervalList public members,  , class IntervalList
@subsection class Interval and methods

The Interval class is in some ways simply an implementation detail of
class IntervalList, but since its existence is exposed by public
methods, it is documented here.

An Interval has an @var{origin} and a @var{length}, and represents the
set of @var{length} unsigned integers beginning with @var{origin}.  It
also has a pointer that can point to another Interval.

The constructor

@example
Interval(unsigned @var{origin}=0, unsigned @var{length}=0,
    Interval* @var{nxt} = 0);
@end example

permits all these members to be set.  The copy constructor copies
the origin and length values but always sets the next pointer to null.
A third constructor

@example
Interval(const Interval& @var{i1},Interval* @var{nxt});
@end example

permits a combination of a copy and a next-pointer initialization.

The members

@example
unsigned origin() const;
unsigned length() const;
@end example

return the origin and length values.

@example
unsigned end() const;
@end example

The @code{end} function returns the last unsigned integer that is a
member of the Interval; 0 is returned for empty Intervals.

There are a number of queries that are valuable for building a set
class out of Intervals:

@example
int isAfter(const Interval &@var{i1}) const;
@end example

@code{isAfter} returns true if this Interval begins after the end of
interval @var{i1}
.
@example
int endsBefore(const Interval &@var{i1}) const;
@end example

@code{endsBefore} returns true if this Interval ends strictly before
the origin of interval i1.

@example
int completelyBefore(const Interval &@var{i1}) const;
@end example

@code{completelyBefore} returns true if @code{endsBefore} is true and there
is space between the intervals (they cannot be merged).

@example
int mergeableWith(const Interval& @var{i1}) const;
@end example

@code{mergeableWith} returns true if two intervals overlap or are
adjacent, so that their union is also an interval.

@example
int intersects(const Interval& @var{i1}) const;
@end example

@code{intersects} returns true if two intervals have a non-null
intersection.

@example
int subsetOf(const Interval& @var{i1}) const;
@end example

@code{subsetOf} returns true if the argument is a subset of this interval.

@example
void merge(const Interval& @var{i1});
@end example

@code{merge} alters the interval to the result of merging it with @var{i1}.
It is assumed that @code{mergeableWith} is true.

@example
Interval& operator&=(const Interval& @var{i1});
@end example

This Interval is changed to the intersection of itself and of @var{i1}.

@node IntervalList public members, IntervalList iterators, class Interval, class IntervalList
@subsection IntervalList public members

@example
IntervalList();
@end example

The default constructor produces the empty IntervalList.

@example
IntervalList(unsigned @var{origin},unsigned @var{length});
@end example

This constructor creates an IntervalList containing @var{length}
integers starting with @var{origin}.

@example
IntervalList(const char* @var{definition});
@end example

This constructor takes a definition of the IntervalList from the
string in @var{definition}, parses it, and creates the list of
intervals accordingly.

There is also a copy constructor, an assignment operator, and a
destructor.

@example
int contains(const Interval& @var{i1}) const;
@end example

The @code{contains} method returns 0 if no part of @var{i1} is in the
IntervalList, 1 if @var{i1} is completely contained in the IntervalList,
and -1 if @var{i1} is partially contained (has a non-null intersection).

@example
IntervalList& operator|=(const Interval& @var{src});
IntervalList& operator|=(const IntervalList& @var{src});
@end example

The @code{|=} operators sets the IntervalList to the union of itself and
the Interval, or the IntervalList, @var{src}.

@example
IntervalList operator&(const IntervalList& @var{arg}) const;
@end example

The binary @code{&} operator returns the intersection of its arguments,
which are not changed.

@example
IntervalList& subtract(const Interval& @var{i1});
IntervalList& operator-=(const Interval& @var{i1});
@end example

Subtract the Interval @var{i1} from the list.  That is, any intersection
is removed from the set.  Both the @code{subtract} and @code{-=} forms
are equivalent.

@example
IntervalList& operator-=(const IntervalList &@var{arg});
@end example

This one subtracts the argument @var{arg} from the list (removes any
intersection).

@example
int empty() const;
@end example

Return TRUE (1) for an empty IntervalList, otherwise FALSE (0).

@node IntervalList iterators,  , IntervalList public members, class IntervalList
@subsection IntervalList iterator classes.

There are two iterator classes associated with IntervalList,
IntervalListIter and CIntervalListIter.  The only difference is that
the latter iterator can be used with const IntervalList objects and
returns pointers to const Interval objects; the former requires a
non-const IntervalIList and returns pointers to Interval.

These objects obey the standard iterator interface; the @code{next()}
or @code{++} function returns a pointer to the next contained Interval;
@code{reset} goes back to the beginning.

@node Clock and TimeVal,  , class IntervalList, Misc
@section Classes for interacting with the system clock

These classes provide simple means of interacting with the operating
system's clock -- sleeping until a specified time, timing events, etc.
They may be replaced with something more general.

class TimeVal represents a time interval to microsecond precision.
There are three constructors:

@example
TimeVal();
TimeVal(long @var{sec}, long @var{usec});
TimeVal(double @var{length});
@end example

The first represents a time interval of zero.  The second represents a
time interval with the specified number of seconds and microseconds.
In the third case, the @var{length} argument is rounded to the nearest
multiple of one millionth.

These classes rely on features found in BSD-based Unix systems and newer
System V Unix systems.  Older System V systems tend not to provide the
ability to sleep for a time specified more accurately than a second.

@example
operator double() const;
@end example

This returns the interval value as a double.

@example
TimeVal operator +(const TimeVal& @var{arg}) const;
TimeVal operator -(const TimeVal& @var{arg}) const;
TimeVal& operator +=(const TimeVal& @var{arg});
TimeVal& operator -=(const TimeVal& @var{arg});
@end example

These operators do simple addition and subtraction of TimeVals.

class Clock provides a simple interface to the system clock for
measurement of actual elapsed time.  It has an internal TimeVal
field that represents the starting time of a time interval.

@example
Clock();
@end example

The constructor creates a Clock with starting time equal to the
time at which the constructor is executed.

@example
void reset();
@end example

This method resets the start time to ``now''.

@example
TimeVal elapsedTime() const;
@end example

This method returns the elapsed time since the last @code{reset} or
the call to the constructor.

@example
int sleepUntil(const TimeVal& @var{howLong}) const;
@end example

This method causes the process to sleep until @var{howLong} after the
start time.

@contents
@bye
