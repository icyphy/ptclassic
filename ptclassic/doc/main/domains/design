.\" $Id$
.H1 "Domain Design\**
.pp
.(f
\**This section can be skipped for those who are not interested in
the domain design.  A knowledgeable reader will obtain the useful
information to build his own domain from this section and from
the documentation of any existing domain as a reference.
.)f
.IE "domain, creation"
Data abstraction and polymorphism, two tenets of object-oriented
programming, allow domains (models of computation) to be abstracted
so that their differences are not visible from the kernel.
By combining the domains of interest to the kernel, we can
tune the system to a particular application.  For example,
if we are interested in the network simulation, we can
add only the DE and the SDF domains to the kernel, 
excluding THOR or Capsim domains.
This modularized design of the domains provides the
extreme flexibility of \*(PT.
For the abstraction of the domains, each domain should be built on
the same basic structure, which will be discussed in this section.
.pp
A domain has a specific operational semantics for a block diagram
representation.  The operational semantics is realized by a
.c Scheduler
for the domain.  The 
.c Scheduler
determines how to and when to fire the blocks in the domain.
The main function of a
.c Scheduler
is to perform the compile-time and the runtime scheduling.
For that purpose, the
.c Scheduler\ class
provides two methods : \fIsetup()\fR (for compile-time scheduling),
\fIrun()\fR (for runtime scheduling).
It also provides two different methods to specify the stopping condition for
the domain.  If the domain is that of a
.c Universe ,
we call the \fIsetStopTime()\fR method.  If the domain resides in a
.c Wormhole ,
we call the \fIresetStopTime()\fR method, instead.
.pp
It may be also necessary to define domain specific
.c Star\ class 
and
.c PortHole\ class .
For example, the 
.c Star s
and the
.c PortHole s
in the DE domain need to keep the timing information while those
in the SDF domain need not.
They may also have some properties accessed by the 
.c Scheduler
in the domain.  The \fIrepetitions\fR in the 
.c SDFStar\ class
is an example.  The \fIrepetitions\fR of a 
.c Star
indicates how many times the
.c Star
will be executed in one iteration.  It is necessary only for the
.c Scheduler
in the SDF domain during the compile-time scheduling.
Thus, the design of the generic
.c Star\ class 
and 
.c PortHole\ class
is closely related to the design of the
.c Scheduler
in the domain.
.pp
The next step is to design 
.c EventHorizon s.
To be a domain in \*(PT, it can be coexistent with other domains.
The
.c Wormhole\ class
and the
.c EventHorizon\ class
are two basic tools for domain interface in \*(PT.
It is worth noting that a domain may do without the
.c Wormhole\ class
in the domain if the domain won't contain other domains inside.
However, the
.c EventHorizon\ class
is still necessary for the domain to be an inner domain of a
.c Wormhole .
We have to define a pair of
.c EventHorizon s
for the new domain :
.c (domain-name)toUniversal
and
.c (domain-name)fromUniversal .
Each
.c EventHorizon
can be placed in the input or output port of a
.c Wormhole
depending on whether the domain is the inner domain of the
.c Wormhole
or the outer.
Look at the section three for details on
.c EventHorizon\ class .
.pp
If a domain is to contain other domains, the domain must have
.c Wormhole\ class .
The domain-specific 
.c Wormhole\ class
is necessary to disguise the
.c Wormhole
indistinguishable from other
.c Star s
in the outer domain.  The role of 
.c Wormhole s
is already discussed in the earlier part of this document.
.pp
There are two additional classes to be defined in a domain.
One is the
.c Universe\ class ,
and the other is the
.c Domain\ class .
Their definitions are straightforward but very essential for
domain abstraction in the kernel.  Refer to the source code
for those classes for details (the code is self-explanatory).
With those classes, the creation of a new domain is completed.
