.\" $Id$
.H1 "Domain Design\**
.pp
.(f
\**This section can be skipped for those who are not interested in
the domain design.  A knowledgeable reader will obtain the useful
information to build his own domain from this section and from
the documentation of any existing domain as a reference.
.)f
Data abstraction and polymorphism, two tenets of object-oriented
programming, allow domains (models of computation) to be abstracted
so that their differences are not visible from the kernel.
By combining the domains of interest to the kernel, we can
tune the system to a particular application.  For example,
if we are interested in the network simulation, we can
add only the DE and the SDF domains to the kernel, 
excluding THOR or Capsim domains.
This modularized design of the domains provides the
extreme flexibility of \*(PT.
For the abstraction of the domains, each domain should be built on
the same basic structure, which will be discussed in this section.
.pp
A domain has a specific operational semantics for a block diagram
representation.  The operational semantics is realized by a
.c Scheduler
for the domain.  The 
.c Scheduler
determines how to and when to fire the blocks in the domain.
The main function of a
.c Scheduler
is to perform the compile-time and the runtime scheduling.
For that purpose, the
.c Scheduler\ class
provides two methods : \fIsetup()\fR (for compile-time scheduling),
\fIrun()\fR (for runtime scheduling).
.pp
It may be also necessary to define domain specific
.c Star\ class 
and
.c PortHole\ class .
For example, the 
.c Star s
and the
.c PortHole s
in the DE domain need to keep the timing information while those
in the SDF domain need not.
They may also have some properties accessed by the 
.c Scheduler
in the domain.  The \fIrepetitions\fR in the 
.c SDFStar\ class
is an example.  The \fIrepetitions\fR of a 
.c Star
indicates how many times the
.c Star
will be executed in one iteration.  It is necessary only for the
.c Scheduler
in the SDF domain during the compile-time scheduling.
Thus, the design of the generic
.c Star\ class 
and 
.c PortHole\ class
is closely related to the design of the
.c Scheduler
in the domain.
.pp
The next step is to design 
.c EventHorizon s.
To be a domain in \*(PT, it can be coexistent with other domains.
The
.c Wormhole\ class
and the
.c EventHorizon\ class
are two basic tools for domain interface in \*(PT.
It is worth noting that a domain may do without the
.c Wormhole\ class
in the domain if the domain won't contain other domains inside and
only be contained in them instead.
However, the
.c EventHorizon\ class
is still necessary for the domain to be an inner domain of a
.c Wormhole .
In the kernel, the
.c EventHorizon\ class
has a couple of derived class. One is the
.c ToEventHorizon\ class
and the other is the
.c FromEventHorizon\ class .
The
.c ToEventHorizon\ class 
is the base class of all
.c (domain-name)toUniversal s
while the
.c FromEventHorizon\ class
is the base class of all
.c (domain-name)fromUniversal s.
Therefore, we have to define a pair of
.c EventHorizon s
for the new domain :
.c (domain-name)toUniversal
and
.c (domain-name)fromUniversal .
Each
.c EventHorizon
can be placed in the input or output port of a
.c Wormhole
depending on whether the domain is the inner domain of the
.c Wormhole
or the outer.
.pp
As discussed earlier in this document, the main function of
the
.c EventHorizon\ class
is to transfer data packets and do timing management between two domains.  
The
.c (domain-name)toUniversal
should define two basic methods : \fIgrabData()\fR, and \fIgetNextStamp()\fR.
The \fIgrabData()\fR is in charge of data movement and
synchronization  of two domains.  It may set the flag,
\fIoutputBeforeDeadlocked\fR if the domain is inside the
.c Wormhole
and timed.  At the end of the execution of the inner domain,
the \fIoutputBeforeDeadlocked\fR is set TRUE if the inner
domain still has some runnable
.c Star s
(when the 
.c Scheduler
is blocked by stopping condition before the system is deadlocked).
The \fIgetNextStamp()\fR provides the stopping condition for the
inner timed domain.
The
.c (domain-name)fromUniversal
should define again two basic methods : \fIsendData()\fR, and \fIready()\fR.
The role of \fIsendData()\fR is similar to that of \fIgrabData()\fR.
We may need some domain-specific features for the method.
If the domain is the outer domain of a
.c Wormhole
and timed, we check the flag, \fIoutputBeforeDeadlocked\fR, of the
counterpart
.c (domain-name)toUniversal .
If the flag is set TRUE, we have to regard the
.c Wormhole
as a process star in the outer domain.
The ready() method provides a way to synchronize all input ports of a
.c Wormhole .
The more important role of this method is to define the stopping
condition of the inner domain of a 
.c Wormhole .
If the inner domain is timed, it uses the \fIgetNextStamp()\fR
method of its counterpart.
Besides those basic methods, each
.c EventHorizon\ class
can provides other methods and properties if necessary.
.pp
If a domain is to contain other domains, the domain must have
.c Wormhole\ class .
The domain-specific 
.c Wormhole\ class
is necessary to disguise the
.c Wormhole
indistinguishable from other
.c Star s
in the outer domain.  The role of 
.c Wormhole s
is already discussed in the earlier part of this document.
.pp
There are two additional classes to be defined in a domain.
One is the
.c Universe\ class ,
and the other is the
.c Domain\ class .
Their definitions are straightforward but very essential for
domain abstraction in the kernel.  Refer to the source code
for those classes for details (the code is self-explanatory).
With those classes, the creation of a new domain is completed.
