.\" $Id$
.H1 "EventHorizons
.pp
.IE "EventHorizon"
.IE "EventHorizon, design"
Like a 
.c Star, a
.c Wormhole
may have input and output
.c PortHole s.
The
.c PortHole s
of the
.c Wormhole
are called
.c EventHorizon s,
which are derived from 
.c class\ PortHole .
Precisely speaking, one
.c PortHole
of a
.c Wormhole
consists of a pair of
.c EventHorizon s
: one corresponds to the outer domain, and the other corresponds to
the inner domain.  For example, suppose a SDF domain has a 
.c Wormhole
.c (SDF\ Wormhole)
which contains a DE domain.
Then, an input port of the
.c Wormhole
comprises a
.c SDFtoUniversal\ EventHorizon
and a
.c DEfromUniversal\ EventHorizon .
The former
.c EventHorizon
is connected to the outer domain (to some
.c SDFStar )
and the latter is connected to the inner domain (to some
.c DEStar ).
Similarly, an output port of the
.c Wormhole
comprises a
.c DEtoUniversal\ EventHorizon
for inner connection and a 
.c SDFfromUniversal\ EventHorizon
for outer connection.
In general, each domain has a pair of derived
.c EventHorizon
classes :
.c (domain-name)toUniversal
and
.c (domain-name)fromUniversal .
The
.c (domain-name)toUniversal\ class
receives data packets from its domain and transfers them to the
counterpart.
The
.c (domain-name)fromUniversal\ class
receives data packets from the counterpart and transfers them to its domain.
Thus, the data transfer between two domains is the basic functionality
of the 
.c EventHorizon s.
.pp
It is worth pointing out that data-format conversion is not a task
.IE "data-format conversion"
of 
.c EventHorizon s
, opposed to what seems to be.
By the virtue of C++ as an object oriented language,
data-format conversion takes place whenever necessary 
by overloaded operator.  In other words, conversion between 
.c int\ Particle
and a special type 
.c Particle
is automatically performed by defining the
appropriate assignment operator in the definition of the special type 
.c Particle
,to and from the 
.c int
.c Particle .
Also, some
.c Star s
can be defined to perform data-conversion functions. 
.pp
If data transfer is the sole purpose of the
.c EventHorizon s,
we may have only one
.c EventHorizon\ class .
Unfortunately, there are some domain-specific operations we need to
do in the
.c EventHorizon s
for domain interface.  There are two alternatives to
perform the domain-specific operations.  First, We may optimize each domain
interface by defining a 
.c EventHorizon
class for each pair of domain.  This approach is not feasible
for the highly modularized and easily expandable design like \*(PT.
If we have $N$ domains, we need to define $N sup 2$ 
.c EventHorizon s.
To make matters worse, if a user wants to add a new domain into \*(PT,
he should know the details of the existing domains to design the
.c EventHorizon s.
Therefore, we choose the second approach where a domain interface
has a pair of
.c EventHorizon s,
one for each domain.  Now, we have only $2N$
.c EventHorizon s
for $N$ domains, and each domain is totally independent of each other.
Among domain-specific operations, timing-management is most
complicated, which will be discussed in the next section.
.pp
One example of domain-specific operation can be found in
.c DEfromUniversal\ class .
The class should not only receives the data packets from the
counterpart but also put them into the global event queue in the
DE domain (refer to the \fBDE Domain\fR chapter in the \fBAlmagest\fR).
Another example is the \fIready()\fR method in the
.c FromEventHorizon\ class .
This method is to check whether the port is ready for the inner domain
to be fired.  For the SDF domain, it returns \fBTRUE\fR only when
it has sufficient data.  Suppose that
the inner domain is SDF and the outer
domain is DE, the inner domain may not be executed until
all input ports of the
.c DEWormhole
have enough data packets. For that purpose, the \fIgo()\fR method
of the
.c Wormhole
checks up all 
.c FromEventHorizon s
(\fIready()\fR method) of the input ports whether they are ready.
For other domains, the \fIready()\fR method can be redefined for
more elaborate synchronization. 
