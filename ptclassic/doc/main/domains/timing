.\" $Id$
.H1 "Timing Relation Between Domains
.pp
\*(PT can support an effectively unlimited number of different
domains since adding a new domain affects neither any existing
implementation of other domains nor the kernel.
The domain interface should take care of timing relations between
the outer and  the inner domains. Timing management is the most 
.IE "timing management"
challenging task in the design of
.c Wormhole s
and their interconnection mechanism.  Our approach is to
classify the domains into two groups: \fItimed\fR, and
\fIuntimed\fR.  In a \fItimed\fR domain, the scheduler
.IE "timed domain"
.IE "untimed domain"
keeps track of the global timing relations among data packets
.c (Particles).
On the other hand, an \fIuntimed\fR domain
requires only the local ordering information of data packets.
The taxonomy of existing domains is:
.sp
.nf
\fItimed\fR : DE, THOR, etc
\fIuntimed\fR : SDF, DDF, CAPSIM, MQ, etc
.fi
.sp
.pp
The scheduler
of a domain maintains a member called \fIcurrentTime\fR for timing
.IE "currentTime"
management.  For a timed domain, \fIcurrentTime\fR indicates the
global time.  As the scheduler proceeds, \fIcurrentTime\fR also
.IE "global time"
increases.  Hence, the stopping condition for a timed domain is
usually given by a stopping time.  On the other hand, an untimed domain
does not have the concept of time.  If an untimed domain resides in a
.c Wormhole ,
then the \fIcurrentTime\fR of the domain is simply the copy of the
\fIcurrentTime\fR of the outer domain.
.pp
There are four combinations of timed and untimed domains.  For each
combination, we will show how to do timing management.
.H2 "An Untimed Domain in an Untimed Domain"
.pp
This first combination is the simplest for timing management: 
an untimed domain contains another untimed domain.
For example, a DDF domain may contain an SDF domain.
Since the outer domain does not care about the \fIcurrentTime\fR 
of the inner domain,
we are free to manage the \fIcurrentTime\fR of the inner domain.
In this case, the \fIcurrentTime\fR of the inner domain is just
copied from that of the outer domain.
During the execution of the
wormhole, the \fIcurrentTime\fR remains unchanged.  
The stopping condition of the inner domain is given by the number of
iterations of the schedule.  
The \fIresetStopTime()\fR method of the scheduler sets the
stopping condition to "one iteration", ignoring the argument to
the method.
The meaning of "one iteration" is domain specific.
.IE "iteration, scheduling"
Refer to the individual domain 
documentation (e.g. \fBSDF Domain, DDF Domain\fR, etc) for their
interpretation of "one iteration".
.H2 "An Untimed Domain in a Timed Domain
.pp
The second possibility is that a timed domain contains an untimed domain.
If a DE domain contains an SDF domain, it falls into this category.
In this case, the \fIcurrentTime\fR of the inner untimed domain
is synchronized with the \fIcurrentTime\fR of the outer timed domain
at the beginning of the
execution of the wormhole.
Like the first case, the \fIcurrentTime\fR
of the inner domain is not increased during the execution.
It gives an illusion to the outer domain that the untimed domain takes
zero time for execution.  Since the inner domain has no notion of
time, it seems not only awkward but infeasible to assign any 
execution delay to the inner domain.  Instead, we can simulate
the execution delay of the inner domain by attaching a
.c Delay
star in the outer domain to the inputs and outputs of the wormhole.
The decoupling of the delay and the functionality of a 
block in a timed domain
is the basic technique we use in a timed domain like DE.
The stopping condition of the inner domain is again "one iteration".
.H2 "A Timed Domain in a Timed Domain
.pp
This third combination is the most complicated: a timed domain contains
another timed domain.  It is complicated because timed domains
have a notion of chronology, but the principle of wormholes
implies that the chronology of one domain cannot be visible from another.
A DE domain containing a THOR domain will be
an example.  First of all, since both domains have their global clocks, 
we have to synchronize both domains.  Therefore, the inner domain
has a 
.c State 
called \fItimeScale\fR which is the ratio between the time unit of
.IE "timeScale"
inner domain and that of the outer domain.  If the state is undefined,
the \fItimeScale\fR is $1.0$ by default (no scaling).  
At the beginning of the execution of the 
wormhole,
the \fIcurrentTime\fR of the outer domain is scaled by the \fItimeScale\fR
and copied to the \fIcurrentTime\fR of the
inner domain.  The \fIcurrentTime\fR of the inner domain
proceeds as the wormhole
is executed until the stopping condition is met.  After the execution 
finishes, the \fIcurrentTime\fR of the inner domain is scaled
by the inverse of the \fItimeScale\fR and assigned to the output data
packets.
A user can change the value of the
scale factor by defining a 
.c FloatState
(\fItimeScale\fR) in the outermost galaxy of the inner timed domain.
In the interpreter, the following line does it:
.(c
(state timeScale float "10.0")
.)c
.pp
The decision about the stopping condition of the inner domain is the most
complex part of the domain interface.  Suppose that the
wormhole
has two inputs ($input sub 1$, $input sub 2$) and two outputs
($output sub 1$, $output sub 2$).  If $input sub 1$ receives an
event
.c (Particle),
the wormhole
starts execution.  The complication arises from the observation
that this wormhole cannot safely process internal events
with later time stamps than the event on $input sub 1$.
It may later receive an event on $input sub 2$ that invalidates
these computations.
For example, if 
$input sub 2$ is a reset input of a system, the reset event will
affect the previous execution if it is not completed.
Therefore, we can process the inner system at a given event
only until the time stamp of the next event to arrive at any input.  
Unfortunately it is generally
not possible to predict when the next event will arrive.
One possible solution is to process the
wormhole
for one time unit at each invocation.  In case of THOR domain, one
time unit is well defined so that this approach is acceptable.
However, there is no notion of a basic time unit in the DE domain.
Also, the approach is too conservative and will result in a lot of overhead.
Even though there will be no event during the next $100$ time units,
the 
wormhole
would be invoked $100$ times to march one time unit
at each invocation.  
.pp
Another approach is to process the 
wormhole
until the next earliest event in the outer domain. 
When the
wormhole
is to be executed, we check the \fIexpected\fR next global time by examining
the next earliest event in the outer domain.  The stopping condition
of the inner timed domain is set with the stop time equal to the
expected next global time.  As long as the
wormhole
does not generate any event during execution, the expected next global
time becomes the \fIactual\fR next global time.  If the inner domain generates
any output events, however, 
they will be the next earliest events
in the outer domain.
.pp
There is a pathological example which
invalidates this approach.
Suppose that the inner domain generates output events through
$output sub 1$ earlier than through $output sub 2$.  Moreover, the
output event through $output sub 1$ is routed back to $input sub 2$ of the
.c Wormhole .
Then, we meet the original problem if this feedback event should have
affected the
output event through $output sub 2$ of the previous execution.
Since the output event through $output sub 2$ is already produced in the
previous execution, there is no way to correct the event.
.pp
We can improve the previous approach as follows. 
Suppose that we have exactly one timed 
.c Wormhole .
At the beginning of the execution,
we set the stop time of the
.c Wormhole
with the expected next global time.  We proceed the inner
scheduling
until the \fIcurrentTime\fR reaches the stop time, or until
the inner domain generates any output.
If the wormhole
generates an output, the output becomes the next earliest event
in the outer domain.  Therefore, our scheme is nothing but to
process the
wormhole
until the actual (not expected) next global time in the outer domain.
This proves the correctness of our solution.
But, if there are more than one, say two, timed
wormholes,
this approach also fails to work.  We have to compare the
time stamps of the output events from the
wormholes to detect the actual next global time. 
While we are executing a 
wormhole,
it is not possible to determine the actual next global
time since it is unknown before executing the other
wormhole.
.pp
Finally, we have developed the following solution.  At the beginning of
the execution, we set the stop time of the
wormhole
to the current global time of the outer domain.
This forces the inner domain to be scheduled
only until the current global time.
The wormhole
acts exactly like a functional star without delay.
According to the scheme, the
wormhole
may finish the execution even before the current event is completely
processed (the domain is not deadlocked).  
Then, the wormhole
should be invoked again to finish the previous execution. 
The trick is to decide when we invoke the wormhole again,
since it may not receive any further events.
At the end of the execution of the
wormhole,
we determine the next event time of the inner domain and copy it to
\fIcurrentTime\fR of the inner scheduler.
We also set a flag, \fIstopBeforeDeadlocked\fR, if the inner domain
is not deadlocked.
Then, the outer 
.c Scheduler
checks the flag and invokes the wormhole
at the next event time of the inner domain, or at the arrival time
of a new event to the wormhole.
Even though a new event arrives before the next event time of the inner
domain, the inner scheduler
can process the incoming event without hazards since
the actual current time of the inner domain is less than the arrival time
of the new event.  When the outer global clock indicates the
next event time of the inner domain, the 
wormhole is executed again at the current global time, and
the operation is repeated.
.pp
In this approach, the inner domain can never overtake the the
outer domain in time, which proves the correctness of the approach
regardless of the number of timed
wormholes involved.  The timed
wormhole forms a special class of
stars in a timed domain, called "process-star".  The first invocation
.IE "process-star"
of a process-star is triggered by external events to the star.
But the further invocations are triggered
without external events until the
star has no more internal events to process.
.H2 "A Timed Domain in an Untimed Domain
.pp
The last possible combination is that of a timed domain in an
untimed domain.  Even though the untimed domain has no notion of
time, it needs to control the inner timed domain by setting the
stopping condition.  For that purpose, an untimed domain
keeps a property called its \fIschedulePeriod\fR.  
.IE "schedulePeriod"
The \fIcurrentTime\fR of the untimed domain is increased by the
\fIschedulePeriod\fR after each iteration.
A user can control the value of the \fIschedulePeriod\fR by defining a 
.c FloatState
(\fIschedulePeriod\fR) in the outermost galaxy of the untimed domain.
In the interpreter command, the following line is enough:
.(c
(state schedulePeriod float "10.0")
.)c
If the state is not defined, the \fIschedulePeriod\fR of the untimed
domain is set to a large number ($10000$) by default.
Presumably, the \fIschedulePeriod\fR has no physical significance
since in the untimed domain, time has no meaning.  The sole
purpose of the state is to define the stopping condition of the
timed domain.  A user should make sure that the 
wormhole does all necessary tasks before it reaches the stopping condition.
The common approach is to set the stop time large enough so that
the timed domain is deadlocked (meaning that there are no
active events in the timed system) before the stop time.  Then, the
timed domain acts as a functional block like a conventional 
star in the untimed domain.  Note that in this case, the inner timed
domain need not stop after it generates its first output event, unlike the
third case above.
.pp
There is a special case where the above discussion is not
applicable.  Suppose that the untimed 
universe is an SDF domain.
We can interpret the SDF domain as a time driven domain where
.IE "time driven"
the time interval between data packets is fixed, and hidden safely
in the system representation.  A synchronous digital
signal processing system falls into this category.
In this case, the SDF domain looks like a timed domain!.  The
\fIschedulePeriod\fR has its physical significance.
Hence, the user has to supply a meaningful value.
The \fIschedulePeriod\fR of the SDF system represents the repetition
period of the SDF schedule, and during one iteration, there may
arrive more than one data packet at the
wormhole.
The time-interval of the data packets becomes the ratio of the
\fIschedulePeriod\fR and the number of arrived data packets during one
iteration.  It is this time-interval and not the \fIschedulePeriod\fR
that determines the stop time of the inner timed domain.
This combination of a SDF domain and a timed domain has 
abundant applications.
.H2 "Summary
.pp
We have discussed four combinations of the domains.
If a wormhole contains another wormhole,
we can apply the basic rule developed in this section
to each domain interface.  For example, a timed domain
contains a wormhole of an untimed domain which itself contains a timed
wormhole.
Since the timed domain inside an untimed domain loses the physical
meaning of times, the innermost timed domain has nothing to do with
the outer timed domain in timing management.  Still the untimed
domain takes zero time in the sense of the outer global clock.
An exceptional case is when
the untimed domain is the SDF domain for time-driven application
(e.g. DSP application).  By controlling the \fIschedulePeriod\fR
of the SDF domain, we can synchronize the innermost timed
domain and the outer timed domain.
