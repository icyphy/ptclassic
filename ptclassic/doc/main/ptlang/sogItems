.\" $Id$
.H1 "Items that may appear in both defstar and defgalaxy"
.pp
This section lists the
.i sgitems .
.UH name
.pp
This is a required item, and has the syntax
.sp
.c name " {"
.i identifier " }"
.sp
It provides the name of the class to be defined, and (together with
the domain) determines
the names of the output files.
.UH descriptor
.pp
This item defines the descriptor for the class.  It has the syntax
.sp
.c descriptor " {"
.i desclist " }"
.sp
or
.c desc " {"
.i desclist " }"
.sp
where
.i desclist
is either a C++ character string, or a series of C++ character strings
separated by whitespace.  If multiple strings are given, they are effectively
concatenated into one string.  Note that if you want line breaks in
the descriptor when it is printed, you must include \\n characters
inside the string(s).
.UH constructor
.pp
This item allows the user to specify extra C++ code to be executed in
the constructor for the class.  This code appears
.i after
any automatically generated code to initialize portholes, states, etc.
Syntax:
.sp
.c constructor
.i body
.sp
where
.i body
is a piece of C++ code surrounded by curly braces.  Note that actions
that must be performed before every simulation run should appear in the
start method, not the constructor.
.UH conscalls
.pp
You may want to have members in your star or galaxy that have constructors
that require arguments (these members would be added with the
.c public ,
.c private ,
or
.c protected
keyword).  If you have such members, the
.c conscalls
keyword provides a mechanism for passing arguments to the constructors.
Simply list the names of the members followed by the list of constructor
arguments for each, separated by commas if there is more than one.
Syntax:
.sp
.c conscalls
{
.i member1(arglist) ,
.i member2(arglist) " }"
.UH destructor
.pp
This item defines a destructor.  Syntax:
.sp
.c destructor
.i body
.lp
You generally need a destructor only if you allocate memory in the
constructor; termination functions that happen with every run should
appear in the
.c wrapup
function.
.UH start
.pp
This item defines the
.c start()
method, which is called every time the simulation is restarted.  Syntax:
.sp
.c start
.i body
.UH wrapup
This item defines the
.c wrapup()
method, which is called at the completion of a simulation.  Syntax:
.sp
.c wrapup
.i body
.UH "public, protected, private"
.pp
These three keywords allow the user to declare extra members for the
class with the desired protection.  Syntax:
.sp
.i "protkey body"
.sp
where
.i protkey
is
.c public ,
.c protected ,
or
.c private .
Example, from the Xgraph star:
.(c
protected {
        FILE *strm;
        int delFile;
        int index;
        const char* fileName;
}
.)c
If any of the added members require arguments for their constructors,
use the
.c conscalls
item to specify them.
.UH "ccinclude, hinclude"
.pp
These directives cause the
.c .cc
file, or the
.c .h
file, to
.c #include
extra files.  By default, the
.c .cc
file includes
.c KnownBlock.h
and the generated
.c .h
file; the
.c .h
file will (for stars) include
.c \fIXXX\fPStar.h ,
where
.i XXX
is the domain name, or (for galaxies)
.c Galaxy.h ,
as well as the files for any states that are defined, and if
a
.c derived
section is found, the name of the baseclass as well.  Syntax:
.sp
.c ccinclude
{
.i inclist
} or
.sp
.c hinclude
{
.i inclist
}
.sp
where
.i inclist
is a comma-separated list of include files.  Each filename must
be surrounded either by quotes or by "<" and ">" (for system include
files like
.c <math.h> ).
.UH code
.pp
This keyword allows the user to specify a chunk of arbitrary C++ code.
This code is inserted into the
.c .cc
file after the include files but before everything else; it can be
used to define static non-class functions, declare external variables,
or anything else.  The outermost pair of curly braces is stripped.
Syntax:
.sp
.c code
.i body
.UH defstate
.pp
This item is used to define a state; it has other items inside it.
Here is an example of a state definition:
.(c
defstate {
        name { gain }
        type { int }
        default { "1.0" }
        desc { "output gain" }
}
.)c
There are five types of sub-items that may appear in a defstate
statement, in any order.  The
.c name
field is the name of the state; the
.c type
field is its type, which may be one of
.c int ,
.c float ,
.c string ,
.c complex ,
.c intarray ,
.c floatarray ,
or
.c complexarray .
Case is ignored for the type argument.
.pp
.c default
specifies the default value of the state; its argument is either
a string or a numeric value.
.c desc
(or
.c descriptor ),
which is optional, gives a descriptor to the state.
.pp
Finally, the
.c attributes
keyword specifies state attributes.  At present, two attributes
are defined: A_CONSTANT and A_SETTABLE (along with their complements
A_NONCONSTANT and A_NONSETTABLE).  If a state has the A_CONSTANT attribute,
then its value is not modified by the run-time code in the star (it is
up to you as the star writer to ensure that this condition is satisfied).
States with the A_NONCONSTANT attribute may change when the star is run.
If a state has the A_SETTABLE attribute, then user interfaces (such as
.i pigi )
will prompt the user for values when directives such as
.i edit-parameters
are given.  States without this attribute are not presented to the user;
such states always start with their default values as the initial value.
If no attributes are specified, the default is A_CONSTANT|A_SETTABLE.
If you specify attributes, you
.i must
specify the state of both bits: for example, A_NONCONSTANT|A_SETTABLE.
.pp
Attributes are ignored for galaxy states.
.UH method
.pp
The
.c method
item provides a fully general way to specify an additional method
for the class of star or galaxy that is being defined.  Here is an
example:
.(c
method {
	name { exec }
	access { protected }
	arglist { "(const char* extraOpts)" }
	type { void }
	code {
		// code for the SDFXgraph::exec method goes here
	}
}
.)c
Here are the
.c method
subitems:
.ip name
The name of the method.  This is a required item.
.ip access
The level of access for the method, one of
.c public ,
.c protected ,
or
.c private .
If the item is omitted,
.c protected
is assumed.
.ip arglist
The argument list for the method, as a quoted string.  If omitted,
the method has no arguments.
.ip type
The return type of the method.  If the return type is not a single
identifier, you must put quotes around it.
.ip code
The code that implements the method.  This is a required item.
