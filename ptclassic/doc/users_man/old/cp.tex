\newcommand{\CP}{\PTOLEMY/src/domains/cp}
\newcommand{\IP}{\CP/infopad}

\node CP Domain
\chapter{CP Domain}
\Author{Seungjun Lee}
\cindex{Lee, S.}
\Contrib{Thomas M. Parks}
\cindex{Parks, T.}

\date{$Date$}

The Communicating Processes (CP) domain
\cindex{Communicating processes domain}
\cindex{CP domain}
in Ptolemy is a
process-oriented domain.  The model of computation is an extension of
\emph{Communicating Sequential Processes(CSP)} proposed by Hoare
[\ref{Hoare78}].  In the CP domain, a system is modeled as a set of
processes that execute concurrently and interact with each other by
message-passing.  Blocks represent autonomous processes.  Each block is
converted into an independent process once the simulation begins, and
the process keeps running until the end of simulation.  The CP domain
is timed, i.e. it has the notion of time.
\cindex{timed domain}
The scheduler maintains the global clock and manages the execution of
blocks to be synchronized with the clock.

The major application of the CP domain is system modeling
\cindex{system modeling} at an early
design stage where the system is partitioned into large subblocks with
complex behavior.  Consequently, a CP block tends to show very
complicated and application-specific behavior, and a user is expected
to write his own models for his application except for the signal
sources and monitoring blocks, which are  provided in the library.
Many useful constructs are provided to ease the task of describing the
complex behavior of big blocks.

\node The CP Scheduler
\section{The Scheduler}

\cindex{CP scheduler}
The ordinary role of the scheduler in Ptolemy is to determine the order
of execution of each block.  But in the CP domain all the blocks are
presumably running all the time so that there is no need of scheduling
in that sense.  The task of the CP scheduler, instead, is to synchronize
the execution of concurrent processes
\cindex{concurrent processes} while they compete with each
other for the CPU.  It keeps the global clock and waiting list of
suspended processes, and manages all the processes to proceed in
lock-step fashion.

\node Process Scheduling
\subsection{Process Scheduling}

Process scheduling \cindex{process scheduling}
in the CP domain is based on priority and is
preemptive.   The scheduler is just another process with higher
priority than blocks.  When the simulation starts, the scheduler
converts each block into a process.  All the processes are created with
the same priority.  After that, the scheduler voluntarily relinquishes
the CPU and goes to sleep.

The blocks execute one at a time until the execution is either blocked
or suspended.  While blocks are executing, the scheduler sleeps and the
global clock doesn't advance.  Hence, all the execution of blocks is
considered to happen instantaneously.  \cindex{instantaneous execution}
A block must be explicitly suspended in order to model execution delay
and to allow the global clock to advance.
When there are no more runnable processes, the scheduler wakes up and
regains the CPU.  It fetches the
next earliest suspended process from the waiting list and advances the
global clock.  If the global clock is past the end time, the scheduler
returns and the simulation ends.  Otherwise, the scheduler resumes all
the suspended processes scheduled at that time slot and goes back to
sleep.

\node Simultaneous Events and Non-Determinism
\subsection{Simultaneous Events and Non-Determinism}

Handling simultaneous events \cindex{simultaneous events}
in a consistent and predictable way is not
an easy task for event-driven simulation.
\cindex{event-driven simulation} When there are simultaneous
events, they have to be handled sequentially in a uni-processor
environment.  The result may show non-deterministic behavior depending
\cindex{non-deterministic behavior}
on the order they are processed.  The problem stems from the existence
of zero-delay blocks.  This problem has been thought out in the
implementation of DE scheduler (see chapter\tie\ref{DE Domain}),
\cindex{DE scheduler}
\cindex{DE domain}
\cindex{Discrete event domain}
and many schemes have been devised to
help a user avoid unexpected behavior.

The CP domain provides no special scheme to handle simultaneous events
because zero delay blocks would be very rare in this domain.  But the
existence of zero-delay blocks is not completely ruled out, which may
result in non-deterministic behavior of the system.   A zero-delay
path from an input to an output within a block is equally dangerous.

\node Inter-Process Communication
\section{Inter-Process Communication}

Blocks communicate with each other by passing messages through
portholes.  \cindex{message passing}
Each block may have several input and output portholes.  A
channel connects an output porthole to an input porthole.  Only
one-to-one connections are allowed.  That implies \emph{auto-forking}
\cindex{auto-forking}
is not supported in this domain.

\node Communication Channels
\subsection{Communication Channels}

Channels can be either buffered or unbuffered.  A buffered channel
is implemented as a FIFO queue and the capacity of the queue can be
either finite or infinite.  The default action of connecting an output
porthole to an input porthole is to create an unbuffered channel, and
the communication through that connection becomes synchronous.  

\begin{ignore}
Two types of queue object are available in the library to implement
buffered channel.  One is a simple FIFO queue and the other is a FIFO
queue with a monitor.  The monitor records the variation of the queue
size versus time, and shows it in an \code{Xgraph} when the simulation
is finished.  The maximum capacity of the queue is parameterized so
that it can be arbitrarily set at run-time.   The capacity of -1 is
interpreted as an infinite buffer.  In that case the queue can grow
without limit, and the sender to this queue will never block.
\end{ignore}

\node Communication Protocols
\subsection{Communication Protocols}

A porthole is characterized by a data type it carries and a port
protocol.  \cindex{port protocol} \cindex{communication protocol, port}
The port protocol specifies the behavior when a channel is
full or empty.  Four different protocols are supported for each input
and output porthole.  For an output porthole, it can be \emph{block on
full, block on full with timeout, overwrite on full,} and \emph{ignore
on full}.  For an input porthole, it can be \emph{block on empty,
block on empty with timeout, previous on empty,} and \emph{ignore on
empty}.  The default protocol is \emph{block on full/empty}.

\node CP Star Overview
\section{An Overview of CP Stars}

Figure\tie\ref{figure CP stars} shows the top-level palette of blocks
included in the CP domain.  Only the blocks used in the demos are
included here.  Most blocks in the CP domain will be application
specific, and so will be written by the user.

\begin{figure}
\begin{center}
\ \psfig{figure=\CP/icons/cp.pal.ps}
\end{center}
\caption{Top-level palette of stars in the CP domain.}
\label{figure CP stars}
\end{figure}

\node CP Basic Stars
\subsection{Basic Stars}

The first row of icons in figure\tie\ref{figure CP stars} shows the
basic stars included in the CP domain.  These stars can be used to
model simple network queueing systems.  The other icon is the palette
for InfoPad stars (\pxref{CP InfoPad Stars}
and figure\tie\ref{figure CP infopad stars}).

\begin{indexlist}{ (CP block)}

\block{Customer}
Model customers with exponential inter-arrival intervals.

\block{Qserver}
Model server with exponential service time.

\block{QueueMon}
FIFO queue with finite or infinite length.

\end{indexlist}

\node CP InfoPad Stars
\subsection{InfoPad Stars}

Figure\tie\ref{figure CP infopad stars} shows the InfoPad
\cindex{InfoPad} stars available in the CP domain.

\begin{figure}
\begin{center}
\ \psfig{figure=\IP/icons/infopad.pal.ps}
\end{center}
\caption{Palette of InfoPad stars in the CP domain.}
\label{figure CP infopad stars}
\end{figure}

\begin{indexlist}{ (CP block)}

\block{IPAudioBlock}       
The primitive description of the audio block.
It receives compressed audio data, decompresses them, 
and generates sound.

\block{IPBaseStation}
The Base Station sends video and audio packets.

\block{IPDecompress}       
It receives compressed video data, decompresses
them, and send it for display on an X window.

\block{IPFastChannel}      
It models a wireless channel.
It receives a data packet, introduces some random noise, 
and send the corrupted data.

\block{IPImage}            
The Image block receives video data and displays 
the image on an X window.

\block{IPRouter}           
The Router block receives packets from the base workstation
and distribute it according to the packet type.
As an initial version, only video and sound packet are 
handled.

\block{IPRouter3}
The Router block receives packets from the base workstation
and distribute it according to the packet type.

\block{IPSoundGen}
The SoundGen block receives digital sound data and generates sound.

\block{IPVideoBlock}
The primitive description of the video block.
It receives compressed video data, decompresses
them, and displays the image on an X window.

\block{IPVideoDisplay}
The VideoDisplay block receives compressed video data and displays 
the image on an X window.

\end{indexlist}

\node CP Demo Overview
\section{An Overview of CP Demos}

Figure\tie\ref{figure CP demos} shows the top-level palette of demos
available in the CP domain.

\begin{figure}
\begin{center}
\ \psfig{figure=\CP/demo/init.pal.ps}
\end{center}
\caption{Top-level palette of demos in the CP domain.}
\label{figure CP demos}
\end{figure}

\node CP Basic Demos
\subsection{Basic Demos}

Figure\tie\ref{figure CP basic demos} shows the palette of basic demos
available in the CP domain.  Currently there is only a simple network
queueing demo.

\begin{figure}
\begin{center}
\ \psfig{figure=\CP/demo/basic.pal.ps}
\end{center}
\caption{Palette of basic demos in the CP domain.}
\label{figure CP basic demos}
\end{figure}

\begin{indexlist}{ (CP demo)}
\block{MM1Queue}
\begin{tex}
The first M means the intervals between arriving processes
follows Poisson distribution, i.e.  $ p[x > t] = e^{-at} $
(exponentially distributed).  The second M means the service time, and
the last argument is the number of the servers.
\end{tex}
\end{indexlist}

\node CP InfoPad Demos
\subsection{InfoPad Demos}

Figure\tie\ref{figure CP infopad demos} shows the InfoPad
\cindex{InfoPad} demos available in the CP domain.  The demos are
simulations of communication between a base station and a hand-held
voice/video terminal.  Each demo models the system at a different level
of detail.

\begin{figure}
\begin{center}
\ \psfig{figure=\IP/demo/init.pal.ps}
\end{center}
\caption{Palette of InfoPad demos in the CP domain.}
\label{figure CP infopad demos}
\end{figure}

\begin{indexlist}{ (CP demo)}
\block{level0}
This is a very high-level simulation of the communication from base
station to terminal.  A summary of processed events is produced on the screen.

\block{level1}
This is a more detailed simulation which displays moving
images and plays sound on the workstation speaker.

\block{IPFastChannel}
This simulation is similar to the previous one except that a more
complicated channel model is used.

\end{indexlist}

\node Installing the CP Domain
\section{Installing the CP Domain}

By default, the CP domain is not compiled into the Ptolemy
\code{pigiRpc} and \code{ptcl} programs.
\pindex{pigiRpc}
\pindex{ptcl}
Only the necessary libraries
are built.  Due to conflicts between Sun's lightweight process library
and the SDF domain, you should not include any part of the dataflow
domains (SDF, DDF, BDF, CG, CGC, etc.) in \code{pigiRpc} or
\code{ptcl}.  If you do, then you will get a core dump every time you
quit.  You may also get core dumps when running some systems.  If you
must have both the CP domain and one or more of the dataflow domains
and can accept this problem, then disregard the instructions below
about excluding the dataflow domains from \code{pigiRpc} and \code{ptcl}.

\node Customizing pigiRpc
\subsection{Customizing \protect\code{pigiRpc}}

To build a version of \code{pigiRpc} that includes the CP domain, you
will have to edit the files \file{makefile} and \file{defpalettes.c} in
\file{$PTOLEMY/src/pigiRpc}.  In \file{makefile}, modify the definition
of \code{LIBS} to include \samp{$(CP_LIBS)} following
\samp{$(STARLIBS)}, and \samp{$(LWP_LIBS)} after \samp{-lptolemy}.
This change causes the proper libraries to be searched when
\code{pigiRpc} is built.

\begin{example}
LIBS=     $(STAR_LIBS) $(CP_LIBS) -lsdftclstars \back
          -lrpc -lpigi -lptk -lgantt -lptolemy \back
          $(LWP_LIBS) $(OCTLIBS)
\end{example}

Modify the definition of \code{LIBFILES} to include
\samp{$(CP_LIBFILES)} and \samp{$(LWP_LIBFILES)}.  This change,
which is optional, sets up
the proper dependencies so that \code{pigiRpc} will be considered
out-of-date if any of the required library files are more recent.

\begin{example}
LIBFILES=  $(STAR_LIBFILES) $(CP_LIBFILES) $(LWP_LIBFILES) \back
           $(LIBDIR)/libsdftclstars.a \back
           $(LIBDIR)/libpigi.a $(LIBDIR)/libptolemy.a \back
           $(LIBDIR)/libgantt.a $(LIBDIR)/libptk.a
\end{example}

Modify the definition of \code{ALLSTARS} to include \samp{$(CPSTARS)}
and exclude all dataflow and code generation stars.  Also eliminate the
targets in \samp{ALLTARGETS}.  This causes the CP domain to be compiled
in to \code{pigiRpc}, and prevents the other domains from being
included.

\begin{example}
ALLSTARS=  $(THORSTARS) $(DESTARS) $(CPSTARS)
ALLTARGETS= 
\end{example}

In \file{defpalettes.c} add \samp{$PTOLEMY/src/domains/cp/icons/cp.pal}
to the definition of \code{defaultPalettes}.  If you wish, you may also
remove references to the palettes of unused domains, but this is not
necessary.  Also modify the value of \code{DEFAULT_DOMAIN} to refer to
a domain that will be included in  \code{pigiRpc}, such as CP.
Once these changes have been made, simply issue the command \samp{make}
in the \file{$PTOLEMY/obj.$ARCH/pigiRpc} directory.  You can now use
this version of \code{pigiRpc} either by setting the environment
variable \code{PIGIRPC} to the full path name of this newly created
version of \code{pigiRpc}, or by using the \samp{-rpc} option of the
\code{pigi} command.

\node Customizing ptcl
\subsection{Customizing \protect\code{ptcl}}

To build a version of \code{ptcl} that includes the CP domain, you will
have to edit the file \file{makefile.template} in
\file{$PTOLEMY/src/ptcl}.  The modifications to \file{make.template}
are similar to those made to \file{makefile} for \code{pigiRpc}.
In \file{make.template}, modify the definition of \code{LIBS} to
include \samp{$(CP_LIBS)} after \samp{$(STAR_LIBS)} and
\samp{$(LWP_LIBS)} after \samp{-lptolemy}.  This change causes the
proper libraries to be searched when \code{ptcl} is built.

\begin{example}
LIBS= $(STAR_LIBS) $(CP_LIBS) -lptolemy $(LWP_LIBS) \back
      $(TCL_LIBSPEC) $(SYSLIBS)
\end{example}

Modify the definition of \code{LIBFILES} to include
\samp{$(CP_LIBFILES)} and \samp{$(LWP_LIBFILES)}.  This change, which
is optional, sets up the proper dependencies so that \code{ptcl} will
be considered out-of-date if any of the required library files are more
recent.

\begin{example}
LIBFILES= $(STAR_LIBFILES) $(CP_LIBFILES) $(LWP_LIBFILES) \back
	  $(LIBDIR)/libptolemy.a
\end{example}

Modify the definition of \code{ALLSTARS} to include \samp{$(CPSTARS)}
and exclude all dataflow and code generation stars.  Also eliminate the
targets in \samp{ALLTARGETS}.  This causes the CP domain to be compiled
in to \code{pigiRpc}, and prevents the other domains from being
included.

\begin{example}
ALLSTARS = $(CPSTARS) $(THORSTARS) $(DESTARS)
ALLTARGETS =
\end{example}

\begin{sloppypar}
Once these changes have been made, simply issue the command \samp{make}
in the \file{$PTOLEMY/obj.$ARCH/ptcl} directory.  Your special version
of \code{ptcl} is ready for use.
\end{sloppypar}

\node References
\unnumberedsec{References}
\begin{enumerate}
\item \label{Hoare78}
C. A. R. Hoare, "Communicating Sequential Processes",
\emph{Communications of the ACM}, August 1978.
\end{enumerate}
