.VR 0.$Revision$ "$Date$"
.TI "CGC Domain"
.AU
S. Ha
.AE
.H1 "Introduction"
.pp
The
.c CGC
domain is used to generate C code. The generated c-code is
compiled, downloaded, and run in the target machine, by default
the \*(PT host machine. Before reading this document, please
read the CG domain document first for the common features and
general structure of code generation domains. In this chapter, we
will explain the features specific to the c-code generation.
.H1 "Targets"
.pp
The default target,
.c CGCTarget 
.Id "CGCTarget, class"
class, is a single processor target. The target machine is specified
by the
.c hostMachine
parameter, which is set to the \*(PT host machine by default.
The CGCTarget contains several other parameters.
The
.c funcName
parameter gives the name to the generated code. Though the default name is
"main", we need to assign a different name in case of multi-processor
targets. In a multi-processor target, it serves as only a child target that
produces a function, and the main function is generated in the parent
target. The generated code is written to a file, named after the
program graph name appended by ".c". If the
.c saveFileName
parameter is given a file name, the generated code is also copied to
the file.
The compilation command is generated by three target parameters:
.c compileCommand (
\fIcc\fR, by default), 
.c compileOptions ,
and 
.c linkOptions .
Then, the compile command will be
.(c
	compileCommand compileOptions fileName linkOptions
.)c
.pp
Besides the
.c myCode
and the
.c procedures
code streams defined in the CGTarget class, the CGCTarget class
defines other code streams for proper code organization.
They are 
.c include ,
.c globalDecls ,
.c mainDecls ,
.c mainInit ,
.c wormIn ,
and
.c wormOut .
In the 
.c frameCode()
method, the code streams are arranged to form the final code.
The "include" code streams goes first, "globalDecls" and
"procedures" streams next,
the function definition (for example, main()), "mainDecls" stream,
"mainInit", and the main loop body of the code. The "wormIn" and
"wormOut" streams are placed at the beginning and at the end of
the main loop body respectively.
To add code strings to these code streams, we can use
.c getStream(stream-name)->put(code-string, optional name) .
For star writers, some methods are defined the 
.c CGCStar
class:
.c addInclude()
to include file names to the "include" code stream,
.c addGlobal()
to add codes to the "globalDecls" stream,
.c addDeclaration()
to add codes to the "mainDecls" stream.
.pp
One of the main task of the target is to allocate resources. In c-code
generation domain, the global names are the resources to be managed.
We need to assign a unique name for each block and their portholes, states,
and variable. One approach was to use a structure (
.c struct
) hierarchy that is the same as the hierachical dataflow program
representation. This approach was rejected since it takes away from the 
compiler any chance of optimization with these global variables. 
Instead, we assign a unique number to each star instance. Using that number
and the name of the galaxy that contains the star, we generate a unique name
for each star instance. All variables inside a star instance is
prepended by the unique name of that star instance.  
.H2 "Multi-Processor Targets"
.pp
An examplary multi-processor target,
.c CGCMultiTarget ,
.Id "CGCMultiTarget, class"
is implemented in the target directory. It models multiple computers
working together, communicating with each other by Unix socket
mechanism. The computer names are given by a string state,
.c machineNames ,
in which machine names are separated by a comma. Since the child targets
are fixed to be the default CGCTargets, the
.c childType
parameter is declared as a non-settable state. To make socket connections,
we need to specify the port numbers for each computers. As a temporary
workaround, we provide a parameter, called
.c portNumber ,
in the target class. We use the consecutive port numbers starting 
from this number for connections. This workaround works as long as no
port number for a connection is already used in the pair of computers 
on the connection.
.pp
The send and receive stars are designed in the same directory:
.c CGCUnixSend
and
.c CGCUnixReceive
stars. When the sub-universes are created for child targets, the
send and receive stars are paired in the
.c pairSendReceive()
method in the target class. In that method, we specify the port number for
each connection, and insert the function calls for connection
establishment between computers in the 
.c mainInit
code stream of the child targets. The order of the connection establishments
between computers are crucial so that the parent target arranges them.









.H1 "Programming Stars in the CGC Domain:
.pp

