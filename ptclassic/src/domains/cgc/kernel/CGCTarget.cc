static const char file_id[] = "CGCTarget.cc";
/**********************************************************
Version identification:
$Id$

Copyright (c) 1990-%Q% The Regents of the University of California.
All rights reserved.

Permission is hereby granted, without written agreement and without
license or royalty fees, to use, copy, modify, and distribute this
software and its documentation for any purpose, provided that the above
copyright notice and the following two paragraphs appear in all copies
of this software.

IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY 
FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES 
ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF 
THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF 
SUCH DAMAGE.

THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE
PROVIDED HEREUNDER IS ON AN "AS IS" BASIS, AND THE UNIVERSITY OF
CALIFORNIA HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,
ENHANCEMENTS, OR MODIFICATIONS.
							COPYRIGHTENDKEY

 Programmer: S. Ha, E. A. Lee, and T. M. Parks

 Base target for C code generation.

*******************************************************************/

#ifdef __GNUG__
#pragma implementation
#endif

#include <unistd.h>		// Pick up R_OK for SunOS4.1 cfront
#include "CGCTarget.h"
#include "CGUtilities.h"
#include "CGCStar.h"
#include "GalIter.h"
#include "miscFuncs.h"
#include "dataType.h"
#include "EventHorizon.h"
#include "SDFScheduler.h"
#include "compat.h"		// Pickup symlink()

/* this modification is necessary to make a galaxy code as a function */
#define MAINDECLS (*getStream("mainDecls"))
#define MAININIT (*getStream("mainInit"))
#define MAINCLOSE (*getStream("mainClose"))

// Add code to the beginning of a CodeStream instead of the end.
void prepend(StringList code, CodeStream& stream)
{
    StringList temp;
    temp << code;
    temp << stream;
    stream.initialize();
    stream << temp;
}

// constructor
CGCTarget::CGCTarget(const char* name,const char* starclass,
                   const char* desc) : HLLTarget(name,starclass,desc) {
	addState(staticBuffering.setState("staticBuffering",this,"YES",
                        "static buffering is enforced between portholes."));
	addState(funcName.setState("funcName",this,"main",
                        "function name to be created."));
	addState(compileCommand.setState("compileCommand",this,"gcc",
                        "command for compiling code."));
	addState(compileOptions.setState("compileOptions",this,"",
                        "options to be specified for compiler."));
	addState(linkOptions.setState("linkOptions",this,"-lm",
                        "options to be specified for linking."));
        addState(resources.setState("resources",this,"STDIO",
        	"standard I/O resource"));
	initCodeStrings();

	targetHost.setAttributes(A_SETTABLE);
	filePrefix.setAttributes(A_SETTABLE);
	displayFlag.setAttributes(A_SETTABLE);
	compileFlag.setAttributes(A_SETTABLE);
	runFlag.setAttributes(A_SETTABLE);

	// Exported codeStreams.
	addStream("globalDecls", &globalDecls);
	addStream("include", &include);
	addStream("mainDecls", &mainDecls);
	addStream("mainInit", &mainInit);
	addStream("commInit", &commInit);
	addStream("mainClose", &mainClose);
}

StringList CGCTarget::comment(const char* text, const char* b,
    const char* e, const char* c)
{
    const char* begin = "/* ";
    const char* end = " */";
    const char* cont = "   ";
    if (b != NULL) {
	begin = b; 
	end = e;
    	cont = c;
    }
    return HLLTarget::comment(text, begin, end, cont);
}

// Galaxy declarations.
void CGCTarget::declareGalaxy(Galaxy& galaxy)
{
    GalStarIter starIter(galaxy);
    CGCStar* star;
    while ((star = (CGCStar*)starIter++) != NULL)
    {
	if (!star->isItFork()) declareStar(star);
    }
}

// Star declarations.
void CGCTarget::declareStar(CGCStar* star)
{
    // States must be declared after the Star has been run because running
    // the Star builds the list of referenced States.

    globalDecls << star->declareStates(A_GLOBAL);
    globalDecls << star->declarePortHoles(P_GLOBAL);

    MAINDECLS << star->declareStates(A_LOCAL);
    MAINDECLS << star->declarePortHoles(P_LOCAL);

    // States must be initialized before they are used, so this code must
    // appear before other code generated by the Star.
    prepend(star->initCodeStates(), MAININIT);
}

void CGCTarget :: setup() {
	// Note that code strings are not initialized here since
	// parent target may want to put some code before calling
	// setup() method.
	// Instead, initCodeStrings() is called in frameCode() method
	// after contructing the whole code.

	// member initialize
	galId = 0; curId = 0;

	if (galaxy()) setStarIndices(*galaxy()); 
	HLLTarget::setup();
}

void CGCTarget :: initCodeStrings() {
	globalDecls.initialize();
	procedures.initialize();
	include.initialize();
	mainDecls.initialize();
	mainInit.initialize();
	commInit.initialize();
	wormIn.initialize();
	wormOut.initialize();
	mainClose.initialize();
}
	

static char* complexDecl =
"\n#if !defined(COMPLEX_DATA)\n#define COMPLEX_DATA 1"
"\n typedef struct complex_data { double real; double imag; } complex; \n"
"#endif\n";
static char* fixDecl =
"\n#if !defined(NO_FIX_SUPPORT)"
"\n/* include definitions for the fix runtime library */"
"\n#include \"CGCrtlib.h\""
"\n#endif\n";

void CGCTarget::trailerCode()
{
    include << fixDecl << complexDecl;
    declareGalaxy(*galaxy());
    if (!SimControl::haltRequested())
	HLLTarget::trailerCode();
}

// Initial stage of code generation.
void CGCTarget::headerCode()
{
    // Do nothing.
}

// Combine all sections of code.
void CGCTarget :: frameCode ()
{
    // Construct the header.  Include directives appear before any other
    // code.  All global variable declarations must appear before any code
    // (such as procedures) which may use those variables.  Within the
    // main function, declarations must appear before any code.

    StringList code = headerComment();
    code << include << globalDecls << procedures
	 << comment("main function")
	 << (const char*)funcName << "() {\n"
	 << mainDecls << commInit << mainInit;

    // Prepend the header.
    prepend(code, myCode);

    // Append the trailer.
    myCode << mainClose << "\n}\n";

    // after generating code, initialize code strings again.
    initCodeStrings();
}

void CGCTarget :: writeCode()
{
    writeFile(myCode,".c",displayFlag);
    if (!onHostMachine(targetHost)) {
	const char* header = "$PTOLEMY/src/domains/cgc/rtlib/CGCrtlib.h";
	const char* source = "$PTOLEMY/src/domains/cgc/rtlib/CGCrtlib.c";
	rcpCopyFile(targetHost, destDirectory, header);
	rcpCopyFile(targetHost, destDirectory, source);
    }
}

int CGCTarget::compileCode()
{
    // invoke the compiler
    StringList file, cmd, error, rtlib;
    if (onHostMachine(targetHost)) {
	StringList ptolemy;
	ptolemy << getenv("PTOLEMY");
	rtlib << "-I" << ptolemy << "/src/domains/cgc/rtlib -L" 
	      << ptolemy << "/lib." << getenv("ARCH") << " -lCGCrtlib" ;
    }
    else {
	rtlib << "CGCrtlib.c";
    }
    file << filePrefix << ".c " << rtlib;
    cmd << compileLine(file) << " -o " << filePrefix;
    error << "Could not compile " << file;
    return (systemCall(cmd, error, targetHost) == 0);
}

// return compile command
StringList CGCTarget :: compileLine(const char* fName) {
	StringList cmd = (const char*) compileCommand;
	cmd << " " << (const char*) compileOptions << " ";
	cmd << fName << " " << (const char*) linkOptions;
	return cmd;
}

// Run the code.
int CGCTarget :: runCode()
{
    StringList cmd, error;
    cmd << "./" << filePrefix << "&";
    error << "Could not run " << filePrefix;
    return (systemCall(cmd, error, targetHost) == 0);
}

// Routines for writing code: schedulers may call these
void CGCTarget::beginIteration(int repetitions, int depth) {
	myCode << indent(depth);
        if (repetitions == -1)          // iterate infinitely
                myCode += "while(1) {\n";
        else {
	    mainDecls << "    "
		      << "int " << targetNestedSymbol.push("i") << ";\n";
	    myCode << "for (" << targetNestedSymbol.get() << "=0; "
		   << targetNestedSymbol.get() << " < " << repetitions << "; "
	    	   << targetNestedSymbol.get() << "++) {\n";
 	    targetNestedSymbol.pop();
        }
	myCode += wormIn;
        return;
}

void CGCTarget :: wormInputCode(PortHole& p) {
	wormIn << "\t/* READ from wormhole port " 
		<< p.fullName() << " */\n";
}

void CGCTarget :: wormOutputCode(PortHole& p) {
	wormOut << "\t/* WRITE to wormhole port " 
		<< p.fullName() << " */\n";
}

void CGCTarget :: endIteration(int /*reps*/, int depth) {
	myCode << wormOut;
	myCode << "} /* end repeat, depth " << depth << "*/\n";
}

// clone
Block* CGCTarget :: makeNew () const {
	LOG_NEW; return new CGCTarget(name(),starType(),descriptor());
}

/////////////////////////////////////////
// routines to determine the buffer sizes
/////////////////////////////////////////

// note that we allow the C compiler to do the actual allocation;
// this routine (1) determines the buffer sizes, and buffer properties.
// (2) splice star for copying
// (3) determine the type of buffers.
// (4) naming buffers
// (5) buffer offset initialization

int CGCTarget :: allocateMemory() {
	Galaxy& g = *galaxy();
	// set up the forkDests members of each Fork inputs.
	setupForkDests(g);
	
	int statBuf = useStaticBuffering();
	if (int(loopingLevel)) statBuf = 0;

	// (1) determine the buffer size
	GalStarIter nextStar(g);
	CGCStar* s;
	while ((s = (CGCStar*)nextStar++) != 0) {
		if (s->isItFork()) continue;
		BlockPortIter next(*s);
		CGCPortHole* p;
		while ((p = (CGCPortHole*) next++) != 0) {
			p->finalBufSize(statBuf);
		}
	}

	// splice copy stars
	addSpliceStars();

	nextStar.reset();
        while ((s = (CGCStar*)nextStar++) != 0) {
                BlockPortIter next(*s);
                CGCPortHole* p;
                while ((p = (CGCPortHole*) next++) != 0) {

			// (3) buffer type
			p->setBufferType();

			// (4) naming buffers.
	    		if (p->isItOutput() && (!p->switched())) {
				StringList sym, sName;
				sName << sanitizedName(*p);
				sym << symbol(sName);
				p->setGeoName(savestring(sym));
	    		}

			// (5) initialize offset pointer.
                        if (!p->initOffset()) return FALSE;
                }
        }

	return TRUE;
}

void CGCTarget :: setupForkDests(Galaxy& g) {
	GalStarIter nextStar(g);
	CGCStar* s;
	while ((s = (CGCStar*)nextStar++) != 0) {
		if (!s->isItFork()) continue;
		BlockPortIter next(*s);
		CGCPortHole* p = (CGCPortHole*) next++;
		if (p->isItOutput()) p = p->getForkSrc();
		p->setupForkDests();
	}
}


/////////////////////////////////////////
// codeGenInit
/////////////////////////////////////////

int CGCTarget :: codeGenInit() {

	// call initialization code.
	defaultStream = &MAININIT;
	GalStarIter nextStar(*galaxy());
	CGCStar* s;
	while ((s = (CGCStar*) nextStar++) != 0) {
		if (s->isItFork()) continue;

		// Generate PortHole initialization code before the Star is run
		// because running the Star modifies the PortHole indices.
		MAININIT << s->initCodePortHoles();
		s->initCode();

	}

        return TRUE;
}

// Splice in stars.
// Return FALSE on error.

    static int needsSpliceStar(CGCPortHole* port)
    {
	if (port->isItOutput()) {

	    // splice conversion star if type of output port does not
	    // match the type of the data connection
	    if ((port->type() != port->resolvedType()) &&
 	        (port->type() != ANYTYPE))
		return TRUE;

	    // check for ports of type FIX;
	    // splice a FixToFix star if the precisions do not match or
	    // one or both side uses precision variables that can change at
	    // runtime
	    if (port->resolvedType() == FIX) {

		Precision p1, p2;

		// Determine the two connected ports;
		// If this port is the output of a fork star we go back to
		// the input of the fork
		CGCPortHole* far_port  = (CGCPortHole*)port->far();
		CGCPortHole* this_port = far_port->realFarPort();

		// if this or the far side is a multiporthole, refer to the
		// multiport rather than to the normal porthole itself;
		// this is because when deriving a new port from the multiport,
		// the precision of the multiport may not have been set yet
		// (cf. MultiInCGCPort::newPort)

		MultiCGCPort *this_mph,*far_mph;
		this_mph = (MultiCGCPort*)this_port->getMyMultiPortHole();
		far_mph  = (MultiCGCPort*)far_port ->getMyMultiPortHole();

		// Get the precision assigned to the two connected ports.
		// Since the precision() method eventually passes the
		// precision of the connected port, we use validPrecision()
		// to determine whether a precision has been assigned
		// explicitly to the port.

		if (this_mph && this_mph->validPrecision())
			p1 = this_mph->precision();
	   else if (this_port->validPrecision())
			p1 = this_port->precision();

		if (far_mph && far_mph->validPrecision())
			p2 = far_mph->precision();
	   else if (far_port->validPrecision())
			p2 = far_port->precision();

		// if at least one of the connected ports uses variable
		// precisions and the other side defines its own precision,
		// we need a FixToFix star
		if (((this_port->attributes() & AB_VARPREC) && p2.isValid()) ||
		    ((far_port->attributes()  & AB_VARPREC) && p1.isValid()))
			return TRUE;

		// otherwise check whether the precisions differ
		if (p1.isValid() && p2.isValid() && (p1 != p2))
			return TRUE;
	    }
	}
	return FALSE;
    }

// hppa.cfront CC 3.50 has this annoying bug that barfs on the code below
// > CC: "../../../../src/domains/cgc/kernel/CGCTarget.cc", line 461:
// > sorry, not implemented: general initializer in initializer list
// So rather than having a nice clean portable way of doing this, we
// use an ugly if/else tree below

#define HP_CC_3_50_BUG
#ifndef HP_CC_3_50_BUG
struct cnv_tb {
  /*DataType src, dst;*/
  const char *src, *dst, *star;
};
static struct cnv_tb cnv_table[7] = {
  {  COMPLEX, 	FIX, 		"CxToFix"	},
  {  COMPLEX, 	ANYTYPE,	"CxToFloat"	},
  {  FIX,	COMPLEX,	"FixToCx"	},
  {  FIX,	FIX,		"FixToFix"	},
  {  FIX,	ANYTYPE,	"FixToFloat"	},
  {  ANYTYPE, 	COMPLEX,	"FloatToCx"	},
  {  ANYTYPE, 	FIX,		"FloatToFix"	}
};
#endif // HP_CC_3_50_BUG


int CGCTarget::modifyGalaxy() {

    extern int warnIfNotConnected (Galaxy&);

    Galaxy& gal = *galaxy();
    GalStarIter starIter(gal);
    Star* star;
    const char* domain = gal.domain();

    // type conversion table;
    // procession takes place in chronological order

    if (warnIfNotConnected(gal)) return FALSE;

    while ((star = starIter++) != NULL) {
	BlockPortIter portIter(*star);
	CGCPortHole* port;
	while ((port = (CGCPortHole*)portIter++) != NULL) {
	    // Splice in type conversion stars.
	    if (needsSpliceStar(port)) {
		// Avoid re-initializing the Galaxy, which will break
		// things if this is a child in a MultiTarget. (Why? See
		// comments for CGTarget::setup() method.)  Initialize it
		// only if there is no resolved type.
		if (port->resolvedType() == NULL) {
		    gal.initialize();
		    if (SimControl::haltRequested()) return FALSE;
		    // We must now re-run modifyGalaxy, blocks & ports may
		    // have been added or deleted in the initialize method.
		    return CGCTarget::modifyGalaxy();
		}

		Star* s = 0;

		PortHole* input = port->far();	// destination input PortHole

#ifdef HP_CC_3_50_BUG
		if ( port->type() == COMPLEX ) {
		  if ( port->resolvedType() == FIX ) {
		    //COMPLEX, 	FIX, 		"CxToFix"
		    if (!(s = (Star*)spliceStar(input, "CxToFix",
						TRUE, domain)))
				return FALSE;
		  } else {
		    //COMPLEX, 	ANYTYPE,	"CxToFloat"
		    if (!(s = (Star*)spliceStar(input, "CxToFloat",
						TRUE, domain)))
				return FALSE;
		  }
		} else if ( port->type() == FIX ) {
		  if ( port->resolvedType() == COMPLEX ) {
		    //FIX,		COMPLEX,	"FixToCx"
		    if (!(s = (Star*)spliceStar(input, "FixToCx",
						TRUE, domain)))
				return FALSE;
		  } else if ( port->resolvedType() == FIX ) {
		    //FIX,		FIX,		"FixToFix"
		    if (!(s = (Star*)spliceStar(input, "FixToFix",
						TRUE, domain)))
				return FALSE;
		  } else {
		    //FIX,		ANYTYPE,	"FixToFloat"
		    if (!(s = (Star*)spliceStar(input, "FixToFloat",
						TRUE, domain)))
				return FALSE;
		  }
		} else {
		  if ( port->resolvedType() == COMPLEX ) {
		    //ANYTYPE, 	COMPLEX,	"FloatToCx"
		    if (!(s = (Star*)spliceStar(input, "FloatToCx",
						TRUE, domain)))
				return FALSE;
		  } else if ( port->resolvedType() == FIX ) {
		    //ANYTYPE, 	FIX,		"FloatToFix"
		    if (!(s = (Star*)spliceStar(input, "FloatToFix",
						TRUE, domain)))
				return FALSE;
		  }
		}

#else // HP_CC_3_50_BUG
		for (int i=0; i < sizeof(cnv_table)/sizeof(*cnv_table); i++) {
		    if (((port->type() == cnv_table[i].src) ||
				  (cnv_table[i].src == ANYTYPE)) &&
		        ((port->resolvedType() == cnv_table[i].dst) ||
				  (cnv_table[i].dst == ANYTYPE))) {
		      if (!(s = (Star*)spliceStar(input,
			  cnv_table[i].star, TRUE, domain)))
				return FALSE;
			  break;
		    }
		}
#endif // HP_CC_3_50_BUG
		if (s) s->setTarget(this);
	    }
	}
    }
    return TRUE;
}

/////////////////////////////////////////
// addSpliceStars
/////////////////////////////////////////

static void setupBuffer(CGCStar* s, int dimen, int bufsz) {
	CGCPortHole* p = (CGCPortHole*) s->portWithName("output");
	p->setSDFParams(dimen);
	if (bufsz) {
		p->giveUpStatic();
		p->requestBufSize(bufsz);
	}
	else       p->requestBufSize(dimen);
	p->setFlags();
	p = (CGCPortHole*) s->portWithName("input");
	p->setSDFParams(dimen);
	p->setFlags();
}

// "Copy" stars are added if an input/output PortHole is a host/embedded
// PortHole and the buffer size is greater than the number of Particles
// transferred.

// NOTE:  Because this splicing takes place after the schedule has been
// constructed, the CGCStar::addSpliceStar() method is used as a hack to
// ensure that code will be generated for the new spliced stars.

void CGCTarget :: addSpliceStars() {
	const char* dom = galaxy()->domain();

	GalStarIter nextStar(*galaxy());
	CGCStar* s;
	CGCPortHole* farP;
	while ((s = (CGCStar*) nextStar++) != 0) {
                BlockPortIter next(*s);
                CGCPortHole* p;
                while ((p = (CGCPortHole*) next++) != 0) {
			CGCStar* news = 0;

			if (p->isItInput()) {
				farP = (CGCPortHole*) p->far();

				if ((p->embedded() || p->embedding()) &&
					 (p->numXfer() < p->bufSize())) {
					news = (CGCStar*)
						spliceStar(p, "Copy", 1, dom);
					CGCPortHole* tp = (CGCPortHole*) 
						news->portWithName("input");
					tp->giveUpStatic();
				}
				if (news) {
					news->setTarget(this);
					setupBuffer(news, p->numXfer(), 0);
					s->addSpliceStar(news, 0);
				}

			// output
			} else if ((p->embedded() || p->embedding()) &&
				 (p->numXfer() < p->bufSize())) {

				// special treatment for Collect star
				// since it is not a normal SDF star
				CGCStar* ps = (CGCStar*) p->parent();
				if (ps->amISpreadCollect()) {
					farP = (CGCPortHole*) p->far();
					news = (CGCStar*) spliceStar(farP,
						"Copy", 0, dom);
					setupBuffer(news, farP->numXfer(), 
						p->bufSize());
					ps = (CGCStar*) farP->parent();
					ps->addSpliceStar(news, 0);

					// set offset manually
					CGCPortHole* tp = (CGCPortHole*) 
						news->portWithName("output");
					int offset = p->numXfer() -
						farP->numInitDelays() - 1;
					if (offset < 0) offset += p->bufSize();
					tp->setOffset(offset);
					tp = (CGCPortHole*) news->
						portWithName("input");
					tp->setOffset(offset);
				} else {
					news = (CGCStar*) 
						spliceStar(p,"Copy",0,dom);	
					setupBuffer(news, p->numXfer(), 
						p->bufSize());
					s->addSpliceStar(news, 1);
				}
				p->requestBufSize(p->numXfer());
				news->setTarget(this);
			}
		}
	}
}

/////////////////////////////////////////
// incrementalAdd
/////////////////////////////////////////

int CGCTarget :: incrementalAdd(CGStar* s, int flag) {

	CGCStar* cs = (CGCStar*) s;
	cs->setTarget(this);

	if (!flag) {
		// run the star
		defaultStream = &myCode;
		writeFiring(*cs, 1);
		return TRUE;
	}

	// initialize the star
	s->initialize();

	// allocate resource
	BlockPortIter nextPort(*s);
	CGCPortHole* p;
	while ((p = (CGCPortHole*)nextPort++) != 0) {

		p->finalBufSize(useStaticBuffering());
	  	p->initOffset(); 

		// Assign names only for each output port
		if (p->isItOutput() && (p->switched() == 0)) {
			StringList sym, sName;
			sName << sanitizedName(*p);
			sym << symbol(sName);
			p->setGeoName(savestring(sym));
	    }
	}

	// Generate PortHole initialization code before the Star is run
	// because running the Star modifies the PortHole indices.
	MAININIT << cs->initCodePortHoles();

	defaultStream = &MAININIT;
	cs->initCode();

	// run the star
	defaultStream = &myCode;

	writeFiring(*cs, 1);

	defaultStream = &MAINCLOSE;
	cs->wrapup();
	defaultStream = &myCode;

	declareStar(cs);
	return TRUE;
}
	
// maintain the galaxy id properly.
int CGCTarget :: insertGalaxyCode(Galaxy* g, SDFScheduler* s) {
	int saveId = galId;
	curId++;
	galId = curId;
	setStarIndices(*g);
	if (!HLLTarget :: insertGalaxyCode(g, s)) return FALSE;
	declareGalaxy(*g);
	galId = saveId;
	return TRUE;
}

// redefine compileRun to switch code stream of stars
void CGCTarget :: compileRun(SDFScheduler* s) {
	defaultStream = &myCode;
	s->compileRun();
	defaultStream = &MAINCLOSE;
}

/////////////////////////////////////////
// Utilities
/////////////////////////////////////////

ISA_FUNC(CGCTarget,HLLTarget);
