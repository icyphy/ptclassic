.\" $Id$
.VR 0.$Revision$ "September 28, 1990"
.TI "DE Domain"
.AU
Soonhoi Ha
.AE
.ds DO DE
.H1 "Introduction"
.pp
The discrete event (DE) domain in \*(PT provides a very general
environment for the time-related simulation of the digital systems,
such as queueing network simulation.  In the \*(DO domain, each
.c Particle
represent an \fIevent\fR which corresponds to the change of system
state.  The
.c DE\ Scheduler
processes the events in the chronological order.  Since the time interval
of the events is generally not fixed, each
.c Particle 
is associated with a \fItime-stamp\fR.
Time stamps are generated by the
.c Block
producing the
.c Particle ,
using the time stamps of the input
.c Particle s
and the latency in the 
.c Block .
.H1 "The \\*(DO Scheduler
.pp
The scheduler in \*(PT determines the order of execution of
blocks, and also expects a particular behavior on the part of
.c Star s
within the \*(DO domain.
In this section, we describe the operation of the \*(DO scheduler.
.pp
A
.c DE\ Star 
basically models the system response on the change of the system state.
The change of system state,
which is called an \fIevent\fR,
will be the content of a
.c Particle 
in the \*(DO domain.  Each 
.c Particle
is assigned to a time stamp telling when it is generated. 
Since the events are irregularly spaced in time
and the system responses can be very dynamic in general,
all scheduling actions are done at runtime.  
At runtime, the
.c DE\ Scheduler
processes the events in the chronological order until the
global time reaches the \fIstop time\fR.
.pp
The
.c DE\ Scheduler
maintains a \fIglobal event queue\fR where
.c Particle s
currently in the system are sorted in accordance with time stamps.
Some 
.c DEStar s
are event-generators which do not consume any events. 
For these stars, some system-generated triggering 
.c Particle s
are placed in the event-queue beforehand.
The 
.c Scheduler
fetches an event from the head of the queue, which is the
earlist event, and sends it to its destination 
.c Block. 
Before executing
the block, it searches the event queue to find out whether there are
any simultaneous events to the same block (user may or may not allow
simultaneous events when defining 
.c Star s).
After a block is executed it may generate some output events on its
output 
.c PortHole s.
These events are by turns put into the global event queue.
Then the scheduler fetches another events and repeats its action until
a given \fIstop time\fR is reached. The \fIstop time\fR should be specified
before scheduler runs (default is 100.0). \fBTime\fR within the \*(DO
domain is simulated time. But the scale of time can be changed. 
.H1 "Special \\*(DO Particles
.pp
.c Particle s
are the envelope that encapsulate the data or messages passing
between blocks in \*(PT.
All
.c Particle s
in \*(PT are derived from a basic
.c class\ Particle .
All
.c Particle s
in \*(PT are available for use within any particular domain.
However, each domain typically has some special
.c Particle s
that are particular to that domain.
.pp
Currently, no \fBDE\fR-specific
.c Particle s
are defined.
.H1 "Programming Stars in the \\*(DO Domain
.pp
There is an attempt to maintain uniformity across
different domains in \*(PT.
However, in each domain there are typically special needs
for the writers of
.c Star s
in that domain.
This section describes how
.c Star s
are programmed in the \*(DO domain.
.pp
A 
.c DE\ Star
can be viewed as an event-processing unit, which receives
events from the outside, processes them, and generates output events after
some latency. In the \*(DO domain, the management of the
time stamps of the
.c Particle s
is as important as the functionality of a
.c Star .
For the time-management, the
.c DEStar\ class
has two DE-specific members : 
\fIarrivalTime\fR and \fIcompletionTime\fR.
The \fIarrivalTime\fR
indicates when the current event arrives while
the \fIcompletionTime\fR 
tells when the last execution of the
.c Star
is completed.  
Since the functionality and the time management are
the orthogonal ingredients of the
.c DE\ Star ,
we dedicate some 
.c DE\ Star s, 
so-called \fIdelay-stars\fR,
to the task of time-management (\fIDelay, ExpDelay, UniDelay\fR).
The other 
.c Star s,
so-called \fIfunctional-stars\fR,
are stripped of the time-management task, generating the output
events at the same time when it receives input events.
The delay-stars and the other-stars compose two orthogonal
sets of the
.c DE\ Star s.
By combining a delay-star and a functional-star, we can
realize a general
.c DE\ Star 
(combining two stars means concatenating them).
.H2 "Delay Stars
.pp
\fIDelay-stars\fR are in charge of time-management task
in the \*(DO domain.  We can classify the delay-stars
further into two types.  One type is a \fIpure-delay\fR.
A delay-star of \fIpure-delay\fR type is that the output
event is generated a user-given latency after the input
event comes.  The following example will help the understanding.
It is the preprocessor format of the
.c ExpDelay\ Star 
in the \*(DO domain.  For more details on the preprocessor,
look at the document, "\fBThe Ptolemy Preprocessor Language\fR".
.(c

ident {
/**************************************************************************
 Copyright (c) 1990 The Regents of the University of California.

 This star delays its input by random amount according to an
 exponential random variable with parameter mean.

**************************************************************************/
}
defstar {
	name {ExpDelay}
	domain {DE}
	desc {
	   "Delays its input by random amount according to an"
	   "exponential random variable with parameter mean."
	}
	input {
		name {input}
		type {anytype}
	}
	output {
		name {output}
		type {anytype}
	}
	defstate {
		name {mean}
		type {float}
		default {"1.0"}
		desc { "Amount of time delay" }
	}
	constructor {
		input.inheritTypeFrom(output);
	}
	go {
	   // Generate a uniform random variable.
	   double p = drand48();
	   // Turn it into an exponential, and add to completionTime
	   completionTime = arrivalTime - log(p) * double(mean);
	   Particle& pp = input.get();
           output.put(completionTime) = pp;
	}
}
.)c
Inside the \fIgo()\fR method description, the \fIcompletionTime\fR
is determined by the arrival time of the current event plus
a random delay which is exponentially distributed.  
The last two lines will be explained in subsection 4.2.
.pp
The other type is a \fIserver\fR.  
In a delay-star of \fIserver\fR type, the input event should wait
until the previous execution is completed.  It emulates a server that
can process only one event at a time.  Here is the example of a
\fIserver\fR type : 
.c Server\ Star .
.(c
ident {
/**************************************************************************

 This star emulates a server.  If input events arrive when it is not busy,
 it delays them by the service time.  If they arrive when it is busy,
 it delays them by more.  It must become free, and then serve them.

**************************************************************************/
}
defstar {
	name {Server}
	domain {DE}
	desc {
	   "This star emulates a server."
	   "If input events arrive when it is not busy,"
 	   "it delays them by the service time."
	   "If they arrive when it is busy,"
 	   "it delays them by more."
	   "It must become free, and then serve them."
	}
	input {
		name {input}
		type {anytype}
	}
	output {
		name {output}
		type {anytype}
	}
	defstate {
		name {serviceTime}
		type {float}
		default {"1.0"}
		desc { "Service time" }
	}
	constructor {
		input.inheritTypeFrom(output);
	}
	go {
	   // No overlapped execution. set the time.
	   if (arrivalTime > completionTime)
		completionTime = arrivalTime + double(serviceTime);
	   else
		completionTime += double(serviceTime);

	   Particle& pp = input.get();
           output.put(completionTime) = pp;
	}
}
.)c
If the \fIarrivalTime\fR is later than the \fIcompletionTime\fR, or
an input event arrives when the server is free, the server processes
the input event immediately and takes some \fIserviveTime\fR.
Otherwise, or an input event arrives when the server is busy, it
is delayed until the server is available and processed.
.H3 "Event Generators
.pp
A
.c DEStar
is fired only when an event is fed into the star. 
In the \*(DO domain, we need another class of
.c DE\ Star ,
called \fIself-scheduling star\fR.
A self-scheduling star generates an event to itself.
The feedback event triggers the star itself, which emulates
an event generator.  An event generator is a special case of a delay star
in that its role is mainly to control the time spacing of source events.
The values of the source events can be determined by a functional block
attached to the end of the event generator (e.g. \fIFloatDC, FloatRamp\fR,
etc).  
.pp
A self-scheduling star is derived from 
.c class\ DERepeatStar
which is again a derived class of
.c class\ DEStar .
The
.c DERepeatStar\ class
has some special methods to facilitate the self-scheduling function :
\fIrefireAtTime()\fR and \fIcanGetFired()\fR.  Let's look at an example :
.c Poisson\ Star.
.(c
ident {
/**************************************************************************

 This star generates events according to a Poisson process.
 The mean inter-arrival time and magnitude of the events are
 given as parameters.

**************************************************************************/
}
defstar {
	name {Poisson}
	domain {DE}
	derivedfrom {DERepeatStar}
	desc {
	   "Generates events according to a Poisson process."
	   "The first event comes out at time zero."
	}
	output {
		name {output}
		type {float}
	}
	defstate {
		name {meanTime}
		type {float}
		default {"1.0"}
		desc { "The mean inter-arrival time" }
	}
	defstate {
		name {magnitude}
		type {float}
		default {"1.0"}
		desc { "The magnitude of samples generated" }
	}
	go {
	   // Generate the output event
	   // (Recall that the first event comes out at time 0).
	   output.put(completionTime) << float(double(magnitude));

	   // and schedule the next firing
	   refireAtTime(completionTime);

	   // Generate a uniform random variable.
	   double p = drand48();

	   // Turn it into an exponential, and add to completionTime
	   completionTime -= log(p) * double(meanTime);
	}
}
.)c
The
.c Poisson\ Star
emulates a Poisson arrival process.  The inter-arrival time of events
is exponentially distributed by parameter \fImeanTime\fR.
The method,
\fIrefireAtTime()\fR launches a event on the feedback arc which is
invisible to the users.  The feedback event triggers the 
self-scheduling star.
.pp
To initiate the event generation, an event is placed on the feedback
arc before the
.c DE\ Scheduler
runs.  In other words, at time 0, some events are placed in the
global queue to trigger the self-scheduling stars.  Also it is
noteworthy that the feedback event for the next execution is
generated in the current execution.
.pp
Another method, \fIcanGetFired()\fR is seldom used in the
.c Star
definitions.  The method
checks the feedback event, and return \fBTRUE\fR if there is
a new event or \fBFALSE\fR otherwise.
.H2 "Functional Stars
.pp
In the \*(DO domain, a
.c Star
is \fIrunnable\fR (ready for execution), if any input
.c PortHole
has a new event 
.c (Particle) .  
And, the
.c DE\ Star
has the responsibility to detect which input 
.c PortHole
a new event arrives at.  The input
.c PortHole
containing a new 
.c Particle
has the \fIdataNew\fR flag set by the 
.c Scheduler
when it sends the event to the 
.c Star .
Then, the 
.c Star
can check up the \fIdataNew\fR flag to detect the event source.
And, it processes the input event and generates an output event
without any latency.  The latency of a \fIfunctional-star\fR can 
be modeled by concatenating a \fIdelay-star\fR which is explained
in the previous subsection.
Now, let's look at how to write the body of a
.c DE\ Star 
with an example : 
.c Switch\ Star .
.(c
ident {
/**************************************************************************

 This star switches input events to one of two outputs, depending on
 the last received control input.

**************************************************************************/
}
defstar {
	name {Switch}
	domain {DE}
	desc {
	   "Switches input events to one of two outputs, depending on"
	   "the last received control input."
	}
	input {
		name {input}
		type {anytype}
	}
	input {
		name {control}
		type {int}
	}
	output {
		name {true}
		type {anytype}
	}
	output {
		name {false}
		type {anytype}
	}
	constructor {
		true.inheritTypeFrom(false);
		input.inheritTypeFrom(true);
	}

	go {
	   if (input.dataNew) {
	   	completionTime = arrivalTime;
		Particle& pp = input.get();
		int c = int(control%0);
		if(c)
           	   true.put(completionTime) = pp;
		else
           	   false.put(completionTime) = pp;
	   }
	}
}
.)c
The
.c Switch\ Star
has two input
.c PortHole s
: \fIinput\fR, and \fIcontrol\fR.
When an event arrives at the \fIinput\fR 
.c PortHole ,
it routes the event to either \fItrue\fR or \fIfalse\fR
.c PortHole
depending the value of the last received \fIcontrol\fR input.
First of all, we have to check
whether a new input event arrives. 
It is done by looking at the \fIdataNew\fR
flag of the \fIinput\fR
.c PortHole .
.pp
There are three methods to access a 
.c Particle
from  input or output ports. First, we may use \fI%\fR operator followed
by a integer, which
is common to \fBSDF\fR domain.  
.c control%0
returns the recentest 
.c Particle
from the \fIcontrol\fR 
.c PortHole ,
and
.c control%2
would retunr the second previous 
.c Particle
if we wish.
The second method, \fIget()\fR, is specific to 
.c InDEPort .
It resets the \fIdataNew\fR member of the port as well as returns the
recentest
.c Particle
from an input port. If you need to reset the \fIdataNew\fR member of a
input port after read the newly arrived event, which is a usual case,
you have to use \fIget()\fR method instead of \fI%0\fR operator.
This is why we use \fIget()\fR method for the \fIinput\fR
.c PortHole .
The last method, \fIput(int)\fR, is specific to 
.c OutDEPort .
It sets the \fItimeStamp\fR member of the port as well as returns the
recentest
.c Particle
from an output port. Let's look at a line in the above example.
.sp
.(c
true.put(completionTime) = pp;
.)c
.sp
It says that we copy the
.c Particle\ pp
to the output port with \fItimeStamp = completionTime\fR.
.sp
.pp
This rather long section describes the method how to design a
.c DE\ Star .
The good starting point to design a
.c Star
would always be to look at the existing 
.c Star s.		
.H1 "EventHorizon in the \\*(DO Domain
.pp
The mixture of the \*(DO domain with other domains
requires a conversion between different computational
models.
In particular, some domains associate a \fItime stamp\fR
with each
.c Particle ,
and other domains do not.
Thus, a common function at the
.c EventHorizon
is the addition of time stamps, the stripping off of
time stamps, interpolation between time stamps,
or removal of redundant repetitions of identical
.c Particle s,
and so forth.
.pp
In \*(PT there has been defined a \fIuniversal event horizon\fR.
The interface between different domains requires first conversion
to the universal event horizon, followed by a conversion from
the universal event horizon to the second domain.
The general mechanism of the domain interface is described in
the document, "\fBDomain Interface in Ptolemy\fR".
In this section, \*(DO-specific features on the domain
interface will be discussed.
.H2 "DE Wormhole
.pp
The \*(DO domain may have a wormhole which contains another domain.
An input port of a
.c DE Wormhole
consists of a 
.c DEtoUniversal\ EventHorizon
and a
.c (in-domain)fromUniversal\ EventHorizon.  Similarly, an output port
consists of a 
.c (in-domain)toUniversal 
and a
.c DEfromUniversal\ EventHorizon .
Since the
.c DE\ Wormhole
looks exactly like a
.c DE\ Star
from the \*(DO domain, it is fired when any input port
has an event. When it is fired, it initiates the
.c Scheduler
of the inner domain.
.H2 "Conversion from the \*(DO Domain to the Universal Event Horizon
.pp
The conversion from the \*(DO domain to the universal
.c EventHorizon
is the function of the
.c DEtoUniversal\ EventHorizon .
It transfers the incoming data to the associated 
.c EventHorizon
of the other domain.  The necessary data-conversion to the universal
format should be done in this
.c class .
Currently, no conversion is performed since only universal
.c Particle s
are defined in the \*(PT.  For non-universal
.c Particle s,
further research is going on.
The
.c DEtoUniversal
also copies the global time of the \*(DO domain into the other domain.
.H2 "Conversion from the Universal Event Horizon to the \*(DO Domain
.pp
The
.c DEfromUniversal\ EventHorizon
receives the data from the associated 
.c EventHorizon 
of the other domain and converts it if necessary.  Since the \*(DO
domain is a typical \fItimed\fR domain, it is important to
set the \fItimeStamp\fR of the
.c EventHorizon
right.  According to the \fItimeStamp\fR, the received events are put into
the global queue of the \*(DO domain.
If the
.c DEfromUniversal
is at an input port of a
.c Wormhole
it also sets the stopping condition of the inner
\*(DO domain. The stopping condition of the \*(DO domain
is the stop time of the
.c DE\ Scheduler .
The stop time is set to the \fItimeStamp\fR of the port.
Since the \fItimeStamp\fR represents the current time of
the outer domain, the inner \*(DO domain is not allowed to
pass the current time of the outer domain.
