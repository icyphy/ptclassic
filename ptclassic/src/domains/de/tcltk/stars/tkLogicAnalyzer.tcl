# Tcl/Tk source for Logic Analyzer for DE domain
#
# Author: Eduardo N. Spring
# Version: $Id$
# 
# ***** General Description *****
# This script file is a tcl/tk source file for DELogicAnalyzer star (which is 
# derived from DETclScript star). The program reads the number of portholes and
# sets up an appropriate size to make a widget. This widget contains the 
# appropriate number of windows to plot the events of each porthole in the 
# related window. Then, as soon as a token is fired, it reads the particle's
# value and its arrival time and plots a point on corresponding window. 
# Upon the user's request, it plots a zero hold diagram of points or connects
# each point to the following point or plots only dots representing the 
# particles. The width of each widow is set to demonstrate events occured in 25
# time unit intervals at a time, therefore after each 25 time interval the
# canvas scrolls and makes the upcoming events be visible.
# The program, also, fits any desired number of events in one window by entering
# the desired range. This feature works as zoom in and zoom out combined in one
# function. There is a print option which uses ptkPlot script as source file
# and prints the selected window's events.
# The following procedures represent the  main structure of this program:
#
# proc mkWindow     { } ;makes the main window and its related canvases
# proc tkPaginate   { } ;puts the value of X-axis on corresponding window
# proc mkYScale     { } ;makes the Y-axis of corresponding window
# proc mkSetValues  { } ;reads and sets the particle's vlue and its arrival time
# proc mkNode       { } ;plots each particle upon its fire 
# proc tkRefresh    { } ;refresh all drawn objects in all windows
# proc tkDrawXYCoord{ } ;draws lines representing x & y coordinates of each
#			;particle upon pressing <Button-2>
# proc tkShowXYval  { } ;shows initial values of each particle upon pointing the
#			;pointer over particle and pressing <Button-1> 
# proc mkWinFit     { } ;makes the window corresponding to zoom fit request
# proc mkZoomXYBar  { } ;draws XY-coordinates in zoom fit corresponding windows
# proc tkTimeRangeEntry  { } ;pops a window to enter X-range upon a zoom fit
#                            ;request
# proc tkZoomFit    { } ;fits all particles of requested range into a window 
 
# *************** set the global variabales *****************

set Sd $starID  ;# Sets the unique ID generated by Ptolemy for star instance
set WinX 0	;# X-Coord of window (in case of multi usage of Logic Analyzer)
set WinY 0	;# Y-Coord of window (in case of multi usage of Logic Analyzer)
set Rd .07	;# Radius of ovals representing each event
set Ud 1        ;# Unit distance on xBar scale, reperesenting the time unit
set bordX .5	;# Position of "zero" point on X-axis
set bordY 4.5	;# Position of "zero" point on Y-axis
set In 0        ;# Initializes the portehole numbers to zero
set DotsOnOff 1 ;# The vaiable to turn the dots on or off in zoom window

set n [set ${starID}(numInputs)]  ;# number of portholes (inputs)
set iter [$ptkControlPanel.iter.entry get] ;# holds the iteration time
source "~ptdesign/src/ptklib/ptkPlot.tcl"

# *** Initialize the global variables
set E1 0 ; set E2 $iter   ;# Hold the iteration time range for zooming purpose

for {set z 0} {$z < $n} {incr z} { 
           set Cnt$Sd$z 0  ;# Holds the number of events in each input window
           set Ck$Sd$z 1   ;# Holds the track of arrival time in each window
}
for {set z 0} {$z < $n} {incr z} { 
            set ZCnt$Sd$z 0 ;# Number of events in zoomed windows
}
for {set z 0} {$z < $n} {incr z} { 
            set By$Sd$z 0   ;# Holds the new position of "zero" point on Y-axis
			    ;# according to specified y1& y2 parameters
}
for {set z 0} {$z < $n} {incr z} { 
	    set Px$Sd$z 0  ;# Hold x & y value of each event to draw line
	    set Py$Sd$z 0  ;# between events
}
for {set z 0} {$z < $n} {incr z} { 
	       set Y1$Sd$z 0   ;# Hold Y range specified by user
	       set Y2$Sd$z 0
}

# Make sure that always y1<y2; to match drawing scales with X&Y-axis values
for {set z 0} {$z < $n} {incr z} {
  set y1 [set Y1$Sd$z]; set y2 [set Y2$Sd$z] 
  if {$y2<$y1} {set Y1$Sd$z $y2; set Y2$Sd$z $y1} 
}
  
# ******* Read the edited parameter from Star *************
set plotStyle$Sd [set ${starID}(PlotStyle)]
set yRange [set ${starID}(yRangeList)]
set plotLabel$Sd [set ${starID}(PlotLabels)]
set winName$Sd [set ${starID}(WindowName)]

set PL [set plotLabel$Sd]
regsub -all \n "$PL" \40 PP
for {set z 0} {$z < $n} {incr z} {set PLabel$Sd$z [lindex $PP $z]}
   
set St [set plotStyle$Sd]
regsub -all \n "$St" \40 SS
for {set z 0} {$z < $n} {incr z} {set Sty$Sd$z [lindex $SS $z]}
     
for {set i 0} {$i < [expr $n*2]} {incr i} {
   set k [expr $i/2]  
   if {[expr $i%2]==0} {set Y1$Sd$k [expr round([lindex $yRange $i])]
   } else {set Y2$Sd$k [expr round([lindex $yRange $i])]} 
}

# *************** procedure to make all widgets, labels, and scrollbar ****** 
# top       toplevel based on StarID
# iter	    iteration number

proc mkWindow { top iter Sd} { 
  global bordX Ud winName$Sd WinX WinY In n 

  toplevel $top
  set h [expr 220*$n]   ;# calculate height of window based on input numbers
  set ht [expr $h+35]
  
  set geo 1060x$ht+$WinX+$WinY
  wm title $top "Ptolemy      [set winName$Sd]           Window ID= $Sd         \
                 Iteration: $iter"
  wm iconname $top "[set winName$Sd]"
  wm geometry $top $geo

  frame $top.mBar  -relief raised -bd 2
  $top.mBar config -cursor {hand2 red}
  menubutton $top.mBar.file -text File -underline 0 -menu $top.mBar.file.m 
  menubutton $top.mBar.input -text Input -underline 0 -menu $top.mBar.input.m
  menubutton $top.mBar.zoom -text Zoom -underline 0 -menu $top.mBar.zoom.m 
  button $top.mBar.quit -text Quit -command "destroy $top"
  menubutton $top.mBar.dum -width 1

  pack $top.mBar -side top  -fill x
  pack $top.mBar.dum $top.mBar.file $top.mBar.input $top.mBar.zoom \
                                                      -side left -padx 2m
  pack $top.mBar.quit -side right -padx 2m

  menu $top.mBar.input.m
  for {set t 0} {$t<$n} {incr t} {
    $top.mBar.input.m add radiobutton -label "input #[expr $t+1]" \
                                                     -variable In -value $t
  } 

  menu $top.mBar.file.m 
  $top.mBar.file.m add command -label "Print" \
                                        -command "tkPrintLogicAnalyzer $top"
  $top.mBar.file.m add command -label "Refresh" -command "tkRefresh $top $n"

  menu $top.mBar.zoom.m       
  $top.mBar.zoom.m add command -label "ZoomFit" \
                                     -command "tkZoomFit $top.lg" 
  pack [frame $top.pf -bd 2m] -side top -fill both 

  for {set m 0} {$m < $n} {incr m} {
     global PLabel$Sd$m
     set InputName [set PLabel$Sd$m]

     frame $top.d$m
     label $top.d$m.input -text "$InputName"
     pack $top.d$m.input -side top
     canvas $top.d$m.yBar$m  -bg LightCyan1 -relief sunken \
                                                 -height 5c -width 14m
     pack $top.d$m.yBar$m -side left 
     canvas $top.d$m.c$m -bg LightCyan1 -relief sunken -height 5c \
                      -xscrollcommand "$top.pf.scroll$m set" \
                      -scrollregion "0c 0c [expr $Ud*[expr $iter+2]]c 5c" \
		      -scrollincrement 1c
     pack $top.d$m.c$m -side top -fill both
     pack append $top.pf $top.d$m {top fillx}
              
     if $n==1 {
       scrollbar $top.pf.scroll0 -orient horizontal -command "$top.d0.c0 xview"
       pack  $top.pf.scroll0 -side bottom -fill x
     } else {      
       scrollbar $top.pf.scroll$m -orient horizontal \
                                                 -command "$top.d$m.c$m xview"
       pack append $top.pf $top.pf.scroll$m {top fillx}
     }
     mkYScale  $top.d$m.yBar$m $m
  } 
  tkPaginate $top    
  # to redraw the objects when the window is resized
  # updateCanvas $top.pf.c
  # bind $top.pf.c <Any-Button> "ptk
}

# ************************************************************************
# Procedure to put X-axis values on the canvas each 25 unit time iteration
# ************************************************************************
proc tkPaginate { top } {
  global iter bordX n

  for {set m 0} {$m < $n} {incr m} {
    if {$iter<25} {
        $top.d$m.c$m create text ${bordX}c 4.8c -text "0" -fill blue          
	$top.d$m.c$m create text [expr $bordX+$iter]c 4.8c -text "$iter" \
                                                             -fill blue
        $top.d$m.c$m create line [expr $bordX+$iter]c 4.5c \
                                         [expr $iter+$bordX]c 5c -fill red
    } else {  
      for {set t 0} {$t < $iter} {incr t} {
        if {[expr $t%25]==0} {
          $top.d$m.c$m create text [expr $t+$bordX]c 4.8c -text "$t" -fill blue
        }   
      }
      if {$t==$iter} { 
         $top.d$m.c$m create text [expr $t+$bordX]c 4.8c -text "$t" -fill blue
      } elseif {([expr $t-1]<$iter) && ($iter<$t)} {
         $top.d$m.c$m create text [expr $iter+$bordX]c 4.8c -text "$iter" \
                                                                     -fill blue
         $top.d$m.c$m create line [expr $iter+$bordX]c 4.5c \
                                             [expr $iter+$bordX]c 5c -fill red
      }   
    }
  } 
}

# *******************************************************************
# procedure to make Y Scale Bar (representing particle value) 
# Four units are chosen as preset distance
# ******************************************************************* 
proc mkYScale { c z } {
    global Sd   
    global bordY Ry$Sd$z By$Sd$z Y1$Sd$z Y2$Sd$z Scal$Sd$z

    set y1 [set Y1$Sd$z]; set y2 [set Y2$Sd$z]
       
    if {($y1==0) && ($y2==0)}  { set y1; set y2 4 }  ;# avoid divide by zero
    if {($y1>=0) && ($y2>=0)}  { set dy [expr $y2-$y1] 
    } elseif {($y1< 0) && ($y2< 0)} { set dy [expr abs($y2)-abs($y1)]
    } else { set dy [expr abs($y1)+abs($y2)] }
    if { $dy==0} {set dy 1}

    set Ry$Sd$z [expr 4/double($dy)]
    set Ry [set Ry$Sd$z]
    set By$Sd$z [expr $bordY+[expr $Ry*$y1]]

    set Scal$Sd$z [expr double($dy)/4]
    set scal [set Scal$Sd$z]

    set c1 [set Y1$Sd$z]
    for {set i 0} {$i <= 4} {incr i} {
       set Vy [expr $bordY-$i]
       $c create line 14m ${Vy}c 12m ${Vy}c -fill black
       $c create text 7m ${Vy}c -text "$c1" -fill blue
       set c1 [expr $c1+$scal]	
    }                   
}
   
# **********************************************************
# procedure to set the particle value and arrival time 
# **********************************************************
proc mkSetValues {starID numInputs top} {
  global bordX
  
  set Sd $starID
  set ParticleVals [grabInputs_$starID]
  set FlagState [grabInputsState_$starID]  
  upvar #0 ${starID}(arrivalTime) A_Time 
    
  for {set i 0} {$i < $numInputs} {incr i} {
	global Y1$Sd$i Y2$Sd$i

        set flag [lindex $FlagState $i]
	set y1 [set Y1$Sd$i]
	set y2 [set Y2$Sd$i]
        if $flag==1 {	
           set y [set y$i [lindex $ParticleVals $i]]
           set at [lindex $A_Time 0]
           if {($y>=$y1) && ($y<=$y2)} {mkNode .w${Sd}.d$i.c$i $at $y $i $Sd}  
	}
   }
}
 
# ***************************************************************************
# procedure to plot a node each time  the star fires a particle.The Y-coord
# represents the particle's value and the X-coord represents its arrival time.
# ***************************************************************************
# COUNT  counts the number of events in each corresponding window
# CK	 keeps track of arrival time in order to scroll canvas at each 25 events
# initX,Y  hold the initial vlue of each arrival time and particle value
# nodeX,Y  hold each particles scaled x&y value in an array baesd on nodes IDs 
# valX,y   hold the initial values of particles to display to user
# DX,y	   hold the particles scaled values to be used in refresh procedure
	 
proc mkNode { canv x y z Sd} { 
   global nodeX nodeY DX DY initX initY valX valY bordX bordY Cnt$Sd$z
   global Ck$Sd$z Ry$Sd$z Px$Sd$z Py$Sd$z Rd  By$Sd$z Sty$Sd$z NodeList$Sd$z 
   
   set COUNT [set Cnt$Sd$z]
   set CK [set Ck$Sd$z]
   set dx [expr $x+$bordX]
   set by [set By$Sd$z]
   set Ry [set Ry$Sd$z] 
   set dy [expr $by-[expr $Ry*$y]]
   set st [set Sty$Sd$z]

   if {$COUNT==0} {set Px$Sd$z $dx; set Py$Sd$z $dy
     } else {
       set px [set Px$Sd$z]; set py [set Py$Sd$z]
       if { $st=="zero" } {              
          $canv create line ${px}c ${py}c ${dx}c ${py}c -fill blue
          $canv create line ${dx}c ${py}c ${dx}c ${dy}c -fill blue
       }
       if { $st=="connect" } {
          $canv create line ${px}c ${py}c ${dx}c ${dy}c -fill blue
       }
       set Px$Sd$z $dx; set Py$Sd$z $dy 
     } 
      
   set new [$canv create oval [expr $dx-$Rd]c [expr $dy-$Rd]c \
      [expr $dx+$Rd]c [expr $dy+$Rd]c -outline black -fill red -tags node]

 lappend NodeList$Sd$z $new ;# keep a list of plotted particles' IDs to be used
			    ;# in event binding

   set initX($Sd,$z,$COUNT) $x;  set initY($Sd,$z,$COUNT) $y
   set DX($Sd,$z,$COUNT) $dx; set DY($Sd,$z,$COUNT) $dy
   set valX($Sd,$z,$new) $x;     set valY($Sd,$z,$new) $y
   set nodeX($Sd,$z,$new) $dx;   set nodeY($Sd,$z,$new) $dy
      
   # *** scroll each canvas based on arrival of 25th event on that canvas   
   set sc [expr round($x)] 
   if {[expr $sc/25]==$CK} {
       $canv xview $sc
       incr Ck$Sd$z
   }
   incr Cnt$Sd$z
}

# *********************************************************
#  Procedure to redraw all objects on the initial windows *
# ********************************************************* 
proc tkRefresh {canv n} {
   global nodeX nodeY initX initY DX DY Rd valX valY
  
   set Sd [string trim $canv .w] 
   for {set z 0} {$z < $n} {incr z} {
     global Cnt$Sd$z Sty$Sd$z NodeList$Sd$z

     $canv.d$z.c$z delete all
     set NodeList$Sd$z {}
     set st [set Sty$Sd$z]
     set COUNT [set Cnt$Sd$z]
     for {set i 0} {$i < $COUNT} {incr i} {
       set dx $DX($Sd,$z,$i);  set dy $DY($Sd,$z,$i)
       set new [$canv.d$z.c$z create oval [expr $dx-$Rd]c [expr $dy-$Rd]c \
               [expr $dx+$Rd]c [expr $dy+$Rd]c -outline black \
                                               -fill red -tags node]
       lappend NodeList$Sd$z $new

       if {$i==0} {set Px$Sd$z $dx; set Py$Sd$z $dy
       } else {
         set px [set Px$Sd$z]; set py [set Py$Sd$z]
         if { $st=="zero" } {              
            $canv.d$z.c$z create line ${px}c ${py}c ${dx}c ${py}c -fill blue
            $canv.d$z.c$z create line ${dx}c ${py}c ${dx}c ${dy}c -fill blue
         }

         if { $st=="connect" } {
            $canv.d$z.c$z create line ${px}c ${py}c ${dx}c ${dy}c -fill blue
         }
         set Px$Sd$z $dx; set Py$Sd$z $dy 
       }
       set nodeX($Sd,$z,$new) $dx
       set nodeY($Sd,$z,$new) $dy
       set valX($Sd,$z,$new) $initX($Sd,$z,$i)
       set valY($Sd,$z,$new) $initY($Sd,$z,$i)
     }
   } 
   tkPaginate $canv  
}


# *****************************************************
# Procedure to make new window for ZoomFit purpose
# *****************************************************
proc mkWinFit {top sd} { 
  global n E1 E2

  toplevel $top
  set h1 [expr 240*$n]
  set Ht [expr $h1+35]
  set geo 1060x$Ht+0+0

  wm title $top "Ptolemy              Zoom Fit "
  wm iconname $top "ZoomFit"
  wm geometry $top $geo
  
  frame $top.mBar  -relief raised -bd 2
  $top.mBar config -cursor {hand2 red}
  menubutton $top.mBar.file -text File -underline 0 -menu $top.mBar.file.m
  menubutton $top.mBar.input -text Input -underline 0 -menu $top.mBar.input.m 
  menubutton $top.mBar.zoom -text Zoom -underline 0 -menu $top.mBar.zoom.m 
  button $top.mBar.quit -text Quit -command "destroy $top"

  pack $top.mBar -side top  -fill x
  pack $top.mBar.file $top.mBar.input $top.mBar.zoom -side left -padx 2m
  pack $top.mBar.quit -side right -padx 2m
  pack [frame $top.pf -bd 2m] -side top -fill both

  menu $top.mBar.file.m 
  $top.mBar.file.m add command -label "Print" \
                       -command "tkPrintLogicAnalyzer $top"
  menu $top.mBar.input.m
  for {set t 0} {$t<$n} {incr t} {
    $top.mBar.input.m add radiobutton -label "input #[expr $t+1]" \
                                                     -variable In -value $t
  } 

  menu $top.mBar.zoom.m       
  $top.mBar.zoom.m add command -label "ZoomFit" -command "tkZoomFit $top"
 
  for {set m 0} {$m < $n} {incr m} {
     global PLabel$sd$m

     frame $top.d$m
     set InputName [set PLabel$sd$m]
     label $top.d$m.input -text "$InputName"
     pack $top.d$m.input -side top
     canvas $top.d$m.c$m -bg LightCyan1 -relief sunken -height 6c 
     pack $top.d$m.c$m -side top -fill both
     pack append $top.pf $top.d$m {top fillx}
  }   
}

# *************************************************
# Procedure to draw X & Y axis on zoom fit window
# *************************************************
proc mkZoomXYBar { c dE Rt Bdx z Sd} {
    global E1 bordY Scal$Sd$z Y1$Sd$z

    #**** Draw Y-axis and its tick marks    
    $c create line 14m [expr $bordY+.8]c 14m .2c -fill black
    set c1 [set Y1$Sd$z]
    set scal [set Scal$Sd$z]

    for {set i 0} {$i <= 4} {incr i} {
       set Vy [expr $bordY-$i]
       $c create line 14m ${Vy}c 12m ${Vy}c -fill black
       $c create text 7m ${Vy}c -text "$c1" -fill blue
       set c1 [expr $c1+$scal]	
    }
    
    #**** Draw X-axis and its tick marks
    set tmp $E1
    $c create line 14m [expr $bordY+.8]c 27c [expr $bordY+.8]c -fill black
    set Xscal [expr double($dE)/5]
      
    for {set i 0} {$i <= 25} {incr i 5} {
      set vX [expr $i+$Bdx]    ;# set the X-axis values
      $c create line ${vX}c [expr $bordY+1.1]c ${vX}c [expr $bordY+.7]c \
                                                               -fill black
      $c create text [expr $vX+.2]c 5.8c -text $tmp -fill blue
      set tmp [expr $tmp+$Xscal]
    }
}

# ********************************************************************
# Procedure to popup an entry window to get the range of particles  to
# be zoomed. It grabs application focus and blocks other procedures to
# work untill a range to be set.
# ********************************************************************
proc tkTimeRangeEntry { timeEntry } {
  global E1 E2 starID DotsOnOff s

  toplevel $timeEntry -bd 2
  wm title $timeEntry "Ptolemy  Time Range"
  wm iconname $timeEntry "TimeRange" 
  wm geometry $timeEntry 300x75+520+0
  wm minsize $timeEntry 300 75
  wm maxsize $timeEntry 490 75

  frame $timeEntry.s -bd 2
  label $timeEntry.s.f1 -text "Display Samples From Time"
  entry $timeEntry.s.f2 -width 5 -relief sunken -textvariable E1
  label $timeEntry.s.f3 -text "To"
  entry $timeEntry.s.f4 -width 5 -relief sunken -textvariable E2
  pack  $timeEntry.s.f1 $timeEntry.s.f2 $timeEntry.s.f3 $timeEntry.s.f4 \
                                               -side left -expand 1 -fill x
  frame $timeEntry.dot -bd 2 -width 90
  label $timeEntry.dot.lab  -text "Dots Option: "
  radiobutton $timeEntry.dot.on -text "On" -var DotsOnOff   -relief flat -val 1
  radiobutton $timeEntry.dot.off -text "Off" -var DotsOnOff -relief flat -val 0
  pack append $timeEntry.dot $timeEntry.dot.lab {left padx 20} \
                             $timeEntry.dot.on left $timeEntry.dot.off left 

  button $timeEntry.ok -text OK -relief raised -command "destroy $timeEntry"  
  pack $timeEntry.s $timeEntry.dot $timeEntry.ok -side top -fill x

  grab set $timeEntry
  tkwait window $timeEntry
}

# **************************************************************
# Procedure to fit all desired numbers of objects in the window 
# **************************************************************
proc tkZoomFit {canv} {
  global DY valX valY initX initY 
  global Rd bordX iter tw E1 E2 DotsOnOff n 
  
  set w $tw.zent
  tkTimeRangeEntry $w
  regexp -nocase {.?([a-z]+)?([0-9]+)?.}  $canv k
  set Sd [string trim $k .w]

  # ***** make sure that E1>=0; E1<E2; dE#0; E1<iteration number;
  if {($E1>$iter) && ($E2>$iter)} {set E1 0; set E2 $iter}
  if {$E1>$iter} {set E1 0}
  if {$E2>$iter} {set E2 $iter}  
  if {$E2<$E1} {set tmp $E1; set E1 $E2; set E2 $tmp}
  if {$E1<0} {set E1 0}

  set dE [expr $E2-$E1]
  if {$dE==0} {set dE 1}
  set Rt [expr 25/double($dE)]
  set Bdx [expr $bordX+1.4]
  set Bx [expr $Bdx-[expr $Rt*$E1]]
  if {![winfo exists $canv]} { mkWinFit $canv $Sd}
    
  for {set z 0} {$z < $n} {incr z} {
    global Cnt$Sd$z ZCnt$Sd$z Sty$Sd$z 

    set st [set Sty$Sd$z]
    set CNT [set Cnt$Sd$z]
    set ZCNT [set ZCnt$Sd$z]
    $canv.d$z.c$z delete all
    for {set i 0} {$i < $CNT} {incr i} {
       if {($initX($Sd,$z,$i)>=$E1) && ($initX($Sd,$z,$i)<=$E2)} {
          set tx [expr $Rt*$initX($Sd,$z,$i)]
	  set dy $DY($Sd,$z,$i)
          set e  [expr $E1*$Rt]
          set dx [expr $tx+$Bx]

    if {$DotsOnOff==1} {
          set id [$canv.d$z.c$z create oval [expr $dx-$Rd]c [expr $dy-$Rd]c \
                            [expr $dx+$Rd]c [expr $dy+$Rd]c -outline black \
                                                      -fill red -tags node]
    }
        
    if {$ZCNT==0} {set Px$Sd$z $dx; set Py$Sd$z $dy
    } else {
        set px [set Px$Sd$z]; set py [set Py$Sd$z]
        if { $st=="zero" } {              
             $canv.d$z.c$z create line ${px}c ${py}c ${dx}c ${py}c -fill blue
             $canv.d$z.c$z create line ${dx}c ${py}c ${dx}c ${dy}c -fill blue
           }

        if { $st=="connect" } {
             $canv.d$z.c$z create line ${px}c ${py}c ${dx}c ${dy}c -fill blue
           }
           set Px$Sd$z $dx; set Py$Sd$z $dy 
        } 
        incr ZCNT      
        } elseif {$initX($Sd,$z,$i)>=$E2} { break}    	
    }   
    mkZoomXYBar $canv.d$z.c$z $dE $Rt $Bdx $z $Sd
   }  
}
  
# *************************************
# main call to create the platform 
# *************************************
set tw .w${Sd}
mkWindow $tw $iter $Sd

# **call goTcl procedure 
proc goTcl_$starID {starID} "
   mkSetValues $starID [set ${starID}(numInputs)] .w${Sd}
"
# ************************************************************************
# Procedure to show the value of each Particle and its arrival time upon
# pressing <Button-1>
# ************************************************************************ 
proc tkShowXYval  { valMsg curN wd k} {   
   global valX valY Sd

   set x [expr double(round([expr $valX($wd,$k,$curN)*100]))/100]
   set y [expr double(round([expr $valY($wd,$k,$curN)*100]))/100]

   if {![winfo exists $valMsg]} {  
      toplevel $valMsg 

      wm geometry $valMsg 170x50+830+0
      text $valMsg.val -relief raised -width 20 -height 10 \
                               -font -Adobe-Helvetica-Medium-R-Normal--*-130-*  
      button $valMsg.ok -text OK -relief raised -bd 2 -command "destroy $valMsg"
      pack $valMsg.ok -side bottom -fill x
      pack $valMsg.val -side top -expand 1
   
   }
   $valMsg.val delete 1.0 end
   $valMsg.val insert @510,10 "($x)( $y)"
}

# ****************************************************************************
# Procedure to draw X & Y lines from node to scale bar by pressing <Button-2> 
# ****************************************************************************
proc tkDrawXYCoord { canv curN wd k} {
   global nodeX nodeY 

   $canv create line $nodeX($wd,$k,$curN)c $nodeY($wd,$k,$curN)c \
                                        0c $nodeY($wd,$k,$curN)c -fill red
   $canv create line $nodeX($wd,$k,$curN)c $nodeY($wd,$k,$curN)c \
                                        $nodeX($wd,$k,$curN)c 5c -fill red   
} 

# **************************************************************************
# Procedure to call the print procedure from ptkPlot (Tcl script for XYPlot)
# **************************************************************************
proc tkPrintLogicAnalyzer { top } {
    global In

    ptkPrintXYPlot $top $top.d$In.c$In "Logic Analyzer"

}

# *************************************************
# Bind all XEvents with Tcl Commands 
# It's set to max number of five inputs (portholes)
# For more inputs you must add binding code
# *************************************************
bind Canvas <Enter> { set Path %W ;tkBindXevent $Path }

proc tkBindXevent { Path } {
   global tw In
   
   $Path bind node <Any-Enter> {
                   $Path itemconfigure current -fill white
    }

   $Path bind node <Any-Leave> {
              $Path itemconfigure current -fill red
    }

   bind $Path <Button-1> { 
    set curN [$Path find withtag current]
    regexp -nocase {.?([a-z]+)?([0-9]+)?.}  $Path k
    set k1 [string trim $k .w] 
    regexp {[0-9]+$} $Path k2
   if {($curN !="") && ([lsearch -exact [set NodeList$k1$k2] $curN] != -1)} {
           tkShowXYval $tw.mg $curN $k1 $k2  
      }
   }

   bind $Path <Button-2> {
    set curN [$Path find withtag current]
    regexp -nocase {.?([a-z]+)?([0-9]+)?.}  $Path k
    set k1 [string trim $k .w]
    regexp {[0-9]+$} $Path k2
    if {($curN !="") && ([lsearch -exact [set NodeList$k1$k2] $curN] != -1)} {
         tkDrawXYCoord $Path $curN $k1 $k2 
      }
   }   
}

focus .w${Sd}.pf





