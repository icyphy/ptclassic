defstar {
	name {Burg}
	domain {SDF}
	version {$Id$}
	desc {
This star uses Burg's algorithm to estimate the linear predictor coefficients
of an input random process.
These coefficients are produced both in autoregressive form
(on the "lp" output) and in lattice filter form (on the "refl" output).
The "errPower" output is the power of the prediction error as a function
of the predictor order.
	}
	author { E. A. Lee and J. T. Buck }
	copyright {
Copyright (c) 1990-1994 The Regents of the University of California.
All rights reserved.
See the file $PTOLEMY/copyright for copyright notice,
limitation of liability, and disclaimer of warranty provisions.
	}
	location { SDF dsp library }
	explanation {
.pp
.Id "Burg's algorithm"
.Ir "linear prediction"
.Ir "spectral estimation, maximum entropy"
.Ir "maximum entropy spectral estimation"
The number of inputs looked at is given by the \fInumInputs\fR parameter
and the order of the autoregressive (AR) model is given by
the \fIorder\fR parameter.
.Ir "autoregressive model"
.Ir "AR model"
The order specifies how many outputs appear on the \fIlp\fR and
\fIrefl\fR output portholes.
These outputs are, respectively, the autoregressive (AR) parameters
(also called the linear predictor parameters),
and the reflection coefficients.
.Ir "reflection coefficients"
.Ir "coefficients, reflection"
.pp
The autoregressive (AR) coefficients are the estimated coefficients of
the all-pole filter that could have produced the observations
(input data) given a white noise input.
The transfer function of the all-pole filter is:
.EQ
H(z) ~=~ 1 over {1 ~+~ sum from n=1 to N d sub n z sup -n }
.EN
where $d$ is the set of AR coefficients.
.pp
Note that the definition of reflection coefficients is not quite
universal in the literature.
The reflection coefficients in references [2] and [3]
are the negative of the ones generated by this star,
which correspond to the definition in most other texts,
and to the definition of partial-correlation (PARCOR)
coefficients in the statistics literature.
.Ir "partial correlation coefficients"
.Ir "coefficients, partial correlation"
.Ir "PARCOR"
.pp
The \fIerrPower\fR output is the power of the prediction error
as a function of the model order.
There are $order+1$ output samples, and the first sample corresponds
to the prediction error of a zero-th order predictor.
This is simply an estimate of the input signal power.
.Id "Makhoul, J."
.Id "Kay, S. M."
.Id "Haykin, S."
.UH References
.ip [1]
J. Makhoul, "Linear Prediction: A Tutorial Review",
\fIProc. IEEE\fR, Vol. 63, pp. 561-580, Apr. 1975.
.ip [2]
S. M. Kay, \fIModern Spectral Estimation: Theory & Application\fR,
Prentice-Hall, Englewood Cliffs, NJ, 1988.
.ip [3]
S. Haykin, \fIModern Filters\fR, MacMillan Publishing Company,
New York, 1989.
	}
	seealso { LevDur, linearPrediction, powerSpectrum }
	input {
		name {input}
		type {float}
		desc { Input random process. }
	}
	output {
		name {lp}
		type {float}
		desc { AR coefficients output. }
	}
	output {
		name {refl}
		type {float}
		desc { Lattice predictor coefficients output. }
	}
	output {
		name {errPower}
		type {float}
		desc { Prediction error power. }
	}
	defstate {
		name {order}
		type {int}
		default {8}
		desc {The number of reflection coefficients to generate.}
	}
	defstate {
		name {numInputs}
		type {int}
		default {64}
		desc { The number of inputs used to estimate the model.}
	}
	protected {
		double *f, *b, *aOrig, *aPrime;
		int N, M;
	}
	constructor {
		f = b = aOrig = aPrime = 0;
		N = M = 0;
	}
	destructor {
		LOG_DEL; delete [] f;
		LOG_DEL; delete [] b;
		LOG_DEL; delete [] aOrig;
		LOG_DEL; delete [] aPrime;
	}
	setup {
		if (N != int(numInputs)) {
			LOG_DEL; delete [] f;
			LOG_DEL; delete [] b;
			N = int(numInputs);
			LOG_NEW; f = new double[N];
			LOG_NEW; b = new double[N];
		}
		if (M != int(order)) {
			LOG_DEL; delete [] aOrig;
			LOG_DEL; delete [] aPrime;
			M = int(order);
			LOG_NEW; aOrig = new double[M+1];
			LOG_NEW; aPrime = new double[M+1];
		}
		refl.setSDFParams (int(order), int(order)-1);
		lp.setSDFParams (int(order), int(order)-1);
		errPower.setSDFParams (int(order)+1, int(order));
		input.setSDFParams (int(numInputs), int(numInputs)-1);
	}
	go {
	    // Define pointers so that the arrays can be swapped
	    double* a = aOrig;
	    double* aP = aPrime;
	    double gamma, dsum, nsum;

	    // initialize the forward and backward predictor errors
	    // and the prediction error power estimate
	    int count = 0;
	    double ep = 0.0;	// error power estimate
	    for (int i = N-1; i >= 0; i--) {
		double x = input%i;
		f[count] = x;
		b[count++] = x;
		ep += x * x;
	    }
	    ep = ep/N;
	    // output the zeroth order prediction error, which is simply
	    // the power estimate of the input
	    errPower%M << ep;

	    // Iterate on the predictor order
	    for (int m = 1; m <= M; m++ ) {
	        // Compute the reflection coefficients, and output them
		nsum = 0.0;
		dsum = 0.0;
		for (i = m; i < N; i++) {
		    nsum += f[i]*b[i-1];
		    dsum += f[i]*f[i] + b[i-1]*b[i-1];
		}
		gamma = -2*nsum/dsum;
		refl%(M-m) << - gamma;

		// update the forward and backward predictor errors
		for (i = N-1; i >= m; i--) {
		    double tempf = f[i];
		    f[i] = tempf + gamma*b[i-1];
		    b[i] = b[i-1] + gamma*tempf;
		}

		// update the prediction error power estimate
		ep = (1 - gamma*gamma) * ep;
		errPower%(M-m) << ep;

		// Update the FIR predictor coefficient estimates
		for (i = 1; i < m; i++) {
		    aP[i] = a[i] + gamma * a[m-i];
		}
		aP[m] = gamma;

		// Swap a and aP for next order recurrence
		double* temp = a;
		a = aP;
		aP = temp;
	    }
	    // generate the lp outputs
	    for (m = 1; m <= M; m++ ) {
		lp%(M-m) << -a[m];
	    }
	}
}
