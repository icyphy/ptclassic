#ifndef lint
static char SccsId[]="$Id$";
#endif /*lint*/
/*
Copyright (c) 1990-%Q% The Regents of the University of California.
All rights reserved.

Permission is hereby granted, without written agreement and without
license or royalty fees, to use, copy, modify, and distribute this
software and its documentation for any purpose, provided that the
above copyright notice and the following two paragraphs appear in all
copies of this software.

IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY
FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF
THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF
SUCH DAMAGE.

THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE
PROVIDED HEREUNDER IS ON AN "AS IS" BASIS, AND THE UNIVERSITY OF
CALIFORNIA HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,
ENHANCEMENTS, OR MODIFICATIONS.

						PT_COPYRIGHT_VERSION_2
						COPYRIGHTENDKEY
*/
/*       crossCap.c
 *
 *       Author: Enrico Malavasi
 *       Ver. 1.00  -  Last revised: August 1991
 *
 *       Exported function: pepCrossCapacitance(). It returns the cross-coupling
 *       capacitance between two objects (nets, terms, segments.
 *       Capacitance is given in Farad.
 */
#include "port.h"
#include "copyright.h"
#include "utility.h"
#include "oct.h"
#include "region.h"
#include "oh.h"
#include "fang.h"
#include "harpoon.h"
#include "tap.h"
#include "th.h"
#include "errtrap.h"
#include "pepint.h"        /*  Includes pep.h too */

#define    MAX_PEP_DISTANCE    300     /* 15 lambda  - halo size */

static int
pepNewTerm(term, terms, termsNo)
    octObject *term;              /*  Term to check  */
    octId    **terms;             /*  Terminal stack */
    int       *termsNo;           /*  Stack size */
/* 
 *  If the given terminal has already been considered for capacitance
 *  extraction, it returns 0. Otherwise it is inserted into a stack and
 *  1 is returned
 */
{
    int  i;        /*  Loop counter */

    for(i=0 ; i<*termsNo ; i++) {
	if(octIdsEqual(term->objectId, (*terms)[i])) {
	    return 0;
	}
    }
  
    if(*termsNo > 0) {
	*terms = REALLOC( octId, *terms, *termsNo+1);
    }
    (*terms)[(*termsNo)++] = term->objectId;
    return 1;
}

static double
pepNetCap(facet, net, obj)
    octObject  *facet;             /*  Facet  */
    octObject  *net;               /*  Net  */
    octObject  *obj;               /*  Object  */
/*
 *  It returns the capacitance between all the objects of the given net
 *  and the given object. Operates recursively if obj is another net.
 */
{
    octObject  path;              /*  Path  */
    octObject  term1, term2;      /*  Terminals */
    octGenerator  Gener;          /*  Path generator */
    octGenerator  TGener;         /*  Term generator */
    double    pepCap = 0.0;       /*  Capacitance    */
    octId    *terms;		  /*  Stack of terms  */
    int       termsNo;            /*  Stack size */
 
    terms = ALLOC(octId, 1 );
    termsNo = 0;
    OH_ASSERT(octInitGenContents(net, OCT_PATH_MASK, &Gener));
    while(octGenerate(&Gener, &path) == OCT_OK) {
	OH_ASSERT(octInitGenContents(&path, OCT_TERM_MASK, &TGener));
	if(octGenerate(&TGener, &term1) == OCT_OK) {
	    if(octGenerate(&TGener, &term2) == OCT_OK) {
		if(pepNewTerm(&term1, &terms, &termsNo)) {
		    pepCap += pepCrossCapacitance(&term1, obj);
		}
		if(pepNewTerm(&term2, &terms, &termsNo)) {
		    pepCap += pepCrossCapacitance( &term2, obj);
		}
		pepCap += pepCrossCapacitance( &path, obj);
	    }
	}
    }
    if(termsNo > 0) {
	FREE(terms);
	termsNo = 0;
    }
    return pepCap;
}

static double
pepCapSameLayer(facet, bb1, bb2, layer)
    octObject  *facet;                 /*  Facet  */
    pepBox     *bb1, *bb2;             /*  Objects */
    octObject  *layer;                 /*  Common layer */
/*
 *  This function returns the capacity between two rectangular objects
 *  on the same layer.
 */
{
    pepBox     BB1, BB2;            /* Bounding boxes    */
    octBox     sBB;	            /* Separation box    */
    octObject  item;                /* Object generated by region */
    octObject  itemLayer;           /* Layer of the object generated by region */
    regObjGen  regGener;            /* Region generator  */
    octCoord distx, disty;          /* Horizontal and vertical distance */
    octCoord dist, width;           /* Distance and alignment size */
    octCoord w1 = (octCoord)0, w2 = (octCoord)0 ;   /* Wire segment widths */
    char      *lname;               /* Layer name */

    BB1 = *bb1;
    BB2 = *bb2;

    sBB.lowerLeft.x  = MIN(BB1.bb.upperRight.x, BB2.bb.upperRight.x);
    sBB.upperRight.x = MAX(BB1.bb.lowerLeft.x,  BB2.bb.lowerLeft.x);
    distx = sBB.upperRight.x - sBB.lowerLeft.x;
    if((distx > 0) &&
       ((! (BB1.freeSides & TAP_RIGHT)) || (! (BB2.freeSides & TAP_LEFT)))) {
	return ((double) 0.0);
    }

    sBB.lowerLeft.y  = MIN(BB1.bb.upperRight.y, BB2.bb.upperRight.y);
    sBB.upperRight.y = MAX(BB1.bb.lowerLeft.y,  BB2.bb.lowerLeft.y);
    disty = sBB.upperRight.y - sBB.lowerLeft.y;
    if((disty > 0) &&
       ((! (BB1.freeSides & TAP_TOP)) || (! (BB2.freeSides & TAP_BOTTOM)))) {
	return ((double) 0.0);
    }
       
    dist  =   MAX(distx, disty);
    width = - MIN(distx, disty);

    /*
     *  Capacitance is calculated if the objects are aligned, not too far
     *  from each other and not shorted
     */
    if(width <= 0) return ((double) 0.0);
    if(dist > MAX_PEP_DISTANCE)  return ((double) 0.0);
    if(dist <= 0) {
	fprintf(stderr, "WARNING: short detected by PEP:\n");
	fprintf(stderr, "  The objects located in (%ld,%ld)-(%ld,%ld) and in ",
		(long)BB1.bb.lowerLeft.x, (long)BB1.bb.lowerLeft.y,
		(long)BB1.bb.upperRight.x, (long)BB1.bb.upperRight.y);
	fprintf(stderr, "(%ld,%ld)-(%ld,%ld) on layer %s\n  are shorted but belong to different nets\n",
		(long)BB2.bb.lowerLeft.x, (long)BB2.bb.lowerLeft.y,
		(long)BB2.bb.upperRight.x, (long)BB2.bb.upperRight.y,
		layer->contents.layer.name);
	return 0;
    }
    if(distx < 0) {
      SWAP(octCoord, sBB.lowerLeft.x, sBB.upperRight.x);
      w1 = bb1->bb.upperRight.y - bb1->bb.lowerLeft.y;
      w2 = bb2->bb.upperRight.y - bb2->bb.lowerLeft.y;
    }
    if(disty < 0) {
      SWAP(octCoord, sBB.lowerLeft.y, sBB.upperRight.y);
      w1 = bb1->bb.upperRight.x - bb1->bb.lowerLeft.x;
      w2 = bb2->bb.upperRight.x - bb2->bb.lowerLeft.x;
    }
  
    /*   Check whether there are obstacles ON THE SAME LAYER.
     *   Ignore the obstacles on other layers.
     */
    sBB.lowerLeft.x += 1;     sBB.upperRight.x -= 1;
    sBB.lowerLeft.y += 1;     sBB.upperRight.y -= 1;
    lname = "";
    regObjStart(facet, &sBB, OCT_GEO_MASK|OCT_INSTANCE_MASK, &regGener, 0);
    while(regObjNext(regGener, &item) != REG_NOMORE) {
	if ( item.type == OCT_INSTANCE ) { /*  */
	    return (double) 0.0;
	}
	while(pepGenNextLayer(&item, &itemLayer, lname) == OCT_OK) {
	    if(octIdsEqual(layer->objectId, itemLayer.objectId)) {
		return ((double) 0);
	    }
	    lname = itemLayer.contents.layer.name;
	}
    }
    regObjFinish(regGener);

    return  pepModParallel(dist, w1, w2, width, layer);
}

static double
pepCapDiffLayers(facet, bb1, bb2, layer1, layer2)
    octObject  *facet;            /*  Facet  */
    pepBox     *bb1, *bb2;        /*  Objects */
    octObject  *layer1, *layer2;  /*  Layers */
/*
 *  Return the capacitance between two objects on different layers.
 */
{
    pepBox     sBB;               /*  Overlap box */
    octBox     extBB;
    unsigned int areaFlag;
    octObject  item;              /*  Object generated by region */
    octObject  itemLayer;         /*  Layer of the object generated by region */
    regObjGen  regGener;          /*  Region generator */
    double     hgt1, hgt2, hgt;   /*  Layer heights */
    double     pepCap = 0.0;
    octCoord   dist;

    areaFlag = 1;

    sBB.bb.lowerLeft.x =  MAX(bb1->bb.lowerLeft.x, bb2->bb.lowerLeft.x);
    sBB.bb.upperRight.x = MIN(bb1->bb.upperRight.x, bb2->bb.upperRight.x);

    sBB.bb.lowerLeft.y =  MAX(bb1->bb.lowerLeft.y, bb2->bb.lowerLeft.y);
    sBB.bb.upperRight.y = MIN(bb1->bb.upperRight.y, bb2->bb.upperRight.y);

    sBB.freeSides = 0;
    dist = (-1);
    if(sBB.bb.lowerLeft.x >= sBB.bb.upperRight.x) {
	areaFlag = 0;
	SWAP(octCoord, sBB.bb.lowerLeft.x, sBB.bb.upperRight.x);
	dist = ohBoxWidth(&(sBB.bb));
	if(ohBoxWidth(&(sBB.bb)) > MAX_PEP_DISTANCE)  return ((double) 0.0);
	if((bb1->bb.upperRight.x < bb2->bb.lowerLeft.x) &&
	   ((! (bb1->freeSides & TAP_RIGHT)) || (! (bb2->freeSides & TAP_LEFT))))
	  return ((double) 0.0);
	if((bb2->bb.upperRight.x < bb1->bb.lowerLeft.x) &&
	   ((! (bb2->freeSides & TAP_RIGHT)) || (! (bb1->freeSides & TAP_LEFT))))
	  return ((double) 0.0);
	sBB.freeSides |= (TAP_LEFT | TAP_RIGHT);
    }
    if(sBB.bb.lowerLeft.y >= sBB.bb.upperRight.y) {
	if(areaFlag == 0)   return ((double) 0.0);
	areaFlag = 0;
	SWAP(octCoord, sBB.bb.lowerLeft.y, sBB.bb.upperRight.y);
	dist = ohBoxHeight(&(sBB.bb));
	if(ohBoxHeight(&(sBB.bb)) > MAX_PEP_DISTANCE)  return ((double) 0.0);
	if((bb1->bb.upperRight.y < bb2->bb.lowerLeft.y) &&
	   ((! (bb1->freeSides & TAP_TOP)) || (! (bb2->freeSides & TAP_BOTTOM))))
	  return ((double) 0.0);
	if((bb2->bb.upperRight.y < bb1->bb.lowerLeft.y) &&
	   ((! (bb2->freeSides & TAP_TOP)) || (! (bb1->freeSides & TAP_BOTTOM))))
	  return ((double) 0.0);
	sBB.freeSides |= (TAP_BOTTOM | TAP_TOP);
    }

    if(dist < 0) {
	if(sBB.bb.lowerLeft.x  == bb1->bb.lowerLeft.x)
	    sBB.freeSides |= (bb1->freeSides & TAP_LEFT);
	 if(sBB.bb.lowerLeft.x == bb2->bb.lowerLeft.x)
	    sBB.freeSides |= (bb2->freeSides & TAP_LEFT);

	if(sBB.bb.lowerLeft.y == bb1->bb.lowerLeft.y)
	    sBB.freeSides |= (bb1->freeSides & TAP_BOTTOM);
	 if(sBB.bb.lowerLeft.y == bb2->bb.lowerLeft.y)
	    sBB.freeSides |= (bb2->freeSides & TAP_BOTTOM);

	if(sBB.bb.upperRight.x == bb1->bb.upperRight.x)
	    sBB.freeSides |= (bb1->freeSides & TAP_RIGHT);
	 if(sBB.bb.upperRight.x == bb2->bb.upperRight.x)
	    sBB.freeSides |= (bb2->freeSides & TAP_RIGHT);

	if(sBB.bb.upperRight.y == bb1->bb.upperRight.y)
	    sBB.freeSides |= (bb1->freeSides & TAP_TOP);
	 if(sBB.bb.upperRight.y == bb2->bb.upperRight.y)
	    sBB.freeSides |= (bb2->freeSides & TAP_TOP);
    }
    
    /*   Check whether there are obstacles ON OTHER LAYERS between layer1 and layer2.
     */
    hgt1 = thGetLayerPropReal(layer1, "HEIGHT");
    hgt2 = thGetLayerPropReal(layer2, "HEIGHT");
    if(hgt1 > hgt2)
      SWAP(double, hgt1, hgt2);

    if(dist != 0) {
	extBB.lowerLeft.x  = sBB.bb.lowerLeft.x+1;
	extBB.lowerLeft.y  = sBB.bb.lowerLeft.y+1;
	extBB.upperRight.x = sBB.bb.upperRight.x-1;
	extBB.upperRight.y = sBB.bb.upperRight.y-1;
	regObjStart(facet, &extBB, OCT_GEO_MASK, &regGener, 0);
	while(regObjNext(regGener, &item) != REG_NOMORE) {
	    OH_ASSERT(pepGenNextLayer(&item, &itemLayer, ""));
	    hgt = thGetLayerPropReal(&itemLayer, "HEIGHT");
	    if((hgt > hgt1) && (hgt < hgt2)) {
		return ((double) 0.0);
	    }
	}
	regObjFinish(regGener);
    }

    /*  Area capacitance */
    if(areaFlag) {
	pepCap = pepModOverlapArea(ohBoxArea( &(sBB.bb) ), layer1, layer2);
    }
/*    if(sBB.freeSides & TAP_TOP)
        pepCap += pepModFringe(ohBoxWidth(&(sBB.bb)), (dist < 0) ? -ohBoxHeight(&(sBB.bb)) : dist,
			       layer1, layer2);
    if(sBB.freeSides & TAP_BOTTOM)
        pepCap += pepModFringe(ohBoxWidth(&(sBB.bb)), (dist < 0) ? -ohBoxHeight(&(sBB.bb)) : dist,
			       layer1, layer2);
    if(sBB.freeSides & TAP_RIGHT)
        pepCap += pepModFringe(ohBoxHeight(&(sBB.bb)), (dist < 0) ? -ohBoxWidth(&(sBB.bb)) : dist,
			       layer1, layer2);
    if(sBB.freeSides & TAP_LEFT)
        pepCap += pepModFringe(ohBoxHeight(&(sBB.bb)), (dist < 0) ? -ohBoxWidth(&(sBB.bb)) : dist,
			       layer1, layer2);
*/
    return pepCap;
}

static double
  pathDiffLayers(path1, path2, bb1, bb2, layer1, layer2)
octObject *path1;
octObject *path2;
pepBox    *bb1;
pepBox    *bb2;
octObject *layer1;
octObject *layer2;
{
    octBox    sBB;
    octCoord  spac;
    octCoord  w1, w2;
    octCoord  side;
    struct octPoint  pts1[2], pts2[2], *pts;      /*  Points at the ends of the path */
    int32  n;
    int    vert1 = 0;
    int    vert2 = 0;
    double  pepCap;
    double  ratio;

    ohGetPoints(path1, &n, &pts);
    if(n != 2) errRaise(PEP_PKG_NAME, 1, "Wrong number of points found in path");
    pts1[0] = pts[0]; pts1[1] = pts[1];
    ohGetPoints(path2, &n, &pts);
    if(n != 2) errRaise(PEP_PKG_NAME, 1, "Wrong number of points found in path");
    pts2[0] = pts[0]; pts2[1] = pts[1];

    if(pts1[0].x > pts1[1].x) 	SWAP(struct octPoint, pts1[0], pts1[1]);
    if(pts1[0].y > pts1[1].y) 	SWAP(struct octPoint, pts1[0], pts1[1]);
    if(pts2[0].x > pts2[1].x) 	SWAP(struct octPoint, pts2[0], pts2[1]);
    if(pts2[0].y > pts2[1].y) 	SWAP(struct octPoint, pts2[0], pts2[1]);

    if(pts1[0].x < bb1->bb.lowerLeft.x)   pts1[0].x = bb1->bb.lowerLeft.x;
    if(pts1[0].y < bb1->bb.lowerLeft.y)   pts1[0].y = bb1->bb.lowerLeft.y;
    if(pts2[1].x > bb2->bb.upperRight.x)   pts2[1].x = bb2->bb.upperRight.x;
    if(pts2[1].y > bb2->bb.upperRight.y)   pts2[1].y = bb2->bb.upperRight.y;

    w1 = path1->contents.path.width;
    w2 = path1->contents.path.width;
    if(pts1[0].x == pts1[1].x)   vert1 = 1;
    if(pts2[0].x == pts2[1].x)   vert2 = 1;

    /* Parallel on diff layers  */
    if(vert1 == vert2) {
	if(vert1) {
	    if(pts1[0].x > pts2[0].x)  {
		SWAP(struct octPoint, pts1[0], pts2[0]);
		SWAP(struct octPoint, pts1[1], pts2[1]);
	    }
	    spac = (pts2[0].x-w2/2) - (pts1[0].x+w1/2);
	    side = (MIN(pts1[1].y, pts2[1].y)) - (MAX(pts1[0].y, pts2[0].y));
	} else {
	    if(pts1[0].y > pts2[0].y)  {
		SWAP(struct octPoint, pts1[0], pts2[0]);
		SWAP(struct octPoint, pts1[1], pts2[1]);
	    }
	    spac = (pts2[0].y-w2/2) - (pts1[0].y+w1/2);
	    side = (MIN(pts1[1].x, pts2[1].x)) - (MAX(pts1[0].x, pts2[0].y));
	} 
	if(spac < (- w1))   spac = (- w1);
	if(spac < (- w2))   spac = (- w2);
	return pepModParallelDiffLayers(spac, w1, w2, side, layer1, layer2);
    }

    if(pts1[0].x > pts2[1].x)    return ((double) 0.0);
    if(pts1[0].y > pts2[1].y)    return ((double) 0.0);
    if(pts2[0].x > pts1[1].x)    return ((double) 0.0);
    if(pts2[0].y > pts1[1].y)    return ((double) 0.0);

    /*  Crossing */
    pepCap = pepModCrossing(w1, w2, layer1, layer2);
    sBB.lowerLeft.x  = MAX(bb1->bb.lowerLeft.x, bb2->bb.lowerLeft.x);
    sBB.upperRight.x = MIN(bb1->bb.upperRight.x, bb2->bb.upperRight.x);
    sBB.lowerLeft.y  = MAX(bb1->bb.lowerLeft.y,  bb2->bb.lowerLeft.y);
    sBB.upperRight.y = MIN(bb1->bb.upperRight.y, bb2->bb.upperRight.y);
    ratio = ((double) ohBoxHeight(&sBB) * ohBoxWidth( &sBB )) / ((double) (w1 * w2));    
    return  pepCap*ratio;
}

double
pepCrossCapacitance( obj1, obj2)
    octObject  *obj1, *obj2;
/*
 *  Return the cross-coupling capacitance between the two objects.
 *  Capacitance is given in Farad. Objects can be geometric objects
 *  or nets.
 */
{
    octObject layer1, layer2, facet;
    pepBox    bb1, bb2;
    double    pepCap;                   /*  Capacitance to be returned */

    octGetFacet( obj1, &facet );

    switch (obj1->type) {
    case OCT_NET:
	return pepNetCap(&facet, obj1, obj2);

    case OCT_PATH:
    case OCT_BOX:
    case OCT_TERM:
	pepPathBB(obj1, &bb1);
	break;

    default:
	errRaise(PEP_PKG_NAME,1,"Object has no geometry to define a bounding box");
    }
    OH_ASSERT(pepGenNextLayer(obj1, &layer1, ""));
  
    switch (obj2->type) {
    case OCT_NET:
	return pepNetCap(&facet, obj2, obj1);
    
    case OCT_PATH:
    case OCT_BOX:
    case OCT_TERM:
	pepPathBB(obj2, &bb2);
	break;

    default:
	errRaise(PEP_PKG_NAME,1,"Object has no geometry to define a bounding box");
    }
    OH_ASSERT(pepGenNextLayer(obj2, &layer2, ""));

/*    if(pepDisjointBoxes(&bb1, &bb2, MAX_PEP_DISTANCE))   return ((double) 0.0); */

    if(strcmp(layer1.contents.layer.name, layer2.contents.layer.name) == 0) {
	pepCap = pepCapSameLayer(&facet, &bb1, &bb2, &layer1);
    } else {
	/*  Are they both paths ?  */
	if((obj1->type == OCT_PATH) && (obj2->type == OCT_PATH)) {
	    pepCap = pathDiffLayers(obj1, obj2, &bb1, &bb2, &layer1, &layer2);
	} else {
	    pepCap = pepCapDiffLayers(&facet, &bb1, &bb2, &layer1, &layer2);
	}
    }

    return pepCap;
}
