#ifndef lint
static char SccsId[]="$Id$";
#endif /*lint*/
/* Copyright (c) 1990-1993 The Regents of the University of California.
 * All rights reserved.
 * 
 * Permission is hereby granted, without written agreement and without
 * license or royalty fees, to use, copy, modify, and distribute this
 * software and its documentation for any purpose, provided that the above
 * copyright notice and the following two paragraphs appear in all copies
 * of this software.
 * 
 * IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY 
 * FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES 
 * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF 
 * THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF 
 * SUCH DAMAGE.
 * 
 * THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE
 * PROVIDED HEREUNDER IS ON AN "AS IS" BASIS, AND THE UNIVERSITY OF
 * CALIFORNIA HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,
 * ENHANCEMENTS, OR MODIFICATIONS.
 * 
 */
#include "copyright.h"
#include "port.h"
#include "utility.h"
#include "errtrap.h"
#include "oct.h"
#include "oh.h"
#include "list.h"

struct boxId {
    octId id;
    struct octBox box;
};

static void freeElement();
static lsList buildList();
static void fixAspectRatio();
static void placeObjects();
static int getRowDim();

/*LINTLIBRARY*/

/*
*	tapLayoutPalette -- lay out objects neatly in a palette
*
*   Takes the objects generated by `*genPtr' (often a user defined
*   generator) and arranges them in rows, separated vertically and
*   horizontally by at least `pad', attempting to achieve an aspect
*   ratio of approximately `widthOverHeight'.  The end of a row can be
*   forced at a particular place by having the generator return an
*   object without a valid bounding box (this could be a non-geometric
*   object or even a non-existent object, if a user defined generator
*   is used). When the generator is exhausted, the objects are moved
*   and the function returns.  The array of objects is alwaysplaced
*   with its upper-left corner at the containing facet's origin.
*/

void tapLayoutPalette(genPtr, pad, widthOverHeight)
octGenerator *genPtr;	/* generator for objects */
octCoord pad;		/* minimum inter-object spacing (in oct units) */
double widthOverHeight;	/* desired aspect ratio */
{
    lsList bBoxList;	/* list of object ids and bounding boxes */
    lsList buildList();
    void fixAspectRatio(), placeObjects(), freeElement();

    TAP_START("tapLayoutPalette");

    bBoxList = buildList(genPtr);
    fixAspectRatio(bBoxList, pad, widthOverHeight);
    placeObjects(bBoxList, pad);
    lsDestroy(bBoxList, freeElement);

    TAP_END();
}

static void freeElement(boxPtr)
struct boxId *boxPtr;
{
    FREE(boxPtr);
}

static lsList buildList(genPtr)
octGenerator *genPtr;	/* generator for objects */
{
    lsList bBoxList;
    octObject obj;
    octStatus stat;
    struct boxId *boxPtr;

    bBoxList = lsCreate();
    while ((stat = octGenerate(genPtr, &obj)) == OCT_OK) {
	boxPtr = ALLOC(struct boxId, 1);
	boxPtr->id = obj.objectId;
	if (octBB(&obj, &boxPtr->box) != OCT_OK) {
	    boxPtr->id = oct_null_id;
	}
	lsNewEnd(bBoxList, (lsGeneric) boxPtr, LS_NH);
    }
    OCT_ASSERT(stat);
    return(bBoxList);
}

static void fixAspectRatio(bBoxList, pad, widthOverHeight)
lsList bBoxList;	/* list of object ids and bounding boxes */
octCoord pad;		/* minimum inter-object spacing (in oct units) */
double widthOverHeight;	/* desired aspect ratio */
{
    octCoord rowWidth, rowHeight, totWidth, totHeight, desiredWidth;
    lsGen boxGen;
    lsGeneric dummy;
    struct boxId *boxPtr;
    int rowCount;

    totWidth = 0;
    totHeight = -pad;
    boxGen = lsStart(bBoxList);
    while (getRowDim(boxGen, &rowWidth, &rowHeight, pad)) {
	totWidth = MAX(totWidth, rowWidth);
	totHeight += rowHeight + pad;
    }
    lsFinish(boxGen);

    desiredWidth = sqrt(widthOverHeight * totWidth * totHeight);

    if (desiredWidth >= totWidth) {
	/* can't improve it without merging rows */
	return;
    }

    boxGen = lsStart(bBoxList);
    rowWidth = -pad;
    rowCount = 0;
    while (lsNext(boxGen, &dummy, LS_NH) == LS_OK) {
	boxPtr = (struct boxId *) dummy;
	if (octIdIsNull(boxPtr->id)) {
	    rowWidth = -pad;
	    rowCount = 0;
	} else {
	    rowWidth += boxPtr->box.upperRight.x-boxPtr->box.lowerLeft.x + pad;
	    if (rowCount++ && rowWidth > desiredWidth) {
		(void) lsPrev(boxGen, &dummy, LS_NH);
		boxPtr = ALLOC(struct boxId, 1);
		boxPtr->id = oct_null_id;
		lsInBefore(boxGen, (lsGeneric) boxPtr, LS_NH);
		(void) lsPrev(boxGen, &dummy, LS_NH);
		rowWidth = -pad;
		rowCount = 0;
	    }
	}
    }
    lsFinish(boxGen);
}

static void placeObjects(bBoxList, pad)
lsList bBoxList;	/* list of object ids and bounding boxes */
octCoord pad;		/* minimum inter-object spacing (in oct units) */
{
    octCoord rowWidth, rowHeight, curX, curY;
    lsGen scanGen, modifyGen;
    lsGeneric dummy;
    struct boxId *boxPtr;
    struct octTransform transform;
    octObject obj;

    curX = curY = 0;
    transform.transformType = OCT_NO_TRANSFORM;
    scanGen = lsStart(bBoxList);
    modifyGen = lsStart(bBoxList);

    while (getRowDim(scanGen, &rowWidth, &rowHeight, pad)) {
	while (lsNext(modifyGen, &dummy, LS_NH) == LS_OK &&
		(boxPtr = (struct boxId *) dummy, !octIdIsNull(boxPtr->id))) {
	    transform.translation.x = curX - boxPtr->box.lowerLeft.x;
	    transform.translation.y = curY -
			(rowHeight +
			 boxPtr->box.lowerLeft.y + boxPtr->box.upperRight.y)/2;
	    OCT_ASSERT(ohGetById(&obj, boxPtr->id));
	    OCT_ASSERT(octTransformAndModifyGeo(&obj, &transform));

	    curX += boxPtr->box.upperRight.x - boxPtr->box.lowerLeft.x + pad;
	}

	curX = 0;
	curY -= rowHeight + pad;
    }
    lsFinish(scanGen);
    lsFinish(modifyGen);
}

static int getRowDim(boxGen, widthPtr, heightPtr, pad)
lsGen boxGen;		/* steps through the bounding boxes */
octCoord *widthPtr;	/* for returning width of row */
octCoord *heightPtr;	/* for returning height of row */
octCoord pad;		/* minimum inter-object spacing (in oct units) */
{
    lsGeneric dummy;
    struct boxId *boxPtr;
    int genActive = 0;

    *widthPtr = -pad;
    *heightPtr = 0;

    while (lsNext(boxGen, &dummy, LS_NH) == LS_OK) {
	genActive = 1;
	boxPtr = (struct boxId *) dummy;
	if (octIdIsNull(boxPtr->id)) break;
	*widthPtr += boxPtr->box.upperRight.x - boxPtr->box.lowerLeft.x + pad;
	*heightPtr = MAX(*heightPtr,
			 boxPtr->box.upperRight.y - boxPtr->box.lowerLeft.y);
    }

    return(genActive);
}
