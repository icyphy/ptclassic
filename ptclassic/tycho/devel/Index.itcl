##########################################################################
# Version: $Id$
# Author: John Reekie, Edward A. Lee
#
# Copyright (c) 1996 The Regents of the University of California.
# All rights reserved.
# 
# Permission is hereby granted, without written agreement and without
# license or royalty fees, to use, copy, modify, and distribute this
# software and its documentation for any purpose, provided that the above
# copyright notice and the following two paragraphs appear in all copies
# of this software.
# 
# IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY
# FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
# ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF
# THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.
# 
# THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE
# PROVIDED HEREUNDER IS ON AN "AS IS" BASIS, AND THE UNIVERSITY OF
# CALIFORNIA HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,
# ENHANCEMENTS, OR MODIFICATIONS.
#                                                         COPYRIGHTENDKEY
##########################################################################


##########################################################################
#### NamedData
#
# The _NamedData_ class implements a simple information model --
# it is, in effect, an associative array, except that the array
# can be associated with
# a set of files, changes to the array can be undone, redone, and
# published, and each entry in the 
# array can have options as well as a value. For example, you
# can add an entry to an array and give it some options with:
# <pre>
#     $dataarray add Foo "Hello" -bar 1
# </pre>
#
# To change an option, use the entryconfigure{} method:
# <pre>
#     $dataarray entryconfigure Foo -bar 0
# </pre>
#
# By default, a NamedData will accept any options. To limit
# the options that will be accepted and to set the default values,
# set the *-entryoptions* option (of the NamedData, not of an entry):
# <pre>
#     $dataarray configure -entryoptions {-bar 0 -tar 99}
# </pre>
#
# There are a number of methods to access the data. The 
# simplest is get{}, which returns the value of an entry. The
# names{} method returns the entry names that match a given 
# glob-style pattern or regular expression. The match{} method
# returns a list of names and patterns, and supports various
# options to select the format of the returned list.
#
#
class ::tycho::NamedData {
    inherit ::tycho::Model
    
    constructor {args} {}
    destructor {}
    
    #################################################################
    ####                        options                          ####

    # The default options of each data entry
    public variable entryoptions {}
    
    # If true, options are checked, otherwise any are allowed
    public variable checkoptions 1

    #################################################################
    ####                     public methods                      ####

    # Assign new data to en existing entry
    method assign {index data}
    
    # Delete an entry
    method delete {index}

    # Describe the data in the model, in the same format as write{}
    method describe {{prefix {}}}

    # Add an entry to the array
    method entry {index data args}
    
    # Get an option or options of an entry
    method entrycget {index option}

    # Configure the entry with one or more options
    method entryconfigure {index args}
    
    # Return all options of an entry
    method entryoptions {index}
    
    # Externalize the model into a state file
    method externalize {fd {nohistory {}}}
    
    # Return an entry in the array
    method get {index}

    # Return a list of entries and values based on a pattern
    method match {pattern args}

    # Return a list of indexes that match a pattern
    method names {{pattern *} {regexpflag {}}}

    #################################################################
    ####                  protected methods                      ####

    # Write data to a data file and image file.
    protected method writeData {fd id}

    #################################################################
    ####                  protected variables                    ####

    # The values in the array
    protected variable _value
    
    # The options of the data values
    protected variable _optns
    
    #################################################################
    ####                   private methods                       ####
   
    # Evaluate code in this object's context
    private method evalInSpecificContext {args}  {
	puts [info class]
	eval $args
    }
}

########################################################################
#### constructor
#
body ::tycho::NamedData::constructor {args} {
    # Evaluate options
    eval configure $args
}

########################################################################
#### assign
#
# Assign new data to an existsing entry. Flag an error if the entry
# does not exist. Return the inverse command.
#
body ::tycho::NamedData::assign {index data} {
    if { ! [::info exists _value($index)] } {
	error "Data $index does not exist in $dataname"
    }
    set inverse [list assign $index $_value($index)]
    set _value($index) $data
    return $inverse
}

########################################################################
#### delete
#
# Delete an entry. Flag an error if the entry does not exist.
# Return the inverse command.
#
body ::tycho::NamedData::delete {index} {
    if { ! [::info exists _value($index)] } {
	error "Unknown entry $index in $dataname"
    }
    set inverse [list entry $index $_value($index)]
    eval lappend inverse $_optns($index)
    unset _value($index)
    
    return $inverse
}

########################################################################
#### describe
#
# Return a string that describes the model. The data format is exectly
# that generated by the write{} method -- note that it is 
# _not_ a well-formed Tcl list. The argument, if present,
# is a string to place at the start of each line.
#
body ::tycho::NamedData::describe {{prefix {}}} {
    set result ""
    array set default $entryoptions

    foreach {entry value} [array get _value] {
        append result $prefix "entry"
        lappend result $entry $value
        foreach {opt val} $_optns($entry) {
            if { ! [::info exists default($opt)] \
                    || $default($opt) != $val } {
                lappend result $opt $val
            }
        }
        append result "\n"
    }
    return $result
}

########################################################################
#### entry
#
# Add a new entry to the array. Flag an error if the entry
# already exists. Additional arguments are the initial values
# of entry options. Return the inverse command.
#
body ::tycho::NamedData::entry {index data args} {
    if { [::info exists _value($index)] } {
	error "Data $index already exists in $dataname"
    }

    # Set options
    if { ! $checkoptions } {
	# If this is turned off, don't even remove duplicates
	# from the option list. It won't matter, since the
	# option handling code all works anyway.
	set _optns($index) [concat $entryoptions $args]
    } else {
     	# Set default options then given options. Flag an error
     	# if a given option is not in the defaults
 	array set temp $entryoptions
 	foreach {option value} $args {
 	    if { ! [::info exists temp($option)] } {
 		error "Unknown option $option in $dataname"
 	    }
 	    set temp($option) $value
 	}
 	set _optns($index) [array get temp]
    }
    # set value
    set _value($index) $data

    # Return the undo command
    return [list delete $index]
}

########################################################################
#### entrycget
#
# Get an option of a data entry. Flag an error if the entry
# does not exist or the option does not.
#
body ::tycho::NamedData::entrycget {index option} {
    if { ! [::info exists _value($index)] } {
	error "Data $index does not exist in $dataname"
    }
    array set temp $_optns($index)
    if { ! [::info exists temp($option)] } {
	error "Unknown option $option in $dataname"
    }
    return $temp($option)
}

########################################################################
#### entryconfigure
#
# Configure the given entry.  The argument list
# is a flat list of option-value pairs. If there are arbitrary
# options, the undo command will not delete options
# that have not already been set, although it will change
# back existing options that are changed.
#
# Flag an error if the entry does not exist, or if an
# option is invalid.
# 
body ::tycho::NamedData::entryconfigure {index args} {
    if { ! [::info exists _value($index)] } {
	error "Data $index does not exist in $dataname"
    }

    set inverse [list entryconfigure $index]
    if { $entryoptions != "" } {
	# Can only change options that are already there
	array set temp $_optns($index)
	foreach {option value} $args {
	    if { ! [::info exists temp($option)] } {
		error "Unknown option $option in $dataname"
	    }
	    lappend inverse $option $temp($option)
	    set temp($option) $value
	}
	set _optns($index) [array get temp]
    } else {
	# Can set any options at all
	array set temp $_optns($index)
	foreach {option value} $args {
	    if { $value == "_NamedDataDeleteThisOption_" } {
		unset temp($option)
	    } elseif { [::info exists temp($option)] } {
		lappend inverse $option $temp($option)
		set temp($option) $value
	    } else {
		lappend inverse $option _NamedDataDeleteThisOption_
		set temp($option) $value
	    }
	}
	set _optns($index) [array get temp]
    }
    return $inverse
}

########################################################################
#### entryoptions
#
# Return a list containing the options of the entry as a flat
# option-value list.
#
body ::tycho::NamedData::entryoptions {index} {
    return $_optns($index)
}

########################################################################
#### externalize
#
# Write the class-dependent description of the data to a file.
# The file doesn't contain the command history only if the second
# argument is suppliedand true.
#
body ::tycho::NamedData::externalize {fd {nohistory {}}} {
    # Chain the superclass' method
    eval chain $fd $nohistory

    # Write this model's data to the file
    puts $fd "\n\n# Values of data $dataname\n\n"
    puts $fd "array set _value \{[array get _value]\}\n"
    puts $fd "\n\n# Options of data $dataname\n\n"
    puts $fd "array set _optns \{[array get _optns]\}\n"

    return ""
}

########################################################################
#### get
#
# Get the value of an entry. Flag an error if the entry does
# not exist.
#
body ::tycho::NamedData::get {index} {
    if { ! [::info exists _value($index)] } {
	error "Data $index does not exist in $dataname"
    }
    return $_value($index)
}

########################################################################
#### match
#
# Return a list of index-value pairs based on the given pattern. By
# default, the entries in the model are matched against _pattern_
# using glob-style matching and the returned list is a flat list of
# name-value pairs. For example, it might return
# <code>{first This second That}</code>. The
# following flags can follow the pattern argument:
# <ul>
# <li>*-regexp*: Use regular expression matching instead of glob-style
# matching.
# <li>*-options*: Return a list of lists, where each sub-list is the
# entry name, its value, and following elements are option-value
# pairs, where options are included in the list only if they differ
# from the defaults. If an entry has an options that has no
# default (possible if *-checkoptions* is zero) then include it in
# the result.
# <li>*-alloptions*: Return a list of lists, where each sub-list is the
# entry name, its value, and following elements are option-value
# pairs, where all options are included in the result.
# <li>*-withoptions* _option_ ... _option_: 
# Return a list of lists, where each sub-list is the
# entry name, its value, and following elements are option-value
# pairs, where only options in the argument list are included in
# the result. If *-alloptions* is specified, include all of the
# options in the argument list; if not, include only those that
# differ from the defaults. This must be the last option flag
# in the argument list.
# </ul>
#
body ::tycho::NamedData::match {pattern args} {
    set regexp 0
    set options "none"

    # Get the option flags
    while { $args != "" } {
	set test [lindex $args 0]
	set args [lreplace $args 0 0]
	if { $test == "-regexp" } {
	    set regexp 1
	} elseif { $test == "-options" } {
	    set options "different"
	} elseif { $test == "-alloptions" } {
	    set options "all"
	} elseif { $test == "-withoptions" } {
	    if { $options == "all" } {
		set options "withalloptions"
	    } else {
		set options "withdifferentoptions"
	    }
            set requested $args
	    set args ""
	}
    }

    # Get the matching indexes
    if { $regexp } {
	set matching [names $pattern -regexp]
    } else {
	# Glob-style matching. Optimize for the default case
	if { $options == "none" } {
	    return [array get _value $pattern]
	} else {
	    set matching [array names _value $pattern]
	}
    }
    
    # Return the found entries with option values
    array set default $entryoptions
    set result {}
    switch -exact $options {
	"none" {
	    # Return names and values
	    foreach index $matching {
		lappend result $index $_value($index)
		append result "\n"
	    }
	}
	"all" {
	    # Return list of lists with all options
	    foreach index $matching {
		set partial [list $index $_value($index)]
		eval lappend partial $_optns($index)
                lappend result $partial
		append result "\n"
	    }
	}
	"different" {
	    # Include options only if they differ from the default
	    foreach index $matching {
		set partial [list $index $_value($index)]
		foreach {opt val} $_optns($index) {
		    if { ! [::info exists default($opt)] \
			    || $default($opt) != $val } {
			lappend partial $opt $val
		    }
		}
		lappend result $partial
                append result "\n"
	    }
	}
	"withalloptions" {
	    # Include options only if they are requested
	    foreach index $matching {
		lappend result $index $_value($index)
		array set temp $_optns($index)
		foreach opt $requested {
		    lappend partial $opt $temp($opt)
		}
		lappend result $partial
		append result "\n"
	    }
	}
	"withdifferentoptions" {
	    # Include options only if they are requested and they
	    # are different from the default
	    foreach index $matching {
		set partial [list $index $_value($index)]
		array set temp $_optns($index)
		foreach opt $requested {
		    if { ! [::info exists default($opt)] \
			    || $default($opt) != $temp($opt) } {
			lappend partial $opt $temp($opt)
		    }
		}
		lappend result $partial
		append result "\n"
	    }
	}
    }
    return $result
}

########################################################################
#### names
#
# Return a list of indexes based on the given pattern. The
# *-regexp* flag following the pattern selects regular expression
# matching instead of glob-style matching.
#
body ::tycho::NamedData::names {{pattern *} {regexpflag {}}} {
    if { $regexpflag != "" } {
	# Get indexes using regular expression matching
	set result {}
	set testlist [array names _value]
	while { [set index [lsearch -regexp $testlist $pattern]] != -1 } {
	    lappend result [lindex $testlist $index]
	    set result [lreplace $testlist 0 $index]
	}
	return $result
    } else {
	# Glob-style matching
	return [array names _value $pattern]
    }
}
