# A graph data structure.
#
# @Author: Edward A. Lee, John Reekie
#
# @Version: $Id$
#
# @Copyright (c) 1995-%Q% The Regents of the University of California.
# All rights reserved.
#
# Permission is hereby granted, without written agreement and without
# license or royalty fees, to use, copy, modify, and distribute this
# software and its documentation for any purpose, provided that the above
# copyright notice and the following two paragraphs appear in all copies
# of this software.
#
# IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY
# FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
# ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF
# THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.
#
# THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE
# PROVIDED HEREUNDER IS ON AN "AS IS" BASIS, AND THE UNIVERSITY OF
# CALIFORNIA HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,
# ENHANCEMENTS, OR MODIFICATIONS.
# 
#                                        PT_COPYRIGHT_VERSION_2
#                                        COPYRIGHTENDKEY
#######################################################################


#######################################################################
#### AbstractGraph
# A graph is a collection of vertices and a collection of edges between
# vertices. _AbstractGraph_ provides the infrastructure needed to build
# a number of different types of graph; subclasses extend this class
# by providing concrete methods for creating, modifying, and accessing
# specific types of graph.
#
# _AbstractGraph_ is the abstract superclass of Tycho's graph hierarchy.
# It provides support for vertices and edges and defines the protocol
# for subclasses; subclasses extend this class by providing concrete
# methods for creating, modifying, and accessing specific types of graph.
#
# Each vertex of a graph has a value and a set of arbitrary options.
# A set of default options can be specified with the *-vertexoptions*
# option of this class. (Note: unlike _NamedData_, any option can be added
# to a vertex, whether in the default list or not.) Each edge of the
# graph can have a set of arbitrary options; the default options of
# each edge are specified by the *-edgeoptions* option of this class.
# (I decided against giving each edge a value -- although it wouldn't be
# difficult to do and would be useful in certain cases such as weighted
# graphs, the most common case seems to be that the edge has
# no value and requiring that a value be specified would clutter the
# interface. A "value" can always be given as an option.)
#
# This abstract class is structured to support what I have dubbed a
# "weld": a named connection between an edge and a vertex. A weld
# is a combination of a vertex name and a "key" that uniquely identifies
# an edge connected to the vertex. Welds are very useful in applications
# like dataflow and so on. If the concrete subclass supports welds,
# then edges join two welds rather than two vertices. A weld is
# assumed to have the syntax _vertex_._key_.
#
# The methods in the graph classes are selectively "lenient." For 
# example, an edge can be added between two vertices that do not
# exist. (Attempting to add an edge that already exists is, however,
# considered to be an error.) This approach is taken for two reasons:
# (i) it simplifies construction of graphs from ill-formed data (for
# example, when reading a directory of files to create a graph representing
# relations between data in those files); and (ii) it makes the
# graph construction method rather more efficient since they perform
# much less error-checking. If a constructed graph is not _known_ to
# be correct, there are method to be called that will test for correct
# construction or "repair" the graph.
#
# Tycho's graph hierarchy currently looks like this:
# <pre>
#         AbstractGraph
#            /   \ 
#           /     \ 
#        Graph  Digraph
#                /   \ 
#               /     \ 
#     MultiGraph   Forest
# </pre>
#
# _Graph_ and _Digraph_ do not inherit from each other because I decided
# that the
# differences in internal representation and interface were enough to 
# warrant separate branches of the tree. _MultiGraph_ is a directed
# graph in which edges adjacent to a vertex are located by a "key" -- 
# this is used for dataflow graphs (a subclass of _MultiGraph_) and
# similar structures. (Note that keyed _undirected_ graphs are not
# supported directly here. This type of graph is important for 
# certain applications, such as circuit simulation. It is not clear yet
# how best to implement this: whether by subclassing _Graph_ or
# _MultiGraph_.) There is no special acyclic graph class: the
# _Digraph_ class has methods for testing for and finding cycles
# and so on.
#
# <i>A note on the implementation of the graph classes</i>: These 
# classes are intended to be used as an "information model" in
# applications such as computation models, scheduling, user
# interfaces, and so on. They will not be useful for building large
# graphs or performing complex algorithms. For that, interface to
# code written in some other (faster) language, inheriting from
# the _Model_ or one of the graph classes if appropriate.
#
class ::tycho::AbstractGraph {
    inherit ::tycho::Model

    constructor {args} {}
    destructor {}
    
    #################################################################
    ####                        options                          ####
    
    # The default options of each edge
    public variable edgeoptions {}

    # The default options of each vertex
    public variable vertexoptions {}

    # The default options of each weld
    public variable weldoptions {}

    ###################################################################
    ####                         public methods                    ####

	# Test if a graph is acyclic
	method acyclic {}

    # Add a vertex with a value and options to the graph
    method add {vertex value args}

    # Return adjacency edges matching two vertex patterns
    method adjacency {{pattern1 *} {pattern2 *}}

    # Assign new data to an existing vertex
    method assign {vertex data}
    
    # Get the children of a vertex
    method children {vertex}

    # Add an edge and options to the graph
    method connect {vertex1 vertex2 args}

    # Remove a vertex (but not adjacent edges) from the graph
    method delete {vertex}

    # Perform a depth-first search of the graph
	method depthFirstSearch {{roots {}}}

	# Perform a depth-sort of the graph
	method depthSort {{roots {}}}

    # Return a description of the graph
    method describe {}

    # Remove an edge from the graph
    method disconnect {vertex1 vertex2}

    # Get an option or options of an edge
    method edgecget {vertex1 vertex2 option}

    # Configure the edge with one or more options
    method edgeconfigure {vertex1 vertex2 args}

    # Return all options of an edge
    method edgeoptions {vertex1 vertex2}

    # Return edges matching a pair of connection patterns
    method edges {pattern1 pattern2}

    # Return the value of a vertex
    method get {vertex}

    # Initialize the graph from a description
    method init {description}

    # Get the keys at a vertex
    method keys {vertex}

    # Get the "leaves" of the graph
    method leaves {}

    # Return the number of edges in the graph
    method numberofedges {}

    # Return the number of vertices in the graph
    method numberofvertices {}

    # Get the parents of a vertex
    method parents {vertex}

    # "Repair" a graph by deleting improperly-connected edges
    method repair {}

    # Get the roots of the graph
    method roots {}

	# Return the topological sort of a graph
	method topologicalSort {{leaves {}}}

    # Test whether a graph is correctly constructed
    method verify {}

    # Get an option or options of a vertex
    method vertexcget {vertex option}

    # Configure the vertex with one or more options
    method vertexconfigure {vertex args}

    # Return all options of a vertex
    method vertexoptions {vertex}

    # Return vertices matching a pattern
    method vertices {{pattern *}}

    # Attach one or more welds to a vertex
    method weld {vertex args}

    # Get an option or options of a weld
    method weldcget {weld option}

    # Configure a weld with one or more options
    method weldconfigure {weld args}

    # Return all options of a weld
    method weldoptions {weld}

    #################################################################
    ####                   protected methods                     ####

    # Remove an edge from the adjacency matrix and adjust edges array
    protected method deleteedge {vertex1 vertex2}

    # Add an edge to the adjacency matrix
    method adjacencyadd {vertex1 vertex2}

    # Delete an edge from the adjacency matrix
    method adjacencydelete {vertex1 vertex2}

    #################################################################
    ####                  protected variables                    ####

    # A "cache" of structural information. All methods that modify
    # the adjacency matrix clear this array.
    protected variable _cache

    # The adjacency "matrix." See the comment with adjacencyadd{}.
    protected variable _adjacency

    # The edges of the graph. The format of this structure is
    # up to the subclass.
    protected variable _edges
    
    # The options of the edges
    protected variable _edgeoptions
    
    # The vertices of the graph. One entry per vertex, with value
    # equal to the value given in the add{} method.
    protected variable _vertices
    
    # The options of the vertices
    protected variable _vertexoptions
}

    ###################################################################
    ###################################################################
    ####                      public methods                       ####

########################################################################
#### acyclic
#
# Test if a graph is acyclic. This method uses a result computed
# by the depth-first search routine, so computes the
# depth-first search as a side-effect if the result hasn't already
# been computed.
#
body ::tycho::AbstractGraph::acyclic {} {
	if { ! [::info exists _cache(acyclic)] } {
		# Try with roots first
		if { [depthFirstSearch] == "" } {
			# If that fails, do with all vertices
			depthFirstSearch [array names _vertices]
		}
	}
	return $_cache(acyclic)
}

########################################################################
#### add
#
# Add a new vertex to the graph, and return the inverse command. Flag an
# error if the vertex already exists. Additional arguments are a flat
# option-value list for the vertex.
#
body ::tycho::AbstractGraph::add {vertex value args} {
	#
	# The vertex matrices is stored as
	#
	#     _vertices:      vertex |-> value
	#     _vertexoptions: vertex |-> {option value ... }
	# 

    if { [::info exists _vertices($vertex)] } {
	error "Vertex $vertex already exists in $dataname"
    }
    set modified 1

    # set value
    set _vertices($vertex) $value

    # Set options
    array set temp [concat $vertexoptions $args]
    set _vertexoptions($vertex) [array get temp]

    # Clear the cache
    catch {unset _cache}

    # Return inverse command
    return [list delete $vertex]
}

########################################################################
#### adjacency
#
# Return a list containing the edges of the graph as represented in
# the adjacency matrix with source and target
# vertex names that match the given patterns. The result is a flat list
# of source-target pairs. If no arguments are
# supplied, return all edges.
#
# This is different from edges{} only if the edges are not connected
# from vertex to vertex -- see _MultiGraph_ for an example.
#
body ::tycho::AbstractGraph::adjacency {{pattern1 *} {pattern2 *}} {
    set result {}
    foreach e [array names _adjacency $pattern1^$pattern2] {
	eval lappend result [split $e "^"]
    }
    return $result
}

########################################################################
#### connect
#
# Add a new edge to the graph, and return the inverse command.
# The edge is specified by name -- the name format depends upon
# the subclass; additional arguments are a
# flat option-value list for the edge. Flag an error if the edge
# already exists, but not if any of the connected vertices do not exist. 
#
# <i>This is an abstract method.</i>
#
body ::tycho::AbstractGraph::connect {vertex1 vertex2 args} {
    abstractMethod connect
}

########################################################################
#### assign
#
# Assign new data to an existing vertex. Flag an error if the vertex
# does not exist. Return the inverse command.
#
body ::tycho::AbstractGraph::assign {vertex data} {
    if { ! [::info exists _vertices($vertex)] } {
	error "Vertex $vertex does not exist in $dataname"
    }
    set inverse [list assign $vertex $_vertices($vertex)]
    set _vertices($vertex) $data
    return $inverse
}

########################################################################
#### delete
#
# Delete a vertex from the graph, and return the inverse command. This
# method overrides the default to clear any cached information
# on the graph structure (transitive closure, depth, and so on)
# so that they will be recalculated for the new structure.
#
body ::tycho::AbstractGraph::delete {vertex} {
    if { ! [::info exists _vertices($vertex)] } {
	error "Unknown vertex $vertex in $dataname"
    }
    set modified 1

    set inverse [list add $vertex $_vertices($vertex) $_vertexoptions($vertex)]
    unset _vertices($vertex)

    # Clear any cached structural information
    catch {unset _cache}

    return $inverse
}

########################################################################
#### depthFirstSearch
#
# Perform a depth-first search of the graph and return the vertices
# in the order visited. This is a non-recursive implementation, and is
# adapted from Sedgewick, Chapter 29. The "stack" in this algorithm
# is a Tcl list, with the "top" of the stack being the _end_ of the list.
#
# If there is no argument, then the graph is assumed to a) be directed
# and b) have at least one root vertex (with no parents). The graph
# is searched from the root nodes. If an argument is supplied, then
# it must be a list of nodes from which to start searching. If nothing
# is known about the structure of the graph, then all vertices should be
# supplied, since that will guarantee that all vertices are reached.
#
# This method can be used to perform naive reachability, by giving
# a single vertex as argument and examining the result list.
#
# As a side-effect, this method sets a flag if a cycle is encountered,
# which can be read by the acyclic{} method.
#
body ::tycho::AbstractGraph::depthFirstSearch {{roots {}}} {
	# If we already have it, just return it
	if { [::info exists _cache(depthfirst.[join $roots -])] } {
		return $_cache(depthfirst.[join $roots -])
	}

	# The traversal "stack" and result list
	set stack {}
	set result {}
	set acyclic 1

	# Initialize visited flags to 0
	foreach v [array names _vertices] {
		set _cache($v.visited) 0
	}

	# Push start vertices onto the stack
	if { $roots == "" } {
		set roots [roots]
	}
	foreach root $roots {
		lappend stack $root
		set _cache($root.visited) -1
	}

	# Keep looking until we run out of vertices
	while { $stack != "" } {
		# Get first on stack
		set current [lindex $stack end]
		set stack [lreplace $stack end end]
		
		# Remember it
		lappend result $current

		# Put each non-visited child onto the stack and mark it
		foreach child [children $current] {
			if { $_cache($child.visited) == 0 } {
				lappend stack $child
				set _cache($child.visited) 1
			} elseif { $_cache($child.visited) == 1 } {
				set acyclic 0
			}
		}
	}

	# Update acyclic flag if all vertices were covered
	if { [llength $result] == [llength [array name _vertices]] } {
		set _cache(acyclic) $acyclic
	}

	# Remember the search in case it's needed later
	set _cache(depthfirst.[join $roots -]) $result
	return $result
}

########################################################################
#### depthSort
#
# Perform a sort of the graph and return the vertices in a list of 
# lists, where each sublist contains vertices of the corresponding 
# depth. If the graph contains a cycle, then the sort will be as
# though an arbitrary edge in each cycle were deleted.
#
# If the graph has cycles, the algorithm will still function, returning
# a sort of a similar acyclic graph (the same graph with cycles
# broken). If the second argument is supplied, it is a list of starting
# vertices -- this may be needed for cyclic graphs.
# 
body ::tycho::AbstractGraph::depthSort {{roots {}}} {
	# If we already have it, just return it
	if { [::info exists _cache(depthsort)] } {
		return $_cache(depthsort)
	}

	# The current vertices and  result list
	if { $roots == {} } {
		set roots [roots]
	}
	set current $roots
	set _cache(depthsort) {}

	# Initialize visited flags to 0
	foreach v [array names _vertices] {
		set _cache($v.visited) [llength [children $v]]
	}
	set count [expr [llength [vertices *]] - [llength $current]]

	# Keep looking until we run out of vertices
	while { 1 } {
		# The next layer of vertices
		set next {}
		
		# Foreach in the current "layer," add each child that has been
		# visited by all of its parents.
		foreach v $current {
			foreach w [children $v] {
				incr _cache($w.visited) -1
				if { ! $_cache($w.visited) } {
					lappend next $w
					incr count -1
				}
			}
		}

		# There are no next vertices: either we are done or there is
		# a cycle
		if { $next == "" } {
			if { $count } {
				# There's a cycle, so choose a child of a vertex
				# of the current layer, decrement its count (i.e. delete
				# an edge), and try again
				# FIXME: Does this really work???
				set x ""
				foreach v $current {
					foreach w [children $v] {
						if { $_cache($w.visited) > 0 } {
							set x $w
							incr _cache($x.visited) -1
							break
						}
					}
					if { $x != "" } {
						break
					}
				}
				continue
			} else {
				# Done
				break
			}
		}

		# Move on to the next layer
		lappend _cache(depthsort) $next
		set current $next
	}
}

#######################################################################
#### describe
# Return a list that describes the graph. The returned list consists
# of a list of method calls that can be executed to reconstruct
# the graph.
#
body ::tycho::AbstractGraph::describe {} {
    set result {}
    foreach vertex [array names _vertices] {
	lappend result [concat add [list $vertex $_vertices($vertex)] \
		$_vertexoptions($vertex)]
    }
    foreach edge [array names _edges] {
	lappend result [concat connect $_edges($edge) $_edgeoptions($edge)]
    }
    return $result
}

########################################################################
#### disconnect
#
# Remove an edge from the graph, and return the inverse command. Flag an
# error if the edge does not exist.
#
# <i>This is an abstract method.</i>
#
body ::tycho::AbstractGraph::disconnect {vertex1 vertex2} {
    abstractMethod disconnect
}

########################################################################
#### edgecget
#
# Get an option of an edge. An error will occur if the edge does not
# exist or the option does not exist.
#
body ::tycho::AbstractGraph::edgecget {vertex1 vertex2 option} {
    array set temp $_edgeoptions($vertex1^$vertex2)
    return $temp($option)
}

########################################################################
#### edgeconfigure
#
# Configure the edge and return the inverse command. An error will
# occur if the edge does not exist. The argument list
# is a flat list of option-value pairs.
#
body ::tycho::AbstractGraph::edgeconfigure {vertex1 vertex2 args} {
    set modified 1

    set inverse [list edgeconfigure $vertex1 $vertex2]
    array set temp $_edgeoptions($vertex1^$vertex2)
    foreach {option value} $args {
	lappend inverse $option $temp($option)
	set temp($option) $value
    }
    set _edgeoptions($vertex1^$vertex2) [array get temp]
    return $inverse
}

########################################################################
#### edgeoptions
#
# Return a list containing the options of the edge as a flat
# option-value list. An error will result if the edge does
# not exist.
#
body ::tycho::AbstractGraph::edgeoptions {vertex1 vertex2} {
    return $_edgeoptions($vertex1^$vertex2)
}

########################################################################
#### edges
#
# Return a list containing the edges of the graph with source and target
# vertex names that match the given patterns. The result is a flat list
# of source-target pairs. If no arguments are
# supplied, return all edges.
# To test for the presence of a single edge, provide its source and 
# target vertices as the arguments and compare the result with the empty
# list.
#
body ::tycho::AbstractGraph::edges {{pattern1 *} {pattern2 *}} {
    set result {}
    foreach e [array names _edges $pattern1^$pattern2] {
	eval lappend result [split $e "^"]
    }
    return $result
}

########################################################################
#### get
#
# Get the value of a vertex. Flag an error if the vertex does
# not exist.
#
body ::tycho::AbstractGraph::get {index} {
    if { ! [::info exists _vertices($vertex)] } {
	error "Vertex $vertex does not exist in $dataname"
    }
    return $_vertices($vertex)
}

#######################################################################
#### init
# Initialize the graph from a description. The format of the
# description should be compatible with that produced by the
# <code>describe</code> method.  The graph should be verified
# after this using <code>verify</code>.
#
body ::tycho::AbstractGraph::init {description} {
    clear
    foreach cmd $description {
        eval $this $cmd
    }
}

########################################################################
#### numberofedges
#
# Return the number of edges in the graph.
#
body ::tycho::AbstractGraph::numberofedges {} {
    return [array size _edges]
}

########################################################################
#### numberofvertices
#
# Return the number of vertices in the graph.
#
body ::tycho::AbstractGraph::numberofvertices {} {
    return [array size _vertices]
}

########################################################################
#### repair
#
# "Repair" a graph by deleting improperly-connected edges. This method
# provides a default implementation that will remove invalid edges in 
# most properly-written subclasses; however,
# subclasses may choose to override it for efficiency, because it doesn't work
# with the subclass, or to perform additional repairs. This
# method should be called after building a graph if it is not certain
# that the graph is correctly constructed.
#
# This method cannot be recorded or published.
#
body ::tycho::AbstractGraph::repair {} {
    set modified 1

    foreach {src tgt} [edges] {
	if { ! [::info exists _vertices($src)] \
		|| ! [::info exists _vertices($tgt)] } {
	    disconnect $src $tgt
	}
    }
    # Return null so record{} or publish{} will complain.
    return ""
}

########################################################################
#### topologicalSort
#
# Perform a topological sort of the graph and return the vertices
# in the order visited. This method works backwards through the graph starting
# with the "leaf" nodes. Because this is a non-recursive implementation,
# we use an explicit "stack" to simulate the recursive call stack. Each
# vertex on the stack is marked as follows:
# <ol>
# <li>0: Not visited yet.
# <li>1: Visited and placed into the topological sort
# <li>2: Visited but not yet placed into the topological sort.
# </ol>
#
# A vertex marked 2 is thus on the stack waiting for the "return
# from the recursive call" to place it into the result.
#
# This algorithm is a non-recursive adaptation of the reverse
# topological sort given in Chapter 32 of Sedgewick. It will work even
# if the graph is cyclic, although the returned list will then be
# some "approximation" of a sort -- nonetheless, it might be useful for
# laying out cyclic graphs.
# If a second argument is supplied, this algorithm will return the sort
# of vertices from which vertices in that list can be reached (again,
# this may be necessary for cyclic graphs).
#
body ::tycho::AbstractGraph::topologicalSort {{leaves {}}} {
	# If we already have it, just return it
	if { [::info exists _cache(topologicalsort)] } {
		return $_cache(topologicalsort)
	}

	# The traversal "stack" and result list
	set stack {}
	set _cache(topologicalsort) {}

	# Initialize visited flags to 0
	foreach v [array names _vertices] {
		set _cache($v.visited) 0
	}

	# Push all leaves onto the stack
	if { $leaves == {} } {
		set leaves [leaves]
	}
	set stack $leaves
	
	# Keep looking until we run out of vertices
	while { $stack != "" } {
		# Get first on stack
		set current [lindex $stack end]
		
		if { $_cache($current.visited) == 2 } {
			# We've already done this one and are "returning"
			set stack [lreplace $stack end end]
			set _cache($current.visited) 1
			lappend _cache(topologicalsort) $current

		} elseif { $_cache($current.visited) == 0 }
			# Leave the current node on the stack before its parents
			set _cache($current.visited) 2

			# Put each non-visited parent onto the stack and mark it
			foreach parent [parents $current] {
				if { ! $_cache($parent.visited) } {
					lappend stack $parent
				}
			}
		} else {
			# Just ignore this one, since we got to it through a different path
			set stack [lreplace $stack end end]
		}
	}
	return $_cache(topologicalsort)
}

########################################################################
#### verify
#
# Test whether a graph is properly constructed. This method
# provides a default implementation that tests for invalid edges; however,
# subclasses may choose to override this method for efficiency, because
# it doesn't work with the subclass, or to perform additional tests.
#
body ::tycho::AbstractGraph::verify {} {
    foreach {src tgt} [adjacency] {
	if { ! [::info exists _vertices($src)] } {
	    return 0
	}
    }
    return 1
}

########################################################################
#### vertexcget
#
# Get an option of an vertex. An error will occur if the vertex does not
# exist or the option does not exist.
#
body ::tycho::AbstractGraph::vertexcget {vertex option} {
    array set temp $_vertexoptions($vertex)
    return $temp($option)
}

########################################################################
#### vertexconfigure
#
# Configure the vertex and return the inverse command. An error will
# occur if the vertex does not exist. The argument list
# is a flat list of option-value pairs.
#
body ::tycho::AbstractGraph::vertexconfigure {vertex args} {
    set modified 1

    set inverse [list vertexconfigure $vertex]
    array set temp $_vertexoptions($vertex)
    foreach {option value} $args {
		lappend inverse $option $temp($option)
		set temp($option) $value
    }
    set _vertexoptions($vertex) [array get temp]
    return $inverse
}

########################################################################
#### vertexoptions
#
# Return a list containing the options of the vertex as a flat
# option-value list. An error wil result of the vertex does
# not exist.
#
body ::tycho::AbstractGraph::vertexoptions {vertex} {
    return $_vertexoptions($vertex)
}

########################################################################
#### vertices
#
# Return a list containing the vertices of the graph whose names match 
# a pattern. If the pattern is not given, all vertices are returned.
# To test for the presence of a single vertex, provide its name
# as the argument and compare the result with the empty list.
#
body ::tycho::AbstractGraph::vertices {{pattern *}} {
    return [array names _vertices $pattern]
}

#####################################################################
#####################################################################
####                     protected methods                       ####

########################################################################
#### deleteedge
#
# Delete an edge from the graph. The edge is specified by the
# two end vertices. The default method simply calls disconnect;
# graphs with complex edge structures will need to override
# the method to adjust the edge structures.
#
# FIXME: What is this used for???
#
body ::tycho::AbstractGraph::deleteedge {vertex1 vertex1} {
    disconnect $vertex1 $vertex2
}

########################################################################
#### adjacencyadd
#
# Add an edge to the adjacency matrix. If it already exists,
# do nothing.
#
# This and the associated method adjacencydelete{} build the
# internal topology of
# the graph independent of complexities associated with 
# hyperedges or keyed connections. It is an array indexed as
# "vertex1^vertex2" with value {vertex1 vertex2}. In future,
# the representation may change to use parent-child lists
# instead of adjacency lists, in which case some subclasses
# will have to be modified. The parent-child representation
# is more efficient for traversing the graph, but rather more
# tedious to maintain in the presence of graph alterations.
# <b>Note:</b> Preliminary tests using the depthsort{} method
# indicate that the efficiency overhead using this representation
# is only about 20%. It may be more critical if we can make
# depthSort{} and similar algorithms fully non-recursive. (Or
# less, depending on how you look at it...)
#
body ::tycho::AbstractGraph::adjacencyadd {vertex1 vertex2} {
	#
	# The adjacency matrix is stored as
	#
	#     _adjacency: source^target |-> {source target}
	# 
    set _adjacency($vertex1^$vertex2) [list $vertex1 $vertex2]
}

########################################################################
#### adjacencydelete
#
# Delete an edge from the adjacency matrix.
#
body ::tycho::AbstractGraph::adjacencydelete {vertex1 vertex2} {
    unset _adjacency($vertex1^$vertex2)
}

