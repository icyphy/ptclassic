# A graph data structure.
#
# @Author: Edward A. Lee, John Reekie
#
# @Version: $Id$
#
# @Copyright (c) 1995-%Q% The Regents of the University of California.
# All rights reserved.
#
# Permission is hereby granted, without written agreement and without
# license or royalty fees, to use, copy, modify, and distribute this
# software and its documentation for any purpose, provided that the above
# copyright notice and the following two paragraphs appear in all copies
# of this software.
#
# IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY
# FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
# ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF
# THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.
#
# THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE
# PROVIDED HEREUNDER IS ON AN "AS IS" BASIS, AND THE UNIVERSITY OF
# CALIFORNIA HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,
# ENHANCEMENTS, OR MODIFICATIONS.
# 
#                                        PT_COPYRIGHT_VERSION_2
#                                        COPYRIGHTENDKEY
#######################################################################


#######################################################################
#### AbstractGraph
# A graph is a collection of vertices and a collection of edges between
# vertices. _AbstractGraph_ provides the infrastructure needed to build
# a number of different types of graph; subclasses extend this class
# by providing concrete methods for creating, modifying, and accessing
# specific types of graph.
#
# _AbstractGraph_ is the abstract superclass of Tycho's graph hierarchy.
# It provides support for vertices and edges and defines the protocol
# for subclasses; subclasses extend this class by providing concrete
# methods for creating, modifying, and accessing specific types of graph.
#
# Each vertex of a graph has a value and a set of arbitrary options.
# A set of default options can be specified with the *-vertexoptions*
# option of this class. (Note: unlike _NamedData_, any option can be added
# to a vertex, whether in the default list or not.) Each edge of the
# graph can have a set of arbitrary options; the default options of
# each edge are specified by the *-edgeoptions* option of this class.
# (I decided against giving each edge a value -- although it wouldn't be
# difficult to do and would be useful in certain cases such as weighted
# graphs, the most common case seems to be that the edge has
# no value and requiring that a value be specified would clutter the
# interface. A "value" can always be given as an option.)
#
# This abstract class is structured to support what I have dubbed a
# "weld": a named connection between an edge and a vertex. A weld
# is a combination of a vertex name and a "key" that uniquely identifies
# an edge connected to the vertex. Welds are very useful in applications
# like dataflow and so on. If the concrete subclass supports welds,
# then edges join two welds rather than two vertices. A weld is
# assumed to have the syntax _vertex_._key_.
#
# The methods in the graph classes are selectively "lenient." For 
# example, an edge can be added between two vertices that do not
# exist. (Attempting to add an edge that already exists is, however,
# considered to be an error.) This approach is taken for two reasons:
# (i) it simplifies construction of graphs from ill-formed data (for
# example, when reading a directory of files to create a graph representing
# relations between data in those files); and (ii) it makes the
# graph construction method rather more efficient since they perform
# much less error-checking. If a constructed graph is not _known_ to
# be correct, there are method to be called that will test for correct
# construction or "repair" the graph.
#
# Tycho's graph hierarchy currently looks like this:
# <pre>
#         AbstractGraph
#            /   \ 
#           /     \ 
#        Graph  Digraph
#                /   \ 
#               /     \ 
#     MultiGraph   Forest
# </pre>
#
# _Graph_ and _Digraph_ do not inherit from each other because I decided
# that the
# differences in internal representation and interface were enough to 
# warrant separate branches of the tree. _MultiGraph_ is a directed
# graph in which edges adjacent to a vertex are located by a "key" -- 
# this is used for dataflow graphs (a subclass of _MultiGraph_) and
# similar structures. (Note that keyed _undirected_ graphs are not
# supported directly here. This type of graph is important for 
# certain applications, such as circuit simulation. It is not clear yet
# how best to implement this: whether by subclassing _Graph_ or
# _MultiGraph_.) There is no special acyclic graph class: the
# _Digraph_ class has methods for testing for and finding cycles
# and so on.
#
# <i>A note on the implementation of the graph classes</i>: These 
# classes are intended to be used as an "information model" in
# applications such as computation models, scheduling, user
# interfaces, and so on. They will not be useful for building large
# graphs or performing complex algorithms. For that, interface to
# code written in some other (faster) language, inheriting from
# the _Model_ or one of the graph classes if appropriate.
#
class ::tycho::AbstractGraph {
    inherit ::tycho::Model

    constructor {args} {}
    destructor {}
    
    #################################################################
    ####                        options                          ####
    
    # The default options of each edge
    public variable edgeoptions {}

    # The default options of each vertex
    public variable vertexoptions {}

    ###################################################################
    ####                         public methods                    ####

    # Add a vertex with a value and options to the graph
    method add {vertex value args}

    # Return adjacency edges matching two vertex patterns
    method adjacency {{pattern1 *} {pattern2 *}}

    # Assign new data to an existing vertex
    method assign {vertex data}
    
    # Return the value of the specified attribute for the specified vertex.
    method attribute {attrname vertex}

    # Set the specified attribute for all vertices to the specified value.
    method attributeInit {attrname {initvalue 0}}

    # Set the specified attribute for the specified vertex to the specified value.
    method attributeSet {attrname vertex {value 1}}

    # Remove all vertices and edges from the graph
    method clear {}

    # Add an edge and options to the graph
    method connect {vertex1 vertex2 args}

    # Remove a vertex (but not adjacent edges) from the graph
    method delete {vertex}

    # Return a description of the graph
    method describe {}

    # Remove an edge from the graph
    method disconnect {vertex1 vertex2}

    # Get an option or options of an edge
    method edgecget {vertex1 vertex2 option}

    # Configure the edge with one or more options
    method edgeconfigure {vertex1 vertex2 args}

    # Return all options of an edge
    method edgeoptions {vertex1 vertex2}

    # Return edges matching a pair of connection patterns
    method edges {pattern1 pattern2}

    # Return the value of a vertex
    method get {vertex}

    # Initialize the graph from a description
    method init {description}

    # Get the keys at a vertex
    method keys {vertex}

    # Add one or more edges to the graph
    method multiconnect {args}

    # Remove one or more edges from the graph
    method multidisconnect {args}

    # Return the number of edges in the graph
    method numberofedges {}

    # Return the number of vertices in the graph
    method numberofvertices {}

    # "Repair" a graph by deleting improperly-connected edges
    method repair {}

    # Test whether a graph is correctly constructed
    method verify {}

    # Get an option or options of a vertex
    method vertexcget {vertex option}

    # Configure the vertex with one or more options
    method vertexconfigure {vertex args}

    # Return all options of a vertex
    method vertexoptions {vertex}

    # Return vertices matching a pattern
    method vertices {{pattern *}}

    # Attach one or more welds to a vertex
    method weld {vertex args}

    # Get an option or options of a weld
    method weldcget {weld option}

    # Configure a weld with one or more options
    method weldconfigure {weld args}

    # Return all options of a weld
    method weldoptions {weld}

    #################################################################
    ####                   protected methods                     ####

    # Remove an edge from the adjacency matrix and adjust edges array
    protected method deleteedge {vertex1 vertex2}

    # Add an edge to the adjacency matrix
    method adjacencyadd {vertex1 vertex2}

    # Delete an edge from the adjacency matrix
    method adjacencydelete {vertex1 vertex2}

    #################################################################
    ####                  protected variables                    ####

    # The adjacency "matrix." This represents the topology of
    # the graph independent of complexities associated with 
    # hyperedges or keyed connections. It is an array indexed as
    # "vertex1^vertex2" with value {vertex1 vertex2}. In future,
    # the representation may change to use parent-child lists
    # instead of adjacency lists, in which case all subclasses
    # will have to be modified. The parent-child representation
    # is more efficient for traversing the graph, but rather more
    # tedious to maintain in the presence of graph alterations.
    # <b>Note:</b> Preliminary tests using the depthsort{} method
    # indicate that the efficiency overhead using this representation
    # is only about 20%. It may be more critical if we can make
    # depthSort{} and similar algorithms fully non-recursive.
    protected variable _adjacency
    
    # A general-purpose array for storing structural information.
    # All subclass methods that add or delete vertices or edges
    # must do a <code>catch {unset _cache}</code.
    protected variable _cache

    # The edges of the graph. The format of this structure is
    # up to the subclass.
    protected variable _edges
    
    # The options of the edges
    protected variable _edgeoptions
    
    # The vertices of the graph. One entry per vertex, with value
    # equal to the value given in the add{} method.
    protected variable _vertices
    
    # The options of the vertices
    protected variable _vertexoptions

    # The options associated with each weld
    protected variable _weldoptions
}

    ###################################################################
    ###################################################################
    ####                      public methods                       ####

########################################################################
#### add
#
# Add a new vertex to the graph, and return the inverse command. Flag an
# error if the vertex already exists. Additional arguments are a flat
# option-value list for the vertex.
#
body ::tycho::AbstractGraph::add {vertex value args} {
    if { [::info exists _vertices($vertex)] } {
	error "Vertex $vertex already exists in $dataname"
    }
    set modified 1

    # set value
    set _vertices($vertex) $value

    # Set options
    array set temp [concat $vertexoptions $args]
    set _vertexoptions($vertex) [array get temp]

    # Clear the cache
    catch {unset _cache}

    # Return inverse command
    return [list delete $vertex]
}

########################################################################
#### adjacency
#
# Return a list containing the edges of the graph as represented in
# the adjacency matrix with source and target
# vertex names that match the given patterns. The result is a flat list
# of source-target pairs. If no arguments are
# supplied, return all edges.
#
# This is different from edges{} only if the edges are not connected
# from vertex to vertex -- see _MultiGraph_ for an example.
#
body ::tycho::AbstractGraph::adjacency {{pattern1 *} {pattern2 *}} {
    set result {}
    foreach e [array names _adjacency $pattern1^$pattern2] {
	eval lappend result [split $e "^"]
    }
    return $result
}

#######################################################################
#### attribute
# Return the value of the specified attribute for the specified vertex.
# It is an error if the attribute has not been set for this vertex.
# The method <code>attributeInit</code> or <code>attributeSet</code>
# should be used to set the value of the attribute.
# Attributes are used by various algorithms that traverse the graph.
# For example, to keep track of which vertices have beed visited already
# in some graph traversal algorithm, you could use an attribute with
# "visited" that takes value 0 or 1.
#
body ::tycho::AbstractGraph::attribute {attrname vertex} {
    return $_cache($attrname,$vertex)
}

#######################################################################
#### attributeInit
# Set the specified attribute for all vertices to the specified value.
# The attribute name is an arbitrary identifying string, and the value
# is an arbitrary string.  If the value is not given, it defaults to "0".
#
body ::tycho::AbstractGraph::attributeInit {attrname {initvalue 0}} {
    if [info exists _vertices] {
        set searchid [array startsearch _vertices]
        while {[set vertex [array nextelement _vertices $searchid]] != {}} {
            set _cache($attrname,$vertex) $initvalue
        }
        array donesearch _vertices $searchid
    }
}

#######################################################################
#### attributeSet
# Set the specified attribute for the specified vertex to the specified value.
# The attribute name and value can be any arbitrary Tcl strings.
#
body ::tycho::AbstractGraph::attributeSet {attrname vertex {value 1}} {
    set _cache($attrname,$vertex) $value
}


########################################################################
#### connect
#
# Add a new edge to the graph, and return the inverse command.
# The edge is specified by name -- the name format depends upon
# the subclass; additional arguments are a
# flat option-value list for the edge. Flag an error if the edge
# already exists, but not if any of the connected vertices do not exist. 
#
# <i>This is an abstract method.</i>
#
body ::tycho::AbstractGraph::connect {vertex1 vertex2 args} {
    abstractMethod connect
}

########################################################################
#### assign
#
# Assign new data to an existsing vertex. Flag an error if the vertex
# does not exist. Return the inverse command.
#
body ::tycho::AbstractGraph::assign {vertex data} {
    if { ! [::info exists _vertices($vertex)] } {
	error "Vertex $vertex does not exist in $dataname"
    }
    set inverse [list assign $vertex $_vertices($vertex)]
    set _vertices($vertex) $data
    return $inverse
}

#######################################################################
#### clear
# Remove all nodes from the graph and delete the undo history.
# This method cannot be undone or redone.
#
body ::tycho::AbstractGraph::clear {} {
    clearHistory
    # The catch is in case the graph is already clear
    catch {
        unset _vertices
        unset _vertexoptions
        unset _edges
	unset _edgeoptions
	unset _weldoptions
	unset _cache
    }
    # Return null so record{} or publish{} will complain.
    return ""
}

########################################################################
#### delete
#
# Delete a vertex from the graph, and return the inverse command. This
# method overrides the default to clear any cached information
# on the graph structure (transitive closure, depth, and so on)
# so that they will be recalculated for the new structure.
#
body ::tycho::AbstractGraph::delete {vertex} {
    if { ! [::info exists _vertices($vertex)] } {
	error "Unknown vertex $vertex in $dataname"
    }
    set modified 1

    set inverse [list add $vertex $_vertices($vertex) $_vertexoptions($vertex)]
    unset _vertices($vertex)

    # Clear any cached structural information
    catch {unset _cache}

    return $inverse
}

#######################################################################
#### describe
# Return a list that describes the graph. The returned list consists
# of a list of method calls that can be executed to reconstruct
# the graph.
#
body ::tycho::AbstractGraph::describe {} {
    set result {}
    foreach vertex [array names _vertices] {
	lappend result [concat add [list $vertex $_vertices($vertex)] \
		$_vertexoptions($vertex)]
    }
    foreach edge [array names _edges] {
	lappend result [concat connect $_edges($edge) $_edgeoptions($edge)]
    }
    return $result
}

########################################################################
#### disconnect
#
# Remove an edge from the graph, and return the inverse command. Flag an
# error if the edge does not exist.
#
# <i>This is an abstract method.</i>
#
body ::tycho::AbstractGraph::disconnect {vertex1 vertex2} {
    abstractMethod disconnect
}

########################################################################
#### edgecget
#
# Get an option of an edge. An error will occur if the edge does not
# exist or the option does not exist.
#
body ::tycho::AbstractGraph::edgecget {vertex1 vertex2 option} {
    array set temp $_edgeoptions($vertex1^$vertex2)
    return $temp($option)
}

########################################################################
#### edgeconfigure
#
# Configure the edge and return the inverse command. An error will
# occur if the edge does not exist. The argument list
# is a flat list of option-value pairs.
#
body ::tycho::AbstractGraph::edgeconfigure {vertex1 vertex2 args} {
    set modified 1

    set inverse [list edgeconfigure $vertex1 $vertex2]
    array set temp $_edgeoptions($vertex1^$vertex2)
    foreach {option value} $args {
	lappend inverse $option $temp($option)
	set temp($option) $value
    }
    set _edgeoptions($vertex1^$vertex2) [array get temp]
    return $inverse
}

########################################################################
#### edgeoptions
#
# Return a list containing the options of the edge as a flat
# option-value list. An error wil result of the edge does
# not exist.
#
body ::tycho::AbstractGraph::edgeoptions {vertex1 vertex2} {
    return $_edgeoptions($vertex1^$vertex2)
}

########################################################################
#### edges
#
# Return a list containing the edges of the graph with source and target
# vertex names that match the given patterns. The result is a flat list
# of source-target pairs. If no arguments are
# supplied, return all edges.
# To test for the presence of a single edge, provide its source and 
# target vertices as the arguments and compare the result with the empty
# list.
#
body ::tycho::AbstractGraph::edges {{pattern1 *} {pattern2 *}} {
    set result {}
    foreach e [array names _edges $pattern1^$pattern2] {
	eval lappend result [split $e "^"]
    }
    return $result
}

########################################################################
#### get
#
# Get the value of a vertex. Flag an error if the vertex does
# not exist.
#
body ::tycho::AbstractGraph::get {index} {
    if { ! [::info exists _vertices($vertex)] } {
	error "Vertex $vertex does not exist in $dataname"
    }
    return $_vertices($vertex)
}

#######################################################################
#### init
# Initialize the graph from a description. The format of the
# description should be compatible with that produced by the
# <code>describe</code> method.  The graph should be verified
# after this using <code>verify</code>.
#
body ::tycho::AbstractGraph::init {description} {
    clear
    foreach cmd $description {
        eval $this $cmd
    }
}

########################################################################
#### keys
#
# Return a list of keys on a given vertex. (This was named "welds," but
# since it does return keys (eg "bar") instead of welds (eg "foo.bar")
# I thought this name would be more accurate.)
#
body ::tycho::AbstractGraph::keys {vertex} {
    set result {}
    foreach weld [array names _weldoptions $vertex.*] {
	lappend result [lindex [split $weld "."] 1]
    }
    return $result
}

########################################################################
#### multiconnect
#
# Add one or more new edges to the graph, and return the inverse command.
# The arguments list is a flat list of source-target pairs; each
# edge in the list is added to the graph. Edges cannot be given
# options with this method.
#
# Subclasses may choose to override this method if efficiency is
# a problem. Graphs with complex edge structures may choose to
# interpret the argument list differently.
#
body ::tycho::AbstractGraph::multiconnect {args} {
    set inverse [list multidisconnect]
    foreach {vertex1 vertex2} $args {
	connect $vertex1 $vertex2
	lappend inverse $vertex1 $vertex2
    }
    return $inverse
}

########################################################################
#### multidisconnect
#
# Remove one or more edges from the graph, and return the inverse command.
# The arguments list is a flat list of source-target pairs; each
# edge in the list is removed from the graph. Edges cannot be given
# options with this method. This method is particular useful when
# deleting a vertex if you want to delete the edges too; for a digraph,
# you can write:
# <pre>
#    eval $graph multidisconnect [edges $vertex *]
#    eval $graph multidisconnect [edges * $vertex]
#    $graph delete $vertex
# </pre>
#
# Subclasses may choose to override this method if efficiency is
# a problem. Graphs with complex edge structures may choose to
# interpret the argument list differently.
#
body ::tycho::AbstractGraph::multidisconnect {args} {
    set inverse [list execute]
    foreach {vertex1 vertex2} $args {
	lappend inverse [disconnect $vertex1 $vertex2]
    }
    return $inverse
}

########################################################################
#### numberofedges
#
# Return the number of edges in the graph.
#
body ::tycho::AbstractGraph::numberofedges {} {
    return [array size _edges]
}

########################################################################
#### numberofvertices
#
# Return the number of vertices in the graph.
#
body ::tycho::AbstractGraph::numberofvertices {} {
    return [array size _vertices]
}

########################################################################
#### repair
#
# "Repair" a graph by deleting improperly-connected edges. This method
# provides a default implementation that will remove invalid edges in 
# properly-written subclasses; however, however,
# subclasses may choose to override it for efficiency, because it doesn't work
# with the subclass, or to perform additional repairs. This
# method should be called after building a graph if it is not certain
# that the graph is correctly constructed.
#
# This method cannot be recorded or published.
#
body ::tycho::AbstractGraph::repair {} {
    set modified 1

    foreach {src tgt} [edges] {
	if { ! [::info exists _vertices($src)] \
		|| ! [::info exists _vertices($tgt)] } {
	    disconnect $src $tgt
	}
    }
    # Return null so record{} or publish{} will complain.
    return ""
}

########################################################################
#### verify
#
# Test whether a graph is properly constructed. This method
# provides a default implementation that tests for invalid edges; however,
# subclasses may choose for efficiency, because it doesn't work
# with the subclass, or to perform additional tests.
#
body ::tycho::AbstractGraph::verify {} {
    foreach {src tgt} [edges] {
	if { ! [::info exists _vertices($src)] } {
	    return 0
	}
    }
    return 1
}

########################################################################
#### vertexcget
#
# Get an option of an vertex. An error will occur if the vertex does not
# exist or the option does not exist.
#
body ::tycho::AbstractGraph::vertexcget {vertex option} {
    array set temp $_vertexoptions($vertex)
    return $temp($option)
}

########################################################################
#### vertexconfigure
#
# Configure the vertex and return the inverse command. An error will
# occur if the vertex does not exist. The argument list
# is a flat list of option-value pairs.
#
body ::tycho::AbstractGraph::vertexconfigure {vertex args} {
    set modified 1

    set inverse [list vertexconfigure $vertex]
    array set temp $_vertexoptions($vertex)
    foreach {option value} $args {
	lappend inverse $option $temp($option)
	set temp($option) $value
    }
    set _vertexoptions($vertex) [array get temp]
    return $inverse
}

########################################################################
#### vertexoptions
#
# Return a list containing the options of the vertex as a flat
# option-value list. An error wil result of the vertex does
# not exist.
#
body ::tycho::AbstractGraph::vertexoptions {vertex} {
    return $_vertexoptions($vertex)
}

########################################################################
#### vertices
#
# Return a list containing the vertices of the graph whose names match 
# a pattern. If the pattern is not given, all vertices are returned.
# To test for the presence of a single vertex, provide its name
# as the argument and compare the result with the empty list.
#
body ::tycho::AbstractGraph::vertices {{pattern *}} {
    return [array names _vertices $pattern]
}

########################################################################
#### weld
#
# Attach one or more welds to a vertex. The arguments are a list of
# keys.
#
body ::tycho::AbstractGraph::weld {vertex args} {
    if { ! [::info exists _vertices($vertex)] } {
	error "Unknown vertex $vertex in $dataname"
    }

    foreach key args {
	set _weldoptions($vertex.$key) $weldoptions
    }
}

########################################################################
#### weldcget
#
# Get an option of a weld.  An error will occur if the
# weld does not exist or the option does not exist for that weld.
#
body ::tycho::AbstractGraph::weldcget {weld option} {
    array set temp $_weldoptions($weld)
    return $temp($option)
}

########################################################################
#### weldconfigure
#
# Configure the weld and return the inverse command. The argument list
# is a flat list of option-value pairs. An error will occur if the
# weld does not exist.
#
body ::tycho::AbstractGraph::weldconfigure {weld args} {
    set inverse [list weldconfigure $weld]
    array set temp $_weldoptions($weld)
    foreach {option value} $args {
	lappend inverse $option $temp($option)
	set temp($option) $value
    }
    set _weldoptions($weld) [array get temp]
    return $inverse
}

########################################################################
#### weldoptions
#
# Return a list containing the options of a weld as a flat
# option-value list. An error will occur if the weld does not exist.
#
body ::tycho::AbstractGraph::weldoptions {weld} {
    return $_weldoptions($weld)
}


#####################################################################
#####################################################################
####                     protected methods                       ####


########################################################################
#### deleteedge
#
# Delete an edge from the graph. The edge is specified by the
# two end vertices. The default method simply calls disconnect;
# graphs with complex edge structures will need to override
# the method to adjust the edge structures.
#
body ::tycho::AbstractGraph::deleteedge {vertex1 vertex1} {
    disconnect $vertex1 $vertex2
}

########################################################################
#### adjacencyadd
#
# Add an edge to the adjacency matrix. If it already exists,
# do nothing.
#
body ::tycho::AbstractGraph::adjacencyadd {vertex1 vertex2} {
    set _adjacency($vertex1^$vertex2) [list $vertex1 $vertex2]
}

# body ::tycho::AbstractGraph::adjacencyadd {vertex1 vertex2} {
#     if { [lsearch -exact _adjacency($vertex1.children) $vertex2] == -1 } {
# 	lappend _adjacency($vertex1.children) $vertex2
# 	lappend _adjacency($vertex1.parents)  $vertex1
#     }
# }

########################################################################
#### adjacencydelete
#
# Delete an edge from the adjacency matrix.
#
body ::tycho::AbstractGraph::adjacencydelete {vertex1 vertex2} {
    unset _adjacency($vertex1^$vertex2)
}

# body ::tycho::AbstractGraph::adjacencydelete {vertex1 vertex2} {
#     set pindex [lsearch -exact _adjacency($vertex1.children) $vertex2]
#     set cindex [lsearch -exact _adjacency($vertex1.parents)  $vertex1]
#     if {$pindex >= 0 && $cindex >= 0} {
#         set _adjacency($vertex1.children) \
#                 [lreplace _adjacency($vertex1.children) $pindex $pindex]
#         set _adjacency($vertex1.parents) \
#                 [lreplace _adjacency($vertex1.parents $cindex $cindex]
#     }
# }
