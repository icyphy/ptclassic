##########################################################################
# Version: $Id$
# Author: John Reekie
#
# @Copyright (c) 1996-1997 The Regents of the University of California.
# All rights reserved.
# 
# Permission is hereby granted, without written agreement and without
# license or royalty fees, to use, copy, modify, and distribute this
# software and its documentation for any purpose, provided that the
# above copyright notice and the following two paragraphs appear in all
# copies of this software.
# 
# IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY
# FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
# ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF
# THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.
# 
# THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE
# PROVIDED HEREUNDER IS ON AN "AS IS" BASIS, AND THE UNIVERSITY OF
# CALIFORNIA HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,
# ENHANCEMENTS, OR MODIFICATIONS.
# 
# 						PT_COPYRIGHT_VERSION_2
# 						COPYRIGHTENDKEY
##########################################################################


##########################################################################
#### editdfg
#
# Procedure to create graph editor
#
proc ::tycho::editdfg {file} {
    set nm [::tycho::view EditDFG -file $file]

    # FIXME FIXME
    # Load stars and icons
    # $nm loadStars [::tycho::expandPath {$TYCHO/editors/graphedit/stars.tim}]
    # $nm loadIcons [::tycho::expandPath {$TYCHO/editors/graphedit/icons.tim}]

    $nm library load editors/graphedit/stars.tim
    $nm library addtomenu stars stars -command "$nm newstar stars"
    return $nm
}

##########################################################################
#### EditDFG
#
# _EditDFG_ is an editor for the _GraphLayout_ model. It edits
# directed graphs.
#
class ::tycho::EditDFG {
    inherit ::tycho::SlateView

    constructor {args} {}
    destructor {}
    
    #################################################################
    ####                        options                          ####

    #################################################################
    ####                     public methods                      ####

    # Clear all data
    method clear {}

    # Edit parameters of the given vertices
    method editparameters {args}

    # Create the line
    method connectbegin {x y}

    # Start creating a new connection
    method connectclick {id x y}

    # Continue move the end of the new connection
    method connectdrag {id x y}

    # Stop moving a new connection
    method connectrelease {args}

    # Test if an item can start a new connection
    method connectsource {id}

    # Test if an item is a suitable target for a connection
    method connecttarget {id}

    # Place a star
    method newstar {libname starname}

    # Handle change notification from the graph model
    method notifygraph {method args}

    # Place an icon
    method placeicon {iconlib iconname starname}

    # Move mouse over a port
    method portenter {}

    # Move mouse away from a port
    method portleave {}

    # Redo the most recent command
    method redo {}
    
    # Handle changes to the selection
    method select {mode args}
    
    # Undo the most recent command
    method undo {}

    # Start moving a vertex
    method vertexclick {tag x y args}

    # Delete a vertex
    method vertexdelete {vertex}

    # Continue moving a vertex
    method vertexdrag {tag x y}

    # Stop moving a vertex
    method vertexrelease {tag}

    #################################################################
    ####                  protected methods                      ####

    # Initialize the menu/status/tool bars
    protected method _initializeBars {menubar statusbar toolbar}

    # Insert the specified data
    protected method insertData {data}

    # Return the data to be saved
    protected method saveText {}

    #################################################################
    ####                 protected variables                     ####
    
    # The interactor to move things around
    protected variable follower

    # The interactor to connect edges
    protected variable dropper

    # The item selector
    protected variable selector

    # The semantic model
    protected variable _graph ""

    # Storage for temporary variables
    protected variable _scratch

    #################################################################
    ####                   private methods                       ####

    # Initialize the menubar
    private method _initializeMenubar {menubar}

    #################################################################
    ####                  FIXME FIXME FIXME                      ####
    
    # Position used to place new icons
    private variable iconx 50
    private variable icony 50
}

########################################################################
#### constructor
#
body ::tycho::EditDFG::constructor {args} {

    # Create the models. The graph model has a special notify{} method
    set _graph [uplevel #0 ::tycho::PortedDigraph [::tycho::autoName graph]]
    model add graph $_graph
    $_graph subscribe data $this "$this notifygraph"

    # The layout model uses notify{} inherited from SlateView
    set _layout [uplevel #0 ::tycho::Layout [::tycho::autoName layout]]
    model add layout $_layout
    $_layout subscribe data $this

    # In addition, subscribe to the layout model as a "view". This
    # is necessary because the Layout model sometimes needs to get
    # data from a real Tk canvas...
    $_layout subscribe view $this

    # Evaluate options
    eval itk_initialize $args

    # Key bindings
    bind $_slate <Meta-Key-z> "$this undo"
    bind $_slate <Meta-Key-r> "$this redo"

    # Make a more pronounced highlight
    $_slate configure -highlightcolor azure2 -highlightwidth 4

    # Enable vertex selection with button 1; shift-click toggles
    set selector [$_slate interactor Selector]
    $selector bind vertex -button 1
    $selector bind vertex -button 1 \
            -modifiers shift -toggle 1

    # Enable edge selection with button 1; shift-click toggles
    $selector bind edge -button 1
    $selector bind edge -button 1 \
            -modifiers shift -toggle 1

    # Create the interactor to move selected items
    set follower [$_slate interactor Follower]
    $selector delegate $follower vertex -button 1
    $selector delegate $follower vertex -button 1 \
            -modifiers shift

    # Now for some tricky stuff: we want the follower to send
    # the interaction to the model, rather than to the slate.
    # Give it the right "prefixes":
    $follower configure \
            -clickprefix "$this vertexclick" \
            -dragprefix "$this vertexdrag" \
            -releaseprefix "$this vertexrelease"

    # More tricky stuff: the selector sends selection events here
    $selector configure \
            -clearprefix "$this select clear" \
            -deselectprefix "$this selectremove" \
            -selectprefix "$this select add"

    # Create a DragDropper to join terminals
    set dropper [$_slate interactor DragDropper]
    $dropper bind input
    $dropper bind output
    $dropper configure \
	    -sourcehalo 2 \
	    -targethalo 6 \
	    -targettags {input output} \
            -sourcepredicate "$this connectsource" \
            -targetpredicate "$this connecttarget" \
	    -activatecommand "$this connectclick" \
	    -dragcommand "$this connectdrag" \
	    -deactivatecommand "$this connectrelease"

    # Is this needed?
    # $_slate configure -exportselection 0
}

########################################################################
#### editparameters
#
body ::tycho::EditDFG::editparameters {args} {
    # FIXME: The parameter editing window must include the whole
    # path name of the model
    foreach v $args {
        set item [$_graph vertexcget $v -type]
        regsub -all {\.} $v "_" nm
        set nm .$nm
        if { [::info which -command $nm] != "" } {
            # Already exists
            wm deiconify $nm
            raise $nm
        } else {
            uplevel #0 [list ::tycho::ParameterEdit $nm \
                    -command "::tycho::post \[$nm get\]"]
            $nm edit $starLibrary $item $_graph $v vertex
            wm deiconify $nm
        }
    }
}

########################################################################
#### connectbegin
#
# Start creating a new edge. This creates the edge item.
#
body ::tycho::EditDFG::connectbegin {x y} {
    set id $_scratch(source)

    # The "direction" of the terminal
    set dir [eval ::tycho::Shape::compassFromVector \
            [$_slate itemcget $id -direction]]

    # Figure out whether we are connecting from an output or input,
    # and act accordingly
    if { [lsearch -exact [$_slate gettags $id] output] >= 0 } {
        set _scratch(outtoin) 1
        set _scratch(aspect) end
        set _scratch(targettag) input
        set coords [concat [$_slate aspect $id terminal] $x $y]       
    } else {
        set _scratch(outtoin) 0
        set _scratch(aspect) start
        set _scratch(targettag) output
        set coords [concat $x $y [$_slate aspect $id terminal]]
        set dir [::tycho::Shape::compass $dir "rev"]
    }
    # Create the line
    set _scratch(line) \
            [eval $_slate create SmartLine $coords $x $y \
            -start $dir \
            -end $dir]
    
    # Remember the line direction
    set _scratch(targetdirection) $dir
}

########################################################################
#### connectclick
#
# Process the click that may create a new edge.
#
body ::tycho::EditDFG::connectclick {id x y} {
    # First we make sure that we clear the selection
    # FIXME: Should this be an event?
    $_layout notify data select clear

    # Remember the source item
    set _scratch(source) $id
    set _scratch(target) ""
    set _scratch(line) ""
}

########################################################################
#### connectdrag
#
# Move the end of the new edge. If the line item does not exist, then
# this is the first drag call, so call connectbegin to create the line.
# If the _item_ argument is null, then we are not over a suitable
# terminal item, so just move the end of the line. If _item_ is not
# null, then we are over an input terminal, so move the end of the
# line to the right connection point.
#
body ::tycho::EditDFG::connectdrag {id x y} {
    if { $_scratch(line) == "" } {
        connectbegin $x $y
    }

    if { $id == "" } {
	# Just move start or end point
	$_slate reshapeto $_scratch(line) $x $y $_scratch(aspect)
    } else {
	# Move end point to terminal connection point
	set coords [$_slate aspect $id terminal]
	eval $_slate reshapeto $_scratch(line) $coords $_scratch(aspect)

	# If the line direction does not match the terminal
	# direction, change the line
        set dir [eval ::tycho::Shape::compassFromVector \
                [$_slate itemcget $id -direction]]
        if $_scratch(outtoin) {
            set dir [::tycho::Shape::compass $dir "rev"]
        }

	if { $dir != $_scratch(targetdirection) } {
	    $_slate itemconfigure $_scratch(line) -$_scratch(aspect) $dir
	    set _scratch(targetdirection) $dir
	}
    }
    # Remember the target item for connectrelease{}
    set _scratch(target) $id
}

########################################################################
#### connectrelease
#
# Release the item. If we are currently over a target input terminal,
# make a connection in the graph. If not, just delete the line,
# since connection failed.
#
body ::tycho::EditDFG::connectrelease {args} {
    set line $_scratch(line)
    if { $_scratch(target) == "" } {
        $_slate delete $line
    } else {
	# Get the vertices and ports being connected
	set source [itemname $_scratch(source)]
	set target [itemname $_scratch(target)]

	# Add an edge to the graph
        if $_scratch(outtoin) {
            set edgename [join $source .]^[join $target .]
        } else {
             set edgename [join $target .]^[join $source .]
         }
	$_graph publish add edge $edgename

	# Add an edge to the layout model. Give it the tag "edge."
	$_layout publish add item $edgename \
                -slatetype [$_slate type $line] \
                -coords [$_slate coords $line] \
		-start [$_slate itemcget $line -start] \
		-end [$_slate itemcget $line -end] \
                -tags "edge"
	
        # Now delete the original edge so we don't end up with two...
        $_slate delete $line

	# Update the layout model's coordinates
        # ???
	# eval $_layout coords $name [$_slate coords $line]
    }
    unset _scratch
}

########################################################################
#### connectsource
#
# Test if an item is a valid candidate for starting a new connection.
# This method looks at the connectivity of the item.
#
body ::tycho::EditDFG::connectsource {id} {
    # Get connections from the graph model
    # FIXME: won't work with multiports...
    set name [itemname $id]
    if { [$_graph names [join $name .]^*.*] == "" \
            && [$_graph names *.*^[join $name .]] == "" } {
        return 1
    } else {
        return 0
    }
}

########################################################################
#### connecttarget
#
# Test if an item is a valid candidate for terminating a new connection.
# This method looks at the tags and the connectivity of the item.
#
body ::tycho::EditDFG::connecttarget {id} {
    if ![::info exists _scratch(targettag)] {
        return 0
    }
    if { [lsearch -exact [$_slate gettags $id] $_scratch(targettag)] >= 0 } {
        set name [itemname $id]
        if { [$_graph names [join $name .]^*.*] == "" \
                && [$_graph names *.*^[join $name .]] == "" } {
            return 1
        } else {
            return 0
        }
    } else {
        return 0
    }
}

########################################################################
#### newstar
#
body ::tycho::EditDFG::newstar {libname starname} {
    set lib [library access $libname]

    # Instantiate the star as a vertex of the graph
    set starname [$lib instantiate $starname $_graph -itemtype vertex]

    # Find the icon of the star
    if [$_graph exists $starname -icon] {
        set iconpath [$_graph attrget $starname -icon]
        set splat [split $iconpath #]
        set iconlib [lindex $splat 0]
        set iconname [lindex $splat 1]

        # FIXME: Need a shorter way of doing this...
        set libpath [::tycho::model load $iconlib]
        # FIXME: key cannpt be reused, hence the autoname...
        set iconmodel [::tycho::model link $libpath [::tycho::autoName $this]]

        # See if the icon has a dot-separated name
        if ![$iconmodel exists $iconname] {
            if [$iconmodel exists [split $iconname .]] {
                set iconname [split $iconname .]
            } else {
                error "Unknown icon \"$iconname\" in $iconlib"
            }
        }
        # Place the icon
        placeicon $iconmodel $iconname $starname
    } else {
        # FIXME
        error "No icon for $starname"
    }
}

########################################################################
#### notifygraph
#
body ::tycho::EditDFG::notifygraph {method args} {
    # puts "$this notifygraph $method"
    # eval _$method $args

    # Assume any notification means a modification...
    # (This is too agrresive -- even selecting an item
    # causes the view to be marked modified...)
    # markModified
}

########################################################################
#### placeicon
#
# Place an icon into the layout model. Currently, this just guesses
# at a good location to put the icon. Later on, it should do some
# kind of grab and place or drag-and-drop.
#
body ::tycho::EditDFG::placeicon {iconlib iconname starname} {
    # Figure out where to put the icon. First check if topleft is free
    if { [$_slate find overlapping 10 10 10 10] == "" } {
        set iconx 10
        set icony 10
    }
    # Place the icon into the layout model, giving it the
    # same name as the vertex in the graph.
    $iconlib instantiate $iconname $_layout \
            -itemname $starname \
            -coords [list $iconx $icony] \
            -tags vertex

    # Move its nw corner to the right position. Find the position
    # from my slate, and then move by publishing to the model
    # $_slate moveto $id $iconx $icony "nw" -shape rectangle
    set current [$_layout forward aspect $starname "nw" -shape "rectangle"]
    set x [expr $iconx - [lindex $current 0]]
    set y [expr $icony - [lindex $current 1]]
    $_layout publish move $starname $x $y

    # Advance place position
    incr iconx 10
    incr icony 10
}

########################################################################
#### redo
#
# Redo the most recent command
#
body ::tycho::EditDFG::redo {} {
    eval $_layout redo
    eval $_graph redo
}

########################################################################
#### select
#
# Handle changes to the selection.
#
body ::tycho::EditDFG::select {mode args} {
    puts "EditDFG::select $args"
    switch -exact $mode {
        "clear" {
            $_slate select clear
        }
        "add" {
            eval $_slate select add $args
        }
        "remove" {
            eval $_slate select remove $args
        }
    }
}

########################################################################
#### undo
#
# Undo the most recent command
#
body ::tycho::EditDFG::undo {} {
    set foo [eval $_layout undo]
    set bar [eval $_graph undo]
}

########################################################################
#### vertexclick
#
# Start a move interaction on vertices. The argument is a tag which
# must be attached only to vertices to be moved. Get the names of
# edges that are fully connected to these vertices and tag
# all vertices and those edges. Also get the names of edges
# that have one end connected to one of these vertices and
# remember who they are.
#
body ::tycho::EditDFG::vertexclick {tag x y args} {
    # Get the vertices, and start a move sequence on them
    set vertices [find withtag $tag]

    # Get the item name or the same tag
    set name [itemname $tag]
    set _scratch(movetag) $name

    # Notify views that these items are about to move
    $_layout publish moveclick $name $x $y

    # Get completely-connected and partially-connected edges
    set _scratch(moveedges) [eval $_graph subgraphEdges $vertices]
    set _scratch(inputedges) [eval $_graph subgraphInputs $vertices]
    set _scratch(outputedges) [eval $_graph subgraphOutputs $vertices]
    
    # Start a move or reshape sequence on found edges
    if { $_scratch(moveedges) != "" } {
	eval $_layout notify data addtag $this.edge $_scratch(moveedges)
	$_layout publish moveclick $this.edge $x $y
    }
    foreach edge $_scratch(inputedges) {
        $_layout publish reshapeclick $edge $x $y -aspects end
    }
    foreach edge $_scratch(outputedges) {
        $_layout publish reshapeclick $edge $x $y -aspects start
    }
}

########################################################################
#### vertexdelete
#
# Delete a vertex and all connected edges.
#
body ::tycho::EditDFG::vertexdelete {vertex} {
    # Get connected edges
    set edges [concat \
	    [$_graph subgraphEdges $vertex] \
	    [$_graph subgraphInputs $vertex]]
    
    # Mark the layout history
    $_layout mark vertex
    
    # Delete the vertex and connected edges
    $_layout publish delete $vertex
    foreach edge $edges {
    	$_layout publish delete $edge
    }
    
    # Merge the deletion commands into one
    if { $edges != "" } {
    	$_layout compactHistory vertex current 1
    }
    
    # Delete the vertex form the graph model. This automatically
    # deletes connected edges
    $_graph publish vertexdelete $vertex
}

########################################################################
#### vertexdrag
#
# Continue a move interaction on vertices. The
# vertices and edges are moved and reshaped as appropriate.
#
body ::tycho::EditDFG::vertexdrag {tag x y} {
    # Move the vertices and fully-connected edges
    $_layout publish movedrag $_scratch(movetag) $x $y
    if { $_scratch(moveedges) != "" } {
	$_layout publish movedrag $this.edge $x $y
    }
    # Reshape the partially-connected edges.
    foreach edge $_scratch(inputedges) {
	$_layout publish reshapedrag $edge $x $y
    }
    foreach edge $_scratch(outputedges) {
	$_layout publish reshapedrag $edge $x $y
    }
}

########################################################################
#### vertexrelease
#
# Terminate a move interaction on vertices and add an undo and
# redo command to the history of the layout model.
#
body ::tycho::EditDFG::vertexrelease {tag} {
    # Because the following will record a bunch of commands that we
    # want merged into a single undo/redo command, set a mark
    $_layout mark set vertex

    # Terminate move of vertices
    $_layout publish moverelease $_scratch(movetag)

    # Terminate move of fully-connected edges
    if { $_scratch(moveedges) != "" } {
        $_layout publish moverelease $this.edge
        $_layout notify data dtag $this.edge
    }

    # Terminate the reshape of partially-connected edges
    foreach edge $_scratch(inputedges) {
	$_layout publish reshaperelease $edge
    }
    foreach edge $_scratch(outputedges) {
	$_layout publish reshaperelease $edge
    }

    # Now merge all those commands into a single one
    $_layout history compact vertex current

    # Finally (and importantly!), add a null command to the graph
    # model to match this command
    $_graph history append {} {}
}

###################################################################
###################################################################
####                      protected methods                    ####

#####################################################################
#### _initializeBars
# Initialize the menu, status, and toolbars associated with this widget.
# The root (view) class sets up the menubar methods in it's initialize
# via the chain command, which should always be the first command in
# this method.
# 
# This method is called by it's displayer when attachView is called (usually
# in ::tycho::view
#
body ::tycho::EditDFG::_initializeBars {menubar statusbar toolbar} {
    chain $menubar $statusbar $toolbar

    if {$menubar != {}} {
        # We have to qualify the call to this supposed-ly private
        # method because Itcl (2.2) has virtual private methods!
        ::tycho::EditDFG::_initializeMenubar $menubar
    }
}

#####################################################################
#### clear
# Clear the data.
#
body ::tycho::EditDFG::clear {} {
    if { $_graph != "" } {
        $_graph clear
    }
    if { $_layout != "" } {
        $_layout clear
    }
    $_slate delete all
}

#####################################################################
#### insertData
# Insert the specified data. For now, this is a two-list containing
# a description of the graph and the layout respectively.
# Note that data cannot be just inserted: it will always
# be cleared too.
#
body ::tycho::EditDFG::insertData {data} {
    # Delete all data
    clear

    # Load the data into the models
    $_graph parse [lindex $data 0]
    $_layout parse [lindex $data 1]

    # Load the new data into this view
    loadLayout
}

#####################################################################
#### saveText
# Return the text to save. For now, this is a two-list containing
# a description of the graph and the layout respectively.
#
body ::tycho::EditDFG::saveText {} {
    set result "\{\n"
    append result [$_graph describe]
    append result "\}\n\{\n"
    append result [$_layout describe]
    append result "\}\n"
    return $result
}

    #####################################################################
    #####################################################################
    ####                       private methods                       ####

#####################################################################
#### _initializeMenubar
# Adds entries to the menu bar specific to this class.
#
body ::tycho::EditDFG::_initializeMenubar {menubar} {
    # Add an Edit menu before the Window menu
    $menubar addMenu edit -label Edit -before window -underline 0
    
    $menubar command undo edit \
	    -label "Undo" -accelerator "M-z" \
	    -underline 0 -command "$this undo"
    
    $menubar command redo edit \
	    -label "Redo" -accelerator "M-r" \
	    -underline 0 -command "$this redo"
    
    $menubar separator editsep1 edit
    
    $menubar command cut edit \
	    -label "Cut" -underline 0 -accelerator "C-w" \
	    -command "$this cut"
    
    $menubar command copy edit \
	    -label "Copy" -underline 1 -accelerator "M-w" \
	    -command "$this copy"
    
    $menubar command paste edit \
	    -label "Paste" -underline 0 -accelerator "C-y" \
	    -command "$this paste"
    
    $menubar separator editsep2 edit
    
    $menubar command selectall edit \
	    -label "Select All" -underline 0 \
	    -accelerator "C-/" -command "$this selectRange 1.0 end"
    
    $menubar command unselect edit \
	    -label "Unselect" -underline 0 \
	    -accelerator "C-\\" -command "$this unselectRange 1.0 end"

    # Build a menu for stars
    $menubar addMenu stars -label Stars -underline 0
    $menubar menuconfigure stars -tearoff 1

    $menubar command editparameters stars \
            -label "Edit Parameters..." \
            -underline 5 \
            -command "eval $this editparameters \[$this find withtag sel\]"

    $menubar separator starsep1 stars

    # Add a Devel menu for development use
    $menubar addMenu devel -label Devel -underline 0

    $menubar add separator develsep1 devel

    $menubar command showlayout devel \
	    -label "Show layout" \
            -command "set _nm_ \[::tycho::view EditTcl\]; \
        \$_nm_ insertData \[$this model access layout describe\]"

    $menubar command showgraph devel \
	    -label "Show graph" \
            -command "set _nm_ \[::tycho::view EditTcl\]; \
        \$_nm_ insertData \[$this model access graph describe\]"

    $menubar add separator develsep2 devel

    $menubar command showlayouthistory devel \
	    -label "Show layout history" \
            -command "set _nm_ \[::tycho::view EditTcl\]; \
        \$_nm_ insertData \[$this model access layout history get\]"

    $menubar command showgraphhistory devel \
	    -label "Show graph history" \
            -command "set _nm_ \[::tycho::view EditTcl\]; \
        \$_nm_ insertData \[$this model access graph history get\]"

}
