##########################################################################
# Version: $Id$
# Author: John Reekie
#
# @Copyright (c) 1996-%Q% The Regents of the University of California.
# All rights reserved.
# 
# Permission is hereby granted, without written agreement and without
# license or royalty fees, to use, copy, modify, and distribute this
# software and its documentation for any purpose, provided that the
# above copyright notice and the following two paragraphs appear in all
# copies of this software.
# 
# IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY
# FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
# ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF
# THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.
# 
# THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE
# PROVIDED HEREUNDER IS ON AN "AS IS" BASIS, AND THE UNIVERSITY OF
# CALIFORNIA HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,
# ENHANCEMENTS, OR MODIFICATIONS.
# 
# 						PT_COPYRIGHT_VERSION_2
# 						COPYRIGHTENDKEY
##########################################################################


##########################################################################
#### PortedDigraph
#
# The _PortedDigraph_ model is a directed graph with the
# notion of "ports" at each vertex. Edges between vertices must
# connect to a port of a vertex rather than just the vertex.
# Ports are implemented as an entity nested within
# vertices, and can therefore be configured with attributes.
# The most obvious application of this kind of graph is dataflow
# graphs, in which each edge from a vertex must be uniquely identified.
#
# _PortedDigraph_ adds the following types to those inherited
# from _AbstractGraph_:
# <dl>
# <dt><b>edge</b> _name_
# <dd>
# An edge between two ports. The name of an edge is formed from the
# vertices and ports it connects:
# <b>edge:</b>_v1_<b>.</b>_p1_<b>^</b>_v2_<b>.</b>_p2_, where _v1_ and _p1_
# are the source vertex and port, and _v2_ and _p2_ are the target
# vertex and port. The external (TIM) format is a little friendlier,
# and represents an edge as <b>edge</b> _v1_ _p1_ _v2_ _p2_.
# Edges have no default attributes.
#
# <dt><b>port</b> _name_
# <dd>
# A port of a vertex. Ports are used to connect edges, but can also
# be given attributes of their own. Ports are usefully only
# contained with a vertex.
#
# </dl>
#
# Here are some examples of creating and accessing a ported digraph.
# The graph looks like this:
# <pre>
#   a---->c--->
#         ^
#   b-----+--->d
# </pre>
# Create the graph, configure attributes of edges and vertices,
# and load data into it:
# <tcl><pre>
#     catch {delete object $graph}
#     set graph [::tycho::PortedDigraph [::tycho::autoName graph]]
#     $graph type configure vertex -weight 1
#     $graph type configure edge -initialdelay 0
#     $graph type configure port -tokencount 1 -type input
#     $graph parse {
#         vertex a {
#             port out -tokencount 2 -type output
#         }
#         vertex b {
#             port out -type output
#         }
#         vertex c {
#             port in-0
#             port in-1
#             port out -type output
#         }
#         vertex d {
#             port in
#         }
#         edge a out c in-0 -initialdelay 1
#         edge b out c in-1
#         edge b out d in
#     }
#     $graph describe
# </tcl></pre>
#
# Get the ports of a vertex:
# <pre><tcl>
#     $graph ports c
# </tcl></pre>
#
# Get the edges coming _in_ to a given port:
# <pre><tcl>
#     $graph edges * * c in-0
# </tcl></pre>
#
# Get the edges coming _out_ of a given port:
# <pre><tcl>
#     $graph edges b out * *
# </tcl></pre>
#
# Delete an edge:
# <pre><tcl>
#     $graph delete edge:b.out^d.in
#     $graph describe
# </tcl></pre>
#
# Delete a vertex but not edges connected to it, and record the deletion:
# <pre><tcl>
#     $graph record delete vertex:c
#     $graph describe
# </tcl></pre>
#
# Undo the deletion:
# <pre><tcl>
#     $graph undo
#     $graph describe
# </tcl></pre>
#
# Delete a vertex and all edges connected to it, recording it:
# <pre><tcl>
#     $graph record remove c
#     $graph describe
# </tcl></pre>
#
# Undo the deletion:
# <pre><tcl>
#     $graph undo
#     $graph describe
# </tcl></pre>
#
class ::tycho::PortedDigraph {
    inherit ::tycho::AbstractGraph
    
    constructor {args} {}
    destructor {}

    #################################################################
    ####                     public methods                      ####

    # Return edges matching a vertex and port patterns
    method edges {{v1 *} {p1 *} {v2 *} {p2 *}}

    # Return ports of a vertex that match a pattern
    method ports {vertex {port *}}

    # Remove a vertex _and_ adjacent edges from the graph
    method remove {vertex}

    # "Repair" a graph by deleting improperly-connected edges
    method repair {}

    # Get the edges within a subgraph
    method subgraphEdges {args}

    # Get the input edges to a subgraph
    method subgraphInputs {args}

    # Get the output edges from a subgraph
    method subgraphOutputs {args}

    # Test whether a graph is correctly constructed
    method verify {}

    #################################################################
    ####                   protected methods                     ####

    # Add an edge
    protected method _addedge {v1 p1 v2 p2 args}

    # Return a description of an edge
    protected method _describeedge {name {prefix {}}}

    # Update the cache
    protected method _updatecache
}

########################################################################
#### constructor
#
body ::tycho::PortedDigraph::constructor {args} {
    # Define the "edge" type
    type define edge \
            :override 1 \
            :leafonly 1

    # Define the "port" entity
    type define port \
	    :leafonly 1

    # Turn off the :leafonly option of vertices, so that
    # they can contain ports
    # type configure vertex :leafonly 0

    # Evaluate options
    eval configure $args
}

########################################################################
#### edges
#
# Return a list containing the edges of the graph that match the
# given patterns, where _v1_ and _p1_ are the source vertex and port,
# and _v2_ and _p2_ are the target vertex and port. The returned list
# alternates source and target vertex and port names (note: not item
# names such as <code>edge:a.out^b.in</code>).
#
body ::tycho::PortedDigraph::edges {{v1 *} {p1 *} {v2 *} {p2 *}} {
    set result {}
    foreach edge [names edge:$v1.$p1^$v2.$p2] {
        eval lappend result [lrange [split $edge :^.] 1 4]
    }
    return $result
}

########################################################################
#### ports
#
# Return a list of ports of the given vertex. If the second argument
# is given, it is a glob-style pattern to be used to match against
# port names. The result is a list of port names, relative to the
# vertex name and without the "port:" qualification
#
body ::tycho::PortedDigraph::ports {vertex {pattern *}} {
    set result {}
    foreach port [names [list vertex:$vertex port:$pattern]] {
    	lappend result [lindex [split [lindex $port end] :] 1]
    }
    return $result
}

########################################################################
#### remove
#
# Delete a vertex and all connected edges from the graph, recording
# commands if the recording flag is set.
#
body ::tycho::PortedDigraph::remove {vertex} {
    if ![exists vertex:$vertex] {
        error "Unknown vertex: \"$vertex\""
    }
    # Mark the history
    mark set temp

    # Delete outward edges
    foreach edge [names edge:$vertex.*^*.*] {
        delete $edge
    }
    # Delete inward edges
    foreach edge [names edge:*.*^$vertex.*] {
        delete $edge
    }
    # Delete the vertex
    delete vertex:$vertex

    # Compact the history
    if $recording {
        history compact temp current
    }
}

########################################################################
#### repair
#
# "Repair" a graph by deleting improperly-connected edges.
# Append to the history if recording.
#
body ::tycho::PortedDigraph::repair {} {
    mark set temp
    foreach edge [names edge:*] {
        foreach {_ v1 p1 v2 p2} [split $edge :.^] {}
        if { ![exists "vertex:$v1 port:$p1"] \
                || ![exists "vertex:$v2 port:$p2"] } {
            # Delete a disconnected edge
            delete edge:$v1.$p1^$v2.$p2
        }
    }
    if $recording {
        history compact temp current
    }
}

########################################################################
#### subgraphEdges
#
# Return the edges within the sub-graph given by the arguments. Each
# argument is the short name of a vertex.
#
body ::tycho::PortedDigraph::subgraphEdges {args} {
    set result {}
    foreach u $args {
        foreach v $args {
            eval lappend result [names edge:$u.*^$v.*]
        }
    }
    return $result
}

########################################################################
#### subgraphInputs
#
# Return the input edges to a sub-graph. Each
# argument is the short name of a vertex.
#
body ::tycho::PortedDigraph::subgraphInputs {args} {
    set result {}
    foreach v $args {
        foreach edge [names edge:*.*^$v.*] {
            if { [lsearch -exact $args [lindex [split $edge :.^] 1]] < 0 } {
                lappend result $edge
            }
        }
    }
    return $result
}

########################################################################
#### subgraphOutputs
#
# Return the output edges from a sub-graph. Each
# argument is the short name of a vertex.
#
body ::tycho::PortedDigraph::subgraphOutputs {args} {
    set result {}
    foreach v $args {
        foreach edge [names edge:$v.*^*.*] {
            if { [lsearch -exact $args [lindex [split $edge :.^] 3]] < 0 } {
                lappend result $edge
            }
        }
    }
    return $result
}

########################################################################
#### verify
#
# Test whether a graph is properly constructed.
# This method checks for improperly-connected edges.
#
body ::tycho::PortedDigraph::verify {} {
    foreach edge [names edge:*] {
        foreach {_ v1 p1 v2 p2} [split $edge :.^] {}
        if { ![exists [list vertex:$v1 port:$p1]] \
                || ![exists [list vertex:$v2 port:$p2]] } {
            return 0
        }
    }
    return 1
}

#####################################################################
#####################################################################
####                     protected methods                       ####

########################################################################
#### _addedge
#
# Add an edge.
#
body ::tycho::PortedDigraph::_addedge {v1 p1 v2 p2 args} {
    eval add edge:$v1.$p1^$v2.$p2 $args
}

########################################################################
#### _describeedge
#
# Return a string describing an edge.
#
body ::tycho::PortedDigraph::_describeedge {name {prefix {}}} {
    return "${prefix}edge [lrange [split $name :^.] 1 4] [itemset $name]\n"
}

########################################################################
#### _updatecache
#
# Clear the cache and build updated versions of the _parents,
# _children and _vertices arrays.
#
body ::tycho::PortedDigraph::_updatecache {} {
    # Do superclass first
    chain

    # Regenerate parent-children. Use arrays to prevent duplicates.
    foreach edge [names edge:*] {
        set splat [split $edge :.^]
        set src [lindex $splat 1]
        set tgt [lindex $splat 3]

        set parents$src($tgt) 0
        set children$tgt($src) 0
    }
    # Regenerate vertex list
    foreach vertex [names vertex:*] {
        set v [lindex [split $vertex :] 1]
        lappend _vertices $v
        set _parents($v) [array get parents$v]
        set _children($v) [array get children$v]
    }
    # Validate cache
    cache validate
}
