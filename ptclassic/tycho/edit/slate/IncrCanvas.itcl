##########################################################################
# A canvas mega-widget for manipulating complex graphical items.
#
# @Version: $Id$
# @Author: H. John Reekie
#
# @Copyright (c) 1996 The Regents of the University of California.
# All rights reserved.
# 
# Permission is hereby granted, without written agreement and without
# license or royalty fees, to use, copy, modify, and distribute this
# software and its documentation for any purpose, provided that the above
# copyright notice and the following two paragraphs appear in all copies
# of this software.
# 
# IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY
# FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
# ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF
# THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.
# 
# THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE
# PROVIDED HEREUNDER IS ON AN "AS IS" BASIS, AND THE UNIVERSITY OF
# CALIFORNIA HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,
# ENHANCEMENTS, OR MODIFICATIONS.
#                                                         COPYRIGHTENDKEY
##########################################################################


#######################################################################
## icanvas pathName args
#
# Create an icanvas. This procedure creates a new widget, as
# recommended on the itk web pages. See ::tycho::slate for comments.
#
proc ::tycho::icanvas {pathName args} {
    uplevel ::tycho::IncrCanvas $pathName $args

    set icanvastags  [bindtags $pathName]
    set canvastags [bindtags [$pathName component canvas]]

    bindtags [$pathName component canvas] \
	    [lreplace $canvastags 1 1 [lindex $icanvastags 1]]
    bindtags $pathName [lreplace $icanvastags 1 1]

    return $pathName
}

#######################################################################
#### IncrCanvas
#
# The IncrCanvas ("icanvas") is a widget based on the Tk canvas that
# supports "complex" items, each of which can contain many "simple"
# canvas items. All methods of the IncrCanvas can manipulate either
# simple or complex items more-or-less transparently.
#
# This is a total re-write of the earlier design. In this new design,
# complex items are not represented by [incr Tcl] objects, but by an
# associative array containing just enough information to allow
# hierarchical item construction and object-oriented-like
# item manipulation.
#
# In addition to the IncrCanvas class itself, there are a number of
# other classes that work with the icanvas to implement its full
# functionality. These classes are grouped into several categories,
# according to their function:
#
# <ul>
# <li><i>Picture</i> and subclasses.
# These classes implement the functionality needed by the icanvas to 
# actually create complex items. Subclasses of Picture includes things
# like ``3D'' rectangles and
# polygons, and ``smart'' objects like self-routing lines.
# </ul>
#
# To create an icanvas, do not call the constructor directly, but call
# the procedure <code>::tycho::icanvas</code>:
#
# <tcl><pre>
#     ::tycho::icanvas .s
#     pack .s -fill both -expand on
#     wm deiconify .
# </pre></tcl>
#
# The IncrCanvas class is almost fully compatible with the canvas.
# Differences are mostly related to tagging:
#
# <ul>
# <li>Tags must not start with the characters "_" or "!". These
# characters are used internally by the IncrCanvas.
# <li>Any item with the tag "#" is an "invisible" item: it will be
# ignored by many methods unless explicitly requested. For example,
# *delete all* will not delete invisible items.
# Such items should be used for "background" items that you do not
# want to respond to the mouse, such as grids and so on.
# </ul>
#
# Note that there is a subclass of _IncrCanvas_, _Slate_, which adds
# further functionality.
#
class ::tycho::IncrCanvas {
    inherit ::tycho::TWidget

    constructor {args} {}
    destructor {}

    ###################################################################
    ####                         public methods                    ####

    # Add a tag to items using a search spec
    method addtag {add searchSpec args}

    # Get the bounding box of one or more items
    method bbox {args}

    # Bind a command to an item or tag
    method bind {id {sequence {}} args}

    # Call a "method" on a complex item
    method call {id method args}

    # Convert a screen x coordinate into a canvas x coordinate
    method canvasx {screenx {gridspacing {}}}

    # Convert a screen y coordinate into a canvas y coordinate
    method canvasy {screeny {gridspacing {}}}

    # Set or get the coordinates of an item
    method coords {tag args}

    # Create a new item
    method create {type args}

    # Create a new item
    method create* {tags type args}

    # Create a root component item
    method createrootchild {parent type args}

    # Create a root component item
    method createrootchild* {parenttags tags type args}

    # Create a component item
    method createchild {parent type args}

    # Create a component item
    method createchild* {parenttags tags type args}

    # Delete characters
    method dchars {id first {last {}}} {
	eval $canvas dchars $id $first $last
    }

    # Delete items
    method delete {args}

    # Delete a tag from items
    method dtag {tag {tagToDelete {}}}

    # Find items according to a search spec
    method find {searchSpec args}

    # Focus on an item
    method focus {args} {
	eval $canvas focus $args
    }

    # Focus on the icanvas
    method focusin {}

    # Get the tags of an item
    method gettags {tag args}

    # Set the insertion cursor
    method icursor {id index} {
	$canvas icursor $id $index
    }

    # Return the numerical value of a symbolic index
    method index {id index} {
	$canvas index $id $index
    }

    # Insert text at the insertion cursor
    method insert {id beforeThis string} {
	$canvas insert $id $beforeThis $string
    }

    # Get a configuration option of an item
    method itemcget {tag option}

    # Configure an item
    method itemconfigure {tag args}

    # Lower an item
    method lower {tag {belowThis {}}}

    # Move items
    method move {tag xAmount yAmount}

    # Generate postscript
    method postscript {args}

    # Raise an item
    method raise {tag {aboveThis {}}}

    # Get the root of an item
    method root {id}

    # Scale an item
    method scale {tag xOrigin yOrigin xScale yScale}

    # Scanning on an item
    method scan {option args} {
	eval $canvas scan $option $args
    }

    # Search for items of a different region to the previous find
    method search {mode tag x0 y0 x1 y1}

    # Manipulate the selection
    method select {option {id {}} {index {}}} {
	eval $canvas select $option $id $index
    }

    # Return the item type
    method type {id}

    # Set the horizontal view for scrolling
    method xview {args}

    # Set the vertical view for scrolling
    method yview {args}

    ###################################################################
    ####                   protected variables                     ####

    # The canvas on which I draw
    protected variable canvas

    # An array storing items and tags
    private variable taggedItems

    ###################################################################
    ####                   protected variables                     ####

    # Remember the class of each complex item
    protected variable itemclass

    # Storage for temporary variables
    protected variable scratch

    ###################################################################
    ####                    private variables                      ####

    # Unique IDs and tags are created using this counter.
    # Note: this _must_ be common so item ids are unique across 
    # all icanvases -- because Picture classes use common arrays
    # indexed by ID.
    private common secretcounter 0
}


#######################################################################
#### constructor
#
# Do not call the constructor of the IncrCanvas directly: _always_
# use the procedure ::tycho::icanvas{}.
#
body ::tycho::IncrCanvas::constructor {args} {
    # Create the canvas and pack it
    itk_component add canvas {
	# Create at the global scope to avoid calls to unknown{}
	uplevel #0 canvas $itk_interior.canvas
    } {
	keep -background -cursor -relief \
		-height -width -borderwidth \
		-xscrollcommand -yscrollcommand \
		-scrollregion
    }
    pack $itk_component(canvas) -fill both -expand yes

    # Keep a pointer to the canvas to save typing
    set canvas $itk_component(canvas)

    # Give the focus to the canvas when the icanvas gets mapped. This
    # is convenient for simple applications. For explicit focus
    # management, use the focusin{} method.
    ::bind $canvas <Map> "focus $canvas"

    # Initialise options
    eval itk_initialize $args
}

#######################################################################
#### addtag
#
# Add a tag to specified items. Uses find{} to get all relevant
# items, and then tags them.
#
body ::tycho::IncrCanvas::addtag {add mode args} {
    # Find all items using find{}, and then
    # add the tag to them according to their type
    foreach id [eval find $mode $args] {
	if { [string match {[0-9]*} $id] } {
	    # Top-level canvas item: just add the tag
	    $canvas addtag $add withtag $id
	} else {
	    # Complex item
	    set tags [$canvas gettags \
		    [@scope ::tycho::Picture [list set primary($id)]]]
	    set root [string range [lindex $tags [lsearch $tags {!*}]] 1 end]
	    
 	    if { $root == $id } {
		# Add to a root: add to visible simple items
		$canvas addtag $add withtag !$id
	    } else {
		# Add to a non-root: add to all simple items
		$canvas addtag $add withtag $id
	    }
	    set taggedItems($add,$id) $id
	}
    }
}

#######################################################################
#### bbox
#
# Return the bounding box of any number of items, as a four-list. Each
# argument can be an item or a tag. If there are no
# items matching the tags, return the null string -- the caller must
# check for this condition. (This behavior matches that of the canvas).
# Invisible items are ignored: this means you can safely do things like
# find the bounding box of all items on the canvas (by supply the argument
# "all") even though you have an "invisible" grid or background item
# drawn.
#
body ::tycho::IncrCanvas::bbox {args} {
    if { [lsearch -exact $args "all"] != -1 } {
	$canvas addtag temp all
	$canvas dtag # temp
	set bbox [$canvas bbox temp]
	$canvas dtag temp
	return $bbox
    } else {
	eval $canvas bbox $args
    }
}

#######################################################################
#### bind
#
# Bind a command to an item or tag. The command accepts the 
# following argument formats:
#
# <ul>
# <li>_tagOrID_: Return the events for which _tagOrID_ has a binding.
# <li>_tagOrID_ _event_: Return the binding on _tagOrID_ for _event_.
# <li>_tagOrID_ _event_ _command_: Bind _command_ to the _tagOrID_
# for _event_
# </ul>
#
body ::tycho::IncrCanvas::bind {tag {sequence {}} args} {
    # If the tag is a complex item ID, we want to use its root
    # tag instead
    if { [string match {_*} $tag] } {
	set tag !$tag
    }
    
    if { $sequence == "" } {
    	# Just one arg: return events
	return [$canvas bind $tag]
    } elseif { $args == {} } {
    	# Two args: return the binding
	return [$canvas bind $tag $sequence]
    } else {
    	# Add a binding
	$canvas bind $tag $sequence [lindex $args 0]
    }
}

#######################################################################
#### call
#
# Call a "method" on an item. This just looks up the method in
# the global "virtual function table" and calls it.
#
# In the IncrCanvas code itself, this method is called in non-critical
# situations; in time-critical situations, the (very obscure)
# code here is "in-lined."
#
body ::tycho::IncrCanvas::call {id method args} {
    @scope ::tycho::$itemclass($id) [list \
	    eval \[set methodtable($method)\] $id $canvas $this $args]
}

#######################################################################
#### canvasx
#
body ::tycho::IncrCanvas::canvasx {screenx {gridspacing {}}} {
    eval $canvas canvasx $screenx $gridspacing
}

#######################################################################
#### canvasy
#
body ::tycho::IncrCanvas::canvasy {screeny {gridspacing {}}} {
    eval $canvas canvasy $screeny $gridspacing
}

#######################################################################
#### coords
#
# Get or set the coordinates of an item. If the argument
# is a tag, perform this operation on the first item on the
# icanvas returned by `find withtag'.
#
body ::tycho::IncrCanvas::coords {tag args} {
    # If the argument is a tag, use the first found item
    if { ! [string match {[_0-9]*} $tag] } {
	set items [find withtag $tag]
	if { $items == "" } {
	    return ""
	}
	set id [lindex $items 0]
    } else {
	set id $tag
    }

    # Call the canvas or the complex item proc
    if { [string match {[0-9]*} $id] } {
	eval $canvas coords $id $args
    } elseif { [string match {_*} $id] } {
	@scope ::tycho::$itemclass($id) [list \
		eval \[set methodtable(coords)\] $id $canvas $this $args]
    }
}

#######################################################################
#### create
#
# Create a top-level item. If the _type_ arg starts with a lower-case
# letter, this method creates a simple (canvas item); if not, it
# assumes that the type is the name of a subclass of Picture, and
# creates the corresponding complex item. In either case, _args_ contains
# the coordinates of the item, followed by option-value pairs.
#
# See the canvas documentation for the coordinates and options of simple
# items; see the <a> href="../internals/index.html">Slate reference</a>
# for complex items implemented by the icanvas.
#
# This method is fully compatible with the Tk canvas create{}
# method; for a faster non-compatible method, see create*{}.
#
# If you are certain that you are only creating a simple item, you
# can call the canvas directly instead of this method.
#
body ::tycho::IncrCanvas::create {type args} {
    if { [string match {[a-z]*} $type] } {
    	# If this is a canvas type, call the canvas
	eval $canvas create $type $args
    } else {
    	# Get the item ID
	set id _$secretcounter
	incr secretcounter
	
	# Remember its class
	set itemclass($id) $type
	
	# Extract the tags from the options list
	set indx [lsearch -exact $args -tags]
	if { $indx != -1 } {
	    set tags [lindex $args [expr $indx+1]]
	    set args [lreplace $args $indx [expr $indx+1]]
	    # Remember them
	    foreach t $tags {
		set taggedItems($t,$id) $id
	    }
	    lappend tags !$id $id
	} else {
	    set tags [list !$id $id]
	}
	
	# Call the construct{} proc to create the item
	eval ::tycho::$type::construct $id $canvas $this [list $tags] $args
	return $id
    }
}

#######################################################################
#### create*
#
# Create an item. This method takes the item tags as the first argument
# instead of in the options list.
#
body ::tycho::IncrCanvas::create* {tags type args} {
    if { [string match {[a-z]*} $type] } {
	eval $canvas create $type $args
    } else {
	set id _$secretcounter
	incr secretcounter
	set itemclass($id) $type
	set indx [lsearch -exact $args -tags]
	foreach t $tags {
	    set taggedItems($t,$id) $id
	}
	lappend tags !$id $id
	eval ::tycho::$type::construct $id $canvas $this [list $tags] $args
	return $id
    }
}

#######################################################################
#### createchild
#
# Create a child item. The first argument is its parent
# item, the second its type, and the remainder the coordinates
# and options.
#
body ::tycho::IncrCanvas::createchild {parent type args} {
    set t [lsearch -exact $args -tags]
    if { $t != -1 } {
	# Extract tags
	set tags [lindex $args [expr $indx+1]]
	set args [lreplace $args $indx [expr $indx+1]]
    } else {
	set tags {}
    }

    set parenttags [$canvas gettags \
	    [@scope ::tycho::$itemclass($parent) [list set primary($parent)]]]

    eval [list createchild* $parenttags $tags $type] $args
}

#######################################################################
#### createchild*
#
# Create a child item. The first argument is the hierarchy
# tags of the parent as passed to the construct{} procs of the
# Picture classes or as obtained by *gettags -hierarchy*; the second
# is the additional tags of the new item.
#
body ::tycho::IncrCanvas::createchild* {parenttags tags type args} {
    if { [string match {[a-z]*} $type] } {
	eval $canvas create $type $args [list -tags [concat $parenttags $tags]]
    } else {
	set id _$secretcounter
	incr secretcounter
	set itemclass($id) $type
	foreach t $tags {
	    set taggedItems($t,$id) $id
	}
	eval lappend tags $parenttags $id
	eval ::tycho::$type::construct $id $canvas $this [list $tags] $args
	return $id
    }
}

#######################################################################
#### createrootchild
#
# Create a root child item. The first argument is its parent
# item, the second its type, and the remainder the coordinates
# and options.
#
body ::tycho::IncrCanvas::createrootchild {parent type args} {
    set t [lsearch -exact $args -tags]
    if { $t != -1 } {
	set tags [lindex $args [expr $indx+1]]
	set args [lreplace $args $indx [expr $indx+1]]
    } else {
	set tags {}
    }

    set parenttags [$canvas gettags \
	    [@scope ::tycho::$itemclass($parent) [list set primary($parent)]]]

    eval [list createrootchild* $parenttags $tags $type] $args
}

#######################################################################
#### createrootchild*
#
# Create a root child item. The first argument is the hierarchy
# tags of the parent as passed to the construct{} procs of the
# Picture classes or as obtained by *gettags -hierarchy*; the second
# is the additional tags of the new item.
#
body ::tycho::IncrCanvas::createrootchild* {parenttags tags type args} {
    set t [lsearch $parenttags {!*}]
    set parenttags [lreplace $parenttags $t $t]

    if { [string match {[a-z]*} $type] } {
	set id [eval $canvas create $type $args \
		[list -tags [concat $parenttags $tags]]]
	$canvas addtag !$id withtag $id
    } else {
	set id _$secretcounter
	incr secretcounter
	set itemclass($id) $type
	foreach t $tags {
	    set taggedItems($t,$id) $id
	}
	eval lappend tags $parenttags !$id $id
	eval ::tycho::$type::construct $id $canvas $this [list $tags] $args
	return $id
    }
}

#######################################################################
#### delete
#
body ::tycho::IncrCanvas::delete {args} {
    foreach id $args {
	if { [string match {[0-9]*} $id] } {
	    # Delete a canvas item
	    $canvas delete $id
	} elseif { [string match {_*} $id] } {
	    # Delete a complex item. Make sure it still exists
	    if { ! [::info exists itemclass($id)] } {
		continue
	    }
	    # Call its destruct method
	    @scope ::tycho::$itemclass($id) [list \
		    eval \[set methodtable(destruct)\] $id $canvas $this]

	    # Then remove all items
	    $canvas delete $id
	    
	    # Then forget the item
	    unset itemclass($id)
	    foreach i [array names taggedItems *,$id] {
		unset taggedItems($i)
	    }
	} else {
	    # Delete by tag: call myself again for simplicity
	    eval $this delete [find withtag $id]
	}
    }
}

#######################################################################
#### dtag
#
# Delete tags from items. If _delete_ is not given, delete _tag_
# from all items; if it is, delete the tag _delete_ from all
# items tagged with _tag_. Invisible items will not be deleted
# unless explicitly selected by supplying the <b>withtag</b> mode
# and supplying a tag that they have.
# 
body ::tycho::IncrCanvas::dtag {tag {delete {}}} {
    if { [string match {[0-9]*} $tag] } {
	# Delete the tag from a canvas item.
	eval $canvas dtag $tag $delete
    } elseif { [string match {_*} $tag] } {
	# Delete the tag from a complex item. Make sure _delete_ exists.
	if { $delete != "" } {
	    $canvas dtag $tag $delete
	    catch {unset taggedItems($delete,$tag)}
	}
    } else {
	# Doing it by tag..
	if { $delete == "" } {
	    set delete $tag
	}
	$canvas dtag $tag $delete
	foreach {_ id} [array get taggedItems $tag,*] {
	    catch {unset taggedItems($delete,$id)}
	}
    }
}

#######################################################################
#### search
#
# An incremental search mechanism for items within or overlapping a
# region of the canvas. _mode_ is the search type: it can be either
# <b>overlapping</b> or <b>enclosed</b>, with the same meaning as
# for the find{} method. _tag_ is the tag with which found items will
# tagged, and the remaining arguments are the coordinates of the region
# to search in.
#
# The method assumes that previously some (zero or more) items were
# tagged with _tag_. It find items overlapping or enclosed by the
# given coordinates, and returns two lists: the first is the items
# in the region that were not already tagged, and the second is the
# items that were previously tagged and are no longer in the region.
# After it completes, only items within or overlapping the region
# still have _tag_, so the next call with different coordinates
# will again return items that have been uncovered or newly covered.
#
# This is useful for applications such as drag-selecting items
# on the canvas. After a drag-select, a client will usually remove
# the tag from all items with dtag{}.
#
# Because the items returned will often be further processed based
# on their tags, each returned list is in fact a flat list of
# item id and tags, which can be processed easily by foreach{}.
#
body ::tycho::IncrCanvas::search {mode tag x0 y0 x1 y1} {
    # There are two sets of items: previously covered and newly covered.
    # Use the tags "temp.uncovered" and "temp.covered" to mark them
    #
    # x0,y0              x1
    # +-------------+----+
    # |XXXXXtagXXXXX|\\\\|<- covered
    # |XXXXXtagXXXXX|\\\\|
    # +-------------+----+ y1
    # |/////tag/////|<-uncovered
    # +-------------+
    #
    $canvas addtag temp.covered $mode $x0 $y0 $x1 $y1
    $canvas addtag temp.uncovered withtag $tag

    # Take the differences of the sets by using tags
    $canvas dtag temp.covered temp.uncovered
    $canvas dtag $tag temp.covered

    # Remove invisible and highlight items from both sets
    $canvas dtag "#" temp.covered
    $canvas dtag "highlight" temp.covered
    $canvas dtag "#" temp.uncovered
    $canvas dtag "highlight" temp.uncovered

    # Process according to mode
    if { $mode == "overlapping" } {
	# Newly covered items
	foreach i [$canvas find withtag temp.covered] {
	    set tags [$canvas gettags $i]

	    # Test for the root tag
	    set t [lsearch $tags {!*}]
	    if { $t == -1 } {
		# This simple item is a root, so add to result and tag it
		set covered($i) $tags
		$canvas addtag $tag withtag $i
	    } else {
		# Use the tag to extract the root item ID
		set root [string range [lindex $tags $t] 1 end]

		# Only process if not already in the result
		if { ! [::info exists covered($root)] } {
		    set covered($root) $tags
		    # Add the tag to the complex item
		    $canvas addtag $tag withtag $root
		    set taggedItems($tag,$root) $root
		}
	    }
	}

	# Uncovered items
	foreach i [$canvas find withtag temp.uncovered] {
	    set tags [$canvas gettags $i]
	    set t [lsearch $tags {!*}]
	    if { $t == -1 } {
		set uncovered($i) $tags
		$canvas dtag $i $tag
	    } else {
		set root [string range [lindex $tags $t] 1 end]
		if { ! [::info exists uncovered($root)] } {
		    # Only add the item to the result if _all_ simple items
		    # in the complex item are outside the region. Test for
		    # this using the bounding box.
		    if { ! [eval rectOverlap \
			    $x0 $y0 $x1 $y1 [$canvas bbox $root]] } {
			set uncovered($root) $tags
			$canvas dtag $root $tag
			unset taggedItems($tag,$root)
		    }
		}
	    }
	}
    } elseif { $mode == "enclosed" } {
	# For comments, see the "overlapping" mode
	foreach i [$canvas find withtag temp.covered] {
	    set tags [$canvas gettags $i]
	    set t [lsearch $tags {!*}]
	    if { $t == -1 } {
		set covered($i) $tags
		$canvas addtag $tag withtag $i
	    } else {
		set root [string range [lindex $tags $t] 1 end]
		if { ! [::info exists covered($root)] } {
		    if { [eval rectInside \
			    [$canvas bbox $root] $x0 $y0 $x1 $y1] } {
			set covered($root) $tags
			$canvas addtag $tag withtag $root
			set taggedItems($tag,$root) $root
		    }
		}
	    }
	}
	foreach i [$canvas find withtag temp.uncovered] {
	    set tags [$canvas gettags $i]
	    set t [lsearch $tags {!*}]
	    if { $t == -1 } {
		set uncovered($i) $tags
		$canvas dtag $i $tag
	    } else {
		set root [string range [lindex $tags $t] 1 end]
		if { ! [::info exists uncovered($root)] } {
		    set uncovered($root) $tags
		    $canvas dtag $root $tag
		    unset taggedItems($tag,$root)
		}
	    }
	}
    }
    # Delete temporary tags
    $canvas dtag temp.covered
    $canvas dtag temp.uncovered

    # Return a pair of lists
    return [list [array get covered] [array get uncovered]]
}

#######################################################################
#### find
#
# Find items as given by _searchSpec_. The argument
# formats are the same as for the Tk canvas; however, this
# method mostly only returns root items. The one case in which it
# may return a non-root item is the "withtag" search spec: in this
# case it returns any items with the given tag, regardless of whether
# the item is root or non-root. Note that in some cases, items with
# the tag "#" (invisible items) are treated specially.
#
# <ul>
# <li><b>above</b> _id_: Return the root item immediately above _id_.
# <li><b>all</b>: Return every root item. Invisible items will not be
# returned.
# <li><b>below</b> _id_: Return the root item immediately below _id_.
# <li><b>closest</b> _x y ?halo? ?start?_: Return the root item
# closest to the point _(x,y)_.
# <li><b>enclosed</b> _x0 x1 y0 y1_: Return every root item
# enclosed by the given region. Invisible items will not be
# returned.
# <li><b>overlapping</b> _x0 x1 y0 y1_: Return every root
# item that overlaps the given region. Invisible items will not be
# returned.
# <li><b>withtag</b> _tag_: If _tag_ is an item ID, then
# return it. If it's the tag "current" then return the root item
# currently hit by the mouse. Otherwise, return every item explicitly
# given the tag. Invisible items _will_ be returned if they match
# the given tag.
#
# </ul>
#
body ::tycho::IncrCanvas::find {mode args} {
    switch -exact $mode {
        "above" {
            root [$canvas find above [find withtag [lindex $args 0]]]
        }
        "all" {
            # In order to make the case where there are a lot of simple
            # items fast, we have used this approach: find all root
            # items and then remove a marker tag from each of those.
            # Remaining items with the marker tag are simple roots.
            
            # Find complex roots
            set found {}
            foreach id [array names itemclass] {
                set tags [$canvas gettags \
                        [@scope ::tycho::Picture [list set primary($id)]]]
                set root [string range \
                        [lindex $tags [lsearch $tags {!*}]] 1 end]
                # If the item is not invisible, mark as found
                if { [lsearch $tags {#}] == -1 } {
                    lappend found [string range \
                            [lindex $tags [lsearch $tags {!*}]] 1 end]
                }
            }

            # Tag all items and remove tag from complex items
            $canvas addtag temp.find all
            foreach i [lnub $found] {
                $canvas dtag $i temp.find
            }
            
            # Remove invisible items
            $canvas dtag "#" temp.find
            
            # Return all roots
            eval lappend found [$canvas find withtag temp.find]
            $canvas dtag temp.find
            return $found
        }
        "below" {
            root [$canvas find below [find withtag [lindex $args 0]]]
        }
        "closest" {
            root [eval $canvas find closest $args]
        }
        "enclosed" {
            # Mark enclosed items
            eval $canvas addtag temp.find enclosed $args
            
            # Remove invisible items
            $canvas dtag "#" temp.find
            
            # Find the set of roots of each item and add to the result
            # if it's either a top-level item or if it's a complex
            # item and its region is entirely enclosed.
            set found {}
            foreach i [eval $canvas find withtag temp.find] {
                set tags [$canvas gettags $i]

                # Test for the root tag
                set t [lsearch $tags {!*}]
                if { $t == -1 } {
                    # The simple item is a root
                    lappend found $i
                } else {
                    # Use the tag to extract the root item ID
                    set root [string range [lindex $tags $t] 1 end]
                    
                    # See if its bounding box is inside the bounding
                    # region. To avoid calculating this twice, keep a
                    # cache of already-added items.
                    if { ! [::info exists temp.find($root)] } {
                        if { [eval rectInside [bbox $root] $args] } {
                            lappend found $root
                            set temp.find($root) 1
                        }
                    }
                }
            }
            # Return the found items -- there are no duplicates
            return $found
        }
        "overlapping" {
            # Mark overlapping items
            eval $canvas addtag temp.find overlapping $args

            # Remove invisible items
            $canvas dtag "#" temp.find

            # Find the set of roots of each item and add to the result
            set found {}
            foreach i [$canvas find withtag temp.find] {
                set tags [$canvas gettags $i]
                
                # Test for the root tag
                set t [lsearch $tags {!*}]
                if { $t == -1 } {
                    # The simple item is a root
                    lappend found $i
                } else {
                    # Use the tag to extract the root item ID
                    lappend found [string range [lindex $tags $t] 1 end]
                }
            }
            # Remove duplicates and return
	    $canvas dtag temp.find
            return [lnub $found]
        }
        "withtag" {
            set tag [lindex $args 0]
            
            if { $tag == "" } {
                # This may happen, so take care of it
                return ""
            } elseif { $tag == "all" } {
                # Return all items
                return [find all]
            } elseif { $tag == "current" } {
                # Return the root of the "current" item
                return [root [$canvas find withtag current]]
            } elseif { [string match {[_0-9]*} $tag] } {
                # An item ID -- just return it. NOTE: if you want to get
                # the root of an item, use the root{} method.
                return $tag
            } else {
                # This is a proper tag. Add a marker tag to all simple items
                $canvas addtag temp.find withtag $tag
                
                # Find matching complex items and remove the marker
                set found {}
                foreach {_ id} [array get taggedItems $tag,*] {
                    $canvas dtag $id temp.find
                    lappend found $id
                }
                
                # Add root simple items and return
                eval lappend found [$canvas find withtag temp.find]
                $canvas dtag temp.find
                return $found
            }
        }
    }
}

#######################################################################
#### focusin
#
# Put the focus into the canvas. This is needed for explicit
# focus control: there seems to be no way to detect that the
# focus{} command has been called with a megawidget as an
# argument, so instead of calling
# <pre>
#     focus $icanvas
# </pre>
# you need to call
# <pre>
#     $icanvas focusin
# </pre>
#
body ::tycho::IncrCanvas::focusin {} {
    uplevel #0 "focus $canvas"
}

#######################################################################
#### gettags
#
# Get the tags of an item. This method returns the tags present
# on an item, less the hierarchy tags. Note, however, that tags
# inherited from a parent item will still be in the result
# list, whether they are explicitly added to the item or not.
# If the argument is a tag, perform this operation on the first
# item on the icanvas returned by `find withtag'.
# If the *-hierarchy* flag is given, the returned result includes
# all hierarchy tags.
#
body ::tycho::IncrCanvas::gettags {tag args} {
    # If a tag, get the first matching item
    if { ! [string match {[_0-9]*} $tag] } {
	set items [find withtag $tag]
	if { $items == "" } {
	    return ""
	}
	set id [lindex $items 0]
    } else {
	set id $tag
    }
    
    # Get the tags from the primary component
    if { [string match {_*} $id] } {
    	set id [@scope ::tycho::Picture [list set primary($id)]]
    }
    
    # Get the sorted tags
    set tags [lsort [$canvas gettags $id]]

    # Filter out hierarchy tags
    # FIXME: This depends on no tags starting with a character that is
    # lexically before "_" (asking for bugs later on...)
    getflag hierarchy args
    if { ! $hierarchy } {
	set t [lsearch $tags {[^!_]*}]
	if { $t == -1 } {
	    return $tags
	} else {
	    return [lrange $tags $t end]
    	}
    } else {
    	return $tags
    }
}

##########################################################################
#### itemcget
#
# Read a configuration option.  If the argument
# is a tag, perform this operation on the first item on the
# icanvas returned by `find withtag'.
#
body ::tycho::IncrCanvas::itemcget {tag option} {
    # If the first argument is a tag, get the first matching item
    if { ! [string match {[_0-9]*} $tag] } {
	set items [find withtag $tag]
	if { $items == "" } {
	    return
	} else {
	    set id [lindex $items 0]
	}
    } else {
	set id $tag
    }

    # Call the canvas or the complex item proc
    if { [string match {[0-9]*} $id] } {
	eval $canvas itemcget $tag $option
    } else {
	@scope ::tycho::$itemclass($id) [list \
		eval \[set methodtable(itemcget)\] $id $canvas $this \
		::tycho::$itemclass($id) $option]
    }
}

#######################################################################
#### itemconfigure
#
# Set configuration option. If the argument
# is a tag, perform this operation on the first item on the
# icanvas returned by `find withtag'.
#
# Note also that dtag{}, gettags{}, and addtag{} are faster (and safer)
# ways of manipulating tags and should be used in preference to
# itemcget{} and itemconfigure{}.
#
body ::tycho::IncrCanvas::itemconfigure {tag args} {
    # If the first argument is a tag, get the first matching item
    if { ! [string match {[_0-9]*} $tag] } {
	set items [find withtag $tag]
	if { $items == "" } {
	    return
	} else {
	    set id [lindex $items 0]
	}
    } else {
	set id $tag
    }

    # Call the canvas or the complex item proc
    if { [string match {[0-9]*} $id] } {
	eval $canvas itemconfigure $id $args
    } else {
	@scope ::tycho::$itemclass($id) [list \
		eval \[set methodtable(itemconfigure)\] $id $canvas $this \
		::tycho::$itemclass($id) $args]
    }
}

#######################################################################
#### lower
#
# Lower the specified complex items to the bottom of the display
# list. If _belowThis_ is specified, then lower below that item,
# or if _belowThis_ is a tag, then lower below the first item
# with that tag.
#
body ::tycho::IncrCanvas::lower {tag {belowThis {}}} {
    # Figure out which item we're talking about
    set items [find withtag $tag]
    if { $items == "" } {
	return ""
    } else {
	set id [lindex $items 0]

	if { $belowThis == "" } {
	    $canvas lower $id
	} elseif { [string match {[_0-9]*} $belowThis] } {
	    # Got an item, so use it
	    $canvas lower $id $belowThis
	} else {
	    # Got a id, so use the first matching item
	    set items [find withtag $belowThis]
	    if { $items == "" } {
		$canvas lower $id
	    } else {
		$canvas lower $id [lindex $items 0]
	    }
	}
    }
}

#######################################################################
#### move
#
# Move one or more items the specified amount. The first argument
# can either be a tag or an id.
#
body ::tycho::IncrCanvas::move {tag x y} {
    if { [string match {[_0-9]*} $tag } {
	# Move an item
	$canvas move $tag $x $y
    } else {
	# Find and move complex items
	$canvas addtag temp all
	foreach {_ id} [array get taggedItems $tag,*] {
	    $canvas move $id $x $y
	    $canvas dtag $id temp
	}
	# Move simple items
	$canvas move temp $x $y
	$canvas dtag temp
    }
}

#######################################################################
#### postscript
#
body ::tycho::IncrCanvas::postscript {args} {
    eval $canvas postscript $args
}

#######################################################################
#### raise
#
# Raise the specified complex item to the top of the display
# list. If _aboveThis_ is specified, then raise above that item,
# or if _aboveThis_ is a tag, then raise above the first item
# with that tag.
#
body ::tycho::IncrCanvas::raise {tag {aboveThis {}}} {
    # Figure out which item we're talking about
    set items [find withtag $tag]
    if { $items == "" } {
	return ""
    } else {
	set id [lindex $items 0]

	if { $aboveThis == "" } {
	    $canvas raise $id
	} elseif { [string match {[_0-9]*} $aboveThis] } {
	    # Got an item, so use it
	    $canvas raise $id $aboveThis
	} else {
	    # Got a id, so use the first matching item
	    set items [find withtag $aboveThis]
	    if { $items == "" } {
		$canvas raise $id
	    } else {
		$canvas raise $id [lindex $items 0]
	    }
	}
    }
}

#######################################################################
#### root
#
# Find the root of an item -- that is, the item which will respond to
# events on this item.
#
body ::tycho::IncrCanvas::root {id} {
    if { $id == "" } {
	# This might happen: deal with it
	return ""
    } elseif { [string match {[0-9]*} $id] } {
	# It's a canvas item ID. Check the tags to find the item to return
    	set tags [$canvas gettags $id]
    	set t [lsearch $tags {!*}]
	if { $t == -1 } {
	    # Top-level item
	    return $id
	} else {
	    # Has a root
	    return [string range [lindex $tags $t] 1 end]
    	}
    } elseif { [string match {_*} $id] } {
	# A complex item ID. Use the primary tags to find the item to return
	set tags [$canvas gettags \
		[@scope ::tycho::Picture [list set primary($id)]]]
    	return [string range [lindex $tags [lsearch $tags {!*}]] 1 end]
    } else {
	error "Argument ($id) is not an item ID"
    }
}

#######################################################################
#### scale
#
body ::tycho::IncrCanvas::scale {tag xOrigin yOrigin xScale yScale} {
    # Find the matching items
    set match [find withtag $tag]

    # Scale complex items and tag simple items
    foreach id $match {
	if { [string match {_*} $id] } {
	    set newcoords {}
	    set coords [$canvas coords \
		    [@scope ::tycho::Picture [list set primary($id)]]]
	    foreach {a b} $coords {
		lappend newcoords \
			[expr $xOrigin + $xScale * ($a - $xOrigin)] \
			[expr $yOrigin + $yScale * ($b - $yOrigin)]
	    }
	    eval $this coords $id $newcoords
	} else {
	    $canvas addtag temp withtag $id
    	}
    }
    
    # Scale simple items
    $canvas scale temp $xOrigin $yOrigin $xScale $yScale
    $canvas dtag temp
}

#######################################################################
#### type
#
# Return the type of an item. Note that types are case-sensitive.
#
body ::tycho::IncrCanvas::type {id} {
    if { [string match {[0-9]*} $id] } {
	$canvas type $id
    } else {
	return $itemclass($id)
    }
}

#######################################################################
#### xview
#
body ::tycho::IncrCanvas::xview {args} {
    eval $canvas xview $args
}

#######################################################################
#### yview
#
body ::tycho::IncrCanvas::yview {args} {
    eval $canvas yview $args
}
