##########################################################################
# @Version: $Id$
# @Author: H. John Reekie
#
# @Copyright (c) 1996 The Regents of the University of California.
# All rights reserved.
# 
# Permission is hereby granted, without written agreement and without
# license or royalty fees, to use, copy, modify, and distribute this
# software and its documentation for any purpose, provided that the above
# copyright notice and the following two paragraphs appear in all copies
# of this software.
# 
# IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY
# FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
# ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF
# THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.
# 
# THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE
# PROVIDED HEREUNDER IS ON AN "AS IS" BASIS, AND THE UNIVERSITY OF
# CALIFORNIA HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,
# ENHANCEMENTS, OR MODIFICATIONS.
#                                                         COPYRIGHTENDKEY
##########################################################################


#######################################################################
#### Polygon
#
# The shape of polygons. Items with
# this shape include <I>polygon</I> and <I>Solid</I>.
#
#  <P><b>Primitive aspects</b>
#
# <ul>
# <li><B>vertex-</B><I>n</I>: The <I>n</I>'th vertex of the polygon.
# </ul>
#
# <p><b>Derived aspects</b>
#
# <ul>
# <li><B>c</B> or <B>center</B>: The center of the polygon.
# <li><B>edges</B>: The number of edges in the polygon.
# </ul>
#
# <p><b>Bugs</b>: Untested.
#
# <p><b>Enhancements</b>: (none)
#
# <p><b>Links</b>
# 
# <ul>
# <li><a href="../internals/shapes.html">An overview of Shape classes</a>
# <li><a href="../internals/index.html">Infrastructure contents</a>
# <li><a href="../codeDoc/index.html">Class documentation index</a>
# </ul>
#
class ::tycho::Polygon {
    inherit ::tycho::Line

    ###################################################################
    ####                         public procs                      ####

    # Get one or more aspects of an item
    proc _aspect {id canvas slate args}

    # Attach a set of grapples to an item
    proc _grapple {id canvas slate interactor args}

    # Reshape one or more aspects of an item
    proc _reshape {id canvas slate x y args}

    # Start a reshape interaction sequence
    proc _reshapeclick {id canvas slate x y args}

    # Continue a reshape interaction sequence
    proc _reshapedrag {id canvas slate x y}

    # Terminate a reshape interaction sequence
    proc _reshaperelease {id canvas slate x y}

    # Get one or more aspects of a polygon
    proc aspect {coords args}

    # Calculate coordinates needed to make polygon borders
    proc borders {minAngle maxAngle coords borderWidth}

    # Reshape one or more aspects of a polygon
    proc reshape {coords x y args}

    # Stretch a polygon
    proc stretch {coords distance {angles {}}}
}

#######################################################################
#### _aspect
#
body ::tycho::Polygon::_aspect {id canvas slate args} {
    set coords [$slate coords $id]

    if { $args == "" } {
	set result {length start end}
	foreach n [::tycho::linterval 0 \
		[expr [llength $coords] / 2 - 2]] {
	    lappend result "vertex-$n"
	}
	return $result
    } else {
	return [eval aspect [list $coords] $args]
    }
}

#######################################################################
#### _reshape
#
body ::tycho::Polygon::_reshape {id canvas slate x y args} {
    eval $slate coords $id \
	    [eval reshape [list [$slate coords $id]] $x $y $args]
}

#######################################################################
#### _reshapeclick
#
body ::tycho::Polygon::_reshapeclick {id canvas slate x y args} {
    ::tycho::getflag ghost args

    # Remember how I am now.
    set scratch($id.prevX) $x
    set scratch($id.prevY) $y

    # Get the coordinates of the line into an efficient-to-process form
    set i 0
    foreach {a b} [$slate coords $id] {
	set scratch($id.$i.x) $a
	set scratch($id.$i.y) $b
	lappend scratch($id.indexes) $i
	incr i
    }

    # If the start vertex is repeated, delete it
    set last [expr $i/2-1]
    if { $scratch($id.0.x) == $scratch($id.$last.x) \
	    && $scratch($id.0.y) == $scratch($id.$last.y) } {
	unset scratch($id.$last.x)
	unset scratch($id.$last.y)
    }
    set scratch($id.indexes) [lreplace $scratch($id.indexes) end end]

    # Figure out the vertices that will be changed
    foreach aspect $args {
	::tycho::assign a n [split $aspect "-"]
	switch -exact $a {
	    "vertex" {
		lappend scratch($id.vertices) $n
	    }
	    "length" {
		error "Cannot set the \"length\" aspect of a line"
	    }
	    default {
		error "Invalid aspect \"$aspect\" of line shape"
	    }
	}
    }
    
    # Make sure there are no duplicates
    set scratch($id.vertices) [::tycho::lnub scratch($id.vertices)]

    # If the -ghost flag is set, draw the ghost line.
    if { $ghost } {
	set scratch($id.ghost) [eval $canvas create line \
		$scratch($id.coords) \
		-fill grey]
    }
}

#######################################################################
#### _reshapedrag
#
# This just calls the "parent" class -- we should probably
# implement "inheritance."
#
body ::tycho::Polygon::_reshapedrag {id canvas slate x y} {
    ::tycho::AsPolygon::reshapedrag $id $canvas $slate $x $y
}

#######################################################################
#### _reshaperelease
#
# This just calls the "parent" class -- we should probably
# implement "inheritance."
#
body ::tycho::Polygon::_reshaperelease {id canvas slate x y} {
    ::tycho::AsPolygon::reshaperelease $id $canvas $slate $x $y
}

#######################################################################
#### aspect
#
# Return one or more aspects of a polygon. Valid aspects are "length"
# and <code>vertex-</code><i>n</i>, where _n_ is
# between 0 and _length_ - 1.
#
body ::tycho::Polygon::aspect {coords args} {
    set result {}

    foreach aspect $args {
	set a [lindex [split $aspect "-"] 0]
	switch -exact $a {
	    "edges" {
		set len [llength $coords]
		if { [lindex $coords 0] == [lindex $coords [expr $len-2]] \
			&& [lindex $coords 0] == [lindex $coords end] } {
		    # The start vertex is repeated
		    lappend result [expr [llength $coords] / 2 - 2]
		} else {
		    lappend result [expr [llength $coords] / 2 - 1]
		}
	    }
	    "length" {
		lappend result [expr [llength $coords] / 2 - 1]
	    }
	    "center" {
		::tycho::assign x0 y0 x1 y1 $coords
		lappend result [expr ($x0+$x1)/ 2] [expr $y0+$y1)/2]
	    }
	    "vertex" {
		set n [lindex [split $aspect "-"] 1]
		lappend result \
			[lindex $coords [expr 2*$n]] \
			[lindex $coords [expr 2*$n + 1]]
	    }
	    default {
		error "Invalid aspect \"$aspect\" of polygon shape"
	    }
	}
    }
    return $result
}

#######################################################################
#### reshape
#
# Reshape one or more aspects of a polygon by the specified _x_
# and _y_ relative values.
#
body ::tycho::Polygon::reshape {coords x y args} {
    # Get the coordinates of the line into an efficient-to-process form
    set i 0
    set indexes {}
    foreach {a b} $coords {
	set _x($i) $a
	set _y($i) $b
	lappend indexes $i
	incr i
    }
    
    # If the start vertex is repeated, delete it
    set last [expr $i/2-1]
    if { $_x(0) == $_x($last) && $_y(0) == $_y($last) } {
	unset _x($last)
	unset _y($last)
    }
    set indexes [lreplace $indexes end end]

    # Process all aspects to change coordinates
    foreach aspect $args {
	::tycho::assign a n [split $aspect "-"]
	switch -exact $a {
	    "length" {
		error "Cannot set the \"length\" aspect of a line"
	    }
	    "vertex" {
		set _x($n) [expr $_x($n) + $x]
		set _y($n) [expr $_y($n) + $y]
	    }
	    default {
		error "Invalid aspect \"$aspect\" of line shape"
	    }
	}
    }

    # Rebuild the coordinates list and return
    set coords {}
    foreach i $indexes {
	lappend coords $_x($i) $_y($i)
    }
    return $coords
}

##########################################################################
#### stretch
#
# Stretch a polygon. Requires that first and last coords be the same.
# The coordinates must proceed around the polygon in a clockwise
# direction to get the right sense of direction.
#
# The -angles options introduces a variable which is set to a list
# of the angles of each segment. The angles are calculated here
# anyway so this seemed like a good way to get them without having
# to calculate them again.
#
# NOTE: Because of Tk's upside-down co-ordinates, the angles will come
# out upside-down as well. Sorry 'bout that.
#
body ::tycho::Polygon::stretch {coords distance {angles {}}} {
    if { $angles != "" } {
	upvar $angles result2
    }
    set result {}
    set result2 {}
    set distance [expr double($distance)]

    set x0 [lindex $coords [expr [llength $coords] - 4]]
    set y0 [lindex $coords [expr [llength $coords] - 3]]

    set x1 [lindex $coords 0]
    set y1 [lindex $coords 1]
    set coords [lreplace $coords 0 1]

    set beta [expr atan2($y0-$y1, $x0-$x1)]

    while { [llength $coords] >= 2 } {
	set x2 [lindex $coords 0]
	set y2 [lindex $coords 1]
	set coords [lrange $coords 2 end]

	set alpha [expr atan2($y2-$y1, $x2-$x1)]
	set gamma [expr ($alpha - $beta) / 2.0]
	set theta [expr $alpha - $gamma]

	set delta [expr $distance / sin($gamma)]

	set xt [expr $x1 + $delta * cos($theta)]
	set yt [expr $y1 + $delta * sin($theta)]

	lappend result $xt $yt
	lappend result2 $alpha

	set x0 $x1
	set y0 $y1
	set x1 $x2
	set y1 $y2

	set beta [expr $alpha + $pi]
    }

    lappend result [lindex $result 0] [lindex $result 1]
    return $result
}

##########################################################################
#### borders
#
# Calculate coordinates needed to make polygon borders. It
# returns a list of three elements:
# <ul>
# <li> the coordinates of the inside of the polygon.
# <li> a list of lists of coordinates of polygons representing lit edges.
# <li> a list of lists of coordinates of polygons representing shaded edges.
# </ul>
#
# The minAngle and maxAngle arguments are the angles between which an
# edge is considered to be lit.
#    
body ::tycho::Polygon::borders {minAngle maxAngle coords borderWidth} {
    set minRadians [radians $minAngle]
    set maxRadians [radians $maxAngle]

    set lit {}
    set shaded {}

    # Get the coordinates of the two parallel polygons
    set outer $coords
    set inner [stretch $outer -$borderWidth angles]

    # Rename to save for later
    set inside $inner

    # Calculate the lists of coordinates.
    set a [lindex $angles 0]
    if { $a <= $minRadians && $a > $maxRadians } {
	set length 2
	set angles [lrange $angles 1 end]

	set a [lindex $angles 0]
	while { ($a <= $minRadians && $a > $maxRadians) \
		&& [llength $angles] > 0 } {
	    incr length 2
	    set angles [lrange $angles 1 end]
	    set a [lindex $angles 0]
	}

	lappend lit [concat \
		[lrange $outer 0 [expr $length+1]] \
		[reverse [lrange $inner 0 [expr $length+1]]] \
		[lindex $outer 0] \
		[lindex $outer 1]]

	set outer [lrange $outer $length end]
	set inner [lrange $inner $length end]
    }

    while { [llength $angles] > 0 } {
 	set length 2
	set angles [lrange $angles 1 end]
	set a [lindex $angles 0]
 	while { ($a > $minRadians || $a <= $maxRadians) \
		&& [llength $angles] > 0 } {
	    incr length 2
 	    set angles [lrange $angles 1 end]
	    set a [lindex $angles 0]
 	}

	lappend shaded [concat \
		[lrange $outer 0 [expr $length+1]] \
		[reverse [lrange $inner 0 [expr $length+1]]] \
		[lindex $outer 0] \
		[lindex $outer 1]]

 	if { [llength $angles] == 0 } {
 	    break
 	}

 	set outer [lrange $outer $length end]
 	set inner [lrange $inner $length end]

 	set length 2
	set angles [lrange $angles 1 end]
 	set a [lindex $angles 0]
 	while { ($a <= $minRadians && $a > $maxRadians) \
		&& [llength $angles] > 0 } {
 	    incr length 2
 	    set angles [lrange $angles 1 end]
 	    set a [lindex $angles 0]
 	}

	lappend lit [concat \
		[lrange $outer 0 [expr $length+1]] \
		[reverse [lrange $inner 0 [expr $length+1]]] \
		[lindex $outer 0] \
		[lindex $outer 1]]

 	set outer [lrange $outer $length end]
 	set inner [lrange $inner $length end]
    }

    # Return the three-list of results
    return [list $inside $lit $shaded]
}
