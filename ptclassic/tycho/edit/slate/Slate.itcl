##########################################################################
# A canvas mega-widget for manipulating complex graphical items.
#
# @Version: $Id$
# @Author: H. John Reekie
#
# @Copyright (c) 1996 The Regents of the University of California.
# All rights reserved.
# 
# Permission is hereby granted, without written agreement and without
# license or royalty fees, to use, copy, modify, and distribute this
# software and its documentation for any purpose, provided that the above
# copyright notice and the following two paragraphs appear in all copies
# of this software.
# 
# IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY
# FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
# ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF
# THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.
# 
# THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE
# PROVIDED HEREUNDER IS ON AN "AS IS" BASIS, AND THE UNIVERSITY OF
# CALIFORNIA HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,
# ENHANCEMENTS, OR MODIFICATIONS.
#                                                         COPYRIGHTENDKEY
##########################################################################


#######################################################################
## slate pathName args
#
# Create a slate. This procedure creates a new widget, as
# recommended on the itk web pages. In addition to creating
# a new slate, this procedure changes the binding tags so
# that events on the canvas are intercepted by the slate.
#
proc ::tycho::slate {pathName args} {
    # Create the widget
    uplevel ::tycho::Slate $pathName $args

    # Muck about with the binding tags in order to make events
    # on the canvas appear to be on the mega-widget. The default
    # bindtags for the slate (say ".s") are:
    #
    #    itk-delete-.s .s Slate . all
    #
    # and for the canvas are:
    #
    #    itk-destroy-.s.canvas .s.canvas Canvas . all
    #
    # The following code changes the binding tags to:
    #
    #    itk-delete-.s Slate . all
    #
    # and:
    #
    #    itk-destroy-.s.canvas .s Canvas . all
    #
    # What this does is: a) make scripts bound to the _slate_ (.s)
    # be matched when an event occurs on the _canvas_; b) removes
    # the slate from its own binding tags so that scripts bound to
    # events like Enter, Leave, Configure don't get executed
    # twice twice.
    #
    # I don't what the itk-delete-.s and itk-destroy-.s.canvas
    # tags are for.
    set slatetags  [bindtags $pathName]
    set canvastags [bindtags [$pathName component canvas]]

    bindtags [$pathName component canvas] \
	    [lreplace $canvastags 1 1 [lindex $slatetags 1]]
    bindtags $pathName [lreplace $slatetags 1 1]

    return $pathName
}



#######################################################################
#### Slate
#
# The slate extends the IncrCanvas widget to support more complex
# item manipulation, including symbolic aspects ("ne," "vertex-2"),
# constraints, reshaping, alignment, and fast construction
# of items. Because it inherits from IncrCanvas, it is (almost)
# fully compatible with the standard Tk canvas and can thus be
# "dropped-in" in place of a Tk canvas. (If you try this and it
# doesn't work, <a href="mailto:tycho@eecs.berkeley.edu">let us
# know</a>.)
#
# A note on this implementation:
# complex items are not represented by [incr Tcl] objects, but by
# manipulating tags on canvas items. An earlier implementation
# that created an [incr Tcl] object for each complex item was
# too cumbersome and slow.
#
# In addition to the Slate class itself, there are a number of
# other classes that work with the slate to implement its full
# functionality. These classes are grouped into several categories,
# according to their function in the slate:
#
# <ul>
# <li><i>ComplexItem</i> and subclasses.
# These classes implement the functionalty needed by the slate to 
# actually create complex items. Subclasses of ComplexItem includes things
# like ``3D'' rectangles and
# polygons, and ``smart'' objects like self-routing lines.
#
# <li><i>Shape</i> and subclasses. Shape classes add functionality
# to items related to their shape. Facilities such as symbolic
# points on an item ("ne," "vertex-2"), alignment, and reshaping
# all depend on the shape classes.
#
# <li><i>Interactor</i> and subclasses. Interactors are objects that
# manage user interaction with the slate. Interactors provide a powerful
# mechanism for capturing and reusing standard patterns of interaction.
# </ul>
#
# To create a slate, do not call the constructor directly, but call
# the procedure <code>::tycho::slate</code>:
#
# <tcl><pre>
#     ::tycho::slate .s
#     pack .s -fill both -expand on
#     wm deiconify .
# </pre></tcl>
#
# The Slate class is designed to be fully compatible with the canvas,
# so some of the methods are less efficient than they could be.
# We are considering writing a second class which will provide a
# faster interface for code that doesn't need backwards compatibility.
#
class ::tycho::Slate {
    inherit ::tycho::IncrCanvas

    constructor {args} {}
    destructor {}

    ###################################################################
    ####                            options                        ####

    # The color of the highlight box
    itk_option define -highlightcolor highlightColor HighlightColor "black"

    # The width of the highlight box
    itk_option define -highlightwidth highlightWidth HighlightWidth 1

    # Export the selection if this flag is true
    itk_option define -exportselection exportSelection ExportSelection 1

    ###################################################################
    ####                         public methods                    ####

    # Align and distribute items
    method align {where args}

    # Get aspects of an item
    method aspect {id args}

    # Attach a constraint
    method attach {id pattern script}

    # Detach a constraint
    method detach {id pattern}

    # Access constraints of an item
    method constraint {id {pattern {}} args}

    # Set up various control things
    method control {command args}

    # Return a representation of an item
    method describe {id args}

    # Remove an item or items from the selection
    method deselect {args}

    # Create a "ghost" of one or more items
    method ghost {tag {tags {}}}

    # Add a highlight to an item
    method highlight {tag args}

    # Manipulate items
    method manipulate {id mode x y args}

    # Move items
    method move {tag xAmount yAmount}

    # Move to an absolute location
    method moveto {tag x y {aspect center}}

    # Propagate the constraints attached to an item
    method propagate {id event args}

    # Recreate an item from a description generated by describe{}
    method recreate {description args}

    # Set or get the rectangular "region" of one or more items
    method region {tag args}

    # Reshape one or more aspects of an item
    method reshape {id x y args}

    # Reshape by moving an aspect to an absolute location
    method reshapeto {tag x y aspect}

    # Add an item or items to the selection
    # method select {args}

    # Get the items in the selection
    method selection {}

    # Access the slate's selector object
    method selector {args}

    # Return the item's shape
    method shape {id {method {}} {region 0}}

    # Remove a highlight from an item
    method unhighlight {tag}

    ###################################################################
    ####                   protected variables                     ####

    ###################################################################
    ####                    private variables                      ####

    # The behavior of items
    private variable behavior

    # The slate's selector
    private variable selector

    # Items can have constraints attached to them
    private variable constraints

    # Constraints "visit" items
    private variable visited
}


#######################################################################
#### -exportselection option configuration
#
# If there's a selector, change its corresponding option.
#
configbody ::tycho::Slate::exportselection {
    if { [::info exists selector] } {
	$selector configure -exportselection $itk_option(-exportselection)
    }
}

#######################################################################
#### -highlightwidth option configuration
#
# If there's a selector, change its corresponding option.
#
configbody ::tycho::Slate::highlightwidth {
    if { [::info exists selector] } {
	$selector configure -highlightwidth $itk_option(-highlightwidth)
    }
}

#######################################################################
#### -highlightcolor option configuration
#
# If there's a selector, change its corresponding option.
#
configbody ::tycho::Slate::highlightcolor {
    if { [::info exists selector] } {
	$selector configure -highlightcolor $itk_option(-highlightcolor)
    }
}

#######################################################################
#### constructor
#
# Do not call the constructor of the Slate directly: _always_
# use the procedure ::tycho::slate{}.
#
body ::tycho::Slate::constructor {args} {
    # Initialise options
    eval itk_initialize $args
}

#######################################################################
#### align
#
# Align items in the vertical or horizontal axis. The first argument
# specifies the alignment, and can be one of "left," "center," "right," 
# "top," "middle," or "bottom." Following arguments are items IDs or tags
# specifying the items to align.
#
body ::tycho::Slate::align {where args} {
    ;# FIXME
}

#######################################################################
#### aspect
#
# Return the value of one or more "aspects" of an item. An aspect
# is a point on the item, such as its center or north-east corner.
# The returned value is a list of coordinates, two (_x_ and _y_) for each
# given aspect.
#
# The aspects supported depends on the shape of the item. See the
# <a href="../internals/shapes.html">Shape</a> classes for information
# on the aspects of each type.
# 
# If there are no arguments, return the list of valid aspects for
# this item.
#
body ::tycho::Slate::aspect {id args} {
    getflag region args

    # Get the proc and call it
    return [eval [shape $id aspect $region] $id $canvas $this $args]
}

#######################################################################
#### constraint
#
# Attach, detach, or query constraints. A "constraint" is simply a
# function-script that is executed when certain things are done to
# an item (such as moving it). (The mechanism is very simple, and
# probably is misnamed -- since it is, however, used to implement
# constraints, I think it's OK.)
#
# A constraint is associated with an item _and_ a glob-style pattern
# that matches certain events generated by the Slate. Each event causes
# all matching function-scripts to be applied to a number of arguments.
# The events and arguments are:
# <ul>
# <li><b>move</b> _id_ _x_ _y_: An item has been moved (_x_, _y_) pixels.
# <li><b>reshape-</b><i>aspect</i> _id_ _x_ _y_ { _aspect_ ... }:
#     An item has had one or more aspects reshaped by (_x_, _y_) pixels.
#     The aspect within the event name is the aspect that was matched
#     to trigger this event; the list of aspects passed to the
#     function-script is the list of aspects which were reshaped.
# </ul>
#
# The argument list to this method takes the following forms:
# <ul>
# <li>_id_: Return the constraint patterns attached to _id_.
# <li>_id_ _pattern_: Return the script attached to the given
#     item and event pattern. Note that the match with the pattern
#     is a _literal_ match. Returns null if there is no script.
# <li>_id_ _pattern_ _script_: Attach _script_ to the given item
#     at the given pattern. If there is already a script attached,
#     it is overwritten; if the script is the empty list, the
#     constraint is removed.
# </ul>
#
# <b>Note</b>: This mechanism should be used sparingly. It is intended
# for use to implement constraints between items for user-interaction,
# and should not be used as a "I want to know whenever something
# happens" mechanism.
#
body ::tycho::Slate::constraint {id {pattern {}} args} {
    if { $pattern == "" } {
	# Return constraint patterns for this item
	set result {}
	foreach name [array names constraints $id,*] {
	    lappend result [lindex [split $name ","] 1]
	}
	return $result
    } elseif { $args == {} } {
	# Return the script bound to the item and pattern
	if { ! [::info exists constraints($id,$pattern)] } {
	    return ""
	} else {
	    return $constraints($id,$pattern)
	}
    } else {
	set script [lindex $args 0]
	if { $script == "" } {
	    # Detach the constraint
	    unset constraints($id,$pattern)
	} else {
	    # Attach a constraint
	    set constraints($id,$pattern) $script
	}
    }
}

body ::tycho::Slate::attach {id pattern script} {
    set constraints($id,$pattern) $script
}

body ::tycho::Slate::detach {id pattern} {
    unset constraints($id,$pattern)
}

#######################################################################
#### control
#
# The Slate's "control" interface. This is a collection of miscellaneous
# commands that control certain things on the slate and on items.
#
# The set of commands and their arguments is:
#
# <ul>
# <li><b>interactor</b> _class_ ?option value ....?: Create a new interactor
# of the specified class. Additional arguments are passed to its
# constructor as options.
# <li><b>behavior</b> _id_ ?_behavior_? ?aspect ... ?: Get or set the
# "behavior"
# of an item. This controls what the item does in response to interaction
# commands (see manipulate{}). If only the _id_ is given, the current
# behavior of the item is returned; if additional arguments are given
# the behavior of the item is set. By default, all items have the behavior
# "move." Valid behaviors are:
# <ul>
# <li><b>move</b>: The item is moved.
# <li><b>reshape</b> _aspect_ ?_aspect_ ...?: The given aspect or aspects
# of the item are reshaped.
# </ul>
# </ul>
#
# Additional control commands and behaviors will be added in future.
#
body ::tycho::Slate::control {command args} {
    switch -exact $command {
	"behavior" {
	    set id [lindex $args 0]
	    set args [lreplace $args 0 0]

	    # Set or query the behavior of this item
	    if { $args == "" } {
		if { ! [::info exists behavior($id)] } {
		    return "move"
		} else {
		    return $behavior($id)
		}
	    } else {
		set behavior($id) $args
	    }
	}
	"interactor" {
	    # Create an interactor
	    set class [lindex $args 0]
	    set args [lreplace $args 0 0]

	    set interactor [uplevel #0 ::tycho::$class #auto \
		    [::info namespace tail $this] $canvas $args]
	    
	    # Return it
	    return $interactor
	}
	default {
	    error "Invalid command $command"
	}
    }
}

#######################################################################
#### describe
#
# Return a description of an item on the canvas. This description will
# be understood by recreate{} so that the item can be recreated or
# duplicated later in various forms. <i>Do not make any assumptions
# about the contents of the string returned by this method.</i>
#
# Note: If saving the description for later recreation, you may also need
# to save other information about the complex item, such as its type
# or whether it has certain tags that affect how you will recreate it.
#
# FIXME: Rethink the describe/recreate implementation
#
body ::tycho::Slate::describe {id args} {
    # Create a "lambda" script with slate as argument
#    set description {lambda slate -> $slate create}

    # Item type
    set description [$this type $id]

    # Coordinates
    eval lappend description [$this coords $id]

    # Add options only if they differ from the default. The -tags
    # options is treated specially, to filter out hierarchy tags.
    foreach {option x y default value} \
	    [eval concat [$this itemconfigure $id]] {
	if { $option == "-tags" } {
	    set tags {}
	    foreach tag $value {
		if { ! [string match {[!_]*} $tag] } {
		    lappend tags $tag
		}
	    }
	    if { $tags != "" } {
		lappend description -tags $tags
	    }
	} elseif { $default != $value } {
	    lappend description $option $value
	}
    }

    # Return 
    return $description
}

#######################################################################
#### deselect
#
# Remove an item or items from the selection.
#
body ::tycho::Slate::deselect {args} {
	# Make sure the selector is initialized
	selector

    foreach t $args {
	foreach i [find withtag $t] {
	    $selector deselect $i
	}
    }
}

#######################################################################
#### ghost
#
# Create a ghost of an item. This is a grey outline of the item
# for (optional) use when moving and resizing the item. If
# _tag_ refers to more than one item, the returned item contains
# a ghost for each of those items. If the optional _tags_ argument
# is given, these tags are given to the created ghost item.
#
body ::tycho::Slate::ghost {tag {tags {}}} {
    if { ! [string match {[_0-9]*} $tag] } {
	# It's a tag, so get matching items
	set match [find withtag $tag]
	if { [llength $match] == 0 } {
	    return
	} elseif { [llength $match] == 1 } {
	    set tag [lindex $match 0]
	} else {
	    # If there are multiple items, create a ComplexItem and
	    # add the ghost of each item to it.
	    set ghost [eval create ComplexItem [region $tag]]
	    eval lappend tags [gettags $ghost]
	    foreach item $match {
		ghost $item $tags
	    }
	    return $ghost
	}
    } elseif { [string match {_*} $tag] } {
	# If it's a complex item and it has a ghost{} method,
	# call that
	if { [@scope ::tycho::$itemClass($id) \
		[list ::info exists methodtable(ghost)]] } {
	    return [@scope ::tycho::$itemClass($id) \
		    [list eval \[set methodtable(ghost)\] \
		    $id $canvas $this]]
    	}
    }

    # If we get to here, tag represents a single item
    set shape [shape $tag]
    set primary [@scope ::tycho::ComplexItem [list set primary($id)]]
    switch -exact $shape {
	"rectangle" -
	"oval" -
	"polygon" {
	    return [eval $canvas create $shape \
		    [$canvas coords $primary] -outline grey -tags $tags]
	}
	"line" {
	    return [eval $canvas create $shape \
		    [$canvas coords $primary] -fill grey -tags $tags]
	}
	"default" {
	    return [eval $canvas create rectangle \
		    [region $tag] -outline grey -tags $tags]
	}
    }
}

#######################################################################
#### highlight
#
# Create a highlight around an item. This is a colored outline 
# around the item's bounding box. Complex items can choose their
# own style of highlighting by providing a highlight{} procedure.
# The highlight item is attached to the item as a constraint.
# Each created highlight item is tagged with "highlight" and
# "highlight._id_", where _id_ is the item it highlights.
#
# If _tag_ refers to more than one item, the returned result
# is a list of highlight items, one for each item represented
# by that tag. If there are additional arguments, these are given
# to the default highlight rectangle.
#
body ::tycho::Slate::highlight {tag args} {
    if { [string match {_*} $tag] } {
	# If it's a complex item and it has a highlight{} method,
	# call that
	if { [@scope ::tycho::$itemClass($tag) \
		[list ::info exists methodtable(highlight)]] } {
	    return [@scope ::tycho::$itemClass($tag) \
		    [list eval \[set methodtable(highlight)\] \
		    $tag $canvas $this]]
    	}
    } elseif { ! [string match {[_0-9]*} $tag] } {
    	# It's a tag, so do for each item
    	set result {}
    	foreach item [find withtag $tag] {
	    lappend result [highlight $item]
    	}
    	return $result
    }

    # If we get to here, tag represents a single item
    # Draw a box around it.
    set result [eval $canvas create rectangle \
	    [$canvas bbox $tag] \
	    -width $itk_option(-highlightwidth) \
	    -outline $itk_option(-highlightcolor) \
	    [list -tags [list "highlight" "highlight.$tag"]] $args]
    $canvas lower highlight.$tag $tag

    # Add it as a constraint to the item
    attach $tag "move" [list lambda id x y -> $this move $result \$x \$y]

    # Return it
    return $result
}

#######################################################################
#### manipulate
#
# Manipulate an item. This method is the interface that interactors
# use for manipulating canvas items, and is not intended for general
# use. The first argument is the ID of an item; the second is the
# "mode" of interaction, and must be one of:
# <ul>
# <li><b>click</b>: The interaction sequence is started at coordinates
# (_x_, _y_). Additional arguments include various flags that may
# be supplied by the interactors that the slate uses to affect
# the behavior of items, such as *-ghost*, which says that an
# item is to be moved or reshaped using a "ghost" outline.
#
# <li><b>drag</b>: The interaction sequence continues with 
# (_x_, _y_) as the new cursor position. There are no additional
# arguments supplied.
#
# <li><b>release</b>: Terminate the interaction sequence at 
# coordinates (_x_, _y_), _x_ and _y_ will usually be the same as
# the last coordinates passed to the drag mode. There are no additional
# arguments supplied.
#
body ::tycho::Slate::manipulate {id mode x y args} {
    switch -exact $mode {
	"click" {
	    if { ! [::info exists behavior($id)] } {
		set behavior($id) move
	    }
	    switch -exact $behavior($id) {
		"move" {
		    eval ::tycho::Shape::moveclick $id $canvas $this $x $y $args
		}
		default {
		    eval [shape $id [lindex $behavior($id) 0]click] \
			    $id $canvas $this $x $y \
			    [lrange $behavior($id) 1 end] $args
		}
	    }
	}
	"drag" {
	    switch -exact $behavior($id) {
		"move" {
		    eval ::tycho::Shape::movedrag $id $canvas $this $x $y
		}
		default {
		    eval [shape $id [lindex $behavior($id) 0]drag] \
			    $id $canvas $this $x $y
		}
	    }
	}
	"release" {
	    switch -exact $behavior($id) {
		"move" {
		    eval ::tycho::Shape::moverelease \
			    $id $canvas $this $x $y
		}
		default {
		    eval [shape $id [lindex $behavior($id) 0]release] \
			    $id $canvas $this $x $y
		}
	    }
	}
    }
}

#######################################################################
#### move
#
# Move one or more items the specified amount. The first argument
# can either be a tag or an id.
#
body ::tycho::Slate::move {tag xAmount yAmount} {
    # Move the items
    # $canvas move $tag $xAmount $yAmount

    # If it's just one item, propagate constraints and move it
    if { [string match {[_0-9]*} $tag] } {
	if { [propagate $tag "move" $xAmount $yAmount] } {
	    $canvas move $tag $xAmount $yAmount
	}
    } else {
	# Do the same things for multiple items
	foreach item [find withtag $tag] {
	    if { [propagate $item "move" $xAmount $yAmount] } {
		$canvas move $item $xAmount $yAmount
	    }
	}
    }
}

#######################################################################
#### moveto
#
# Move one or more items to an absolute location. The point
# of the item that is moved to the specified location is
# specified by the fourth argument, the aspect. If omitted, this
# argument defaults to "center."
#
# If a tag is specified and the tag denotes more than one item,
# then the items are moved so that the indicated point on the
# region covered by those items is at the specified location.
#
body ::tycho::Slate::moveto {tag x y {aspect center}} {
    # Get the current location of the aspect
    if { ! [string match {[_0-9]*} $tag] } {
	# A tag is specified. See if there's just one item
	set items [find withtag $tag]
	if { [llength $items] == 0 } {
	    # No items, so just return
	    return
	} elseif { [llength $items] == 1 } {
	    # One item, so act as though that item was specified
	    set current [aspect [lindex $items 0] $aspect]
	} else {
	    # Multiple items, so use the region
	    set current [rectAspect [$this bbox $tag] $aspect]
	}
    } else {
	# Just get the aspect of the item
	set current [$this aspect $tag $aspect]
    }

    # Move the item(s)
    set x [expr $x - [lindex $current 0]]
    set y [expr $y - [lindex $current 1]]
    $canvas move $tag $x $y
}

#######################################################################
#### propagate
#
# Propagate the constraints attached to an item and event. The first
# argument is the item, the second the interaction event name.
# Following arguments depends on the event, and must be as documented
# in the comment to the *constraint* method.
#
# This methods check for circular constraints. It
# returns 1 if the item was visited for the first
# time and zero otherwise. Methods that call it should test the
# return value, and if it is zero, should _not_ perform their
# action.
#
# <b>Note</b>: If an error occurs, some items will have been
# moved (reshaped etc.) and some won't. At the moment, we ignore
# this problem, but later on there should probably be some way
# of "unwinding" constraint propagation.
#
body ::tycho::Slate::propagate {id event args} {
    # If the item has already been visited, return 0
    if { [::info exists visited($id)] } {
	return 0
    }

    # Mark the item
    set visited($id) 1

    # Match constraints and apply them
    foreach name [array names constraints $id,*] {
 	set pattern [lindex [split $name ","] 1]
 	if { [string match $pattern $event] } {
 	    # Apply the constraint script if a match
 	    if { [catch { \
 		    uplevel #0 apply \
 		    [list $constraints($id,$pattern)] $id $args} msg]} {
 		# If there's an error, reset the visited items
 		# and reinvoke the error
 		catch {unset visited}
 		error $msg
 	    }
 	}
    }

    # Unmark the item
    unset visited($id)
    return 1
}

#######################################################################
#### recreate
#
# Re-create a complex item from a description returned by describe{}.
# By default, the complex item will be created in exactly the same
# position as when describe was called, and without any hierarchy.
# A number of options can modify this behavior (these options do not
# have to be used, but are really just short-cuts to save other calls:
# <ul>
# <li>*-move* _x y_: Move the new complex item relative to the described
# position.
# <li>*-at* _x y_ ?_aspect_?: Place the given _aspect_ at (_x_,_y_).
# The aspect default to center.
# <li>*-coords* _x0 y0_ ...: Use these coordinates instead of the ones
# given by the description.
# <li>*-in* _id_: Make the complex item a child of the complex item _id.
# </ul>
#
# *-move*, *-at* and *-coords* are mutually exclusive.
#
# FIXME: Rethink the describe/recreate implementation
#
body ::tycho::Slate::recreate {description args} {
    # What we'll do is just create the item in the default mode,
    # and then move or tag it if there are options for doing so.
    # This could be made a fair bit more efficient by modifying the
    # description string _before_ applying it
    set id [apply $description $this]

    # -move option
    set move [readoption move args]
    if { $move != "" } {
	$this move $id [lindex $move 0] [lindex $move 1]
    } else {
	# -at option
	set at [readoption at args]
	if { $at != "" } {
	    if { [llength $at] > 2 } {
		set aspect [lindex $at 2]
	    } else {
		set aspect center
	    }
	    $this moveto $id [lindex $at 0] [lindex $at 1] $aspect
	} else {
	    # -coords option
	    set coords [readoption coords args]
	    if { $coords != "" } {
		eval $this coords $id $coords
	    }
	}
    }

    # -in option
    set in [readopt in args]
    if { $in != "" } {
	$this itemconfigure $id \
		-tags [lunion [$this gettags $id] [$this gettags $in]]
    }

    return $id
}

#######################################################################
#### region
#
# Set or get the "region" of an item or set of items. The first
# argument is an item id or a tag. If an id or if the tag denotes
# a single item, then the coordinates of that item are tested: if
# there are four of them, then that is treated as the its
# region; if there are not four, then the bounding box of the
# item less 2 in each direction is its region. If the first
# argument is a tag that denotes more than one item, the bounding
# box less 2 is the region; if it denotes no items, the method return
# with null.
#
# If no additional arguments are given, return the region. If
# additional arguments are given, scale the item or items so that
# its region become the given arguments.
#
body ::tycho::Slate::region {tag args} {
    set rectangular 1
    # For an item, use the coords if it's a 4-list, else
    # use the bounding box shrunk by 2 in each direction
    if { [string match {_[0-9]*} $tag] } {
	set region [coords $tag]
	if { [llength $region] != 4 } {
	    set region [rectShrink [bbox $tag] 2]
	    set rectangular 0
    	}
    } else {
	# It's a tag, so first find matching items
	set match [find withtag $tag]
	
	# If there are none, return
	if { [llength $match] == 0 } {
	    return
	} elseif { [llength $match] == 1 } {
	    # If there's one item, process that
	    set region [coords $tag]
	    if { [llength $region] != 4 } {
		set region [rectShrink [bbox $tag] 2]
		set rectangular 0
	    }
	    set tag [lindex $match 0]
	} else {
	    # There are many items, so get the bounding box less 2
	    set region [rectShrink [$canvas bbox $tag] 2]
	    set rectangular 0
	}
    }

    # If no arguments are given, return the region
    if { $args == "" } {
	return $region
    } else {
	# Change the region to the newly-specified coordinates.
	if { $rectangular } {
	    # If there's one rectangular item, call coords{}
	    eval coords $tag $args
	} else {
	    # Otherwise figure out the scaling factors and call scale{}
	    assign x0 y0 x1 y1 $region
	    assign a0 b0 a1 b1 $args

	    set xscale [expr double($a1-$a0)/($x1-$x0)]
	    set yscale [expr double($b1-$b0)/($y1-$y0)]

	    scale $tag $a0 $b0 $xscale $yscale
	}
    }
}

#######################################################################
#### reshape
#
# Reshape an item by moving one or more of its aspects the specified
# distance. If the *-region* flag is specified, treat the picture as
# a rectangular region.
#
# FIXME: Allow first arg to be a tag.
#
body ::tycho::Slate::reshape {id x y args} {
    getflag region args

    # First, propagate constraints and return if already visited
    if { ! [eval propagate $id reshape $x $y $args] } {
	return
    }

    # Get the proc and call it
    return [eval [shape $id reshape $region] $id $canvas $this $x $y $args]
}

#######################################################################
#### reshapeto
#
# Move an aspect of an item to a specified location.
# The first argument can be a tag as long as it denotes only
# one item -- if it denotes more than one, an error is flagged.
#
# FIXME: add -region flag.
#
body ::tycho::Slate::reshapeto {tag x y aspect} {
    # Get the current location of the aspect
    if { ! [string match {[_0-9]*} $tag] } {
	# A tag is specified. See if there's just one item
	set items [find withtag $tag]
	if { [llength $items] == 0 } {
	    # No items, so just return
	    return
	} elseif { [llength $items] == 1 } {
	    # One item, so act as though that item was specified
	    set current [aspect [lindex $items 0] $aspect]
	} else {
	    # Multiple items, so flag an error
	    error "Cannot specify multiple items to reshapeto{}"
	}
    } else {
	# Just get the aspect of the item
	set current [$this aspect $tag $aspect]
    }

    # Reshape the item
    set x [expr $x - [lindex $current 0]]
    set y [expr $y - [lindex $current 1]]
    reshape $tag $x $y $aspect
}

#######################################################################
#### select
#
# Add an item or items to the selection.
#
# body ::tycho::Slate::select {args} {
#	# Make sure the selector is initialized
#	selector
#
#
#     foreach t $args {
# 	foreach i [find withtag $t] {
# 	    $selector select $i
# 	}
#     }
# }

#######################################################################
#### selection
#
# Get the selection.
#
body ::tycho::Slate::selection {} {
    # Call the selector. NB Do not use $selector here!
    selector selection
}

#######################################################################
#### selector
#
# Access the slate's selector interactor. If the slate does not
# have a selector, create it. With no arguments, return the
# selector interactor; with arguments, call the selector with
# the first argument as method name and remaining arguments as
# its arguments.
#
body ::tycho::Slate::selector {args} {
    # If there's no selector, create one. Note that some options
    # are given directly to the selector.
    if { ! [::info exists selector] } {
	set selector [control interactor Selector \
		-highlightcolor $itk_option(-highlightcolor) \
		-highlightwidth $itk_option(-highlightwidth) \
		-exportselection $itk_option(-exportselection)]
    }

    # Return the selector or evaluate a command on it
    if { $args == "" } {
	return $selector
    } else {
    	uplevel #0 $selector $args
    }
}

#######################################################################
#### shape
#
# Return the "shape" of an item. The shape of an item
# value returned is a subset of the types.
#
# If an extra argument given, this method returns the proc to
# call that implements that method on the item's shape. A
# third argument, if present and true, causes the item to be treated
# as a rectangle regardless of its "real" shape. (FIXME: Won't work
# until the region{} method is implemented properly.)
#
body ::tycho::Slate::shape {id {method {}} {region 0}} {
    # First get the shape. If the -region flag is given,
    # treat the item as a rectangle
    if { $region } {
        set shape "rectangle"
    } elseif { [string match {[0-9]*} $id] } {
	set shape [$canvas type $id]
        # Text, image, and bitmap items are treated as a "point"
        if { [lmember {text bitmap image} $shape] } {
            set shape point
        }
    } else {
	set shape [@scope ::tycho::$itemClass($id) [list set shape]]
    }

    # Return just the shape
    if { $method == "" } {
	return $shape
    } else {
	# If a method name is given, get the proc that implements it
	if { ! $region && [string match {_*} $id] && \
		[@scope ::tycho::$itemClass($id) \
		[list ::info exists methodtable($method)]] } {
	    # If the item is complex and the region flag is not given,
	    # get it from the complex item class
	    return [@scope ::tycho::$itemClass($id) \
		    [list set methodtable($method)]]
	} else {
	    # If we can't get it from the item class, then get it
	    # from the shape class
	    return ::tycho::As[capitalize $shape]::$method
	}
    }
}

#######################################################################
#### unhighlight
#
# Delete highlights.
#
body ::tycho::Slate::unhighlight {tag} {
    if { [string match {_*} $tag] } {
	# If it's a complex item and it has an unhighlight{} method,
	# call that
	if { [@scope ::tycho::$itemClass($tag) \
		[list ::info exists methodtable(unhighlight)]] } {
	    @scope ::tycho::$itemClass($tag) \
		    [list eval \[set methodtable(unhighlight)\] \
		    $tag $canvas $this]

	    # Remove the constraint
	    detach $tag "move"
	    return
    	}
    } elseif { ! [string match {[_0-9]*} $tag] } {
    	# It's a tag, so do for each item
    	foreach item [find withtag $tag] {
	    unhighlight $item
    	}
    	return
    }

    # If we get to here, tag represents a single item
    # Delete the highlight item
    $canvas delete highlight.$tag

    # Remove the constraint
    detach $tag "move"
}
