##########################################################################
# A canvas mega-widget for manipulating complex graphical items.
#
# @Version: $Id$
# @Author: H. John Reekie
#
# @Copyright (c) 1996-%Q% The Regents of the University of California.
# All rights reserved.
# 
# Permission is hereby granted, without written agreement and without
# license or royalty fees, to use, copy, modify, and distribute this
# software and its documentation for any purpose, provided that the
# above copyright notice and the following two paragraphs appear in all
# copies of this software.
# 
# IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY
# FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
# ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF
# THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.
# 
# THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE
# PROVIDED HEREUNDER IS ON AN "AS IS" BASIS, AND THE UNIVERSITY OF
# CALIFORNIA HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,
# ENHANCEMENTS, OR MODIFICATIONS.
# 
# 						PT_COPYRIGHT_VERSION_2
# 						COPYRIGHTENDKEY
##########################################################################


#######################################################################
## slate pathName args
#
# Create a slate. This procedure creates a new widget, as
# recommended on the itk web pages. In addition to creating
# a new slate, this procedure changes the binding tags so
# that events on the canvas are intercepted by the slate.
#
proc ::tycho::slate {pathName args} {
    # Create the widget
    uplevel ::tycho::Slate $pathName $args

    # Muck about with the binding tags in order to make events
    # on the canvas appear to be on the mega-widget. The default
    # bindtags for the slate (say ".s") are:
    #
    #    itk-delete-.s .s Slate . all
    #
    # and for the canvas are:
    #
    #    itk-destroy-.s.canvas .s.canvas Canvas . all
    #
    # The following code changes the binding tags to:
    #
    #    itk-delete-.s Slate . all
    #
    # and:
    #
    #    itk-destroy-.s.canvas .s Canvas . all
    #
    # What this does is: a) make scripts bound to the _slate_ (.s)
    # be matched when an event occurs on the _canvas_; b) removes
    # the slate from its own binding tags so that scripts bound to
    # events like Enter, Leave, Configure don't get executed
    # twice twice.
    #
    # I don't what the itk-delete-.s and itk-destroy-.s.canvas
    # tags are for.
    set slatetags  [bindtags $pathName]
    set canvastags [bindtags [$pathName component canvas]]

    bindtags [$pathName component canvas] \
	    [lreplace $canvastags 1 1 [lindex $slatetags 1]]
    bindtags $pathName [lreplace $slatetags 1 1]

    return $pathName
}

#######################################################################
#### Slate
#
# The slate extends the <a href="Slate.html">IncrCanvas</a>
#  widget to support more complex
# item manipulation, including symbolic aspects ("ne," "vertex-2"),
# reshaping, alignment, and fast construction
# of items. Because it inherits from IncrCanvas, it is (almost)
# fully compatible with the standard Tk canvas and can thus be
# "dropped-in" in place of a Tk canvas. (If you try this and it
# doesn't work, <a href="mailto:tycho@eecs.berkeley.edu">let us
# know</a>.)
#
# A note on this implementation:
# complex items are not represented by [incr Tcl] objects, but by
# manipulating tags on canvas items. An earlier implementation
# that created an [incr Tcl] object for each complex item was
# too cumbersome and slow.
#
# In addition to the Slate class itself, there are a number of
# other classes that work with the slate to implement its full
# functionality. These classes are grouped into several categories,
# according to their function in the slate:
#
# <ul>
# <li><a href="../internals/items.html"><i>ComplexItem</i> and subclasses</a>.
# These classes implement the functionalty needed by the slate to 
# actually create complex items. Subclasses of ComplexItem includes things
# like ``3D'' rectangles and
# polygons, and ``smart'' objects like self-routing lines.
#
# <li><a href="../internals/shapes.html"><i>Shape</i> and
# subclasses</a>. Shape classes add functionality
# to items related to their shape. Facilities such as symbolic
# points on an item ("ne," "vertex-2"), alignment, and reshaping
# all depend on the shape classes.
#
# <li><a href="../internals/interactors.html"><i>Interactor</i>
# and subclasses</a>. Interactors are objects that
# manage user interaction with the slate. Interactors provide a powerful
# mechanism for capturing and reusing standard patterns of interaction.
# </ul>
#
# To create a slate, do not call the constructor directly, but call
# the procedure <code>::tycho::slate</code>:
#
# <tcl><pre>
#     ::tycho::slate .s
#     pack .s -fill both -expand on
#     wm deiconify .
# </pre></tcl>
#
# The Slate class is designed to be fully compatible with the canvas,
# so some of the methods are less efficient than they could be.
#
class ::tycho::Slate {
    inherit ::tycho::IncrCanvas

    constructor {args} {}
    destructor {}

    ###################################################################
    ####                            options                        ####

    # The color of the highlight box
    itk_option define -highlightcolor highlightColor HighlightColor "black"

    # The width of the highlight box
    itk_option define -highlightwidth highlightWidth HighlightWidth 1

    # Export the selection if this flag is true
    itk_option define -exportselection exportSelection ExportSelection 1

    ###################################################################
    ####                         public methods                    ####

    # Manipulate the selection -- low level
    method _selection {option {id {}} {index {}}}

    # Align and distribute items
    method align {where args}

    # Get aspects of an item
    method aspect {id args}

    # Delete items
    method delete {args}

    # Return a representation of an item
    method describe {id args}

    # Create a "ghost" of one or more items
    method ghost {tag args}

    # Add a highlight to an item
    method highlight {tag args}

    # Create an interactor on the slate
    method interactor {class args}

    # Move items
    method move {tag xAmount yAmount}

    # Start a move interaction sequence
    method moveclick {id x y args}

    # Continue a move interaction sequence
    method movedrag {id x y}

    # Terminate a move interaction sequence
    method moverelease {id x y}

    # Move to an absolute location
    method moveto {tag x y {aspect center}}

    # Recreate an item from a description generated by describe{}
    method recreate {description args}

    # Set or get the rectangular "region" of one or more items
    method region {tag args}

    # Reshape one or more aspects of an item
    method reshape {id x y args}

    # Start a reshape interaction sequence
    method reshapeclick {id x y args}

    # Continue a reshape interaction sequence
    method reshapedrag {id x y args}

    # Terminate a reshape interaction sequence
    method reshaperelease {id x y args}

    # Reshape by moving an aspect to an absolute location
    method reshapeto {tag x y aspect}

    # Manipulate the selection
    method selection {option {id {}} {index {}}}

    # Access the slate's selector object
    method selector {args}

    # Return the item's shape
    method shape {id {method {}} {region 0}}

    # Remove a highlight from an item
    method unhighlight {tag}

    ###################################################################
    ####                       public procs                        ####

    # Create a sample slate for testing, tutorials, etc
    proc sample {} {
        uplevel #0 {
            catch {delete object .t}
            ::tycho::Displayer .t
            ::tycho::slate .t.s
            pack .t.s -fill both -expand on
            .t centerOnScreen
            return .t.s
        }
    }

    ###################################################################
    ####                    protected methods                      ####

    # Claim the selection if enabled and appropriate
    protected method claimSelection {}

    ###################################################################
    ####                   protected variables                     ####

    ###################################################################
    ####                    private variables                      ####

    # The slate's selector
    private variable selector
}

#######################################################################
#### constructor
#
# Do not call the constructor of the Slate directly: _always_
# use the procedure ::tycho::slate{}.
#
body ::tycho::Slate::constructor {args} {
    # Initialise options
    eval itk_initialize $args

    # Create the selection handler
    ::selection handle [::info namespace tail $this] "$this select describe"
}

#######################################################################
#### _selection
#
# Manipulate the selection. For use by the Selector object.
#
body ::tycho::Slate::_selection {mode {id {}} {index {}}} {
    switch -exact $mode {
	"add" {
	    $canvas select clear
	    addtag "sel" withtag $id
	    highlight $id highlight.sel
	}
	"clear" {
	    unhighlight "sel"
	    dtag "sel"
	    $canvas select clear
        }
	"remove" {
	    unhighlight $id
	    dtag $id "sel"
	}
        default {
            error "Invalid mode $mode"
        }
    }
}

#######################################################################
#### align
#
# Align items in the vertical or horizontal axis. The first argument
# specifies the alignment, and can be one of "left," "center," "right," 
# "top," "middle," or "bottom." Following arguments are items IDs or tags
# specifying the items to align. <b>Not implemented</b>.
#
body ::tycho::Slate::align {where args} {
    ;# FIXME
}

#######################################################################
#### aspect
#
# Return the value of one or more "aspects" of an item. An aspect
# is a point on the item, such as its center or north-east corner.
# The returned value is a list of coordinates, two (_x_ and _y_) for each
# given aspect.  The aspects of an item depend on its type -- see the
# <a href="../internals/shapes.html">Shape</a> classes for information
# on the aspects of each type..  If the 
# <code>-region</code> flag is supplied, treat the item as a rectangular 
# item regardless of its real shape.  To query legal aspects, call with no 
# argument, and a list of legal aspects will be returned.  (Note that the 
# legal aspects are not necessarily constant over the lifetime of an item 
# -- for example, adding a vertex to a polygon will also add an aspect.)
#
body ::tycho::Slate::aspect {id args} {
    ::tycho::getflag region args

    # Get the proc and call it
    return [eval [shape $id aspect $region] $id $canvas $this $args]
}

#######################################################################
#### delete
#
# Override the superclass method to delete highlights too.
#
body ::tycho::Slate::delete {args} {
    eval chain $args
    set h {}
    foreach a $args {
	lappend h highlight.$a
    }
    eval chain $h
}

#######################################################################
#### describe
#
# Return a description of an item on the canvas. This description will
# be understood by recreate{} so that the item can be recreated or
# duplicated later in various forms. <i>Do not make any assumptions
# about the contents of the string returned by this method.</i>
#
# Note: If saving the description for later recreation, you may also need
# to save other information about the complex item, such as its type
# or whether it has certain tags that affect how you will recreate it.
#
# FIXME: Rethink the describe/recreate implementation
#
body ::tycho::Slate::describe {id args} {
    # Item type
    set description [$this type $id]

    # Coordinates
    eval lappend description [$this coords $id]

    # Add options only if they differ from the default. The -tags
    # options is treated specially, to filter out hierarchy tags.
    foreach {option x y default value} \
	    [eval concat [$this itemconfigure $id]] {
	if { $option == "-tags" } {
	    set tags {}
	    foreach tag $value {
		if { ! [string match {[!_]*} $tag] } {
		    lappend tags $tag
		}
	    }
	    if { $tags != "" } {
		lappend description -tags $tags
	    }
	} elseif { $default != $value } {
	    lappend description $option $value
	}
    }

    # Return 
    return $description
}

#######################################################################
#### ghost
#
# Create a ghost of an item and return the ID of the ghost item.
# This is a grey outline of the item for use when moving and resizing
# the item. Complex items can choose their
# own style of ghosting by providing a ghost{} procedure.
# Each created ghost item is tagged with "ghost" and
# "ghost._id_", where _id_ is the item it ghosts, and any
# additional arguments to this method. If the first argument is
# tag, then each ghosted item is also tagged with
# "ghost._tag_". The return value is a list of created items.
#
# Note: It is ths caller's responsibility to delete ghosts after
# completion with a call such as <code>$slate delete ghost</code>.
#
body ::tycho::Slate::ghost {tag args} {
    if { [string match {_*} $tag] } {
	# If it's a complex item and it has a ghost{} method,
	# call that
	if { [@scope ::tycho::$itemClass($tag) \
		[list ::info exists methodtable(ghost)]] } {
	    return [@scope ::tycho::$itemClass($tag) \
		    [list eval \[set methodtable(ghost)\] \
		    $tag $canvas $this \
		    -tags [concat "ghost" "ghost.$tag" $args]]]]
    	} else {
	    set primary [@scope ::tycho::ComplexItem [list set primary($tag)]]
	}
    } elseif { ! [string match {[_0-9]*} $tag] } {
    	# It's a tag, so do for each item
    	set result {}
    	foreach item [find withtag $tag] {
	    lappend result [eval ghost $item "ghost.$tag" $args]
    	}
    	return $result
    } else {
	# Simple item
	set primary $tag
    }

    # If we get to here, tag represents a single item
    set shape [shape $tag]
    set tags [concat "ghost" "ghost.$tag" $args]
    switch -exact $shape {
	"rectangle" -
	"oval" -
	"polygon" {
	    return [eval $canvas create $shape \
		    [$canvas coords $primary] -outline grey \
                    -tags [list $tags]]
	}
	"line" {
	    return [eval $canvas create $shape \
		    [$canvas coords $primary] -fill grey \
		    -arrow [$canvas itemcget $primary -arrow] \
                    -tags [list $tags]]
	}
	"default" {
	    return [eval $canvas create rectangle \
		    [region $tag] -outline grey \
                    -tags [list $tags]]
	}
    }
}

#######################################################################
#### highlight
#
# Create a highlight around an item. This is a colored outline 
# around the item's bounding box. Complex items can choose their
# own style of highlighting by providing a highlight{} procedure.
# Each created highlight item is tagged with "highlight" and
# "highlight._id_", where _id_ is the item it highlights, and any
# additional arguments to this method. If the first argument is
# tag, then each highlighted item is also tagged with
# "highlight._tag_". The return value is a list of created items.
#
body ::tycho::Slate::highlight {tag args} {
    if { [string match {_*} $tag] } {
	# If it's a complex item and it has a highlight{} method,
	# call that
	if { [@scope ::tycho::$itemClass($tag) \
		[list ::info exists methodtable(highlight)]] } {
	    return [@scope ::tycho::$itemClass($tag) \
		    [list eval \[set methodtable(highlight)\] \
		    $tag $canvas $this \
		    [list -width $itk_option(-highlightwidth) \
		    -outline $itk_option(-highlightcolor) \
		    -tags [concat "highlight" "highlight.$tag" $args]]]]
    	}
    } elseif { ! [string match {[_0-9]*} $tag] } {
    	# It's a tag, so do for each item
    	set result {}
    	foreach item [find withtag $tag] {
	    lappend result [eval highlight $item highlight.$tag $args]
    	}
    	return $result
    }

    # If we get to here, tag represents a single item.
    # Draw a box around it.
    set result [eval $canvas create rectangle \
	    [$canvas bbox $tag] \
	    -width $itk_option(-highlightwidth) \
	    -outline $itk_option(-highlightcolor) \
	    [list -tags [concat "highlight" "highlight.$tag" $args]]]

    # Lower the box to just below the item
    $canvas lower highlight.$tag $tag

    # Return it
    return $result
}

#######################################################################
#### interactor
#
# Create an interactor on the slate and return it. This is just a
# convenient interface to the interactor constructors. The first
# argument is the name of the interactor class, following arguments
# are options to the interactor.
#
body ::tycho::Slate::interactor {class args} {
    uplevel #0 ::tycho::$class #auto \
	    [::info namespace tail $this] $canvas $args
}

#######################################################################
#### move
#
# Move one or more items the specified amount. The first argument
# can either be a tag or an id. This method override the
# superclass' method to move highlight items as well.
#
body ::tycho::Slate::move {tag xAmount yAmount} {
    # Move the items
    chain $tag $xAmount $yAmount

    # Move the highlights
    $canvas move highlight.$tag $xAmount $yAmount
}

#######################################################################
#### moveclick
#
# Start a move interaction sequence at coordinates
# (_x_, _y_). Additional arguments include various flags that may
# be supplied by the interactors that the slate uses to affect
# the behavior of items, such as *-ghost*, which says that an
# item is to be moved or reshaped using a "ghost" outline.
#
body ::tycho::Slate::moveclick {id x y args} {
    eval ::tycho::Shape::_moveclick $id $canvas $this $x $y $args
}

#######################################################################
#### movedrag
#
# Continue a move interaction sequence with 
# (_x_, _y_) as the new cursor position. There are no additional
# arguments supplied.
#
body ::tycho::Slate::movedrag {id x y} {
    eval ::tycho::Shape::_movedrag $id $canvas $this $x $y
}

#######################################################################
#### moverelease
#
# Terminate the interaction sequence at 
# coordinates (_x_, _y_), _x_ and _y_ will usually be the same as
# the last coordinates passed to the drag mode. There are no additional
# arguments supplied.
#
body ::tycho::Slate::moverelease {id x y} {
    eval ::tycho::Shape::_moverelease $id $canvas $this $x $y
}

#######################################################################
#### moveto
#
# Move one or more items to an absolute location. The point
# of the item that is moved to the specified location is
# specified by the fourth argument, the aspect. If omitted, this
# argument defaults to "center."
#
# If a tag is specified and the tag denotes more than one item,
# then the items are moved so that the indicated point on the
# region covered by those items is at the specified location.
#
body ::tycho::Slate::moveto {tag x y {aspect center}} {
    # Get the current location of the aspect
    if { ! [string match {[_0-9]*} $tag] } {
	# A tag is specified. See if there's just one item
	set items [find withtag $tag]
	if { [llength $items] == 0 } {
	    # No items, so just return
	    return
	} elseif { [llength $items] == 1 } {
	    # One item, so act as though that item was specified
	    set current [aspect [lindex $items 0] $aspect]
	} else {
	    # Multiple items, so use the region
	    set current [eval ::tycho::Rectangle::aspect \
		    [$this bbox $tag] $aspect]
	}
    } else {
	# Just get the aspect of the item
	set current [$this aspect $tag $aspect]
    }

    # Move the item(s)
    set x [expr $x - [lindex $current 0]]
    set y [expr $y - [lindex $current 1]]
    $canvas move $tag $x $y
}

#######################################################################
#### recreate
#
# Re-create a complex item from a description returned by describe{}.
# By default, the complex item will be created in exactly the same
# position as when describe was called, and without any hierarchy.
# A number of options can modify this behavior (these options do not
# have to be used, but are really just short-cuts to save other calls:
# <ul>
# <li>*-move* _x y_: Move the new complex item relative to the described
# position.
# <li>*-at* _x y_ ?_aspect_?: Place the given _aspect_ at (_x_,_y_).
# The aspect default to center.
# <li>*-coords* _x0 y0_ ...: Use these coordinates instead of the ones
# given by the description.
# <li>*-in* _id_: Make the complex item a child of the complex item _id.
# </ul>
#
# *-move*, *-at* and *-coords* are mutually exclusive.
#
# FIXME: Rethink the describe/recreate implementation
#
body ::tycho::Slate::recreate {description args} {
    # What we'll do is just create the item in the default mode,
    # and then move or tag it if there are options for doing so.
    # This could be made a fair bit more efficient by modifying the
    # description string _before_ applying it
    set id [::tycho::apply $description $this]

    # -move option
    set move [::tycho::readoption move args]
    if { $move != "" } {
	$this move $id [lindex $move 0] [lindex $move 1]
    } else {
	# -at option
	set at [::tycho::readoption at args]
	if { $at != "" } {
	    if { [llength $at] > 2 } {
		set aspect [lindex $at 2]
	    } else {
		set aspect center
	    }
	    $this moveto $id [lindex $at 0] [lindex $at 1] $aspect
	} else {
	    # -coords option
	    set coords [::tycho::readoption coords args]
	    if { $coords != "" } {
		eval $this coords $id $coords
	    }
	}
    }

    # -in option
    set in [::tycho::readopt in args]
    if { $in != "" } {
	$this itemconfigure $id \
		-tags [::tycho::lunion [$this gettags $id] [$this gettags $in]]
    }

    return $id
}

#######################################################################
#### region
#
# Set or get the "region" of an item or set of items. The first
# argument is an item id or a tag. If an id or if the tag denotes
# a single item, then the coordinates of that item are tested: if
# there are four of them, then that is treated as the its
# region; if there are not four, then the bounding box of the
# item less 2 in each direction is its region. If the first
# argument is a tag that denotes more than one item, the bounding
# box less 2 is the region; if it denotes no items, the method return
# with null.
#
# If no additional arguments are given, return the region. If
# additional arguments are given, scale the item or items so that
# its region become the given arguments.
#
# FIXME: Figure out how to allow complex items to sensibly
# override.
#
body ::tycho::Slate::region {tag args} {
    set rectangular 1

    # If it's a complex item and it has a region{} method,
    # call that. FIXME: Need to rethink overriding mechanism.
    if { [string match {_*} $tag] } {
        if { [@scope ::tycho::$itemClass($tag) \
                [list ::info exists methodtable(region)]] } {
            set region [@scope ::tycho::$itemClass($tag) \
                    [list eval \[set methodtable(region)\] \
                    $tag $canvas $this $args]]
            if { [llength $region] != 4 } {
                set region [eval ::tycho::Rectangle::shrink [bbox $tag] 2]
                set rectangular 0
            }
        } else {
            set region [coords $tag]
            if { [llength $region] != 4 } {
                set region [eval ::tycho::Rectangle::shrink [bbox $tag] 2]
                set rectangular 0
            }
        }
    } elseif { [string match {_[0-9]*} $tag] } {
        # For an item, use the coords if it's a 4-list, else
        # use the bounding box shrunk by 2 in each direction
	set region [coords $tag]
	if { [llength $region] != 4 } {
	    set region [eval ::tycho::Rectangle::shrink [bbox $tag] 2]
	    set rectangular 0
    	}
    } else {
	# It's a tag, so first find matching items
	set match [find withtag $tag]
	
	# If there are none, return
	if { [llength $match] == 0 } {
	    return
	} elseif { [llength $match] == 1 } {
	    # If there's one item, process that
	    set region [coords $tag]
	    if { [llength $region] != 4 } {
		set region [eval ::tycho::Rectangle::shrink [bbox $tag] 2]
		set rectangular 0
	    }
	    set tag [lindex $match 0]
	} else {
	    # There are many items, so get the bounding box less 2
	    set region [eval ::tycho::Rectangle::shrink [$canvas bbox $tag] 2]
	    set rectangular 0
	}
    }

    # If no arguments are given, return the region
    if { $args == "" } {
	return $region
    } else {
	# Change the region to the newly-specified coordinates.
	if { $rectangular } {
	    # If there's one rectangular item, call coords{}
	    eval coords $tag $args
	} else {
	    # Otherwise figure out the scaling factors and call scale{}
	    ::tycho::assign x0 y0 x1 y1 $region
	    ::tycho::assign a0 b0 a1 b1 $args

	    set xscale [expr double($a1-$a0)/($x1-$x0)]
	    set yscale [expr double($b1-$b0)/($y1-$y0)]

	    scale $tag $a0 $b0 $xscale $yscale
	}
    }
}

#######################################################################
#### reshape
#
# Reshape an item by moving one or more of its aspects the specified
# distance. If the *-region* flag is specified, treat the item as
# a rectangular region.
#
body ::tycho::Slate::reshape {id x y args} {
    ::tycho::getflag region args

    # Get the proc and call it
    return [eval [shape $id reshape $region] $id $canvas $this $x $y $args]
}

#######################################################################
#### reshapeclick
#
# Start a reshape interaction sequence at coordinates
# (_x_, _y_). Additional arguments include various flags that may
# be supplied by the interactors that the slate uses to affect
# the behavior of items, such as *-ghost*, which says that an
# item is to be moved or reshaped using a "ghost" outline, and
# the aspects to be reshaped.
#
body ::tycho::Slate::reshapeclick {id x y args} {
    eval [shape $id reshapeclick] $id $canvas $this $x $y $args
}

#######################################################################
#### reshapedrag
#
# Continue a reshape interaction sequence with 
# (_x_, _y_) as the new cursor position. Additional
# arguments can be supplied but are _ignored_ -- this
# is simply to make it easy to implement constraints.
#
body ::tycho::Slate::reshapedrag {id x y args} {
    eval [shape $id reshapedrag] $id $canvas $this $x $y
}

#######################################################################
#### reshaperelease
#
# Terminate the interaction sequence at 
# coordinates (_x_, _y_), _x_ and _y_ will usually be the same as
# the last coordinates passed to the drag mode. Additional
# arguments can be supplied but are _ignored_ -- this
# is simply to make it easy to implement constraints.
#
body ::tycho::Slate::reshaperelease {id x y args} {
    eval [shape $id reshapedrag] $id $canvas $this $x $y
}

#######################################################################
#### reshapeto
#
# Move an aspect of an item to a specified location.
# The first argument can be a tag as long as it denotes only
# one item -- if it denotes more than one, an error is flagged.
#
# FIXME: add -region flag.
#
body ::tycho::Slate::reshapeto {tag x y aspect} {
    # Get the current location of the aspect
    if { ! [string match {[_0-9]*} $tag] } {
	# A tag is specified. See if there's just one item
	set items [find withtag $tag]
	if { [llength $items] == 0 } {
	    # No items, so just return
	    return
	} elseif { [llength $items] == 1 } {
	    # One item, so act as though that item was specified
	    set current [aspect [lindex $items 0] $aspect]
	} else {
	    # Multiple items, so flag an error
	    error "Cannot specify multiple items to reshapeto{}"
	}
    } else {
	# Just get the aspect of the item
	set current [$this aspect $tag $aspect]
    }

    # Reshape the item
    set x [expr $x - [lindex $current 0]]
    set y [expr $y - [lindex $current 1]]
    reshape $tag $x $y $aspect
}

#######################################################################
#### selection
#
# Manipulate the selection. This methods extends the canvas mechanism
# to allow multiple items to be selected. In particular, the "item"
# mode returns a list of selected items. Selected items are tagged with
# the tag "sel." Several new modes are added:
# <ul>
# <li><b>add</b> _tagorid_: Add the items specified by _tagorid_
# to the selection. If the selection is currently inside an item, that
# selection is cleared.
# <li><b>remove</b> _tagorid_: Remove the items specified by
# _tagorid_ from the selection.
# <li><b>describe</b>: Return a string describing the items
# in the selection.
# <li><b>exists</b>: Test if an item is in the selection.
# <li><b>claimsel</b>: Claim the X selection. For use by the Selector
# class only.
# </ul>
#
# Any command that changes the selection causes the slate to
# claim the X selection if the option *-exportselection* is true.
#
# FIXME: there is a small problem here: the add and remove modes
# will not in fact update the interactor bindings that are
# managed by the selector object. If called directly, this
# will result in incorrect behaviour.
#
body ::tycho::Slate::selection {mode {id {}} {index {}}} {
    switch -exact $mode {
	"clear" {
	    unhighlight "sel"
	    dtag "sel"
	    $canvas select clear
	    # Update interactor bindings
	    selector refresh
	}
	"item" {
	    set items [find withtag "sel"]
	    if { $items == "" } {
		return [$canvas select item]
	    } else {
		return $items
	    }
	}
	"exists" {
	    return [hastag $id sel]
	}
	"add" {
	    $canvas select clear
	    # Only add to the selection if it is not already
	    if { ! [hastag $id sel] } {
		addtag "sel" withtag $id
		highlight $id highlight.sel
	    }
	    # Update interactor bindings
	    selector refresh
	    claimSelection
	}
	"remove" {
	    unhighlight $id
	    dtag $id "sel"
	    # Update interactor bindings
	    selector refresh
	}
	"describe" {
	    set description ""
	    foreach item [find withtag "sel"] {
		append description [describe $item] "\n"
	    }
	    return $description
	}
	default {
	    error "Sorry, I think this is bogus"
            # eval chain $mode $id $index
	    # claimSelection
	}
    }
}

#######################################################################
#### selector
#
# Access the slate's selector interactor. If the slate does not
# have a selector, create it. With no arguments, return the
# selector interactor; with arguments, call the selector with
# the first argument as method name and remaining arguments as
# its arguments.
#
body ::tycho::Slate::selector {args} {
    # If there's no selector, create one. Note that some options
    # are given directly to the selector.
    if { ! [::info exists selector] } {
	set selector [interactor Selector]
    }

    # Return the selector or evaluate a command on it
    if { $args == "" } {
	return $selector
    } else {
    	uplevel #0 $selector $args
    }
}

#######################################################################
#### shape
#
# Return the "shape" of an item. The shape of an item
# value returned is a subset of the types.
# If an extra argument given, this method returns the proc to
# call that implements that method on the item's shape. A
# third argument, if present and true, causes the item to be treated
# as a rectangle regardless of its "real" shape.
#
body ::tycho::Slate::shape {id {method {}} {region 0}} {
    # First get the shape. If the -region flag is given,
    # treat the item as a rectangle
    if { $region } {
        set shape "rectangle"
    } elseif { [string match {[0-9]*} $id] } {
	set shape [$canvas type $id]
        # Text, image, and bitmap items are treated as a "point"
        if { [::tycho::lmember {text bitmap image} $shape] } {
            set shape point
        }
    } else {
	set shape [@scope ::tycho::$itemClass($id) [list set shape]]
    }

    # Return just the shape
    if { $method == "" } {
	return $shape
    } else {
	# If a method name is given, get the proc that implements it
	if { ! $region && [string match {_*} $id] && \
		[@scope ::tycho::$itemClass($id) \
		[list ::info exists methodtable($method)]] } {
	    # If the item is complex and the region flag is not given,
	    # get it from the complex item class
	    return [@scope ::tycho::$itemClass($id) \
		    [list set methodtable($method)]]
	} else {
	    # If we can't get it from the item class, then get it
	    # from the shape class
	    return ::tycho::[::tycho::capitalize $shape]::_$method
	}
    }
}

#######################################################################
#### unhighlight
#
# Delete highlights from all matching items.
#
body ::tycho::Slate::unhighlight {tag} {
    if { [string match {_*} $tag] } {
	# If it's a complex item and it has an unhighlight{} method,
	# call that
	if { [@scope ::tycho::$itemClass($tag) \
		[list ::info exists methodtable(unhighlight)]] } {
	    @scope ::tycho::$itemClass($tag) \
		    [list eval \[set methodtable(unhighlight)\] \
		    $tag $canvas $this]
	    return
    	}
    } elseif { ! [string match {[_0-9]*} $tag] } {
    	# It's a tag, so do for each item
    	foreach item [find withtag $tag] {
	    unhighlight $item
    	}
    	return
    }

    # If we get to here, tag represents a single item
    # Delete the highlight item
    $canvas delete highlight.$tag
}


#####################################################################
#####################################################################
####                     protected methods                       ####

#######################################################################
#### claimSelection
#
# Claim the X selection if *-exportselection* is enabled and the
# selection is not empty.
#
body ::tycho::Slate::claimSelection {} {
    if { $itk_option(-exportselection) && [select item] != "" } {
	::selection own -command "$this select clear" \
		[::info namespace tail $this]
    }
}
