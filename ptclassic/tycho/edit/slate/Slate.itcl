##########################################################################
# A canvas mega-widget for manipulating complex graphical items.
#
# @Version: $Id$
# @Author: H. John Reekie
#
# @Copyright (c) 1996 The Regents of the University of California.
# All rights reserved.
# 
# Permission is hereby granted, without written agreement and without
# license or royalty fees, to use, copy, modify, and distribute this
# software and its documentation for any purpose, provided that the above
# copyright notice and the following two paragraphs appear in all copies
# of this software.
# 
# IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY
# FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
# ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF
# THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.
# 
# THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE
# PROVIDED HEREUNDER IS ON AN "AS IS" BASIS, AND THE UNIVERSITY OF
# CALIFORNIA HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,
# ENHANCEMENTS, OR MODIFICATIONS.
#                                                         COPYRIGHTENDKEY
##########################################################################


#######################################################################
## slate pathName args
#
# Create a slate. This procedure creates a new widget, as
# recommended on the itk web pages. In addition to creating
# a new slate, this procedure changes the binding tags so
# that events on the canvas are intercepted by the slate.
#
proc ::tycho::slate {pathName args} {
    # Create the widget
    uplevel ::tycho::Slate $pathName $args

    # Muck about with the binding tags in order to make events
    # on the canvas appear to be on the mega-widget. The default
    # bindtags for the slate (say ".s") are:
    #
    #    itk-delete-.s .s Slate . all
    #
    # and for the canvas are:
    #
    #    itk-destroy-.s.canvas .s.canvas Canvas . all
    #
    # The following code changes the binding tags to:
    #
    #    itk-delete-.s Slate . all
    #
    # and:
    #
    #    itk-destroy-.s.canvas .s Canvas . all
    #
    # What this does is: a) make scripts bound to the _slate_ (.s)
    # be matched when an event occurs on the _canvas_; b) removes
    # the slate from its own binding tags so that scripts bound to
    # events like Enter, Leave, Configure don't get executed
    # twice twice.
    #
    # I don't what the itk-delete-.s and itk-destroy-.s.canvas
    # tags are for.
    set slatetags  [bindtags $pathName]
    set canvastags [bindtags [$pathName component canvas]]

    bindtags [$pathName component canvas] \
	    [lreplace $canvastags 1 1 [lindex $slatetags 1]]
    bindtags $pathName [lreplace $slatetags 1 1]

    return $pathName
}



#######################################################################
#### Slate
#
# The slate is a widget based on the Tk canvas that support "complex"
# items, each of which can contain many "simple" canvas items.
# All methods of the Slate can manipulate either simple or
# complex items more-or-less transparently.
#
# This is a total re-write of the earlier design. In this new design,
# complex items are not represented by [incr Tcl] objects, but by an
# associative array containing just enough information to allow
# hierarchical item construction and object-oriented-like
# item manipulation.
#
# In addition to the Slate class itself, there are a number of
# other classes that work with the slate to implement its full
# functionality. These classes are grouped into several categories,
# according to their function in the slate:
#
# <ul>
# <li><i>Picture</i> and subclasses.
# These classes implement the functionailty needed by the slate to 
# actually create complex items. Subclasses of Picture includes things
# like ``3D'' rectangles and
# polygons, and ``smart'' objects like self-routing lines.
#
# <li><i>Interactor</i> and subclasses. Interactors are objects that
# manage user interaction with the slate. Interactors provide a powerful
# mechanism for capturing and reusing standard patterns of interaction.
# </ul>
#
# To create a slate, do not call the constructor directly, but call
# the procedure <code>::tycho::slate</code>:
#
# <tcl><pre>
#     ::tycho::slate .s
#     pack .s -fill both -expand on
#     wm deiconify .
# </pre></tcl>
#
# The Slate class is designed to be fully compatible with the canvas,
# so some of the methods are less efficient than they could be.
# We are considering writing a second class which will provide a
# faster interface for code that doesn't need backwards compatibility.
#
class ::tycho::Slate {
    inherit ::tycho::TWidget

    constructor {args} {}
    destructor {}

    ###################################################################
    ####                         public methods                    ####

    # Add a tag to items using a search spec
    method addtag {add searchSpec args}

    # Get aspects of an item
    method aspect {id args}

    # Get the bounding box of one or more items
    method bbox {args}

    # Bind a command to an item or tag
    method bind {id {sequence {}} args}

    # Call a "method" on a complex item
    method call {id method args}

    # Convert a screen x coordinate into a canvas x coordinate
    method canvasx {screenx {gridspacing {}}}

    # Convert a screen y coordinate into a canvas y coordinate
    method canvasy {screeny {gridspacing {}}}

    # Set or get the coordinates of an item
    method coords {id args}

    # Access a component of an item
    method component {id args}

    # Create a new item
    method create {type args}

    # Delete characters
    method dchars {id first {last {}}} {
	eval $canvas dchars $id $first $last
    }

    # Delete items
    method delete {args}

    # Return a representation of an item
    method describe {id args}

    # Delete a tag from items
    method dtag {tag {tagToDelete {}}}

    # Find items according to a search spec
    method find {searchSpec args}

    # Focus on an item
    method focus {args} {
	eval $canvas focus $args
    }

    # Focus on the slate
    method focusin {}

    # Get the tags of an item
    method gettags {id}

    # Set the insertion cursor
    method icursor {id index} {
	$canvas icursor $id $index
    }

    # Return the numerical value of a symbolic index
    method index {id index} {
	$canvas index $id $index
    }

    # Insert text at the insertion cursor
    method insert {id beforeThis string} {
	$canvas insert $id $beforeThis $string
    }

    # Interact with items
    method interact {command item args}

    # Get a configuration option of an item
    method itemcget {id option}

    # Configure an item
    method itemconfigure {id args}

    # Lower an item
    method lower {id {belowThis {}}}

    # Move items
    method move {tag xAmount yAmount}

    # Move to an absolute location
    method moveto {tag x y {aspect center}}

    # Manipulate complex items
    method picture {mode args}

    # Generate postscript
    method postscript {args}

    # Raise an item
    method raise {id {aboveThis {}}}

    # Recreate an item from a description generated by describe{}
    method recreate {description args}

    # Set or get the rectangular "region" of the item
    method region {id args}

    # Scale an item
    method scale {id xOrigin yOrigin xScale yScale}

    # Scanning on an item
    method scan {option args} {
	eval $canvas scan $option $args
    }

    # Manipulate the selection
    method select {option {id {}} {index {}}} {
	eval $canvas select $option $id $index
    }

    # Return the item type
    method type {id args}

    # Set the horizontal view for scrolling
    method xview {args}

    # Set the vertical view for scrolling
    method yview {args}


    ###################################################################
    ####                   protected variables                     ####

    # The canvas on which I draw
    protected variable canvas


    ###################################################################
    ####                     private methods                       ####
    
    # Give an item a new parent
    private method adopt {parent id}

    # Test id an item is an ancestor of another
    private method ancestor {ancestor descendent}

    # Return the children of an item or complex item
    private method children {id}

    # Return the ancestors of an item or complex item
    private method ancestors {id}

    # Return the items only under this item or complex item
    private method items {id}

    # Make an item have no parent
    private method orphan {id}

    # Return the "owner" of an item -- the parent if there is one,
    # else the item.
    private method owner {id}

    # Return the parent of an item or complex item
    private method parent {id}

    # Return the root of an item or complex item
    private method root {id}

    # Add a tag to items and complex items
    private method tagadd {tag args}


    ###################################################################
    ####                    private variables                      ####

    # Unique IDs and tags are created using this counter.
    # Note: this must be common so item ids are unique across 
    # all slates!
    private common secretcounter 0

    # Every complex item remembers its parent
    private variable parent

    # Each item has a "type"
    private variable itemtype

    # Each tag belongs to one or more items
    private variable tagged

    # Storage for temporary variables
    private variable scratch
}


#######################################################################
#### constructor
#
# Do not call the constructor of the Slate directly: _always_
# use the procedure ::tycho::slate{}.
#
body ::tycho::Slate::constructor {args} {
    # Create the canvas and pack it
    itk_component add canvas {
	# Create at the global scope to avoid calls to unknown{}
	uplevel #0 canvas $itk_interior.canvas
    } {
	keep -background -cursor -relief \
		-height -width -borderwidth \
		-xscrollcommand -yscrollcommand \
		-scrollregion
    }
    pack $itk_component(canvas) -fill both -expand yes

    # Keep a pointer to the canvas to save typing
    set canvas $itk_component(canvas)

    # Give the focus to the canvas when the slate gets mapped. This
    # is convenient for simple applications. For explicit focus
    # management, use the focusin{} method.
    ::bind $canvas <Map> "focus $canvas"

    # Initialise some things
    set slatetags() {{}}

    # Initialise options
    eval itk_initialize $args
}

#######################################################################
#### addtag
#
# Add a tag to specified items. Uses find{} to get all relevent
# items, and then tags them; optimized for some special cases.
#
body ::tycho::Slate::addtag {add mode args} {
    switch -exact $mode {
	"withtag" {
	    set tag [lindex $args 0]

	    if { $tag == "all" || $tag == "current" } {
		eval $this tagadd $add [eval $this find withtag $tag]

	    } elseif { [string match {[0-9]*} $tag] } {
		# Hey, this is just an item ID
		$canvas addtag $add withtag $tag

	    } elseif { [string match {_*} $tag] } {
		# Hey, this is just a complex item ID
		$canvas addtag $add withtag $tag

		if { ! [::info exists tagged($add)] } {
		    set tagged($add) [list $tag]
		} elseif { ! [lmember $tagged($add) $tag] } {
		    lappend tagged($add) $tag
		}
	    } else {
		# It really is a tag..
		$canvas addtag $add withtag $tag
		if { [::info exists tagged($tag)] } {
		    if { ! [::info exists tagged($add)] } {
			set tagged($add) $tagged($tag)
		    } else {
			set tagged($add) [lunion $tagged($add) $tagged($tag)]
		    }
		}
	    }
	}
	default {
	    eval $this tagadd $add [eval $this find $mode $args]
	}
    }
}

#######################################################################
#### aspect
#
# Return the value of one or more "aspects" of an item. An aspect
# is a point on the complex item, such as its center or north-east corner.
# The returned value is a list of coordinates, two (x and y) for each
# given aspect.
#
# The aspects supported depends on the type (or more specifically,
# the shape type -- see the type{} method) of the complex item. Some
# item types will support a more complex set of aspects. If the
# complex item is rectangular, is supports at least the aspects _c_ or
# _center_, and the eight compass
# points: _n_, _s_, _e_, _w_, _ne_, _nw_, _se_, and _sw_. If the
# *-region* option is given, these aspects will be assumed regardless
# of the complex item's actual shape, and will denote the corners
# of the complex item's _region_ (see the region{} method).
#
# If there are no arguments, return the list of valid aspects for
# this complex item.
#
body ::tycho::Slate::aspect {id args} {
    getflag region args

    # If the -region flag is given, treat the complex item as a rectangle
    if { $region } {
	if { $args == "" } {
	    return {c n s e w ne nw se sw}
	} else {
	    return [eval rectAspect [list [$this region $id]] $args]
	}
    }

    # If this is a complex item, and there's a method defined for it,
    # call the method
    if { [string match {_*} $id] } {
	if { [@scope ::tycho::$itemtype($id) [list \
		::info exists methodtable(aspect)]] } {
	    return [@scope ::tycho::$itemtype($id) [list \
		    eval \[set methodtable(aspect)\] $id $canvas $this $args]]
	}
    }

    # There's no method defined or this is a canvas item,
    # so process according to the shape type of the item
    if { [string match {[0-9]*} $id] } {
	set shape [$canvas type $id]
    } else {
	set shape [@scope ::tycho::$itemtype($id) [list set shape]]
    }
    switch -exact $shape {
	"oval" -
	"rectangle" {
	    if { $args == "" } {
		return {c n s e w ne nw se sw}
	    } else {
		return [eval \
			rectAspect [list [$this coords $id]] $args]
	    }
	}
	"line" -
	"polygon" {
	    if { $args == "" } {
		# Generate the legal aspects
		set result {}
		foreach n [interval 0 \
			[expr [llength [$this coords $id]] / 2 - 1]] {
		    lappend result "vertex-$n"
		}
		return $result
	    } else {
		return [eval \
			lineAspect [list [$this coords $id]] $args]
	    }
	}
	"text" -
	"point" {
	    if { $args == "" } {
		# Generate the legal aspects
		return "origin"
	    } else {
		return [$this coords $id]
	    }
	}
	default {
	    error "Unsupported item shape $shape"
	}
    }
}

#######################################################################
#### bbox
#
# Return the bounding box of any number of items, as a four-list. Each
# argument can be an item or a tag. If there are no
# items matching the tags, return the null string -- the caller must
# check for this condition. (This behavior matches that of the canvas).
#
body ::tycho::Slate::bbox {args} {
    eval $canvas bbox $args
}

#######################################################################
#### bind
#
# Bind a command to an item, complex item, or tag. The command accepts the 
# following argument formats:
#
# <ul>
# <li>_tagOrID_: Return the events for which _tagOrID_ has a binding.
# <li>_tagOrID_ _event_: Return the binding on _tagOrID_ for _event_.
# <li>_tagOrID_ _event_ _command_: Bind _command_ to the _tagOrID_
# for _event_
# </ul>
#
# <b>Caveat</b>: The bind{} command dpes not work properly on
# hierarchical complex items yet. There are
# some interactions with canvas bindings, multiple bindings on the
# same tag/object, and hierarchical complex items that need to be
# explored and clarified.
#
body ::tycho::Slate::bind {tag {sequence {}} args} {
    if { $sequence == "" } {
	return [$canvas bind $tag]
    } elseif { $args == {} } {
	return [$canvas bind $tag $sequence]
    } else {
	$canvas bind $tag $sequence [lindex $args 0]
    }
}

#######################################################################
#### call
# Call a "method" on an item. This just looks up the method in
# the global "virtual function table" and calls it.
#
# In the Slate code itself, this method is called in non-critical
# situations; in time-critical situations, the (very obscure)
# code here is "in-lined."
#
body ::tycho::Slate::call {id method args} {
    @scope ::tycho::$itemtype($id) [list \
	    eval \[set methodtable($method)\] $id $canvas $this $args]
}

#######################################################################
#### canvasx
#
body ::tycho::Slate::canvasx {screenx {gridspacing {}}} {
    eval $canvas canvasx $screenx $gridspacing
}

#######################################################################
#### canvasy
#
body ::tycho::Slate::canvasy {screeny {gridspacing {}}} {
    eval $canvas canvasy $screeny $gridspacing
}

#######################################################################
#### component
#
# Access a component of a complex item. Items only support components
# if they have been explicitly declared as such in the "components"
# variable in the complex item class.
#
# With one argument, return the names of the components of this
# complex item. With two arguments, return the specified component. With
# more than two arguments, call the specified method on the
# component and return its result.
#
# Since this method shadows the default itk method of the same name,
# this one checks for the argument "canvas" and returns the canvas
# name if it matches -- using component to access the canvas inside
# the slate thus still works as expected.
#
# <b>Note</b>: The first argument cannot be an arbitrary tag.
#
# FIXME: The bulk of this method should probably be moved into the
# Picture class.
#
body ::tycho::Slate::component {id {component {}} {method {}} args} {
    # Check for "component canvas"
    if { $id == "canvas" } {
	return $canvas
    }

    # If there's a component method on the complex item, just call that
    if { [@scope ::tycho::$itemtype($id) \
	    [list ::info exists methodtable(component)]] } {
	set component [@scope ::tycho::$itemtype($id) \
		[list eval \[set methodtable(component)\] \
		$id $canvas $this $component]]
    } else {
	# Check for no component arg
	if { $component == "" } {
	    return [@scope ::tycho::$itemtype($id) [list set components]]
	}

	# Check for a valid component
	if { ! [@scope ::tycho::$itemtype($id) \
		[list ::info exists components]] \
		|| ! [lmember [@scope ::tycho::$itemtype($id) \
		[list set components]] $component] } {
	    error "unknown component $component"
	}

	# Finally, read its value
	if { [@scope $itemtype($id) \
		[list ::info exists [set component]($id)]] } {
	    set component [@scope $itemtype($id) \
		    [list [set [set component]($id)]]]
	} else {
	    set component {}
	}
    }

    # Call a method on the component
    # FIXME: Should this deal with multiple items returned?
    if { $method == {} } {
	return $component
    } else {
	return [eval $this $method $component $args]
    }
}

#######################################################################
#### coords
#
# Get or set the coordinates of an item. If the argument
# is a tag, perform this operation on the first item on the
# slate returned by `find withtag'.
#
body ::tycho::Slate::coords {id args} {
    # If this is a canvas item, call the canvas
    if { [string match {[0-9]*} $id] } {
	eval $canvas coords $id $args
    } elseif { [string match {_*} $id] } {
	# Call the complex item's coords method
	@scope ::tycho::$itemtype($id) [list \
		eval \[set methodtable(coords)\] $id $canvas $this $args]
    } else {
	# It's a tag, so get the first matching item and process that
	set items [$this find withtag $id]
	if { $items == "" } {
	    return ""
	}
	set id [lindex $items 0]
	if { [string match {[0-9]*} $id] } {
	    eval $canvas coords $id $args
	} elseif { [string match {_*} $id] } {
	    @scope ::tycho::$itemtype($id) [list \
		    eval \[set methodtable(coords)\] $id $canvas $this $args]
	}
    }
}

#######################################################################
#### create
#
# Create an item. If the _type_ arg starts
# with a lower-case letter, create an item; if not, create a
# complex item. In either case, _args_ is the coordinates
# and options used to create the complex item. See the canvas documentation
# for primitive canvas items; see the
# <a> href="../../../complex items/doc/codeDoc/index.html"><b>complex items</b></a>
# hierarchy for complex items implemented by the slate.
# If the options include <code>-tag</code> with
# tags returned by calling <code>gettags</code> on a complex item, the new 
# item will be added to that complex item.
#
body ::tycho::Slate::create {type args} {
    if { [string match {[a-z]*} $type] } {
	# Create a canvas item; tags determine nesting (if any)
	eval $canvas create $type $args

    } else {
	# Create a complex item. Tags determine nesting.

	# Get the unique id
	set id _$secretcounter
	incr secretcounter

	# Remember the complex item-type mapping
	set itemtype($id) $type

	# Add the complex item id tag to the tags. If there's a parent
	# then remember it.
	set indx [lsearch -exact $args -tags]
	if { $indx != -1 } {
 	    set tags [lsort [lindex $args [expr $indx+1]]]
 	    set args [lreplace $args $indx [expr $indx+1]]

	    # The tags are sorted: the owner tag must be first,
	    # followed by hierarchy tags, then user tags.
	    if { [string match {!*} [lindex $tags 0]] } {
		set parent($id) [string range [lindex $tags 0] 1 end]
		set tags [lreplace $tags 0 0 !$id $id]
	    } else {
		set parent($id) ""
		set tags [concat !$id $id $tags]
	    }
	    # Remember "user" tags
	    set tidx [lsearch -regexp $tags {^[^!_]}]
	    if { $tidx != -1 } {
		foreach t [lrange $tags $tidx end] {
		    lappend tagged($t) $id
		}
	    }
	} else {
	    set parent($id) ""
	    set tags [list !$id $id]
	}

	# Create the complex item by calling the construct{} proc. This
	# is OK, since every complex item must have a constructor, and also
	# guarantees that auto-loading will work.
	eval ::tycho::$type::construct $id $canvas $this [list $tags] $args

	# Make sure the name is returned
	return $id
    }
}


#######################################################################
#### delete
#
body ::tycho::Slate::delete {args} {
    foreach id $args {
	if { [string match {[0-9]*} $id] } {
	    # Delete a canvas item
	    $canvas delete $id
	} elseif { [string match {_*} $id] } {
	    # Delete a complex item. First remember its tags.
	    set tags [$canvas gettags \
		    [@scope ::tycho::$itemtype($id) \
		    [list set primary($id)]]]

	    # Filter out hierarchy tags. Boy, this is kludgy...
	    set temp $tags
	    set tags {}
	    foreach t $temp {
		if { ! [string match {[!_]*} $t] } {
		    lappend tags $t
		}
	    }
	    
	    # First call its destruct method
	    @scope ::tycho::$itemtype($id) [list \
		    eval \[set methodtable(destruct)\] $id $canvas $this]

	    # Then remove all items
	    $canvas delete $id

	    # Then forget it
	    unset itemtype($id)
	    unset parent($id)
	    foreach t $tags {
		set tagged($t) [ldelete $tagged($t) $id]
	    }
	} else {
	    # Delete by tag: call myself again for simplicity
	    eval $this delete [$this find withtag $id]
	}
    }
}

#######################################################################
#### describe
#
# Return a description of an item on the canvas. This description will
# be understood by recreate{} so that the item can be recreated or
# duplicated later in various forms. <i>Do not make any assumptions
# about the contents of the string returned by this method.</i>
#
# Note: If saving the description for later recreation, you may also need
# to save other information about the complex item, such as its type
# or whether it has certain tags that affect how you will recreate it.
#
# describe{} accepts the following optional arguments:
# <ul>
# <li>*-hierarchical*: Return a description of all child complex items as well.
# <li>*-constraints*: Include all constraints in the description.
# </ul>
#
# FIXME: *-hierarchical* and *-constraints* options do nothing.
#
body ::tycho::Slate::describe {id args} {
    # Create a "lambda" script with slate as argument
    set description {lambda slate -> $slate create}

    # Item type
    lappend description [$this type $id]

    # Coordinates
    set description [concat $description [$this coords $id]]

    # Add options only if they differ from the default. The -tags
    # options is treated specially, to filter out hierarchy tags.
    foreach {option x y default value} \
	    [eval concat [$this itemconfigure $id]] {
	if { $option == "-tags" } {
	    set tags {}
	    foreach tag $value {
		if { ! [string match {[!_]*} $tag] } {
		    lappend tags $tag
		}
	    }
	    if { $tags != "" } {
		lappend description -tags $tags
	    }
	} elseif { $default != $value } {
	    lappend description $option $value
	}
    }

    # Return 
    return $description
}

#######################################################################
#### dtag
#
# Delete tags from items. If _delete_ is not given, delete _tag_
# from all items; if it is, delete the tag _delete_ from all
# items tagged with _tag_.
# 
body ::tycho::Slate::dtag {tag {delete {}}} {
    if { [string match {[0-9]*} $tag] } {
	# A canvas item.
	eval $canvas dtag $tag $delete
    } elseif { [string match {_*} $tag] } {
	# A complex item. Make sure _delete exists.
	if { $delete != "" } {
	    set tagged($delete) [ldelete $tagged($delete) $tag]
	    $canvas dtag $tag $delete
	}
    } else {
	# Doing it by tag..
	if { $delete == "" } {
	    set delete $tag
	}
	$canvas dtag $tag $delete
	if { [::info exists tagged($delete)] } {
	    set tagged($delete) [lsubtract $tagged($delete) $tagged($tag)]
	}
    }
}

#######################################################################
#### find
#
# Find a items, as given by _searchSpec_. The argument
# formats are the same as for the Tk canvas; however, because of
# hierarchy, the behavior for the different search modes differ
# from each other. As a general rule, the slate does not
# attempt to deal with hierarchy, but blindly returns a set of
# complex items and items -- the caller must eliminate unwanted parents
# or children explicitly (see the <i>complex item</i> method).
# The following argument formats are supported:
#
# <ul>
# <li><b>above</b> _id_: Return the complex item immediately above
# _id_. Currently, this will not work if _id_ is a tag.
#
# <li><b>all</b>: Return every _root_ complex item, and every
# item that is not a component of a complex item.
#
# <li><b>below</b> _id_: Return the complex item immediately below
# _id_. Currently, this will not work if _id_ is a tag.
#
# <li><b>closest</b> _x y ?halo? ?start?_: Return the complex item
# closest to the point _(x,y)_. Currently, this mode is not
# working correctly.
#
# <li><b>enclosed</b> _x0 x1 y0 y1_: Return every complex item and
# unparented item enclosed by the given region.
#
# <li><b>overlapping</b> _x0 x1 y0 y1_: Return every complex item and
# unparented item that overlaps the given region.
#
# <li><b>withtag</b> _tag_: Return every complex item and every item
# with the given tag. (In the case of items, this means items that
# were explicitly tagged, rather than implicitly as a result of being
# a component of a complex item with that tag.)
#
# The _tag_ can also be
# ``current,''  in which case either a) the current item is
# returned if that item is not a component; or b) the parent
# of the current item is returned.
#
# </ul>
#
body ::tycho::Slate::find {mode args} {
    switch -exact $mode {
	"above" {
	    # Get the passed item/id as a complex item if possible
	    set id [$this owner [lindex $args 0]]
	    
	    # Get the item above it and return its owner
	    set id [$canvas find above $id]
	    if { $id == "" } {
		return ""
	    } else {
		return [$this owner $id]
	    }
	}
	"all" {
	    # Find top-level complex items
	    set complexitems {}
	    foreach p [array names parent] {
		if { $parent($p) == "" } {
		    lappend complexitems $p
		}
	    }

	    # Tag top-level complex items
	    $canvas addtag temp all
	    foreach id $complexitems {
		$canvas dtag $id temp
	    }
	    set canvasitems [$canvas find withtag temp]
	    $canvas dtag temp

	    # Return canvas items and complex items
	    return [concat $canvasitems $complexitems]
	}
	"below" {
	    # Get the passed item/id as a complex item if possible
	    set id [$this owner [lindex $args 0]]
	    
	    # Get the item below it and return its owner
	    set id [$canvas find below $id]
	    if { $id == "" } {
		return ""
	    } else {
		return [$this owner $id]
	    }
	}
	"closest" {
	    set x [lindex $args 0]
	    set y [lindex $args 1]

	    set item [lindex [$canvas find closest $x $y] 0]

	    return [$this owner $item]
	}
	"enclosed" {
	    # Find enclosed canvas items
	    set canvasitems [eval $canvas find enclosed $args]

	    # For each, find out whether the owner is also fully
	    # enclosed by looking at its region. If it is, include
	    # it in the result list, and process its parent.
	    set result {}
	    while { $canvasitems != "" } {
		set canvasitem [lindex $canvasitems 0]
		set complexitem [$this owner $canvasitem]
		if { [string match {[0-9]*} $complexitem] } {
		    # It's a top-level canvas item, so include it
		    lappend result $canvasitem
		    set canvasitems [lreplace $canvasitems 0 0]
		} else {
		    if { [rectInside [$this region $complexitem] $args] } {
			set result [lsetadd $result $complexitem]
			while { $parent($complexitem) != "" } {
			    set complexitem $parent($complexitem)
			    if { [rectInside [$this region $complexitem] $args] } {
				set result [lsetadd $result $complexitem]
			    } else {
				break
			    }
			}
		    }
		    set canvasitems [lsubtract $canvasitems \
                            [$canvas find withtag $complexitem]]
		}
	    }
	    return $result
	}
	"overlapping" {
	    # Find overlapping canvas items
	    set canvasitems [eval $canvas find overlapping $args]

	    # Find the set of owners
	    set complexitems {}
	    foreach i $canvasitems {
		set complexitems [lsetadd $complexitems [$this owner $i]]
	    }

	    # For each owner, include all ancestors
	    foreach p $complexitems {
		if { [string match {_*} $p] } {
		    set complexitems [lunion $complexitems [$this ancestors $p]]
		}
	    }
	    return $complexitems
	}
	"withtag" {
	    set tag [lindex $args 0]

	    if { $tag == "all" } {
		return [$this find all]

	    } elseif { $tag == "current" } {
		set current [$canvas find withtag current]
		if { $current == "" } {
		    return {}
		}

		set par [$this parent $current]
		if { $par == "" } {
		    return $current
		} else {
		    return $par
		}
	    } elseif { [string match {[0-9]*} $tag] \
		    || [string match {_*} $tag] } {
		# Hey, this is really just an item ID
		return $tag

	    } else {
		# Get unparented items with this tag
		$canvas addtag temp withtag $tag
		if { [::info exists tagged($tag)] } {
		    set complexitems $tagged($tag)
		} else {
		    set complexitems {}
		}
		foreach id $complexitems {
		    $canvas dtag $id temp
		}
		set canvasitems [$canvas find withtag temp]
		$canvas dtag temp

		# Return canvas items and complex items
		return [concat $canvasitems $complexitems]
	    }
	}
    }
}

#######################################################################
#### focusin
#
# Put the focus into the canvas. This is needed for explicit
# focus control: there seems to be no way to detect that the
# focu{} command has been called with a megawidget as an
# argument, so instead of calling
# <pre>
#     focus $slate
# </pre>
# you need to call
# <pre>
#     $slate focusin
# </pre>
#
body ::tycho::Slate::focusin {} {
    uplevel #0 "focus $canvas"
}

#######################################################################
#### gettags
#
# Returns the tags of an item. The slate does not
# attempt to hide its internal tags, so they are all returned by
# this method in addition to any "user-specified" tags. If the argument
# is a tag, perform this operation on the first item on the
# slate returned by `find withtag'.
#
body ::tycho::Slate::gettags {id} {
    # If a tag, get the first matching item
    if { ! [string match {[_0-9]*} $id] } {
	set items [$this find withtag $id]
	if { $items == "" } {
	    return ""
	}
	set id [lindex $items 0]
    }
    # If a complex item, get the primary
    if { [string match {_*} $id] } {
	set id [@scope ::tycho::Picture [list set primary($id)]]
    }
    $canvas gettags $id
}

#######################################################################
#### interact "create" class [options]
#### interact "click" id x y [options]
#### interact "drag" id x y
#### interact "release" id
#
body ::tycho::Slate::interact {command id args} {
    switch -exact $command {
	"create" {
	    # Create an interactor
	    set interactor [::info context]::[eval ::tycho::$id #auto \
		    [::info namespace tail $this] $canvas $args]

	    # Return it
	    return $interactor
	}
	"click" {
	    # Remember where we started
	    set x [lindex $args 0]
	    set y [lindex $args 1]

	    set scratch($id.prevX) $x
	    set scratch($id.prevY) $y

	    # If the -ghost option is specified, create the ghost
	    if { [lsearch -exact $args -ghost] != -1 } {
		set scratch($id.ghost) [$this call $id ghost]
		set scratch($id.start) [$this coords $scratch($id.ghost)]
	    }
	}
	"drag" {
	    set x [lindex $args 0]
	    set y [lindex $args 1]

	    # If there's a ghost, move it. else move the complex item.
	    if { [::info exists scratch($id.ghost)] } {
		set movethis $scratch($id.ghost)
	    } else {
		set movethis $id
	    }

	    # Move is a delta operation.
	    $this move $movethis \
		    [expr $x - $scratch($id.prevX)] \
		    [expr $y - $scratch($id.prevY)]

	    # Remember the new position
	    set scratch($id.prevX) $x
	    set scratch($id.prevY) $y
	}
	"release" {
	    # If there's a ghost, move the complex item to its position and then
	    # delete it
	    if { [::info exists scratch($id.ghost)] } {
		assign x y $scratch($id.start)
		assign a b [$this coords $scratch($id.ghost)]

		$this move $id [expr $a - $x] [expr $b - $y]
		$this delete $scratch($id.ghost)

		unset scratch($id.ghost)
		unset scratch($id.start)
	    }

	    # Clean up
	    unset scratch($id.prevX)
	    unset scratch($id.prevY)
	}
    }
}

##########################################################################
#### itemcget
#
# Read a configuration option.  If the argument
# is a tag, perform this operation on the first item on the
# slate returned by `find withtag'.
#
body ::tycho::Slate::itemcget {id option} {
    if { [string match {[0-9]*} $id] } {
	# If this is a canvas item, just call the canvas
	return [$canvas itemcget $id $option]

    } elseif { ! [string match {_*} $id] } {
	# It's a tag, so get the first matching complex item
	set items [$this find withtag $id]
	if { $items == "" } {
	    return ""
	}
	set id [lindex $items 0]
	if { [string match {[0-9]*} $id] } {
	    # In the end, it's a canvas item
	    return [$canvas itemcget $id $option]
	}
    }

    # If we get to here, id must be a complex item
    if { ! [string compare $option -tags] } {
	# Return the tags of this complex item using the primary
	return [$canvas gettags \
		[@scope ::tycho::$itemtype($id) [list set primary($id)]]]

    } elseif { [@scope ::tycho::$itemtype($id) \
	    [list ::info exists optiondefault($option)]] } {
	# Read the value directly from the class
	return [@scope ::tycho::$itemtype($id) \
		[list set _[string trimleft $option -]($id)]]
    } else {
	error "unknown option $option"
    }
}

#######################################################################
#### itemconfigure
#
# Set configuration option. If the argument
# is a tag, perform this operation on the first item on the
# slate returned by `find withtag'.
#
# Note also that dtag{}, gettags{}, and addtag{} are faster (and safer)
# ways of manipulating tags and should be used in preference to
# itemcget{} and itemconfigure{}.
#
body ::tycho::Slate::itemconfigure {id args} {

    # If this is an item, just call the canvas
    if { [string match {[0-9]*} $id] } {
	return [eval $canvas itemconfigure $id $args]
    } elseif { ! [string match {_*} $id] } {
	# It's a tag, so get the first matching complex item
	set items [$this find withtag $id]
	if { $items == "" } {
	    return ""
	}
	set id [lindex $items 0]
	if { [string match {[0-9]*} $id] } {
	    # In the end, it's a canvas item
	    return [eval $canvas itemconfigure $id $args]
	}
    }
    
    # If we get to here, the id represents a complex item
    if { [llength $args] == 0 } {
	# We've been asked for all configuration values. Use
	# the defaultoptions array to get the names of all options,
	# and read their values.
	set result {}
	foreach option [@scope ::tycho::$itemtype($id) \
		{array names optiondefault}] {
	    # Read its value
	    set value [@scope ::tycho::$itemtype($id) \
		    [list set _[string trimleft $option -]($id)]]
	    # Read default value
	    set default [@scope ::tycho::$itemtype($id) \
		    [list set optiondefault($option)]]
	    # Add to result
	    lappend result [list $option {} {} $default $value]
	}
	# Add the tags
	lappend result [list -tags {} {} {} \
		[$canvas gettags \
		[@scope ::tycho::$itemtype($id) [list set primary($id)]]]]

	return $result

    } elseif { [llength $args] == 1 } {
	set option [lindex $args 0]
	if { [@scope ::tycho::$itemtype($id) \
		[list ::info exists optiondefault($option)]] } {
	    # Read its value
	    set value [@scope ::tycho::$itemtype($id) \
		    [list set _[string trimleft $option -]($id)]]
	    # Read default value
	    set default [@scope ::tycho::$itemtype($id) \
		    [list set optiondefault($option)]]
	    
	    return [list $option {} {} $default $value]

	} else {
	    error "unknown option \"$option\""
	}
    } else {
	foreach {option value} $args {
	    if { ! [string compare $option -tags] } {
		# Set the tags of the complex item. Figure out the differences.
		set tags [$canvas gettags \
			[@scope ::tycho::$itemtype($id) \
			[list set primary($id)]]]

		# Filter out hierarchy tags. Boy, this is kludgy...
		set temp $tags
		set tags {}
		foreach t $temp {
		    if { ! [string match {[!_]*} $t] } {
			lappend tags $t
		    }
		}

		set new [lsubtract $value $tags]
		set old [lsubtract $tags $value]

		# Delete old tags, add new tags
		foreach t $old {
		    $canvas dtag $id $t
		    set tagged($t) [ldelete $tagged($t) $t]
		}
		foreach t $new {
		    $canvas addtag $t withtag $id
		    lappend tagged($t) $id
		}
	    } else {
		# Call the proc on the class to set the option
		if { [@scope ::tycho::$itemtype($id) \
			[list ::info exists optiondefault($option)]] } {
		    $this call $id _[string trimleft $option -] $value
		} else {
		    error "unknown option \"$option\""
		}
	    }
	}
    }
}

#######################################################################
#### lower
#
# Lower the specified complex items to the bottom of the display
# list. If _belowThis_ is specified, then lower below that item,
# or if _belowThis_ is a tag, then lower below the first item
# with that tag.
#
# FIXME: I am by no means certain that this works correctly!
#
body ::tycho::Slate::lower {id {belowThis {}}} {
    # We have to intercept the "current" tag since it applies
    # only to a canvas item, not a complex item
    if { $id == "current" } {
	set id [$this find withtag current]
    }

    if { $belowThis == "" } {
	$canvas lower $id
    } elseif { [string match {[_0-9]*} $belowThis] } {
	# Got an item, so use it
	$canvas lower $id $belowThis
    } else {
	# Got a id, so use the first matching item
	set items [$this find withtag $belowThis]
	if { $items == "" } {
	    $canvas lower $id
	} else {
	    $canvas lower $id [lindex $items 0]
	}
    }
}

#######################################################################
#### move
#
# Move one or more items the specified amount. The first argument
# can either be a tag or an id.
#
body ::tycho::Slate::move {tag xAmount yAmount} {
    $canvas move $tag $xAmount $yAmount
}

#######################################################################
#### moveto
#
# Move one or more complex items to an absolute location. The point
# of the complex item that is moved to the specified location is
# specified by the fourth argument, the aspect. If omitted, this
# argument defaults to center.
#
# If a tag is specified and the tag denotes more than one complex item,
# then the complex items are moved so that the indicated point on the
# region covered by those complex items is at the specified location.
#
body ::tycho::Slate::moveto {tag x y {aspect center}} {
    # Get the current location of the aspect
    if { ! [string match {[!_]*} $tag] } {
	# A tag is specified. See if there's just one item
	set items [$this find withtag $tag]
	if { [llength $items] == 1 } {
	    # it is, so act as though that item was specified
	    set current [$this aspect $items $aspect]
	} else {
	    # it wasn't so use the region
	    # FIXME: Use the region, not the bounding box
	    set current [rectAspect [$this bbox $tag]]
	}
    } else {
	# Just get the aspect of the item
	set current [$this aspect $tag $aspect]
    }

    # Move the item
    set x [expr $x - [lindex $current 0]]
    set y [expr $y - [lindex $current 1]]
    $canvas move $tag $x $y
}

#######################################################################
#### picture
# Manipulate complex items. This is a "safe" interface to some of the
# complex item manipulation methods used within the slate.
#
# <b>Note</b>: The functionality of the method is still evolving,
# and much of it may end up in other methods, such as component{}.
#
body ::tycho::Slate::picture {command args} {
    switch -exact $command {
	"adopt" {
	    eval $this adopt $args
	}
	"ancestor" {
	    eval $this ancestor $args
	}
	"ancestors" {
	    eval $this ancestors $args
	}
	"children" {
	    eval $this children $args
	}
	"items" {
	    eval $this items $args
	}
	"orphan" {
	    eval $this orphan $args
	}
	"owner" {
	    eval $this owner $args
	}
	"parent" {
	    eval $this parent $args
	}
	"root" {
	    eval $this root $args
	}
    }
}

#######################################################################
#### postscript
#
body ::tycho::Slate::postscript {args} {
    eval $canvas postscript $args
}

#######################################################################
#### raise
#
# Raise the specified complex items to the top of the display
# list. If _aboveThis_ is specified, then raise above that item,
# or if _aboveThis_ is a tag, then raise above the first item
# with that tag.
#
# FIXME: I am by no means certain that this works correctly!
#
body ::tycho::Slate::raise {id {aboveThis {}}} {
    # We have to intercept the "current" tag since it applies
    # only to an item, not a complex item
    if { $id == "current" } {
	set id [$this find withtag current]
    }

    if { $aboveThis == "" } {
	$canvas raise $id
    } elseif { [string match {[_0-9]*} $aboveThis] } {
	# Got an item, so use it
	$canvas raise $id $aboveThis
    } else {
	# Got a tag, so use the first matching item
	set items [$this find withtag $aboveThis]
	if { $items == "" } {
	    $canvas raise $id
	} else {
	    $canvas raise $id [lindex $items 0]
	}
    }
}

#######################################################################
#### recreate
#
# Re-create a complex item from a description returned by describe{}.
# By default, the complex item will be created in exactly the same
# position as when describe was called, and without any hierarchy.
# A number of options can modify this behavior (these options do not
# have to be used, but are really just short-cuts to save other calls:
# <ul>
# <li>*-move* _x y_: Move the new complex item relative to the described
# potision.
# <li>*-at* _x y_ ?_aspect_?: Place the given _aspect_ at (_x_,_y_).
# The aspect default to center.
# <li>*-coords* _x0 y0_ ...: Use these coordinates instead of the ones
# given by the description.
# <li>*-in* _id_: Make the complex item a child of the complex item _id.
# </ul>
#
# *-move*, *-at* and *-coords* are mutually exclusive.
#
body ::tycho::Slate::recreate {description args} {
    # What we'll do is just create the item in the default mode,
    # and then move or tag it there are options for doing so.
    # This could be made a fair bit more efficient by modifying the
    # description string _before_ applying it
    set id [apply $description $this]

    # -move option
    set move [readoption move args]
    if { $move != "" } {
	$this move $id [lindex $move 0] [lindex $move 1]
    } else {
	# -at option
	set at [readoption at args]
	if { $at != "" } {
	    if { [llength $at] > 2 } {
		set aspect [lindex $at 2]
	    } else {
		set aspect center
	    }
	    $this moveto $id [lindex $at 0] [lindex $at 1] $aspect
	} else {
	    # -coords option
	    set coords [readoption coords args]
	    if { $coords != "" } {
		eval $this coords $id $coords
	    }
	}
    }

    # -in option
    set in [readopt in args]
    if { $in != "" } {
	$this itemconfigure $id \
		-tags [lunion [$this gettags $id] [$this gettags $in]]
    }

    return $id
}


#######################################################################
#### region
#
# FIXME: Not working yet.
#
# FIXME: Be sure to give Picture classes the chance to override.
#
body ::tycho::Slate::region {id args} {
    # If there are no arguments, just read the region.
    if { $args == "" } {
	# For a canvas item, use the coords if it's a 4-list, else
	# use the bounding box shrunk by 2 in each direction
	if { [string match {[0-9]*} $id] } {
	    set region [$canvas coords $id]
	    if { [llength $region] == 4 } {
		return $region
	    } else {
		return [rectShrink [$canvas bbox $id] 2]
	    }
	} else {
	    # For a complex item, use the primary component if there is one.
	    # If not, use the bounding box.
	    if { [@scope ::tycho::$itemtype($id) \
		    [list ::info exists primary($id)]] } {
		set region [$canvas coords \
			[@scope ::tycho::$itemtype($id) \
			[list set primary($id)]]]

		if { [llength $region] == 4 } {
		    return $region
		}
	    }
	    return [rectShrink [$this bbox $id] 2]
	}
    }

    # Set the region -- FIXME!
}

#######################################################################
#### scale
#
# FIXME: Won't work if first argument is a tag!!!
#
body ::tycho::Slate::scale {id xOrigin yOrigin xScale yScale} {
    # If this is a canvas item, just call the canvas
    if { [string match {[0-9]*} $id] } {
	$canvas scale $id $xOrigin $yOrigin $xScale $yScale
	return
    } else {
	# Get new coordinates
	set newcoords {}
	set coords [$canvas coords \
		[@scope ::tycho::$itemtype($id) [list set primary($id)]]]
	foreach {a b} $coords {
	    set a [expr $xOrigin + $xScale * ($a - $xOrigin)]
	    set b [expr $yOrigin + $yScale * ($b - $yOrigin)]
	    lappend newcoords $a $b
	}

	# Apply scaling
	eval $this coords $id $newcoords
    }
}

#######################################################################
#### type
#
# Return the type of an item. Note that types are case-sensitive.
#
# With the *-shape* option, return the "shape" of the complex item. The
# value returned is a subset of the types.
#
body ::tycho::Slate::type {id args} {
    if { [string match {[0-9]*} $id] } {
	$canvas type $id
    } else {
	getflag shape args
	if { $shape } {
	    return [@scope ::tycho::$itemtype($id) [list set shape]]
	} else {
	    return $itemtype($id)
	}
    }
}

#######################################################################
#### xview
#
body ::tycho::Slate::xview {args} {
    eval $canvas xview $args
}

#######################################################################
#### yview
#
body ::tycho::Slate::yview {args} {
    eval $canvas yview $args
}



#######################################################################
#### canvasslate
#
# Get the slate name given the canvas name
#
proc canvasslate {canvas} {
    return [join [linit [split $canvas .]] .]
}


###################################################################
###################################################################
####                      private methods                      ####


#######################################################################
#### adopt
#
# Give a complex item a new parent
#
body ::tycho::Slate::adopt {parent id} {
    # If we have a parent, then orphan it first
    if { [$this parent $id] != "" } {
	$this orphan $id
    }

    # If this is a complex item, remove the owner tags
    if { ! [string match {[0-9]*} $id] } {
	$canvas dtag !$id
    }

    # Add the parent's tags, but without the parent owner tag
    foreach tag [ldelete [$this tags $parent] !$parent] {
	$canvas addtag $tag withtag $id
    }
}

#######################################################################
#### ancestor
#
# Test if a complex item is an ancestor of another
#
body ::tycho::Slate::ancestor {ancestor descendent} {
    return [lmember [$this itemcget $descendent -tags] $ancestor]
}

#######################################################################
#### ancestors
#
# Return the ancestors of an item or complex item
#
body ::tycho::Slate::ancestors {id} {
    if { [string match {[0-9]*} $id] } {
	# A canvas item: find the owner and call again
	return [$this ancestors [$this owner $id]]
    } else {
	set items [list $id]
	while { $parent($id) != "" } {
	    lappend $items $parent($id)
	    set id $parent($id)
	}
	return $items
    }
}

#######################################################################
#### children
#
# Return the children of an item or complex item
#
body ::tycho::Slate::children {id} {
    if { [string match {[0-9]*} $id] } {
	return {}
    }
    set children {}
    foreach {child par} [array get parent] {
	if { $par == $id } {
	    lappend children $child
	}
    }
    return $children
}

#######################################################################
#### items
#
# Return the items only under this item or complex item
# Note that this includes the primary -- is this good or bad?
#
body ::tycho::Slate::items {id} {
    if { [string match {[0-9]*} $id] } {
	return [list $id]
    } else {
	return [$canvas find withtag !$id]
    }
}

#######################################################################
#### orphan
#
# Make a complex item have no parent
#
body ::tycho::Slate::orphan {id} {
    # Remove parent tags
    foreach tag [$this tags [$this parent $id]] {
	$canvas dtag $tag
    }
    
    # If this is a complex item, add the owner tag
    if { ! [string match {[0-9]*} $id] } {
	$canvas addtag !$id withtag $id
    }
}

#######################################################################
#### owner
#
# Return the "owner" of an item -- the parent if there is one,
# else the item.
#
body ::tycho::Slate::owner {id} {
    if { ! [string match {[0-9]*} $id] } {
	return $id
    }
    set tags [$canvas gettags $id]
    set indx [lsearch $tags {!*}]
    if { $indx != -1 } {
	return [string range [lindex $tags $indx] 1 end]
    } else {
	return $id
    }
}

#######################################################################
#### parent
#
# Return the parent of an item or complex item
#
body ::tycho::Slate::parent {id} {
    if { [string match {[0-9]*} $id] } {
	# A canvas item: find the owner
	set tags [$canvas gettags $id]
	set indx [lsearch $tags {!*}]
	if { $indx != -1 } {
	    return [string range [lindex $tags $indx] 1 end]
	} else {
	    return {}
	}
    } else {
	return $parent($id)
    }
}

#######################################################################
#### root
#
# Return the root of an item or complex item
#
body ::tycho::Slate::root {id} {
    if { [string match {[0-9]*} $id] } {
	set nid [$this parent $id]
	if { $nid == "" } {
	    return $id
	} else {
	    set id $nid
	}
    }
    while { $parent($id) != "" } {
	set id $parent($id)
    }
    return $id
}

#######################################################################
#### tagadd
#
# Add a tag to items and complex items
#
body ::tycho::Slate::tagadd {tag args} {
    foreach id $args {
	# Add the tag to canvas items
	$canvas addtag $tag withtag $id

	# If a complex item, remember the tag
	if { [string match {_*} $id] } {
	    if { ! [::info exists tagged($tag)] } {
		set tagged($tag) [list $id]
	    } elseif { ! [lmember $tagged($tag) $id] } {
		lappend tagged($tag) $id
	    }
	}
    }
}
