# Definition of an HTML context-sensitive editor.
#
# @Author: Edward A. Lee
#
# @Version: $Id$
#
# @Copyright (c) 1995-%Q% The Regents of the University of California.
# All rights reserved.
# 
# Permission is hereby granted, without written agreement and without
# license or royalty fees, to use, copy, modify, and distribute this
# software and its documentation for any purpose, provided that the
# above copyright notice and the following two paragraphs appear in all
# copies of this software.
# 
# IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY
# FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
# ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF
# THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.
# 
# THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE
# PROVIDED HEREUNDER IS ON AN "AS IS" BASIS, AND THE UNIVERSITY OF
# CALIFORNIA HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,
# ENHANCEMENTS, OR MODIFICATIONS.
# 
# 						PT_COPYRIGHT_VERSION_2
# 						COPYRIGHTENDKEY
#######################################################################

#######################################################################
#### options
# Define colors for the HTML context-sensitive editor. The HTML
# editor uses its own preference set.
#
preference add textedit html.commandColor [ptkColor maroon black]
preference add textedit html.pointerColor [ptkColor blue black]
preference add textedit html.destColor    [ptkColor forestGreen black]


#######################################################################
#### EditHTML
# This class defines a text widget with an emacs-like editor with some
# context-specific features for editing HTML files. It tags and colors
# HTML statements enclosed by angle brackets, and makes hyperlinks live.
# It also provides a command for checking hyperlinks.
#
class ::tycho::EditHTML {
    inherit ::tycho::Edit

    constructor {args} {}
    destructor {}

    ##########################################################################
    ####                         public methods                           ####

    # Check hyperlinks for validity.
    method checkLinks {}

    # Execute the HTML and display.
    method evaluate {}

    # Open a help window.
    method help {}

    # Jump to the link under the "current" mark, if any.
    method jump {}

    # Color the HTML statements in a region.
    method parseNow {start stop}

    # Find a name definition.
    method seePoint {point}

    # Returns a list of tags to use when checking the spelling.
    method spellCheckTags {} {return {text}}

    ####################################################################
    ####                  protected methods and variables           ####

    # Fix the link between start and end, which has error indicated by err.
    protected method fixLink {link start end err}

    # Given an HTML anchor, return the filename and point within the file.
    protected method parseLink {dest}
}

###################################################################
#
body ::tycho::EditHTML::constructor {args} {
    eval itk_initialize $args

    # Add to the format menu commands to comment and uncomment
    # the regions defined by the selection.
    menubar addSeparator Format
        
    menubar add "Recolorize" Format -underline 0 \
	    -command "$this parseRegion 1.0 end"

    menubar addSeparator Edit
        
    menubar add "Check Links" Edit -underline 6 \
	    -command "$this busy checkLinks"

}

#####################################################################
#### checkLinks
# Check hyperlinks for validity.
#
body ::tycho::EditHTML::checkLinks {} {
    # Clear marks from previous checking
    $itk_component(text) tag delete badlink

    # Have to parse first, since we use the tags.
    # Note that cannot allow the parsing to be deferred.
    parseNow 1.0 end
    set next 1.0
    set even 0
    set ok 1
    while {[set point [$itk_component(text) tag nextrange pointer $next]] \
	    != {}} {
	set start [lindex $point 0]
	set end [lindex $point 1]
	set next $end
	set dest [$itk_component(text) get $start $end]
	set ret [parseLink $dest]
	if {$ret == {}} {
	    set ok 0
	    if {[fixLink $dest $start $end {Malformed hyperlink}] == {}} {
		break
	    }
	} {
	    set filename [lindex $ret 0]
	    set name [lindex $ret 1]
	    set nameexp "<\[ \t\]*a\[ \t\]+name\[ \t\]*=\[ \t\]*\"?$name\"?>"
	    if {$filename != {}} {
		if {![file exists $filename]} {
		    set ok 0
		    if {[fixLink $dest $start $end {Non-existant file}] == {}} {
			break
		    }
		    continue
		} elseif {![file readable $filename]} {
		    set ok 0
		    if {[fixLink $dest $start $end {Non-readable file}] == {}} {
			break
		    }
		    continue
		}
		if {$name != {}} {
		    # Check that name exists in the remote file.
		    set fid [open $filename]
		    set contents [read $fid]
		    close $fid
		    if {![regexp -nocase $nameexp $contents]} {
			set ok 0
			if {[fixLink $dest $start $end {Bad name after #}] \
				== {}} {
			    break
			}
		    }
		}
	    } elseif {$name != {}} {
		# Check that name exists in the local file
		if {[$itk_component(text) search -nocase -regexp $nameexp 1.0] \
			== {}} {
		    set ok 0
		    if {[fixLink $dest $start $end {Bad name after #}] == {}} {
			break
		    }
		}
	    }
	}
    }
    if {$ok} {
	::tycho::inform "Hyperlinks appear to be OK"
    } {
	::tycho::inform "Done checking hyperlinks"
    }
}

#####################################################################
#### evaluate
# Evaluate the contents of the text window as HTML commands.
#
body ::tycho::EditHTML::evaluate {} {
    $itk_component(text) evaluate
}

###################################################################
#### help
# Open a window with help on the current widget.
#
body ::tycho::EditHTML::help {} {
    global ::TYCHO
    ::tycho::File::openContext \
	    [file join $TYCHO editors textedit doc usersGuides \
	    EditHTMLHelp.html]
}

#####################################################################
#### jump
# Jump to the link under the "current" mark, if any.
#
body ::tycho::EditHTML::jump {} {
    set dest [getTaggedText pointer]
    if {$dest != {}} {
	set ret [parseLink $dest]
	if {$ret != {}} {
	    set filename [lindex $ret 0]
	    set name [lindex $ret 1]
	    if {$filename == {}} {
		seePoint $name
	    } {
		hyperJump $filename $name
	    }
	}
    }    
}

#####################################################################
#### parseNow
# Tag and color HTML commands in the specified range.
#
body ::tycho::EditHTML::parseNow {start stop} {

    set text $itk_component(text)

    # Remove tags first, if necessary
    $text tag remove command $start $stop
    $text tag remove text $start $stop
    $text tag remove pointer $start $stop
    $text tag remove dest $start $stop
    
    # Scan the text for HTML commands.
    set upto $start
    while {[set ret \
	    [$text search -count length -regexp {\<[^>]+\>} \
	    $upto $stop]] != {}} {
	$text tag add text $upto $ret
	$text tag add command $ret "$ret + $length char"
	# The following appears to be needed to prevent infinite loops.
	if [$text compare $upto >= end] {break}
	set upto [$text index "$ret + $length char"]
    }
    $text tag add text $upto $stop
    
    # Set the visual characteristics of the tagged commands
    $text tag configure command -foreground \
	    [preference get textedit html.commandColor]

    # Scan the text for hypertext pointers.
    set upto $start
    while {[set upto \
	    [$text search -count length -nocase \
	    -regexp {\<a[ \t]+href[ \t]*=[ \t]*[^>]+\>} \
	    $upto $stop]] != {}} {
	$text tag add pointer $upto "$upto + $length char"
	set upto [$text index "$upto + $length char"]
	# The following appears to be needed to prevent infinite loops.
	if [$text compare $upto >= end] {break}
    }
    
    # Set the visual characteristics of the tagged commands
    $text tag configure pointer -foreground \
	    [preference get textedit html.pointerColor]

    # for testing
    # $text tag configure text -foreground red

    $text tag bind pointer <Double-Button-1> "$this jump"

    # Scan the text for hypertext destinations.
    set upto $start
    while {[set upto \
	    [$text search -count length -nocase \
	    -regexp {\<a[ \t]+name[ \t]*=[ \t]*[^>]+\>} \
	    $upto $stop]] != {}} {
	$text tag add dest $upto "$upto + $length char"
	set upto [$text index "$upto + $length char"]
	# The following appears to be needed to prevent infinite loops.
	if [$text compare $upto >= end] {break}
    }
    
    # Set the visual characteristics of the tagged commands
    $text tag configure dest -foreground \
	    [preference get textedit html.destColor]
}

#####################################################################
#### seePoint
# Find a point within the file, center in the
# visible part of the text window, and briefly highlight it.
# The point can have any of three forms:
# <pre>
#    {line <i>linenumber</i>}
#    {range <i>startindex endindex</i>}
#    <i>name</i>
# <pre>
# where in the latter form, <i>name</i> should be a named
# anchor within the HTML file.
#
body ::tycho::EditHTML::seePoint {point} {
    if {([llength $point] == 2 && [lindex $point 0] == {line}) || \
            ([llength $point] == 3 && [lindex $point 0] == {range})} {
        Edit::seePoint $point
    } {
        # Edit the pattern to identify the named anchor.
        Edit::seePoint "name\[ \t\]*=\[ \t\]*\"?$point\"?"
    }
}

#####################################################################
#####################################################################
#####################################################################
####                    protected methods                        ####

#####################################################################
#### fixLink
# Fix the link between start and end, which has error indicated by err.
# The user is queried for a replacement.  The first argument is the
# original text of the bad link.  The second is the start position, the
# third is the end position, and the final argument is a message indicating
# what is wrong with the link.  If the user does not cancel, the link
# will be replaced with an edited value.  Return the replacement string
# if there is one, or the null string if the user cancels.
#
body ::tycho::EditHTML::fixLink {link start end err} {

    $itk_component(text) tag add badlink $start $end
    $itk_component(text) see $start

    # Set up reverse video for the bad match.
    # First lower the priority of the tag so the selection is still visible
    # as normal.
    $itk_component(text) tag raise sel badlink
    $itk_component(text) tag configure badlink \
	    -background [preference get textedit html.targetColor]

    set replacement [::tycho::DialogWindow::newModal EntryQuery \
	    [::tycho::autoName .entry] \
	    -bitmap questhead \
	    -text "$err: Make corrections." \
	    -queries [list [list correction {} $link]] \
	    -entrywidth 80 \
	    -geometry +0+0]

    set replacement [lindex [lindex $replacement 0] 1]

    if {$replacement != {} && $replacement != $link} {
	deleteRange $start $end
	insertString $start $replacement
	$itk_component(text) tag add pointer $start \
		"$start +[string length $replacement] chars"
    }
    return $replacement
}

#####################################################################
#### parseLink
# Given an HTML anchor, return a two-element list with a fully
# expanded filename (which could be based on the location of the
# current file we are displaying) and a point within the file.
# It is possible for either the filename or the point within the
# file to be an empty string, meaning that they were not specified.
# If the parsing fails, an empty string is returned rather than a
# two-element list.
# FIXME: This will not work unless the parent widget is created
# at the global scope.
#
body ::tycho::EditHTML::parseLink {dest} {
    if [regexp -nocase \
	    {\<a[ \t]+href[ \t]*=[ \t]*\"?(file:)?([^>#\"]*)#?([^>\"]*)\"?\>} \
	    $dest dummy1 dummy2 filename name] {
	# If the filename is not absolute, use the directory
	# of the current file.  This only works if we are inside
	# a file object.
	if {$filename != {} && ![string match /* $filename] && \
            ![string match "\$*" $filename] && ![string match "~*" $filename]} {
	    set tl [winfo toplevel $itk_component(hull)]
	    if {[uplevel #0 info objects $tl] != {} && \
		    [$tl isa ::tycho::File]} {
		set filename [file dirname [$tl filename]]/$filename
	    }
            set filename [::tycho::expandPath $filename]
	}
	return [list $filename $name]
    } {
	return {}
    }
}
