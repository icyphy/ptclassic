# A graphical entry tool for state transition diagrams (STD).
#
# @Author: Bilung Lee
#
# @Version: $Id$
#
# @Copyright (c) 1995-%Q% The Regents of the University of California.
# All rights reserved.
# 
# Permission is hereby granted, without written agreement and without
# license or royalty fees, to use, copy, modify, and distribute this
# software and its documentation for any purpose, provided that the
# above copyright notice and the following two paragraphs appear in all
# copies of this software.
# 
# IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY
# FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
# ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF
# THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.
# 
# THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE
# PROVIDED HEREUNDER IS ON AN "AS IS" BASIS, AND THE UNIVERSITY OF
# CALIFORNIA HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,
# ENHANCEMENTS, OR MODIFICATIONS.
# 
# 						PT_COPYRIGHT_VERSION_2
# 						COPYRIGHTENDKEY
#######################################################################

#######################################################################
#### EditSTD
# A graphical editor for editing the state transition diagrams (STD).
# It recognizes the file extension ".std".
#

class ::tycho::EditSTD {
    inherit ::tycho::EditBubbleAndArc

    ##########################################################################
    ####                      constructor & destructor                    ####
    constructor {args} {}
    destructor {}

    ##########################################################################
    ####                         public methods                           ####

    # Clear the display, discarding the current items.
    method clear {}

    method editArc {arc} 
    method editArcDone {arc w}

    # Invoked by the "Edit Item" command in the Edit menu.
    # It invokes the "editState" or "editArc" methods depending on 
    # whether the item is a node or an arc.
    method editItem {item}

    method editState {node} 
    method editStateDone {node w} 

    # getInfo
    method getInfo {} 
 
    # To set the names of the I/O ports & internal events
    method ioPortNames {}
    method ioPortNamesDone {w}

    # Look inside an item with tag $tag.
    method lookInside {tag}
    
    # Look inside a state with id $node.
    method lookInsideState {node}

    # makeIcon
    method makeIcon {}
    method makeIconOk {w}

    # Pop up a file
    method popUpFile {name}

    # The following methods are used only when work with Ptolemy
    method ptkCompile {}

    # Invoked by the "Set Initial State" command in the Edit menu.
    method setInitialState {tag} 

    # Set the machine type.
    method setMachineType {type}

    # Set the in, out and internal port names.
    method setPortNames {in out internal}

    # Specify whether or not modifications are allowed in the displayed text.
    method setReadOnly {bool}

    ##########################################################################
    ####                     protected methods                            ####

    # Insert the specified data into the canvas.
    protected method insertData {data}

    # Return the text to save.
    protected method saveText {}

    ##########################################################################
    ####                     protected variables                          ####

    # Machine type of this state transition diagram.
    protected variable machineType

    # Names of the I/O ports.  This is an array with two elements:
    # "in" and "out".
    protected variable portNames

    # Store the value used in makeIcon last time.
    protected common makeIconSrcDir [file join $PTOLEMY src domains fsm demo]
    protected common makeIconPaletteName "user.pal"
}

##########################################################################
####  constructor & destructor
#
body ::tycho::EditSTD::constructor {args} {
    interactiveEnable 0

    # Add items into File menu
    menubar insert "Look Inside" "Close" \
	    -underline 5 -accelerator "i" -command "$this lookInside selected"
    menubar insertSeparator "Close"

    # Enable items in Edit menu
    menubar enable "Edit Item"

    # Change command of items in Edit menu
    menubar entryconfigure {Edit Item} \
	    -command "$this editItem selected"

    # Add items into Special menu
    menubar insert "I/O Port Names..." "Smooth Toggle" \
	    -underline 0 -command "$this ioPortNames"
    menubar insert "Set Initial State" "Smooth Toggle" \
	    -underline 0 -command "$this setInitialState selected"
    menubar insertSeparator "Smooth Toggle"

    menubar insert "Make Icon..." "Get Info" -underline 0 \
            -command "$this makeIcon"

    # Initialize the io portNames array elements.
    set portNames(in)  ""
    set portNames(out) ""
    set portNames(internal) ""

    # Setup menu hot key and mouse binding
    bind $slate <Key-e> "$this editItem selected"
    bind $slate <Double-1> "$this editItem current"
    bind $slate <Key-i> "$this lookInside current"

    # The following initialize options and then invoke any
    # configuration options, assuming there are options specified.
    eval itk_initialize $args 

    # Need the data in the file right away to decide if there is a machine 
    # type or not, so couldn't wait for the delay reload in File::constructor.
    [code evalIfExists $this reload]

    # If no machine type is specified yet, initialize it.
    if {![info exists machineType]} {
	set w $prefix.editMachineType
	::tycho::Dialog $w -title "Edit the Machine Type"\
		-text "Press button to choose the machine type:"
	$w addButton mixed -text "Mixed"\
		-command "$this setMachineType Mixed; destroy $w"
	$w centerOnScreen
	tkwait window $w
    }

    interactiveEnable 1
}

    ##########################################################################
    ####                         public methods                           ####

#######################################################################
#### clear
# Clear the display, discarding the current graphics and corresponding
# data structure.
#
body ::tycho::EditSTD::clear {} {
    if [getReadOnly] {bell; return}

#    foreach node [$slate find withtag node] {
#	# destroy the corresponding edit state window if it exists.
#	set w $prefix.stdEditState$node
#	if [winfo exists $w] { destroy $w }
#    }
#    foreach arc [$slate find withtag arc] {
#	# destroy the corresponding edit arc window if it exists.
#	set w $prefix.stdEditArc$arc
#	if [winfo exists $w] { destroy $w }
#    } 

    $slate delete all
    foreach index [array names nodeInfo] {
	unset nodeInfo($index)
    }
    foreach index [array names edgeInfo] {
	unset edgeInfo($index)
    }
}

###################################################################
#### editArc and editArcDone
# Edit an arc.
#
body ::tycho::EditSTD::editArc {arc} {
    set w $prefix.stdEditArc$arc
    if [winfo exists $w] {
	wm deiconify $w
	raise $w
    } else {

	set arcLabel [$slate itemcget $edgeInfo($arc,label) -text]
	set src [$slate itemcget $edgeInfo($arc,src) -text]
	set dest [$slate itemcget $edgeInfo($arc,dest) -text]
	set title "Edit $machineType Arc \"$arcLabel\"\nSource state: $src\
		\nDestination state: $dest"

	set labelQuery [list line label {Label:} $arcLabel]

	if "![info exists edgeInfo($arc,guard)]" {
	    set edgeInfo($arc,guard) ""
	}
	set guardQuery [list line guard {Guard:} $edgeInfo($arc,guard)]

	set cmd "$this editArcDone $arc $w"

	::tycho::Query $w -title "STD Edit $machineType Arc"\
		-text $title -queries [list $labelQuery $guardQuery]\
		-okcommand [list catch $cmd]

	foreach outName $portNames(out) {
	    if "![info exists edgeInfo($arc,output,$outName)]" {
		set edgeInfo($arc,output,$outName) 0
	    } 
	    $w line outputFor$outName "Output for \"${outName}\":"\
		    $edgeInfo($arc,output,$outName)
	}

	foreach internalName $portNames(internal) {
	    if "![info exists edgeInfo($arc,action,$internalName)]" {
		set edgeInfo($arc,action,$internalName) 0
	    } 
	    $w line actionFor$internalName "Action for\
		    \"$internalName\":" \
		    $edgeInfo($arc,action,$internalName)
	}

	if "![info exists edgeInfo($arc,preemptive)]" {
	    set edgeInfo($arc,preemptive) NO
	} 
	$w radio preemptive {Preemptive:} {NO YES}\
		$edgeInfo($arc,preemptive)
	
	if "![info exists edgeInfo($arc,entryType)]" {
	    set edgeInfo($arc,entryType) History
	} 
	$w radio entryType {Entry Type:} {History Default}\
		$edgeInfo($arc,entryType)
    }
    
    $w centerOnScreen
}

body ::tycho::EditSTD::editArcDone {arc w} {
    set label [$slate itemcget $edgeInfo($arc,label) -text]
    set newLabel [$w get label]
    if {$label != $newLabel} {
	$slate itemconfigure $edgeInfo($arc,label) -text $newLabel
	$this markModified
    }

    set newGuard [$w get guard]
    if {$edgeInfo($arc,guard) != $newGuard} {
	set edgeInfo($arc,guard) $newGuard
	$this markModified
    }

    set newPreemptive [$w get preemptive]
    if {$edgeInfo($arc,preemptive) != $newPreemptive} {
	set edgeInfo($arc,preemptive) $newPreemptive
	$this markModified	
    }

    set newEntryType [$w get entryType]
    if {$edgeInfo($arc,entryType) != $newEntryType} {
	set edgeInfo($arc,entryType) $newEntryType
	$this markModified	
    }

    foreach outName $portNames(out) {
	set newValue [$w get outputFor$outName]
	if {$edgeInfo($arc,output,$outName) != $newValue} {
	    set edgeInfo($arc,output,$outName) $newValue
	    $this markModified
	}
    }

    foreach internalName $portNames(internal) {
	set newValue [$w get actionFor$internalName]
	if {$edgeInfo($arc,action,$internalName) != $newValue} {
	    set edgeInfo($arc,action,$internalName) $newValue
	    $this markModified
	}
    }
}

###################################################################
#### editItem
# Invoked by the "Edit Item" command in the Edit menu.
#
body ::tycho::EditSTD::editItem {item} {
    # The indices in the nodeInfo and edgeInfo arrays
    # are item IDs.
    set id [$slate find withtag $item]
    if {[lsearch -exact [$slate gettags $id] node] >= 0} {
	# id is a node.
	$this editState $id
    } elseif {[lsearch -exact [$slate gettags $id] arc] >= 0} {
	# id is an arc.
	$this editArc $id
    }
}

#########################################################################
#### editState and editStateDone
# Edit a state.
#
body ::tycho::EditSTD::editState {node} {
    
    set w $prefix.stdEditState$node
    if [winfo exists $w] {
	wm deiconify $w
	raise $w
    } else {

	set nodeLabel [$slate itemcget $node -text]
	set title "Edit $machineType State \"$nodeLabel\""
	set labelQuery [list line label {Label:} $nodeLabel]

	set cmd "$this editStateDone $node $w"

	::tycho::Query $w -title "STD Edit $machineType State" \
		-text $title -queries [list $labelQuery]\
		-okcommand [list catch $cmd]

	if "![info exists nodeInfo($node,machine)]" {
	    set nodeInfo($node,machine) ""
	}
	$w line machine {Internal Machine:} $nodeInfo($node,machine)

	$w centerOnScreen
    }


}

body ::tycho::EditSTD::editStateDone {node w} {
    set label [$slate itemcget $node -text]
    set newLabel [$w get label]

    if {$label != $newLabel} {
	$slate itemconfigure $node -text $newLabel
	$this markModified
    }

    set newMachine [$w get machine]
    if {$nodeInfo($node,machine) != $newMachine} {
	set nodeInfo($node,machine) $newMachine
	$this markModified	
    }
}

##############################################################
#### getInfo
body ::tycho::EditSTD::getInfo {} {
    set nodes [$slate find withtag node]
    set arcs [$slate find withtag arc]
    set w $prefix.getInfo
    catch {destroy $w}
    ::tycho::Message $w -text "Machine type: $machineType\
	    \n# of nodes  : [llength $nodes]\
	    \n# of arcs   : [llength $arcs]"
    $w centerOnScreen
}

################################################################
#### ioPortNames
# Edit the I/O portNames of the STD.
#
body ::tycho::EditSTD::ioPortNames {} {

    set w $prefix.stdIOPortNames
    if [winfo exists $w] {
	wm deiconify $w
	raise $w
    } else {
	set name [file tail [file rootname $file]]
	set titleLabel "Edit I/O Port Names of $name"

	set inPortQuery [list line inPort {InPort  names:} $portNames(in)]
	set outPortQuery [list line outPort {OutPort names:} $portNames(out)]
	set internalQuery [list line internalEvents {Internal event names:}\
		    $portNames(internal)]

	::tycho::Query $w -title "STD I/O Port Names"\
		-text $titleLabel \
		-queries [list $inPortQuery $outPortQuery $internalQuery]\
		-okcommand "$this ioPortNamesDone $w"

	$w centerOnScreen
    }
}

###################################################################
#### ioPortNamesDone
# Only used by ioPortNames.
#
body ::tycho::EditSTD::ioPortNamesDone {w} {
    set newInPortNames [$w get inPort]
    if {$portNames(in) != $newInPortNames} {
	set portNames(in) $newInPortNames
	$this markModified
    }

    set newOutPortNames [$w get outPort]
    if {$portNames(out) != $newOutPortNames} {
	set portNames(out) $newOutPortNames
	$this markModified
    }

    set newInternalEvents [$w get internalEvents]
    if {$portNames(internal) != $newInternalEvents} {
	set portNames(internal) $newInternalEvents
	$this markModified
    }	
}

###################################################################
#### lookInside.
# Look inside an item with tag $tag.
#
body ::tycho::EditSTD::lookInside {tag} {
    set id [$slate find withtag $tag]
    if {[lsearch -exact [$slate gettags $id] node] >= 0} {
	# If item is a node (state).
	$this lookInsideState $id
    }
}

###################################################################
#### lookInsideState.
# Look inside a state (node) with id $node.
#
body ::tycho::EditSTD::lookInsideState {node} {
	if "![info exists nodeInfo($node,machine)]" {
	    set nodeInfo($node,machine) ""
	}
	set name $nodeInfo($node,machine)	
	$this popUpFile $name
}


##############################################################
#### makeIcon
# Make a icon for this STD to be put into a VEM palette facet.
body ::tycho::EditSTD::makeIcon {} {

    set w $prefix.stdMakeIcon
    if [winfo exists $w] {
	wm deiconify $w
	raise $w
    } else {
	set srcdirQuery [list line srcdir {Src File Directory:}\
		$makeIconSrcDir]

	set paletteQuery [list line palette {Pathname of Palette:}\
		$makeIconPaletteName]

	::tycho::Query $w -title "stdMakeIcon" -text "Make Icon"\
		-queries [list $srcdirQuery $paletteQuery]\
		-okcommand "$this makeIconOk $w"

	$w centerOnScreen
    }
}

##############################################################
#### makeIconOk
body ::tycho::EditSTD::makeIconOk {w} {
    set name [file tail [file rootname $file]]
    set makeIconSrcDir [$w get srcdir]
    set makeIconPaletteName [$w get palette]
    # It doesn't matter in which domain this icon is made.
    ptkSetMkStar $name SDF $makeIconSrcDir $makeIconPaletteName
}

##############################################################
#### popUpFile
body ::tycho::EditSTD::popUpFile {name} {
    if {$name == ""} {
	error "No galaxy for the machine is specified yet."
    }

    set name [::tycho::expandPath $name]

    if [file exists $name] {
	::tycho::File::openContext $name
    } else {
	error "Specified galaxy for the machine does not exist."
    }
}

##############################################################
#### ptkCompile
# Compile this STD into Ptolemy using ptcl code.
# This method can used only when invoked from Ptolemy.
# FIXME : Should add some code to check if Ptolemy exists.
body ::tycho::EditSTD::ptkCompile {} {

    if "![file exists $file]" {
	error "The specified STD file doesn't exist. "
    }

    # set the name for the FSM galaxy.
    set name [file tail [file rootname $file]]

    # Create a galaxy :
    defgalaxy $name {
	domain FSM

	# Setup Target.
	target default-FSM
	# Set Target parameters.
	set inPorts "";
	foreach inName $portNames(in) {
	    append inPorts \"$inName\"     ;#" (emacs highlighting)
	}
	targetparam inputNameMap $inPorts
	set outPorts "";
	foreach outName $portNames(out) {
	    append outPorts \"$outName\"     ;#" (emacs highlighting)
	}
	targetparam outputNameMap $outPorts
	set internalEvents "";
	foreach internalName $portNames(internal) {
	    append internalEvents \"$internalName\"  ;#" (emacs highlighting)
	}
	targetparam internalNameMap $internalEvents

        targetparam machineType $machineType
        
        # Setup In/Out Ports
        star DataInStar DataIn
        star DataOutStar DataOut
	numports DataInStar input [llength $portNames(in)]
	numports DataOutStar output [llength $portNames(out)]
        set count 1
	foreach inName $portNames(in) {
	    alias $inName DataInStar input#$count
	    incr count
	}
        set count 1
	foreach outName $portNames(out) {
	    alias $outName DataOutStar output#$count
	    incr count
	}
        
	# Step through all the nodes in the canvas.
	# Creating a star for each node : 
	foreach node [$slate find withtag node] {
	    set star$node [$slate itemcget $node -text]
	    star [set star$node] $machineType
	}

	# Set initial state
	set init_state_id [$slate find withtag init_state]
	if {$init_state_id == ""} {
	    error "No initial state is specified. "
	} elseif {[llength $init_state_id] > 1} {
	    error "Only one initial state is allowed. "
	} else {
	    # Setup one initial state :
	    setstate [set star$init_state_id] isInitState YES
	}
    
	# Set the parameters for each star :
	foreach node [$slate find withtag node] {

	    set conditions ""
	    foreach arc $nodeInfo($node,outEdges) {
		if {![info exists edgeInfo($arc,guard)]} {
		    error "A guard is required in each arc. "
		} else {
		    append conditions \"$edgeInfo($arc,guard)\" ;#"
		}
	    }
	    setstate [set star$node] conditions $conditions
	 
	    if { ![info exists nodeInfo($node,machine)] } {
		setstate [set star$node] inMachNm ""
		setstate [set star$node] where_is_defined ""
	    } else {
		set inMachNm [file tail $nodeInfo($node,machine)]
		setstate [set star$node] inMachNm $inMachNm
		set dirname [file dirname $nodeInfo($node,machine)]
		setstate [set star$node] where_is_defined $dirname
	    }

	    set preemptive ""
	    set entryType ""
	    set actions ""
	    foreach arc $nodeInfo($node,outEdges) {
		if "![info exists edgeInfo($arc,preemptive)]" {
		    set edgeInfo($arc,preemptive) NO
		}
		if {$edgeInfo($arc,preemptive) == "NO"} {
		    append preemptive "0\ "
		} elseif {$edgeInfo($arc,preemptive) == "YES"}  {
		    append preemptive "1\ "
		} else {
		    error "Unrecognized preemptive! "
		}

		if "![info exists edgeInfo($arc,entryType)]" {
		    set edgeInfo($arc,entryType) History
		}
		if {$edgeInfo($arc,entryType) == "History"} {
		    append entryType "0\ "
		} elseif {$edgeInfo($arc,entryType) == "Default"}  {
		    append entryType "1\ "
		} else {
		    error "Unrecognized entryType! "
		}

		append actions "\{"
		foreach outName $portNames(out) {
		    if "![info exists edgeInfo($arc,output,$outName)]" {
			set edgeInfo($arc,output,$outName) 0
		    }
		    append actions \"$edgeInfo($arc,output,$outName)\" ;#"
		}
		foreach internalName $portNames(internal) {
		    if "![info exists edgeInfo($arc,action,$internalName)]" {
			set edgeInfo($arc,action,$internalName) 0
		    }
		    append actions \"$edgeInfo($arc,action,$internalName)\" ;#"
		}
		append actions "\}"
	    }
	    setstate [set star$node] preemptive $preemptive
	    setstate [set star$node] entryType $entryType
	    setstate [set star$node] actions $actions

	} 

	# Do the output connection of each star :
	foreach node [$slate find withtag node] {
	    numports [set star$node] stateOut \
		    [llength $nodeInfo($node,outEdges)]
	    set count 1
	    foreach arc $nodeInfo($node,outEdges) {
		connect [set star$node] stateOut#$count \
			[set star$edgeInfo($arc,dest)] stateIn
		incr count
	    }
	}

    }

    # Done
}

###################################################################
#### setInitialState
# If the specified item is a node, mark it as the initial state
# of the STD.
#
body ::tycho::EditSTD::setInitialState {tag} {
    set item [$slate find withtag $tag]
    if {$item == {}} return
    
    if {[lsearch -exact [$slate gettags $item] node] >= 0} {
	# Item is a node.  See if there is already an initial state.
	set init_state_id [$slate find withtag init_state]
	if {$init_state_id != ""} {
	    $slate itemconfigure $init_state_id -width 1.0
	    $slate dtag init_state
	}
	$slate addtag init_state withtag $item
	$slate itemconfigure $item -width 5.0
	$this markModified
    }
}

#######################################################################
#### setMachineType
#
body ::tycho::EditSTD::setMachineType {type} {
    set machineType $type
}

#######################################################################
#### setPortNames
#
body ::tycho::EditSTD::setPortNames {in out internal} {
    set portNames(in)       $in
    set portNames(out)      $out
    set portNames(internal) $internal
}

#####################################################################
#### setReadOnly
# Specify whether or not modifications are allowed in the displayed text.
# Note that this is independent of whether the associated file is readonly.
# It merely determines whether the buffer can be modified, not whether the
# file can be modified.  To control the file, use <code>toggleReadOnly</code>.
#
body ::tycho::EditSTD::setReadOnly {bool} {
    ::tycho::File::setReadOnly $bool
    if [winfo exists $prefix] {
	if {$bool} {
	    menubar disable {Edit Item}
            menubar disable {Delete}
	} {
	    menubar enable {Edit Item}
            menubar enable {Delete}
	}
    }
}

    ##########################################################################
    ####                     protected methods                            ####

#######################################################################
#### insertData
# Append the specified data to the existing display$this setMachineType.
#
body ::tycho::EditSTD::insertData {data} {
    if [getReadOnly] {bell; return}
    if {[catch {eval $data} msg]} {
	error "$msg "
    }
}

################################################################
#### saveText
# Save the contents of the canvas widget as text, and return it.
# This method is invoked by the "save" method.
#
body ::tycho::EditSTD::saveText {} {
    # Identification header comment 
    set name [file tail $file]
    set text "### State transition diagram : $name\n"

    # First, save the canvas dimensions
    append text "\n### Canvas widget dimensions\n"
    set height [winfo height $slate]
    if {$height == 1} {
        # Canvas has not been mapped yet
        set height [cget -canvasheight]
    }
    append text "\$this configure -canvasheight $height\n"
    set width [winfo width $slate]
    if {$width == 1} {
        # Canvas has not been mapped yet
        set width [cget -canvaswidth]
    }
    append text "\$this configure -canvaswidth $width\n"

    # Machine type
    append text "### Machine type: $machineType\n"
    append text "\$this setMachineType $machineType\n"

    # Set member variables
    append text "\n### Member variables\n"
    # I/O port names
    append text "\$this setPortNames \
         [list $portNames(in) $portNames(out) $portNames(internal)]\n"

    # Step through all the nodes in the canvas.
    append text "\n### Creating the nodes\n"
    foreach node [$slate find withtag node] {
	# Generate code to draw the node as an oval on the canvas.
	append text "set node$node\
		\[\$slate create LabeledOval [$slate coords $node]\
		-outline black -fill white -tags node \
		-text [list [$slate itemcget $node -text]]\]\n"
	append text "set nodeInfo(\$node$node,inEdges) \{\}\n"
	append text "set nodeInfo(\$node$node,outEdges) \{\}\n"

	# Generate code to draw the label.
# 	append text "set nodeInfo(\$node$node,label)\
# 		\[\$slate create text\
# 		[$slate coords $nodeInfo($node,label)] -fill black"
# 	set label [$slate itemcget $node -text]
# 	if {$label != {}} {
# 	    append text " -text \{$label\}"
# 	}
#	append text "\]\n"

        # Internal machine
        if "[info exists nodeInfo($node,machine)]" {
	    append text "# Internal machine:\n"
	    append text "set nodeInfo(\$node$node,machine)\
		    [list $nodeInfo($node,machine)]\n"
	}

	append text "\n"
    }
    
    # See if the initial state is specified.  If so, generate
    # code to set the initial state.
    set init_state_id [$slate find withtag init_state]
    if {[llength $init_state_id] > 1} {
	error "Internel error: more than one initial state!!! "
    } elseif {$init_state_id != ""} {
	append text "### Initial state\n"
	append text "\$slate addtag init_state withtag \$node$init_state_id\n"
	append text "\$slate itemconfigure \$node$init_state_id -width 5.0\n"
    }

    # Step through all the arcs in the canvas.
    append text "\n### Creating the arcs\n"
    foreach arc [$slate find withtag arc] {
	set smooth [$slate itemcget $arc -smooth]
	append text "set arc \[\$slate create line\
		[$slate coords $arc] -arrow last -tags arc -fill black\
		-smooth $smooth\]\n"
	# Set up the corresponding nodeInfo and edgeInfo entries.
	set src $edgeInfo($arc,src)
	append text "set edgeInfo(\$arc,src) \$node$src\n"
	append text "lappend nodeInfo(\$node$src,outEdges) \$arc\n"
	set dest $edgeInfo($arc,dest)
	append text "set edgeInfo(\$arc,dest) \$node$dest\n"
	append text "lappend nodeInfo(\$node$dest,inEdges) \$arc\n"

	# Set up the points of the arc.
	foreach point $edgeInfo($arc,points) {
	    append text "set point \[\$slate create rectangle\
		    [$slate coords $point] -fill \{\} -outline \{\}\]\n"
	    append text "lappend edgeInfo(\$arc,points) \$point\n"
	}
	
	# Set up the "outSlope", "outXneg", "inSlope", and "inXneg"
	# entries.
	append text "set edgeInfo(\$arc,outSlope) $edgeInfo($arc,outSlope)\n"
	append text "set edgeInfo(\$arc,outXneg) $edgeInfo($arc,outXneg)\n"
	append text "set edgeInfo(\$arc,inSlope) $edgeInfo($arc,inSlope)\n"
	append text "set edgeInfo(\$arc,inXneg) $edgeInfo($arc,inXneg)\n"
	
	set mid_xy [$this lineMidpoint $arc]
	set mid_x [lindex $mid_xy 0]
	set mid_y [lindex $mid_xy 1]
	append text "set edgeInfo(\$arc,label)\
		\[\$slate create text\
		[expr $mid_x + $edgeInfo($arc,label_deltax)]\
		[expr $mid_y + $edgeInfo($arc,label_deltay)]\
		-fill black"
	set label [$slate itemcget $edgeInfo($arc,label) -text]
	if {$label != {}} {
	    append text " -text \{$label\}"
	}
	append text "\]\n"

	append text "set edgeInfo(\$arc,label_deltax)\
		$edgeInfo($arc,label_deltax)\n"
	append text "set edgeInfo(\$arc,label_deltay)\
		$edgeInfo($arc,label_deltay)\n"

	# Guard
	if [info exists edgeInfo($arc,guard)] {
	    append text "set edgeInfo(\$arc,guard)\
		    [list $edgeInfo($arc,guard)]\n"
	}

	if [info exists edgeInfo($arc,preemptive)] {
	    append text "set edgeInfo(\$arc,preemptive)\
		    $edgeInfo($arc,preemptive)\n"
	}

	if [info exists edgeInfo($arc,entryType)] {
	    append text "set edgeInfo(\$arc,entryType)\
		    $edgeInfo($arc,entryType)\n"
	}

	foreach outName $portNames(out) {
	    if [info exists edgeInfo($arc,output,$outName)] {
		append text "set edgeInfo(\$arc,output,$outName)\
			[list $edgeInfo($arc,output,$outName)]\n"
	    }
	}

	foreach internalName $portNames(internal) {
	    if [info exists edgeInfo($arc,action,$internalName)] {
		append text "set edgeInfo(\$arc,action,$internalName)\
			[list $edgeInfo($arc,action,$internalName)]\n"
	    }
	}

	append text "\n"
    }
    
    # Done
    append text "### End of File\n"

    return $text
}

