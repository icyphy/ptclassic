# A graphical viewer and editor widget based on the Tk canvas.
#
# @Author: Edward A. Lee
#
# @Version: $Id$
#
# @Copyright (c) 1995-%Q% The Regents of the University of California.
# All rights reserved.
#
# Permission is hereby granted, without written agreement and without
# license or royalty fees, to use, copy, modify, and distribute this
# software and its documentation for any purpose, provided that the above
# copyright notice and the following two paragraphs appear in all copies
# of this software.
#
# IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY
# FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
# ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF
# THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.
#
# THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE
# PROVIDED HEREUNDER IS ON AN "AS IS" BASIS, AND THE UNIVERSITY OF
# CALIFORNIA HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,
# ENHANCEMENTS, OR MODIFICATIONS.
# 
#                                        PT_COPYRIGHT_VERSION_2
#                                        COPYRIGHTENDKEY
#######################################################################

# FIXME: Known bugs:
# - When scrollbars are added or removed, actions bound to <Configure>
#   are triggered three times.  This can be very expensive.
#
# FIXME: To do:
# - Create a font hiearchy (huge, large, medium, ...),
#   and use that.
# - Make undo mechanism multi-level.
# - Methods to insert HTML
# - Method to move an item
# - Support canvas itemconfigure method and modify the stored create
#   command accordingly.

#######################################################################
#### options

# Canvas background color.
option add *Graphics.canvasColor \
        [ptkColor antiqueWhite3 white] widgetDefault

# Default canvas foreground color.
option add *Graphics.canvasForeground black widgetDefault

# Default height of the canvas widget, in pixels.
option add *Graphics.canvasHeight 500 widgetDefault

# Default width of the canvas widget, in pixels.
option add *Graphics.canvasWidth 600 widgetDefault

# Specify types of titles in the order in which they appear on the screen.
option add *Graphics.titleTypes {title subtitle author version copyright}

# FIXME: Pending better handling of fonts:
# Title fonts lists
option add *Graphics.authorFont {{helvetica 16 bold i} {times 16 bold i}} widgetDefault
option add *Graphics.copyrightFont {{helvetica 14 medium r} {times 14 medium r}} widgetDefault
option add *Graphics.versionFont {{helvetica 14 medium r} {times 14 medium r}} widgetDefault
option add *Graphics.subtitleFont {{helvetica 16 bold r} {times 16 bold r}} widgetDefault
option add *Graphics.titleFont {{helvetica 24 bold r} {times 24 bold r}} widgetDefault

# Colors for title text
option add *Graphics.authorColor firebrick widgetDefault
option add *Graphics.copyrightColor black widgetDefault
option add *Graphics.subtitleColor blue widgetDefault
option add *Graphics.titleColor black widgetDefault
option add *Graphics.versionColor black widgetDefault

#######################################################################
#### Graphics
# This widget is the principal Tycho interface to the Tk Canvas.
# It creates a widget that contains a canvas with optional scrollbars.
# A set of methods support commonly used operations and encourage a
# a consistent look to graphical displays and editors.
# <p>
# The widget manages a set of <i>items</i> consisting of one or more
# canvas items. Items can be saved in files and edited using
# customizable editors. Their creation and deletion can be interfaced
# to the undo and clipboard mechanisms. The <code>create</code> method
# is the simplest way to create an item, which in this case is a simple
# canvas item. The <code>create</code> method passes all its arguments
# to the Tk <code>canvas create</code> command. Items with more complex
# behavior, such as centered text that adjusts to changes in window
# sizes and insertion of other items, can also be created. Derived
# classes provide yet more complex items.
# <p>
# If you use its <code>create</code> method to create items in the
# canvas, then then undo and clipboard operations will work on this
# item and the details about the item will be reported by the
# <code>describe</code> method, which is used to save the contents to a
# file. If this object is embedded in a <code>Graphics</code> object,
# then items created this way are automatically saved in files. Any
# item created with the <code>create</code> method should be removed
# using the <code>delete</code> method. Commands that are issued
# directly to the canvas are ignored for the purposes of undo, the
# clipboard, and saving to a file. The <code>describe</code> method
# will not reflect any such commands.
# <p>
# The <code>describe</code> method also reports the current canvas size.
# Thus, if the data reported by this method is saved (as is done by the
# <code>Graphics</code> class), then the size of the canvas is persistent.
# <p>
# A set of methods and options are provided to encourage a consistent
# look and feel in graphical editors and displays.  The
# <code>centeredText</code> method can be used to create titles, subtitles,
# author information, etc.  These can be specified or edited interactively.
# <p>
# This class is a base class for more interesting graphical displays
# and editors. It is not meant to be used on its own. Derived classes
# may create objects in the canvas without using the <code>create</code>
# method.  Such objects can be registered using the <code>register</code>
# method.
# <p>
# This design has borrowed some ideas from the scrolled canvas widget
# written by Mark Ulferts and Sue Yockey of DSC Technologies Corporation,
# but goes well beyond the intent of that widget.
#
class ::tycho::Graphics {
    inherit ::tycho::File

    constructor {args} {}
    destructor {}
    
    ###################################################################
    ####                            options                        ####

    # Specify the height of the canvas widget, in pixels.
    itk_option define -canvasheight canvasHeight CanvasHeight 300

    # Specify the width of the canvas widget, in pixels.
    itk_option define -canvaswidth canvasWidth CanvasWidth 400

    # Specify what type of scrolling to use: bars, bars, or none.
    itk_option define -scrolling scrolling Scrolling {auto}

    ###################################################################
    ####                         public methods                    ####

    # Return the name of the Tk canvas, for interfacing to non-Itcl code.
    method canvasName {} {return $canvas}

    # Create centered text.
    method centeredText {text {tag {}} {below {}} {color black} {font {}}}

    # Interactively edit centered text.
    method centeredTextEdit {{tag {}}}

    # Clear the display, discarding the current items.
    method clear {}

    # Save the specified items to the clipboard, or if none, the selected items.
    method copy {{ids {}}}

    # Create a canvas items, recording for undo, and registering for saving.
    method create {args}

    # Remove and save to the clipboard the specified items or the selection.
    method cut {{ids {}}}

    # Delete one or more canvas items, recording for undo.
    method delete {args}

    # Declare that a child item depends on a parent item.
    method dependenceAdd {parenttag childtag {update {}}}

    # Update items in the dependence list.
    method dependenceUpdate {args}

    # Describe the contents of the canvas as a list of method invocations.
    method describe {}

    # Edit the specified items, or if none, the selected items.
    method edit {{ids {}}}

    # Give the canvas the focus.
    method focusin {}

    # Open a help window.
    method help {}

    # Insert the specified data into the canvas.
    method insertData {data}

    # If the argument is non-zero, enable the undo system and automatic updates.
    method interactiveEnable {bool} {set interactiveEnabled $bool}

    # Execute the arguments as a command in this scope, marking modified.
    method modify {args}

    # Insert from the clipboard.
    method paste {}

    # Print the contents of the canvas, using conversion to postscript.
    method print {}

    # FIXME: comment needed here.
    method printOut {win}

    # Redo using the current redo buffer.
    method redo {}

    # Query the user for the type of scrollbars to use.
    method scrollQuery {}

    # Set the scrolling style (use with scrollQuery).
    method scrollSet {dialog}

    # Find the item identified by "name".
    # FIXME: Implement this.
    # method seePoint {point}

    # Select all selectable objects under the cursor.
    method select {{append 0}}

    # Return a list of the ids of selected objects.
    method selected {} {return $selection}

    # Clear the selection.
    method selectionClear {}

    # Specify whether or not modifications are allowed in the displayed text.
    method setReadOnly {bool}

    # Interactively add title information.
    method titleAdd {{newcategory 0}}

    # Set the title, subtitle, author, etc.
    method titleSet {category text}

    # Undo using the current undo buffer.
    method undo {}

    # Append a command to the end of the undo or redo buffer.
    method undoAppend {command}

    # Start a new undo buffer.
    method undoBoundary {}

    # Append a command to the beginning of the undo or redo buffer.
    method undoPrepend {command}

    # Update the scrollbars to reflect the current canvas contents.
    method updateScrollbars {}

    ###################################################################
    ####                   protected methods                       ####

    # Add or configure a textual display at the bottom.
    protected method addInfo {tag label value {width {}} {description {}}}

    # Return the y position of the bottom of the lowest item matching the tags.
    protected method bottomOf {args}

    # Find all the items in the canvas that have all of the specified tags.
    protected method findAll {args}

    # If the argument is non-null, return it.  Otherwise, return the selection.
    protected method itemlist {{items {}}}

    # Register the creation, undo, deletion, and edit commands for an item.
    protected method register {id create undo remove {edit {}}}

    # Return the text to be saved.
    protected method saveText {}

    ###################################################################
    ####                   protected variables                     ####
    
    # The name of the Tk canvas as a variable, for convenience.
    protected variable canvas {}

    # Flag indicating whether undo and automatic updates are enabled.
    protected variable interactiveEnabled 0

    ###################################################################
    ####                   private methods                         ####

    # The updateScrollbars method schedules this method for execution.
    private method configureScrollbars {}

    ###################################################################
    ####                   private variables                       ####

    # The name of the dependence graph
    private variable dependenceGraph {}

    # An array of commands used to create items.
    private variable itemCreate

    # An array of commands used to delete items.
    private variable itemDelete

    # An array of commands used to edit items.
    private variable itemEdit

    # A list of the currently selected objects.
    private variable selection {}    

    # The redo buffer
    private variable redoCommands {}

    # Pending configuration command
    private variable scheduledUpdate {}

    # The undo buffer
    private variable undoCommands {}

    # Flag indicating whether we are undoing or redoing
    private variable undoing 0
}

#######################################################################
#### -scrolling option configuration
# If the value is "bars", then the canvas is equipped with scrollbars.
# If the value is "auto", then the canvas is equipped with scrollbars
# only when its contents are not all visible.
# Otherwise, scrolling is turned off.  For the change to take effect
# after configuring this option, call <code>updateScrollbars</code>.
#
configbody ::tycho::Graphics::scrolling {
    # Do not call updateScrollbars here because this configuration occurs
    # too often.
}

#######################################################################
#### constructor
#
body ::tycho::Graphics::constructor {args} {
    interactiveEnable 0

    # Create a top frame to contain both the canvas and vertical 
    # scrollbar and a bottom frame to hold the horizontal scrollbar and 
    # some filler.

    itk_component add top {
	frame $itk_component(childsite).top
    } {
	keep -background -cursor
    }
    pack $itk_component(top) -fill both -expand yes -side top

    # The canvas.
    itk_component add canvas {
        uplevel #0 ::tycho::slate $itk_component(top).canvas
    } {
        keep -cursor
        rename -background -canvascolor canvasColor CanvasColor
        rename -height -canvasheight canvasHeight CanvasHeight
        rename -width -canvaswidth canvasWidth CanvasWidth
    }
    set canvas $itk_component(canvas)
    pack $canvas -expand yes -fill both -side left

    # NOTE: This used to be bound to the hull of TopLevel, which caused
    # focusin to be called a very large number of times.
    bind $itk_component(canvas) <Map> "$this focusin; break"

    # Create vertical scrollbar. This may not be packed.
    itk_component add vsb {
        scrollbar $itk_component(top).vsb \
                -orient vertical \
                -command "$itk_component(canvas) yview"
    } {
        keep -background -cursor
    }
    
    # Frame to hold the horizontal scrollbar and filler.
    itk_component add bottom {
	frame $itk_component(childsite).bottom
    } {
	keep -background -cursor
    }
    pack $itk_component(bottom) -fill both -side bottom \
            -before $itk_component(top)

    # Create horizontal scrollbar. This may not be packed.
    itk_component add hsb {
        scrollbar $itk_component(bottom).hsb \
                -orient horizontal \
                -command "$itk_component(canvas) xview"
    } {
        keep -background -cursor
    }

    # Filler frame for the lower right corner.
    itk_component add filler {
	frame $itk_component(bottom).filler
    } {
	keep  -background -cursor
    }

    $canvas configure \
            -xscrollcommand "$itk_component(hsb) set" \
            -yscrollcommand "$itk_component(vsb) set"

    # Add a widget at the bottom for displaying info
    itk_component add info {
	frame $itk_component(childsite).info -relief sunken
    } {
	keep -background -cursor
    }
    pack $itk_component(info) -expand no -fill x

    menubar addMenu Edit left Window -underline 0

    menubar addMenuItem {Undo} Edit -underline 0 -accelerator "z" \
	    -command "$this undo"

    menubar addMenuItem {Redo} Edit -underline 0 -accelerator "d" \
	    -command "$this redo"

    menubar addMenuSeparator Edit

    menubar addMenuItem Cut Edit -underline 0 -accelerator "x" \
	    -command "$this modify cut"
    
    menubar addMenuItem Copy Edit -underline 1 -accelerator "c" \
	    -command "$this copy"
    
    menubar addMenuItem Paste Edit -underline 0 -accelerator "v" \
	    -command "$this modify paste"
    
    menubar addMenuSeparator Edit

    menubar addMenuItem {Title...} Edit -underline 0 -accelerator "T" \
            -command "$this titleAdd"

    menubar addMenuItem {Edit Item} Edit -underline 0 -accelerator "e" \
	    -command "$this edit"

    menubar addMenu Format left {} -underline 1

    menubar addMenuItem {Scrollbars...} Format -underline 0 \
            -command "$this scrollQuery"

    # Undo and Redo menu start out disabled
    menubar disableMenuItem Undo Edit
    menubar disableMenuItem Redo Edit

    eval itk_initialize $args

    bind $canvas <Button-1> "$this select"
    bind $canvas <Shift-Button-1> "$this select 1"

    # Prevent shadowing of bindings in the File class.
    bind $canvas <Control-x> { }
    bind $canvas <Control-x><Control-w> { }
    bind $canvas <Control-x><v> { }
    bind $canvas <Control-x><i> { }
    bind $canvas <Control-x><p> { }
    bind $canvas <Control-x><k> { }

    # Simpler bindings provided because this is not a text editor.
    # These are fashioned after the Macintosh commands
    bind $canvas <Key-z> "$this undo; break"
    bind $canvas <Key-d> "$this redo; break"
    bind $canvas <Key-x> "$this modify cut; break"
    bind $canvas <Key-c> "$this copy; break"
    bind $canvas <Key-v> "$this modify paste; break"
    bind $canvas <Key-e> "$this edit; break"

    # Specialized bindings.
    bind $canvas <Key-T> "$this titleAdd; break"

    # Bindings provided for compatibility with emacs conventions.
    # These must be specified after the simpler bindings above.
    bind $canvas <Meta-x> { }
    bind $canvas <Control-x><u> "$this undo; break"
    bind $canvas <Control-w> "$this modify cut; break"
    bind $canvas <Meta-w> "$this copy; break"
    bind $canvas <Control-y> "$this modify paste; break"

    # Bind configure events to update the display.
    # Interactivity is enabled only after the first configure event.
    bind $itk_component(bottom) <Configure> \
            "$this updateScrollbars; $this dependenceUpdate resize"
# FIXME:
#            $this interactiveEnable 1
}

#######################################################################
#### destructor
#
body ::tycho::Graphics::destructor {} {
    if {$dependenceGraph != {}} {
        ::delete object $dependenceGraph
    }
    if {$scheduledUpdate != {}} {
        after cancel $scheduledUpdate
    }
}

    ###################################################################
    ###################################################################
    ####                      public methods                       ####

#######################################################################
#### clear
# Clear the display, discarding the current graphics.
#
body ::tycho::Graphics::clear {} {
    if [getReadOnly] {bell; return}
    [canvasName] delete all
}

# NOTE: The following implementation assumes that the visible portion
# of the canvas always has the origin at the upper right.  Is this a
# safe assumption?

#######################################################################
#### centeredText
# Create text that is centered in the portion of the canvas that will
# be visible when the window is first opened. The first argument is the
# text to insert. The text will be wrapped at word boundaries if it is
# wider than the window. The remaining arguments are optional, although
# if any one of them is given, then the ones before it must also be
# given. The second argument is a tag to assign to the text (in
# addition to "selectable", which is always assigned). If any items
# already exist with this tag, then they are deleted.  The third
# argument is a list of tags identifying tagged items in the canvas
# below which the text will be placed. If the tag is given, and this
# list is non-null, then the dependence is registered so that when
# <code>dependenceUpdate</code> is called, if any of the items in the
# "below" list have moved, then this item will be moved. The fourth
# argument specifies the color. Any color name accepted by
# <code>ptkColor</code> will work. The fifth argument specifies the
# font in a form accepted by the <code>findFont</code> method of the
# <code>FontManager</code> class. If the color and font are not
# specified, then the text is black using the default variable font.
# The text is tagged "selectable," and the id of the text object is
# returned. If the text is an empty string and the tag is given, then
# items with that tag are simply deleted and a null string is returned.
# The action is registered for undoing, and <code>dependenceUpdate</code>
# is called with the argument being either the tag (if given) or
# "centeredtext".  Thus, any object that is registered as depending
# on "centeredtext" using <code>dependenceAdd</code> will be updated.
#
body ::tycho::Graphics::centeredText \
        {text {tag {}} {below {}} {color black} {font {}}} {
    if {$tag != {} && [$canvas find withtag $tag] != {}} {
        if [catch {set oldtext [$canvas itemcget $tag -text]}] {
            set oldtext {}
        }
        $canvas delete $tag
    } {
        set oldtext {}
    }
    if {$text != {}} {
        set top [eval bottomOf $below]
        set cwidth [winfo width $canvas]
        if {$cwidth == 1} {
            # The canvas has not been mapped yet.  Use the requested width.
            set cwidth [cget -canvaswidth]
        }
        set xcoord [expr int($cwidth/2)]
        # Allow for some padding left and right of the title.
        if {$cwidth > 20} {
            set cwidth [expr $cwidth-20]
        }
        if {$font != {}} {
            set usefont [::tycho::.tychoFonts findFont $font]
        } {
            set usefont [::tycho::.tychoFonts defaultFont variable]
        }
        set usecolor [ptkColor $color]
        set id [$canvas create text $xcoord $top \
                -width $cwidth \
                -justify center \
                -anchor n \
                -fill $usecolor \
                -text $text \
                -tag selectable \
                -font $usefont]
        if {$tag != {}} {
            $canvas addtag $tag withtag $id
            # NOTE: add a command to update position rather than just
            # recreating the text on an update.
            set cmd [list centeredText $text $tag $below $color $font]
            foreach dep $below {
                dependenceAdd $dep $tag $cmd
            }
            # FIXME: This dependence should probably be there regardless
            # of whether there is a $tag.  The tag used should be
            # that of the canvas object, which means it would have to
            # be deleted.  The dependence mechanism is not quite rich
            # enough to support this.
            dependenceAdd resize $tag $cmd
            dependenceAdd $tag centeredtext
        }
        register $id \
                [list centeredText $text $tag $below $color $font] \
                [list centeredText $oldtext $tag $below $color $font] \
                [list centeredText {} $tag $below $color $font] \
                [list centeredTextEdit $tag]
    } {
        # Text is simply deleted
        undoPrepend [list centeredText $oldtext $tag $below $color $font]
        set id {}
    }
    if {$tag != {}} {
        dependenceUpdate $tag
    } {
        dependenceUpdate centeredtext
    }
    return $id
}

#######################################################################
#### centeredTextEdit
# Interactively edit centered text.  If the optional argument is given,
# and a centered text item exists in the canvas with the specified tag,
# then that item is edited.  Otherwise, if there is a selected item and
# that item is a centered text item, that item is edited.  Otherwise,
# an error occurs.
#
body ::tycho::Graphics::centeredTextEdit {{tag {}}} {
    if {$tag == {}} {
        set tag [lindex [selected] 0]
    }
    selectionClear
    if {$tag != {}} {
        set id [$canvas find withtag $tag]
        if {$id != {}} {
            if {[info exists itemCreate($id)]} {
                set create $itemCreate($id)
                if {[lindex $create 0] == {centeredText}} {
                    # We have a centered text item.
                    set text [lindex $create 1]
                    set tag [lindex $create 2]
                    set below [lindex $create 3]
                    set color [lindex $create 4]
                    set font [lindex $create 5]
                    set name [::tycho::autoName .query]
                    set cmd "$this modify centeredText \[$name get text\] \
                            [list $tag] [list $below] \
                            [list $color] [list $font]"
                    ::tycho::EntryQuery $name -queries \
                            [list [list text {Text:} $text]] \
                            -okcommand [list catch $cmd]
                    $name centerOnScreen
                    return
                }
            }
        }
    }
    error "No centered text item specified."
}

#######################################################################
#### copy
# Copy the commands to create the specified items to the clipboard. If
# no items are specified, then copy the selected items. The argument is
# a list of item ids.  Only items that were created with the 
# <code>create</code> method or registered with the
# <code>register</code> method can be copied to the clipboard.
#
body ::tycho::Graphics::copy {{ids {}}} {
    set cmds {}
    foreach id [itemlist $ids] {
        if [info exists itemCreate($id)] {
            lappend cmds $itemCreate($id)
        } {
            error "Don't know how to create item with id: $id"
        }
    }
    setClipboard $cmds
}

#######################################################################
#### create
# Create a canvas item, recording for undo. The arguments are exactly
# those of the Tk canvas widget. Also register the creation command so
# that the item can be saved. Return the id of the item created.
#
body ::tycho::Graphics::create {args} {
    undoBoundary
    set id [eval $canvas create $args]
    register $id [concat create $args] [list delete $id] [list delete $id]
    markModified
    return $id
}

#######################################################################
#### cut
# Remove the specified list of items, or if none, the selected items,
# adding to the clipboard commands to recreate them. The argument is a
# list of item ids.
# This method should be called via the <code>modify</code>method.
#
body ::tycho::Graphics::cut {{ids {}}} {
    set ids [itemlist $ids]
    copy $ids
    delete $ids
    selectionClear
}

#######################################################################
#### delete
# Delete one or more canvas items, recording for undo. If the items
# were created with <code>create</code> or registered with
# <code>register</code>, then the deletion is implemented by executing
# the registered delete command, and the corresponding create command
# is recorded for undo. The arguments are tags or ids of items to be
# deleted.
# <p>
# Note that this method shadows the Itcl <code>delete</code> command
# because it has the same name. To invoke that command within a method
# or proc of a class derived from this one, use the syntax
# <code>::delete</code>.
# <p>
# This method should be called via the <code>modify</code> method.
#
body ::tycho::Graphics::delete {args} {
    undoBoundary
    foreach tag $args {
        foreach id [$canvas find withtag $tag] {
            if [info exists itemCreate($id)] {
                if {[lindex $itemDelete($id) 0] == {delete}} {
                    eval $canvas $itemDelete($id)
                    undoAppend $itemCreate($id)
                } {
                    eval $this $itemDelete($id)
                }
                unset itemCreate($id)
                unset itemDelete($id)
                unset itemEdit($id)
            } {
                # Nothing registered.  Just delete.
                $canvas delete $id
            }
        }
    }
    markModified
}

#######################################################################
#### dependenceAdd
# Declare that a child item depends on a parent item.
# The items are specified by tag.  There is no need for items to
# exist with the given tags.  If the optional third argument is given,
# it is a command that will be evaluated by <code>dependenceUpdate</code>
# when a parent has been modified.  If such a command has been previously
# set for this child tag, it is overwritten.
#
body ::tycho::Graphics::dependenceAdd {parenttag childtag {update {}}} {
    if {$dependenceGraph == {}} {
        set dependenceGraph [::tycho::DirectedAcyclicGraph #auto]
    }
    if {![$dependenceGraph exists $parenttag]} {
        # Add a new root to the graph
        $dependenceGraph add $parenttag {}
    }
    if {![$dependenceGraph exists $childtag]} {
        # Add a new leaf node to the graph
        $dependenceGraph add $childtag $update [list $parenttag]
    } {
        # Both exist.  Add a new arc and overwrite the update command.
        # Note that we assume (and don't check) that no cycle is introduced
        # (this makes the code faster).
        $dependenceGraph addArc $parenttag $childtag
        if {$update != {}} {
            $dependenceGraph setContents $childtag $update
        }
    }
}

#######################################################################
#### dependenceUpdate
# Update items in the dependence graph that have been registered with
# calls to <code>dependenceAdd</code>. The optional arguments are nodes
# in the dependence graph representing items that have changed. Nodes
# that depend on those items will be updated. If no argument is given,
# then all items that depend on root items in the dependence graph will
# be updated. An update consists of one of two actions. If an update
# command was given when <code>dependenceAdd</code> was called, then
# that command is executed. Otherwise, for each updated item in the
# dependence graph, if any items exist in the canvas with tags that
# match the name of the item, the item is deleted and recreated using
# registered deletion and creation commands.  If interactive mode is not
# enabled or there is no dependence graph, this method simply returns.
#
body ::tycho::Graphics::dependenceUpdate {args} {
    if {$interactiveEnabled && $dependenceGraph != {}} {
        if {$args != {}} {
            set rootspresent {}
            foreach root $args {
                if [$dependenceGraph exists $root] {
                    lappend rootspresent $root
                }
            }
            # Find all children of given roots.  This is a bit tricky
            # because we have to avoid listing any child twice.
            set roots {}
            foreach root $rootspresent {
                foreach child [$dependenceGraph children $root] {
                    if {[lsearch -exact $roots $child] < 0} {
                        lappend roots $child
                    }
                }
            }
            if {$roots != {}} {
                set nodes [$dependenceGraph topologicalSort $roots]
            } {
                # No children.  Nothing to do.
                return
            }
        } {
            set nodes [$dependenceGraph describe]
        }
        foreach node $nodes {
            set name [lindex $node 0]
            set ids [$canvas find withtag $name]
            # Skip the node if there is nothing in the canvas that matches.
            if {$ids == {}} {continue}
            set contents [lindex $node 1]
            set parents [lindex $node 2]
            # Ignore root nodes
            if {$parents != {}} {
                if {$contents == {}} {
                    # No update command has been indicated.
                    foreach id $ids {
                        # Ignore if we don't know how to recreate.
                        if [info exists itemCreate($id)] {
                            interactiveEnable 0
                            save saveCreate $itemCreate($id)
                            eval $this $itemDelete($id)
                            eval $this $saveCreate
                            interactiveEnable 1
                        }
                    }
                } {
                    # Evaluate the indicated update command.
                    if [catch {
                        interactiveEnable 0
                        eval $contents
                        interactiveEnable 1
                    } msg] {
                        error "Failed to evaluate dependency for $name.\n$msg"
                    }
                }
            }
        }
    }
}

#########################################################################
#### describe
# Describe the contents of the canvas as a list of commands.
# All items are included if they have been registered using the
# <code>register</code> method, or were created using
# the <code>create</code> method.
#
body ::tycho::Graphics::describe {} {

    # First, describe the canvas dimensions
    set height [winfo height $canvas]
    if {$height == 1} {
        # Canvas has not been mapped yet
        set height [cget -canvasheight]
    }
    lappend dsc [list configure -canvasheight $height]
    set width [winfo width $canvas]
    if {$width == 1} {
        # Canvas has not been mapped yet
        set width [cget -canvaswidth]
    }
    lappend dsc [list configure -canvaswidth $width]

    # Report the scrolling mode
    lappend dsc [list configure -scrolling [cget -scrolling]]

    # Next, describe the items in the canvas.
    # Although it is undocumented, the "find withtags all" returns
    # items in the order in which they are displayed.  We describe
    # them in this same order.
    foreach id [$canvas find withtag all] {
        if [info exists itemCreate($id)] {
            lappend dsc $itemCreate($id)
        }
    }
    return $dsc
}

#######################################################################
#### edit
# Edit the specified items, or if none, the selected items. If an edit
# command was registered using the <code>register</code> method, then that
# command is used to edit the item. Otherwise, if the command was
# created using <code>create</code>, or a creation command was registered 
# using the <code>register</code> method, then a text editor is invoked
# to edit that creation command. If the item has not been
# registered at all, then the item is ignored. The argument is a list
# of item ids.
# <p>
# Note that the edit command will be invoked even if the object is
# read-only.  Thus, it is up to that command to ensure that no
# destructive changes are made.
#
body ::tycho::Graphics::edit {{ids {}}} {
    set ids [itemlist $ids]
    foreach id $ids {
        if {[info exists itemEdit($id)] && $itemEdit($id) != {}} {
            eval $this $itemEdit($id)
        } elseif [info exists itemCreate($id)] {
            set name [::tycho::autoName .query]
            set queries [list [list x {Create command:} $itemCreate($id) 8]]
            ::tycho::EntryQuery $name -queries $queries \
                    -okcommand "if {\[info objects $this\] != {}} \
                    {eval $this modify \[$name get x\]}"
            $name centerOnScreen
        }
    }
}

#########################################################################
#### focusin
# Put the focus in the canvas.
#
body ::tycho::Graphics::focusin {} {
    # FIXME: The following does not work.  Slate gets the focus, but
    # not the canvas.
    focus $canvas
    displayer setCurrentView $viewName
}

#######################################################################
#### help
# Open a help window.
#
body ::tycho::Graphics::help {} {
    hyperJump "\$TYCHO/editors/visedit/doc/usersGuides/GraphicsHelp.html" {}
}

#######################################################################
#### insertData
# Append the specified data to the existing display.
# The data should be a list of items of the form <i>methodname args</i>,
# where <i>methodname</i> is a method of this class (i.e. any class
# derived from <code>Graphics</code>), and <i>args</i> is the
# set of arguments appropriate for that method.
#
body ::tycho::Graphics::insertData {data} {
    if [getReadOnly] {bell; return}
    foreach command $data {
        if [catch {
            eval $this $command
        } msg] {
            global ::errorInfo
            set saveErr $errorInfo
            error "Invalid item: $data\n$msg" $saveErr
        }
    }
}

#########################################################################
#### modify
# Modify the canvas by executing the arguments in the scope of this object.
# The command is identified as a distinct action for undo, the window
# is marked modified (if appropriate), the display is updated, and the
# focus is returned to this object.  If the object is read-only,
# ring the bell and return, doing nothing.
#
body ::tycho::Graphics::modify {args} {
    if $readOnly {bell; return}
    undoBoundary
    eval $this $args
    markModified
    focusin
}

#######################################################################
#### print
# Print out the graph in the canvas.
# FIXME: This should be reimplimented as a print manager class.
#
body ::tycho::Graphics::print {} {
    set w [$this windowName].print

    if [winfo exists $w] {
	wm deiconify $w
	raise $w

    } else {
	toplevel $w
        wm title $w "Print Graphics"
        wm iconname $w "Print Graphics"

	label $w.title -text "Print Graphics"
	frame $w.rotate -relief groove -bd 3
	frame $w.page
	frame $w.color -relief groove -bd 3
	frame $w.command
	frame $w.tofile
	frame $w.buttons
	pack $w.title $w.rotate $w.page $w.color $w.command $w.tofile\
		$w.buttons -side top -padx 1 -pady 3 -expand 1 -fill both

	radiobutton $w.rotate.portrait -text Portrait -value Portrait\
		-variable [scope $itk_component(hull)_rotate]
	radiobutton $w.rotate.landscape -text Landscape -value Landscape\
		-variable [scope $itk_component(hull)_rotate]
	set [scope $itk_component(hull)_rotate] Portrait
	pack $w.rotate.portrait $w.rotate.landscape -side left

	frame $w.page.pageheight
	frame $w.page.pagewidth
	frame $w.page.pagey
	frame $w.page.pagex
	pack $w.page.pageheight $w.page.pagewidth $w.page.pagey $w.page.pagex

	label $w.page.pageheight.label -text {Max. height (inches):}
	label $w.page.pagewidth.label -text {Max. width (inches) :}
	label $w.page.pagey.label -text {Verticle offset     :}
	label $w.page.pagex.label -text {Horizontal offset   :}

	foreach name {pageheight pagewidth pagey pagex} {
	    entry $w.page.${name}.entry -relief sunken -bd 2 -width 6 
	    pack $w.page.${name}.label $w.page.${name}.entry -side left
	}

	$w.page.pageheight.entry insert 0 "14.0"
	$w.page.pagewidth.entry insert 0 "8.0"
	$w.page.pagey.entry insert 0 "0.0"
	$w.page.pagex.entry insert 0 "0.0"

	label $w.command.label -text "Print Command:"
	entry $w.command.entry -relief sunken -bd 2 -width 15
	pack $w.command.label $w.command.entry -side left
	$w.command.entry insert 0 "lpr "

	radiobutton $w.color.mono -text "Black & White" -value mono\
		-variable [scope $itk_component(hull)_color]
	radiobutton $w.color.gray -text Gray -value gray\
		-variable [scope $itk_component(hull)_color]
	radiobutton $w.color.color -text Color -value color\
		-variable [scope $itk_component(hull)_color]
	set [scope $itk_component(hull)_color] mono
	pack $w.color.mono $w.color.gray $w.color.color -side left

	checkbutton $w.tofile.button -text "To file only:"\
		-variable [scope $itk_component(hull)_tofile]
	entry $w.tofile.entry -relief sunken -bd 2 -width 35
	pack $w.tofile.button $w.tofile.entry -side top -anchor w
	$w.tofile.entry insert 0 "[file rootname $file].ps"

	button $w.buttons.print -text "Print"\
		-command "$this printOut $w" -relief groove -bd 8
	button $w.buttons.cancel -text "Cancel" -command "destroy $w" -bd 5
	pack $w.buttons.print $w.buttons.cancel -fill both -expand 1\
		-side left -padx 2 -pady 2
    }
}

# FIXME: Comment needed here.
#
body ::tycho::Graphics::printOut {win} {
    set height [winfo height [canvasName]]
    if {$height == 1} {
        # Canvas has not been mapped yet
        set height [cget -canvasheight]
    }
    set width [winfo width [canvasName]]
    if {$width == 1} {
        # Canvas has not been mapped yet
        set width [cget -canvaswidth]
    }

    set pageheight [$win.page.pageheight.entry get]
    set pagewidth [$win.page.pagewidth.entry get]
    set pagey [$win.page.pagey.entry get]
    set pagex [$win.page.pagex.entry get]

    set printCmd [$win.command.entry get]

    set rotate [set [scope $itk_component(hull)_rotate]]
    if {$rotate == "Landscape"} {
	set rotate 1
    } else {
	set rotate 0
    }

    # Adjust the offset.
    set pagey [expr $pageheight/2+$pagey]
    set pagex [expr $pagewidth/2+$pagex]

    set color [set [scope $itk_component(hull)_color]]

    set ps [ [canvasName] postscript\
	     -height $height -width $width\
	     -pageheight ${pageheight}i -pagewidth ${pagewidth}i\
	     -rotate $rotate -colormode $color]

    if [set [scope $itk_component(hull)_tofile]] {
	set fileID [open [$win.tofile.entry get] w]
	puts $fileID $ps
	close $fileID

    } else {
	set tmpFile [file join /tmp [$this windowName]]
	catch {exec "rm -f $tmpFile"}

	set fileID [open $tmpFile w]
	puts $fileID $ps
	close $fileID

	eval exec "$printCmd $tmpFile"

	catch {exec "rm -f $tmpFile"}
    }

    destroy $win
}

#######################################################################
#### redo
# Execute the current command in the redo buffer.
# This method calls <code>undoBoundary</code>.
#
body ::tycho::Graphics::redo {} {
    if {$redoCommands == {} || !$interactiveEnabled} {bell; return}
    selectionClear
    set undoing 0
    undoBoundary
    # Step through the redo commands.
    foreach cmd $redoCommands {
        eval $this $cmd
    }
    set redoCommands {}
    catch {$itk_option(-top) disableMenuItem Redo Edit}
    markModified
}

#####################################################################
#### scrollQuery
# Query the user for the type of scrollbars to use.
#
body ::tycho::Graphics::scrollQuery {} {
    set name [::tycho::autoName .query]
    ::tycho::EntryQuery $name -okcommand "$this scrollSet $name"
    switch -exact [cget -scrolling] {
        bars {set default {Always use scrollbars}}
        auto {set default {Automatic scrollbars}}
        default {set default {Never use scrollbars}}
    }
    $name addRadioQuery scrolling {} [list \
            {Always use scrollbars} \
            {Automatic scrollbars} \
            {Never use scrollbars}] $default
    $name centerOnScreen
}

#####################################################################
#### scrollSet
# Set the scrolling style of the child widget depending on the user's
# response in the specified dialog box.
#
body ::tycho::Graphics::scrollSet {dialog} {
    set prevoption [cget -scrolling]
    switch -exact [$dialog get scrolling] {
        {Always use scrollbars} {set option bars}
        {Automatic scrollbars} {set option auto}
        default {set option none}
    }
    if {$option != $prevoption} {
        configure -scrolling $option
        updateScrollbars
        markModified
    }
}

#######################################################################
#### select
# Select all objects under the current mouse position that have the tag
# "selectable".  If there are none, the clear any selection.
# If the argument is non-zero, then append to the selection rather than
# replacing it.
#
body ::tycho::Graphics::select {{append 0}} {
    if !$append {
        selectionClear
    }
    set objs [findAll current selectable]
    foreach obj $objs {
        lappend selection $obj
        set bbox [component canvas bbox $obj]
        eval component canvas create rectangle $bbox -tags selectbox
        # FIXME: Put into the Tk clipboard?
    }
}

#######################################################################
#### selectionClear
# Clear the selection.
#
body ::tycho::Graphics::selectionClear {} {
    component canvas delete selectbox
    set selection {}
}

#####################################################################
#### setReadOnly
# Specify whether or not modifications are allowed in the displayed text.
# Note that this is independent of whether the associated file is readonly.
# It merely determines whether the buffer can be modified, not whether the
# file can be modified.  To control the file, use <code>toggleReadOnly</code>.
#
body ::tycho::Graphics::setReadOnly {bool} {
    ::tycho::File::setReadOnly $bool
    if [winfo exists $prefix] {
	if {$bool} {
            menubar disableMenuItem {Edit Item} Edit
            menubar disableMenuItem {Cut} Edit
            menubar disableMenuItem {Paste} Edit
	} {
            menubar enableMenuItem {Edit Item} Edit
            menubar enableMenuItem {Cut} Edit
            menubar enableMenuItem {Paste} Edit
	}
    }
}

#########################################################################
#### titleAdd
# Interactively add title information to the window. The types of title
# information directly supported and the order in which they appear are
# given by the titleTypes option. The dialog lists those of these that are
# not already specified in the canvas. If all of these are specified,
# or the optional argument is given and is non-zero, then a more
# complicated dialog is opened allowing the user to create a new title
# category. That more complicated dialog can also be opened via a
# button in the first dialog.
#
body ::tycho::Graphics::titleAdd {{newcategory 0}} {
    set name [::tycho::autoName .query]
    if !$newcategory {
        if $readOnly {bell; return}
        set titleTypes \
                [option get $itk_component(hull) titleTypes Graphics]
        set categories {}
        foreach cat $titleTypes {
            if {[$canvas find withtag $cat] == {}} {
                lappend categories $cat
            }
        }
        if {$categories != {}} {
            # The "catch" is in case the object is deleted before the dialog
            # is dismissed.
            ::tycho::EntryQuery $name -queries \
                    [list [list title {Text:} {}]] \
                    -okcommand [list catch \
                    "$this modify \
                    titleSet \[$name get category\] \[$name get title\]"]
            $name addRadioQuery category {} $categories [lindex $categories 0]
            $name addButton new -text "New Title Item" -command \
                    "$this titleAdd 1; destroy $name"
        } {
            titleAdd 1
            return
        }
    } {
        # New title category
        ::tycho::EntryQuery $name -queries [list \
                [list text {Text:} {}] \
                [list category {Tag:} {}] \
                [list below {Below tags:} {}] \
                [list color {Color:} {}] \
                [list font {Font:} {}]] \
                -okcommand [list catch \
                "$this centeredText \[$name get text\] \
                \[$name get category\] \
                \[$name get below\] \
                \[$name get color\] \
                \[$name get font\]"]
    }
    $name centerOnScreen
}

#########################################################################
#### titleSet
# Specify title information for the window. The types of title
# information directly supported and the order in which they appear are
# given by the titleTypes option. The first argument is one of these types
# or some other type (all other types will appear below titleTypes types).
# Any previous instance of such a title type will be removed.
# The second argument is the text of the title.
#
body ::tycho::Graphics::titleSet {category text} {
    # Define the order in which title categories appear by specifying tags
    # that should come before them.
    set titleTypes [option get $itk_component(hull) titleTypes Graphics]
    set idx [lsearch -exact $titleTypes $category]
    if {$idx >= 0} {
        set below [lrange $titleTypes 0 [incr idx -1]]
    } {
        set below $titleTypes
    }
    set font [option get $itk_component(hull) ${category}Font Graphics]
    set color [option get $itk_component(hull) ${category}Color Graphics]
    centeredText $text $category $below $color $font
}

#######################################################################
#### undo
# Execute the command in the undo buffer.
# This method calls <code>undoBoundary</code>.
#
body ::tycho::Graphics::undo {} {
    if {$undoCommands == {} || !$interactiveEnabled} {bell; return}
    selectionClear
    set undoing 1
    undoBoundary
    # Step through the undo commands.
    foreach cmd $undoCommands {
        if [catch {
            # NOTE: Why is $this needed?  Itcl bug?
            eval $this $cmd
        } msg] {
            set undoing 0
            global ::errorInfo
            set saveInfo $errorInfo
            error $msg $saveInfo
        }
    }
    set undoing 0
    set undoCommands {}
    catch {$itk_option(-top) disableMenuItem Undo Edit}
    markModified
}

#######################################################################
#### undoAppend
# Append a command to the end of the undo or redo buffer (the latter
# only happens if an undo is in progress). This should be called
# anytime an object is deleted, to ensure that the deletion can be
# undone. If an object is being created, call <code>register</code>
# instead.
#
body ::tycho::Graphics::undoAppend {command} {
    if !$interactiveEnabled {return}
    if $undoing {
        catch {$itk_option(-top) enableMenuItem Redo Edit}
        lappend redoCommands $command
    } {
        catch {$itk_option(-top) enableMenuItem Undo Edit}
        lappend undoCommands $command
    }
}

#######################################################################
#### undoBoundary
# Break a sequence of commands for the purposes of undo.  Any commands
# appended or prepended to the undo buffer between calls to this method
# will be undone together.
#
body ::tycho::Graphics::undoBoundary {} {
    if !$interactiveEnabled {return}
    if $undoing {
        if {$itk_option(-top) != {}} {
            catch {$itk_option(-top) disableMenuItem Redo Edit}
        }
        set redoCommands {}
    } {
        if {$itk_option(-top) != {}} {
            catch {$itk_option(-top) disableMenuItem Undo Edit}
        }
        set undoCommands {}
    }
}

#######################################################################
#### undoPrepend
# Append a command to the beginning of the undo or redo buffer (the
# latter only happens if an undo is in progress). This should be called
# anytime an object is deleted, to ensure that the deletion can be
# undone. If an object is being created, call <code>register</code>
# instead.
#
body ::tycho::Graphics::undoPrepend {command} {
    if !$interactiveEnabled {return}
    if $undoing {
        catch {$itk_option(-top) enableMenuItem Redo Edit}
        set redoCommands [concat [list $command] $redoCommands]
    } {
        catch {$itk_option(-top) enableMenuItem Undo Edit}
        set undoCommands [concat [list $command] $undoCommands]
    }
}

#########################################################################
#### updateScrollbars
# Update the range of the scrollbars so that they cover the bounding box
# of the contents of the canvas.  This should be called after each action
# that changes the bounding the box of the items in the canvas or the size
# of the canvas.
#
body ::tycho::Graphics::updateScrollbars {} {
    if {$scheduledUpdate == {}} {
        set scheduledUpdate [after idle [code $this configureScrollbars]]
    }
}

    ###################################################################
    ###################################################################
    ####                      protected methods                    ####

#####################################################################
#### addInfo
# Add or configure textual information displayed at the bottom.
# The arguments are: a name for the widget, the label to be displayed,
# the value to be displayed, an optional width field and an optional
# textual description
# If the description argument is non-empty, then when the user moves
# the mouse over the widget, the status line will have the description
# displayed in it.
# For example:
# <pre>
#    addInfo foo {Value of foobar} $foobar 3 {foobar is a variable}
# </pre>
# will create a widget with a label 'Value of foobar', a value that
# is the value of the foobar variable and displayed with a width of 3
# characters.
body ::tycho::Graphics::addInfo {tag label value {width {}} \
        {description {}}} {

    if [info exists itk_component($tag)] {
        # Display already exists.  Configure it.
        component label_$tag configure -text $label
        component value_$tag configure -text $value
        if {$description != {} } {
            bind $itk_component($tag) <Enter> \
                    "$this putStatus \"$description\" "
            bind $itk_component($tag) <Leave> \
                    "$this putStatus \"\" "
        }

    } {
        # Display does not exist. Create it.
	itk_component add $tag {
	    frame $itk_component(info).$tag
	} {
	    keep -background -cursor
	}
	pack $itk_component($tag) -side right -padx 5

        if {$description != {} } {
            bind $itk_component($tag) <Enter> \
                    "$this putStatus \"$description\" "
            bind $itk_component($tag) <Leave> \
                    "$this putStatus \"\" "
        }

        itk_component add label_$tag {
            label $itk_component($tag).label -text $label -relief flat
        } {
            keep -font -background -foreground
        }
        pack $itk_component(label_$tag) -side left

        itk_component add value_$tag {
            label $itk_component($tag).value -text $value -relief ridge
        } {
            keep -font -background -foreground
        }
        if {$width != {}} {
            component value_$tag configure -width $width
        }
        pack $itk_component(value_$tag) -side left
    }
}

#########################################################################
#### bottomOf
# Given any number of tags, return the distance from the top of the
# canvas (in pixels) of the bottom of the lowest item found in the
# canvas with one of the tags. This can be used in derived classes to
# determine the uppermost range of their drawing area (placing text
# below centered text for example). If no matching items are found,
# return 2 (suggesting two pixels of margin at the top).
#
body ::tycho::Graphics::bottomOf {args} {
    set id {}
    set bottom 2
    foreach tag $args {
        foreach item [$canvas find withtag $tag] {
            set bot [expr [lindex [$canvas bbox $item] 3]+2]
            if {$bot > $bottom} {set bottom $bot}
        }
    }
    return $bottom
}

#######################################################################
#### findAll
# Find all the items in the canvas that have all of the tags given
# as arguments.  Return a list of ids. If no tags are given as
# arguments, then return a list of all ids.  If no items have all
# the specified tags, return an empty list. Note: This will execute
# fastest if the most restrictive tag is given first.
#
body ::tycho::Graphics::findAll {args} {
    if {$args == {}} {
        return [$canvas find withtag all]
    } {
        # Get a list of all ids with the first tag.
        set ids [$canvas find withtag [lindex $args 0]]

        # Construct a list of the remaining tags
        set rest [lrange $args 1 end]

        # Construct the list to return by checking each id to
        # verify that it has all the rest of the tags.
        set toret {}
        foreach id $ids {
            set tags [$canvas gettags $id]

            # Verify that all tags in the list "rest" are in the list "tags"
            set in 1
            foreach tag $rest {
                if {[lsearch -exact $tags $tag] < 0} {
                    set in 0
                    break
                }
            }
            if $in {
                lappend toret $id
            }
        }
        return $toret
    }
}

#######################################################################
#### itemlist
# If the argument is non-null, just return it.  Otherwise, return a list
# of the ids of selected items, if there are any.  If there are also no
# selected items, return the id of the item under the cursor, if it has
# tag "selectable".  If there is also no such item, report an error.
#
body ::tycho::Graphics::itemlist {{items {}}} {
    if {$items == {}} {
        set items [selected]
        if {$items == {}} {
            set items [findAll current selectable]
        }
    }
    if {$items == {}} {
        error "No item selected"
    }
    return $items
}

#######################################################################
#### paste
# Paste the items in the clipboard by executing the commands stored
# in the clipboard in the context of the current object.  If an error
# occurs doing this, then assume that the item in the clipboard is raw
# text, and insert it into the canvas as a label.
#
body ::tycho::Graphics::paste {} {
    set cmds [getClipboard]
    if {$cmds != {}} {
        foreach cmd $cmds {
            if [catch {
                eval $this $cmd
            } msg] {
                # FIXME: Insert text label
                ::tycho::warn "ignoring for now: $cmds\n$msg"
                break
            }
        }
    }
}

#######################################################################
#### register
# Register the creation, undo, deletion, and (optionally) edit commands for
# an item in the canvas. This is necessary for the item to be saved when
# the canvas is saved to a file. It also permits cut, copy, undo, and redo
# to work with this item. The first argument is the id of a representative
# canvas item. This need not be the only item associated with the
# object being registered. The representative item should normally have
# the tag "selectable". The second argument is a command (a method
# invocation actually) that can be used to recreate the item. When
# recreating the item, that command will be invoked verbatim as a
# method of this object. That command should, as a side effect, also
# register items it creates. The third argument is a command
# to undo the creation of the object. This may, for example, restore
# some previous item, in which case the command should register the new
# item.  The fourth argument is a command to delete the object, which
# will be used to delete or cut the object. This may be the same as
# the undo command, and should have the side effect of calling
# <code>appendUndo</code> to enable undoing the deletion.  The
# <code>delete</code> method provides a convenient way to do this.
# The final argument is an optional edit command.  That command will
# be invoked to edit the item.
# That command should, as a side effect, append to the undo buffer a
# command that will undo the editing operation.
#
body ::tycho::Graphics::register {id create undo remove {edit {}}} {
    set itemCreate($id) $create
    set itemDelete($id) $remove
    undoPrepend $undo
	set itemEdit($id) $edit
}

#######################################################################
#### saveText
# Return the text to be saved.
#
body ::tycho::Graphics::saveText {} {
    # Insert carriage returns between list elements.
    set dsc {}
    foreach cmd [describe] {
        append dsc "{$cmd}"
        append dsc "\n"
    }
    return $dsc
}

    ###################################################################
    ###################################################################
    ####                      private methods                      ####

#########################################################################
#### configureScrollbars
# This method does the work of updateScrollbars, and should be called
# via updateScrollbars.
#
body ::tycho::Graphics::configureScrollbars {} {
    set bwidth 0
    set bheight 0
    set bbox [$canvas bbox all]
    if {$itk_option(-scrolling) == {auto}} {
        set cwidth [winfo width $canvas]
        if {$cwidth == 1} {
            # The canvas has not been mapped yet.  Use the requested width.
            set cwidth [cget -canvaswidth]
        }
        set cheight [winfo height $canvas]
        if {$cheight == 1} {
            # The canvas has not been mapped yet.  Use the requested width.
            set cheight [cget -canvasheight]
        }
    
        if {$bbox != {}} {
            # So that the scrollbars don't move to the edge of the contents
            set marg 4
            set bbox [list [expr [lindex $bbox 0] - $marg] \
                    [expr [lindex $bbox 1] - $marg] \
                    [expr [lindex $bbox 2] + $marg] \
                    [expr [lindex $bbox 3] + $marg]]
        }

        if {$bbox != {}} {
            set bwidth [expr [lindex $bbox 2] - [lindex $bbox 0]]
            set bheight [expr [lindex $bbox 3] - [lindex $bbox 1]]
        }
    } {
        set cwidth 1
        set cheight 1
    }
    if {$itk_option(-scrolling) == {bars} || \
            $bwidth > $cwidth || \
            $bheight > $cheight} {
        pack $itk_component(vsb) -side right -fill y -expand 0 \
                -before $itk_component(canvas)
        pack $itk_component(hsb) -side left -fill x -expand 1
        set fillwidth [winfo reqwidth $itk_component(vsb)]
        $itk_component(filler) configure -width $fillwidth
        pack $itk_component(filler) -side right -expand 0
    
        $canvas configure -scrollregion $bbox
    } {
        if [winfo ismapped $itk_component(vsb)] {
            pack forget $itk_component(vsb)
            pack forget $itk_component(hsb)
            pack forget $itk_component(filler)
            # Unpack and repack bottom so that it shrinks
            pack forget $itk_component(bottom)
            pack $itk_component(bottom) -fill both -side bottom \
                    -before $itk_component(top)
        }
    }
    set scheduledUpdate {}
}
