# Spell checker associated with an EditText widget.
#
# @Author: Edward A. Lee
#
# @Version: $Id$
#
# @Copyright (c) %Q% The Regents of the University of California.
# All rights reserved.
# 
# Permission is hereby granted, without written agreement and without
# license or royalty fees, to use, copy, modify, and distribute this
# software and its documentation for any purpose, provided that the
# above copyright notice and the following two paragraphs appear in all
# copies of this software.
# 
# IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY
# FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
# ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF
# THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.
# 
# THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE
# PROVIDED HEREUNDER IS ON AN "AS IS" BASIS, AND THE UNIVERSITY OF
# CALIFORNIA HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,
# ENHANCEMENTS, OR MODIFICATIONS.
# 
# 						PT_COPYRIGHT_VERSION_2
# 						COPYRIGHTENDKEY
##########################################################################

# Default width (in characters) of the entry boxes.
option add *EditSpell.entryWidth 30 widgetDefault

# Color of the entry box background
option add *EditSpell.entryBackground \
	[ptkColor antiqueWhite white] widgetDefault

option add *EditSpell.entryfont [.tychoFonts defaultFont fixed]

# Colors for spelling errors
option add *EditSpell.spellMatchBackgroundColor \
        [ptkColor red4 black] widgetDefault
option add *EditSpell.spellMatchForegroundColor \
        [ptkColor white white] widgetDefault

##########################################################################
#### EditSpell class.
# This class provides a dialog box for checking the spelling in a
# text editor.  Depending on the text editor, a subset of the text might
# be checked.  For example, for programming language editors, comments are
# typically spell checked.
# <p>
# This dialog box should be child window of the
# EditText widget or its top-level window so that it is removed when
# the parent is removed. To do this, just give it a name that is the
# name of the EditText window (or its top-level parent) with an
# additional field appended after a period. For example, if the name of
# the top-level object is ".file0", the search object could be
# ".file0.search". Note that this is a UNIX-specific spell checker.
#
class ::tycho::EditSpell {
    inherit ::tycho::EntryQuery

    constructor {args} {}

    #################################################################
    ####                        options                          ####

    # Specify the associated EditText object.
    itk_option define -edittext edittext EditText {}

    # Specify whether changes are allowed in the text being checked.
    itk_option define -nochange nochange NoChange 0

    ##################################################################
    ####                     public methods                       ####

    # Clear the spelling error marks on the associated text window.
    method clearSpellMatch {}

    # Open the personal dictionary for editing.
    method dictionary {}

    # Add to the personal dictionary the word currently in the misspell window.
    method learn {}

    # Find the next misspelling and query the user for a replacement.
    method next {}

    # Check the spelling from the beginning.
    method recheck {}

    # Replace the selection with a spelling correction.
    method replace {}

    ###################################################################
    ####                      private variables                    ####

    # Where we are in the search.
    private variable upto {}

    # For unique temporary file names
    private common count 0

    ###################################################################
    ####                      private methods                      ####

    # Read items from the personal dictionary.
    private method readDictionary {}

    # Sort and write a list to the private dictionary
    private method writeDictionary {dict}
}

#####################################################################
#### -edittext option
# Set the associated EditText widget.
# 
configbody ::tycho::EditSpell::edittext {
    if {$itk_option(-edittext) == {} || \
	    [::info objects $itk_option(-edittext)] == {} || \
	    ![$itk_option(-edittext) isa ::tycho::EditText]} {
	error "EditSpell::find: Invalid -edittext option: \
		$itk_option(-edittext)"
    }
}

#####################################################################
#### constructor
#
body ::tycho::EditSpell::constructor {args} {

    configure -queries {
	{word {Mispelling:} {}}
    }

    eval itk_initialize $args

    $itk_component(bbox) buttonconfigure ok \
	    -text {Next <Ret>} \
	    -command "$this busy next"

    addButton clear -text {Clear Marks} \
	    -command "$this clearSpellMatch"

    addButton recheck -text {Recheck} \
	    -command "$this busy recheck"

    if {$itk_option(-nochange) == 0} {
	addButton replace -text {Change <M-Ret>} \
		-command "$this replace"
	bind $itk_component(hull) <Meta-Return> \
		"$this replace; break"
    }

    #
    # Create a button box for dictionary buttons
    #
    itk_component add dbox {
	button $itk_component(childsite).dbox -text {Dictionary}\
		-command "$this dictionary" -pady 0 -width 14
    } {
	keep -background -cursor
    }
    pack $itk_component(dbox) -side right -before $itk_component(word)

    itk_component add lbox {
	button $itk_component(childsite).lbox -text {Learn} \
		-command "$this learn" -pady 0 -width 14
    } {
	keep -background -cursor
    }
    pack $itk_component(lbox) -side right -before $itk_component(word)
}

##################################################################
####                     public methods                       ####

#####################################################################
#### clearSpellMatch
# Clear the highlighting in the text window due to the spell check.
# 
body ::tycho::EditSpell::clearSpellMatch {} {
    set tw $itk_option(-edittext)
    [$tw textWinName] tag remove spellmatch 1.0 end
}

#####################################################################
#### dictionary
# Open the personal dictionary for editing, and issue some instructions
# to the user.
# 
body ::tycho::EditSpell::dictionary {} {
    ::tycho::File::makeTychoDir
    ::tycho::File::openContext "~/.Tycho/tychodict.lst"
    ::tycho::post {You must save your changes and \
	    recheck for them to take effect}
}

#####################################################################
#### learn
# Add to the personal dictionary the word currently in the misspell window.
# Then move to the next spelling error. The dictionary file is
# sorted while we are at it.
# 
body ::tycho::EditSpell::learn {} {
    set changeto [get word]
    if {$changeto != {}} {
	set dict [readDictionary]
	if {[lsearch -exact $dict $changeto] == -1} {
	    lappend dict $changeto
	    writeDictionary $dict
	}
    }
    next
}

#####################################################################
#### next
# Find the next misspelling and query the user for a replacement.
# The first time this is called, it calls "recheck," which actually
# checks the spelling.
# 
body ::tycho::EditSpell::next {} {
    if {$upto == {}} {
	recheck
    } {
	set tw $itk_option(-edittext)
	set tx [$tw textWinName]
	set range [$tx tag nextrange spellmatch $upto]
	if {$range == {}} {
	    if [::tycho::askuser "End of file.  Start at the top?"] {
		set range [$tx tag nextrange spellmatch 1.0]
		if {$range == {}} {
		    # No more errors tagged.  Recheck
		    recheck
		    return
		}
	    } {
		return
	    }
	}
	set start [lindex $range 0]
	set end [lindex $range 1]
	$tx mark set insert $start
	$tx see $start
	selection clear -displayof $tx
	$tx tag add sel $start $end
	clear word
	insert word [$tw getSelection]
	set upto $end
    }
}

#####################################################################
#### recheck
# Check the spelling from the beginning.
# 
body ::tycho::EditSpell::recheck {} {
    set tw $itk_option(-edittext)

    set filename "/tmp/tychoSpell[pid]x[incr count]"
    if {![$tw busy writeSpellText $filename]} {return}
    set errs [exec spell $filename]
    set dict [readDictionary]
    foreach exception $dict {
	if {[set idx [lsearch -exact $errs $exception]] >= 0} {
	    set errs [lreplace $errs $idx $idx]
	}
    }
    if {$errs == {}} {
	::tycho::inform "Spelling OK."
	return
    }
    exec rm $filename
    set pattern [join $errs |]
    set tags [$tw spellCheckTags]

    # Search is case sensitive, regexp, and wholeword.
    $tw findAll spellmatch 1 1 1 $pattern 1.0 end $tags
    set text [$tw textWinName]
    set result [$text tag nextrange spellmatch 1.0]
    if {$result == {}} {
        # This should not happen.
	error "Can't match reported spelling errors with text: $errs"
    } {
	set upto [lindex $result 0]
        # Set up reverse video for the found text. First lower the
        # priority of the tag so selection is still visible as normal.
        $text tag raise sel spellmatch
        $text tag configure spellmatch \
                -background [option get $itk_component(hull) \
                spellMatchBackgroundColor EditSpell]
        $text tag configure spellmatch \
                -foreground [option get $itk_component(hull) \
                spellMatchForegroundColor EditSpell]
        next
    }
}

#####################################################################
#### replace
# Replace the selection with a spelling correction.
# Then move to the next spelling error.
# 
body ::tycho::EditSpell::replace {} {
    set editWindow $itk_option(-edittext)

    set changeto [get word]
    if {[$editWindow getSelection] != {}} {
	$editWindow deleteRange sel.first sel.last
	$editWindow insertString insert $changeto
    } {
	error "No selection to change"
    }
    next
}

#####################################################################
#####################################################################
####                       private methods                       ####

#####################################################################
#### readDictionary
# Read the personal dictionary file and return the list of entries.
# If there is no personal dictionary, return the empty list.  If the
# file exists, but is not readable, issue a warning.
# 
body ::tycho::EditSpell::readDictionary {} {
    ::tycho::File::makeTychoDir
    set dictfile {~/.Tycho/tychodict.lst}
    if {[file exists $dictfile]} {
	if {[file readable $dictfile]} {
	    set fd [open $dictfile]
	    set dict [read $fd]
	    close $fd
	    return $dict
	} {
	    ::tycho::warn "Personal dictionary file, ~/.Tycho/tychodict.lst, \
		    is not readable"
	}
    }
    return {}
}

#####################################################################
#### writeDictionary
# Write the specified list to the personal dictionary file. First the
# list is sorted to put in alphabetical order. If we cannot create a
# personal dictionary trigger an error.
# 
body ::tycho::EditSpell::writeDictionary {dict} {
    ::tycho::File::makeTychoDir
    set dictfile {~/.Tycho/tychodict.lst}
    set fd [open $dictfile w]
    set sorted [lsort $dict]
    foreach item $sorted {
	puts $fd $item
    }
    close $fd
}
