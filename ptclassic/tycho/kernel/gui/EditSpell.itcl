# Spell checker associated with an EditText widget.
#
# @Author: Edward A. Lee
#
# @Version: $Id$
#
# @Copyright (c) %Q% The Regents of the University of California.
# All rights reserved.
# 
# Permission is hereby granted, without written agreement and without
# license or royalty fees, to use, copy, modify, and distribute this
# software and its documentation for any purpose, provided that the
# above copyright notice and the following two paragraphs appear in all
# copies of this software.
# 
# IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY
# FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
# ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF
# THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.
# 
# THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE
# PROVIDED HEREUNDER IS ON AN "AS IS" BASIS, AND THE UNIVERSITY OF
# CALIFORNIA HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,
# ENHANCEMENTS, OR MODIFICATIONS.
# 
# 						PT_COPYRIGHT_VERSION_2
# 						COPYRIGHTENDKEY
##########################################################################

# Default width (in characters) of the entry boxes.
option add *EditSpell.entryWidth 30 widgetDefault

# Color of the entry box background
option add *EditSpell.entryBackground \
	[ptkColor antiqueWhite white] widgetDefault

option add *EditSpell.entryfont [.tychoFonts defaultFont fixed]

##########################################################################
#### EditSpell class.
# Create a dialog box for checking the spelling in an EditText widget.
# This dialog box should be child window of the EditText widget or its
# top-level window so that it is removed when the parent is removed.
# Note that this is a UNIX-specific spell checker.
#
class ::tycho::EditSpell {
    inherit ::tycho::EntryQuery

    constructor {args} {}

    #################################################################
    ####                        options                          ####

    # The associated EditText object.
    itk_option define -edittext edittext EditText {}

    # Check spelling, but do not allow changes.
    itk_option define -nochange nochange NoChange 0

    ##################################################################
    ####                     public methods                       ####

    # Clear the spelling error marks on the associated text window.
    method clearFindMatch

    # Open the personal dictionary for editing.
    method dictionary {}

    # Add to the personal dictionary the word currently in the misspell window.
    method learn {}

    # Find the next misspelling and query the user for a replacement.
    method next {}

    # Check the spelling from the beginning.
    method recheck {}

    # Replace the selection with the contents of the entry query.
    method replace {}

    ###################################################################
    ####                      protected variables                  ####

    # Keep common configuration information
    protected common dictsw 0

    # Where we are in the search.
    protected variable upto {}

    # For unique temporary file names
    protected common count 0

    ###################################################################
    ####                      private methods                      ####

    # Read items from the personal dictionary.
    private method readDictionary {}

    # Sort and write a list to the private dictionary
    private method writeDictionary {dict}
}

#####################################################################
#### -edittext option
# Set the associated EditText widget.
# 
configbody ::tycho::EditSpell::edittext {
    if {$itk_option(-edittext) == {} || \
	    [::info objects $itk_option(-edittext)] == {} || \
	    ![$itk_option(-edittext) isa ::tycho::EditText]} {
	error "EditSpell::find: Invalid -edittext option: \
		$itk_option(-edittext)"
    }
}

#####################################################################
#### constructor
#
body ::tycho::EditSpell::constructor {args} {

    configure -queries {
	{word {Mispelling:} {}}
    }

    eval itk_initialize $args

    $itk_component(bbox) buttonconfigure ok \
	    -text {Next <Ret>} \
	    -command "$this busy next"

    addButton clear -text {Clear Marks} \
	    -command "$this clearFindMatch"

    addButton recheck -text {Recheck} \
	    -command "$this busy recheck"

    if {$itk_option(-nochange) == 0} {
	addButton replace -text {Change <M-Ret>} \
		-command "$this replace"
	bind $itk_component(hull) <Meta-Return> \
		"$this replace; break"
    }

    #
    # Create a button box for dictionary buttons
    #
    itk_component add dbox {
	button $itk_component(childsite).dbox -text {Dictionary}\
		-command "$this dictionary" -pady 0 -width 14
    } {
	keep -background -cursor
    }
    pack $itk_component(dbox) -side right -before $itk_component(word)

    itk_component add lbox {
	button $itk_component(childsite).lbox -text {Learn} \
		-command "$this learn" -pady 0 -width 14
    } {
	keep -background -cursor
    }
    pack $itk_component(lbox) -side right -before $itk_component(word)
}

##################################################################
####                     public methods                       ####

#####################################################################
#### clearFindMatch
# Clear the highlighting in the text window due to the spell check.
# 
body ::tycho::EditSpell::clearFindMatch {} {
    set tw $itk_option(-edittext)
    $tw clearFindMatch
}

#####################################################################
#### dictionary
# Open the personal dictionary for editing, and issue some instructions
# to the user.
# 
body ::tycho::EditSpell::dictionary {} {
    ::tycho::File::openContext "~/.tychodictionary.lst"
    ::tycho::post {You must save your changes and \
	    recheck for them to take effect}
}

#####################################################################
#### learn
# Add to the personal dictionary the word currently in the misspell window.
# Then move to the next spelling error. The dictionary file is
# sorted is sorted while we are at it.
# 
body ::tycho::EditSpell::learn {} {
    set changeto [get word]
    if {$changeto != {}} {
	set dict [readDictionary]
	if {[lsearch -exact $dict $changeto] == -1} {
	    lappend dict $changeto
	    writeDictionary $dict
	}
    }
    next
}

#####################################################################
#### next
# Find the next misspelling and query the user for a replacement.
# The first time this is called, it calls "recheck," which actually
# checks the spelling.
# 
body ::tycho::EditSpell::next {} {
    if {$upto == {}} {
	recheck
    } {
	set tw $itk_option(-edittext)
	set tx [$tw textWinName]
	set range [$tx tag nextrange findmatch $upto]
	if {$range == {}} {
	    if [::tycho::askuser "End of file.  Start at the top?"] {
		set range [$tx tag nextrange findmatch 1.0]
		if {$range == {}} {
		    # No more errors tagged.  Recheck
		    recheck
		    return
		}
	    } {
		return
	    }
	}
	set start [lindex $range 0]
	set end [lindex $range 1]
	$tx mark set insert $start
	$tx see $start
	selection clear -displayof $tx
	$tx tag add sel $start $end
	clear word
	insert word [$tw getSelection]
	set upto $end
    }
}

#####################################################################
#### recheck
# Check the spelling from the beginning.
# 
body ::tycho::EditSpell::recheck {} {
    set tw $itk_option(-edittext)

    set filename "/tmp/tychoSpell[pid]x[incr count]"
    if {![$tw busy writeSpellText $filename]} {return}
    set errs [exec spell $filename]
    set dict [readDictionary]
    foreach exception $dict {
	if {[set idx [lsearch -exact $errs $exception]] >= 0} {
	    set errs [lreplace $errs $idx $idx]
	}
    }
    if {$errs == {}} {
	::tycho::inform "Spelling OK."
	return
    }
    exec rm $filename
    set pattern [join $errs |]
    set tags [$tw spellCheckTags]

    set result [$tw find -forwards -regexp -wholeword \
	    -tags $tags $pattern 1.0]
    if {$result == {}} {
	error "Can't match reported spelling errors with text: $errs"
    } {
	set upto [[$tw textWinName] index \
		"[lindex $result 0] + [lindex $result 1] chars"]
	clear word
	insert word [$tw getSelection]
	return 1
    }
}

#####################################################################
#### replace
# Replace the selection with the contents of the entry query.
# Then move to the next spelling error.
# 
body ::tycho::EditSpell::replace {} {
    set editWindow $itk_option(-edittext)

    set changeto [get word]
    if {[$editWindow getSelection] != {}} {
	$editWindow deleteRange sel.first sel.last
	$editWindow insertString insert $changeto
    } {
	error "No selection to change"
    }
    next
}

#####################################################################
#####################################################################
####                       private methods                       ####

#####################################################################
#### readDictionary
# Read the personal dictionary file and return the list of entries.
# If there is no personal dictionary, return the empty list.  If the
# file exists, but is not readable, issue a warning.
# 
body ::tycho::EditSpell::readDictionary {} {
    set dictfile {~/.tychodictionary.lst}
    if {[file exists $dictfile]} {
	if {[file readable $dictfile]} {
	    set fd [open $dictfile]
	    set dict [read $fd]
	    close $fd
	    return $dict
	} {
	    ::tycho::warn "Personal dictionary file, ~/.tychodictionary.lst, \
		    is not readable"
	}
    }
    return {}
}

#####################################################################
#### writeDictionary
# Write the specified list to the personal dictionary file. First the
# list is sorted to put in alphabetical order. If we cannot create a
# personal dictionary trigger an error.
# 
body ::tycho::EditSpell::writeDictionary {dict} {
    set dictfile {~/.tychodictionary.lst}
    set fd [open $dictfile w]
    set sorted [lsort $dict]
    foreach item $sorted {
	puts $fd $item
    }
    close $fd
}
