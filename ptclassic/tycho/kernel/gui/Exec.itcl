# Ptolemy Tycho class that exec's a process and displays the output
#
# @Author: Christopher Hylands and Kevin Chang
#
# @Version: $Id$
#
# @Copyright (c) 1996-%Q% The Regents of the University of California.
# All rights reserved.
#
# Permission is hereby granted, without written agreement and without
# license or royalty fees, to use, copy, modify, and distribute this
# software and its documentation for any purpose, provided that the above
# copyright notice and the following two paragraphs appear in all copies
# of this software.
#
# IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY
# FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
# ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF
# THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.
#
# THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE
# PROVIDED HEREUNDER IS ON AN "AS IS" BASIS, AND THE UNIVERSITY OF
# CALIFORNIA HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,
# ENHANCEMENTS, OR MODIFICATIONS.
# 
#                                        PT_COPYRIGHT_VERSION_2
#                                        COPYRIGHTENDKEY
#######################################################################

##############################################################################
#### tyexec
# Invoke an external program, passing it the specified arguments.
# The format of the command is exactly that of the Tcl "exec" command.
# The main purpose of this procedure is to generate an informative
# error message if the "exec" fails.
#
proc ::tycho::tyexec { args } {
    global tcl_platform
    if {$tcl_platform(platform) == "macintosh"} {
	error "Sorry, the tcl \"exec\" command is not supported on the\
		Macintosh.\nThe command:\n$args\ncannot be executed"
    }
    # NOTE: Unix-ism.
    if [catch {eval exec $args} msg] {
        # The command failed.  It would be nice to check to see
        # whether the program exists, and generate a suitable message,
        # but it's not clear how to do this.
        error "The following command invocation failed:\n \
                $args\n \
                Is the program [lindex $args 0] installed and in your path?\n \
                $msg"
    }
}

#######################################################################
#### execModal
# Short cut to run a Modal Exec by creating an Exec widget,
# automatically starting and automatically exiting.
# If you call this proc with no arguments, then 'make' is run. 
#
# This proc returns a two element list, the first element is 
# the state of the Exec widget, either "running", "abnormal, or "normal"
# The second element of the list is the name of the Exec widget
# that was created.  If this proc is called with the third argument *execWidget*
# being a non-empty string, then the Exec widget named by *execWidget*
# is reused.  If the third argument is the empty string, then
# a new Exec widget is created.
#
# Here's an example:
# <tcl></pre>
# set retVal [::tycho::execModal {ls -l} {/tmp}]
# ::tycho::execModal {} {} [lindex $retVal 1]
# </pre></tcl>
# The above example runs <code>ls -l</code> the first time, then
# the user can edit the command to a different command and then
# the command is run.  If the user did not edit the command then
# <code>ls -l</code> is rerun.
#
proc ::tycho::execModal {{command {}} {dir {}} {execWidget {}}} {
    if {$execWidget == {}} {
        set win [::tycho::autoName .makeExec]
        #set execWidget [::tycho::Exec $win]
        set execWidget [::tycho::Monitor $win]
    }

    if {$command != {} } {
	$execWidget configure -command $command
    }
    if {$dir != {} } {
	$execWidget configure -dir $dir
    }
    $execWidget raiseWindow
    $execWidget execProcessInMonitor

    #This is the modal mode, which we don't use anymore
    #::tycho::Dialog::wait $win

    # Get the name of the variable that will contain the status of 
    # exec after the exec is deleted
    set statusVariableName [$execWidget getStatusVariableName]
    global $statusVariableName
    
    # If statement is used to prevent crashing
    if [info exists $statusVariableName] {
        #uplevel #0 [tkwait variable $statusVariableName]
        # Get the return value and unset the variable that contained it
        #set retval [uplevel #0 "set $statusVariableName"]
        #return [list $retval $execWidget]
        return [list [$execWidget getStatusWait] $execWidget]
    } else {
        error "ERROR IN execModal: $statusVariableName doesn't exist!"
    }
}

#######################################################################
#### Exec
# Exec a process, and if there is output, display the output.
# See
# <a href="../internals/exec.html">$TYCHO/kernel/doc/internals/exec.html</a>
# for further documentation.
#
# This is the basic non-graphical based Exec.

class ::tycho::Exec {
    ###################################################################
    ####                         private variables                 ####

    # The name of the global variable that will contain the exit status.
    # This line here is a hack, does it still have functionality???
    public variable statusVariableName {}

    # File descriptor of the process. Process id is simply pid = [pid $fd]
    private variable fd {}

    # History is the buffer (used to be just history in Tk canvas)
    # Otheres used to be embedded in Tk, now they're simply variables
    private variable history {}
    private variable commandToExec {}
    private variable dirToExecFrom {}
    private variable maxLineAllow {}
    private variable linecount 0
    # Commands to execute from 3rd party methods
    private variable doWhenDone {}
    private variable doEachLine {}

    #inherit ::tycho::Query
    constructor {command dir maxline} {}
    destructor {}
    
    ###################################################################
    ####                         public methods                    ####

    # Exec a process, if there is any output, save it to history.
    # The arguments are: command line, directory name, and maximum lines
    # of output allowed.
    method execProcess {command dir maxline}
    # Stop a process now.
    method killProcess {parent}

    # Get the contents of the history window, if any.
    method getHistory {{start 0.0} {end end}} {}
    method clearHistory {} {set history {}; set maxLineAllow 0}
    method addHistory {line} {}

    # Read from the file descriptor, and close if we are at eof.
    method readOrClose {fd}

    # Set the action for each output from the execution
    method doEachLine {action} {set doEachLine $action}
    method doWhenDone {action} {set doWhenDone $action}

    # Get the name of the global variable that will contain the return status.
    method getStatusVariableName {} {return $statusVariableName}

    # Get the immediate status
    method getStatusNow {} {
        global $statusVariableName
        return [uplevel #0 "set $statusVariableName"]
    }
    # Wait patiently until the forked process ends and returns status
    # Default wait time is 30 seconds
    method getStatusWait {{timeToWait 30000} } {
        global $statusVariableName
        after $timeToWait set $statusVariableName "timeout"
        tkwait variable $statusVariableName
        if {[uplevel #0 "set $statusVariableName"]=="timeout"} {
            addHistory "Timeout after $timeToWait\n"
            killProcess "$this and ::getStatusWait"
        }
        return [getStatusNow]
    }

    # Open a help window.
    method help {}

    ###################################################################
    ####                         public procs                       ####

    # Return 1 if the Exec widget will work on the current platform
    proc execWidgetIsSupported {} 
}

# For some reason this is needed within the constructor, or else
# it doesn't work.
proc setGlobal {name value} {
    global $name
    set $name $value
}

#######################################################################
#### constructor
#
body ::tycho::Exec::constructor { {cmd make} {dir {}} {maxline {}} } {
    set history {}

    set commandToExec $cmd
    set dirToExecFrom $dir
    set maxLineAllow $maxline

    set statusVariableName [::tycho::autoName gExecStatus]

    #the following lines do not work for some reason!
    #global $statusVariableName
    #set $statusVariableName "constructed"
    setGlobal $statusVariableName "constructed"
}

#######################################################################
#### destructor
#
body ::tycho::Exec::destructor {} {
    # Adding this close seems to hang the window manager
    #close $fd
    # Unregister our fileevent handler
    catch {fileevent $fd readable {}}

    # Mark the editor as unmodified so that we are not prompted as
    # to whether we want to save it.
    catch {unset ::tycho::Exec::$statusVariableName}
}



    ###################################################################
    ###################################################################
    ####                      public methods                       ####

#######################################################################
#### execProcess
# Execute a process.  If there is any output, append to history
#
body ::tycho::Exec::execProcess { {cmd {}} {dir {}} {maxline {999999}} } {
    clearHistory
    global $statusVariableName
    if {[uplevel #0 "set $statusVariableName"] == "running"} {
        error "Sorry, process is already running"
    }

    # Manually set the command, or use the previous value
    if {$cmd != {}} {set commandToExec $cmd}
    if {$dir != {}} {set dirToExecFrom $dir}
    if {$maxline != {}} {set maxLineAllow $maxline}

    # If necessary, cd to the proper directory.
    if { $dirToExecFrom != {} } {
        set saveDir [pwd]
        cd "$dirToExecFrom"
    }

    # Add command to history log...
    #$itk_component(history) insertData "<<Running: [get commandToExec]>>\n"
    addHistory "<<Running: $commandToExec in $dirToExecFrom>>\n"

    #set continue 0
    #after 1000 set continue 1
    #tkwait variable continue
    ::tycho::safeUpdate $this

    # Open a non-blocking pipe from the command
    # FIXME: Unixism - Brent Welch says to use '|& cat' here to get standard
    # error.  However, this presupposes that 'cat' is a command, which might
    # not be true under Windows or Macintosh.
    if [catch {set fd [open \
	    [concat "|$commandToExec |& cat"] {RDONLY NONBLOCK}]} errMsg] {
        addHistory "$errMsg\n"
	error "$errMsg"   ;#This exits this procedure
    }

    # Register our file event handler
    fileevent $fd readable "$this readOrClose $fd"

    # Go back to our original directory before the execution
    if { $dirToExecFrom != {} } {
        cd "$saveDir"
    }

    global $statusVariableName
    set $statusVariableName "running"
    return $statusVariableName
}


#####################################################################
#### stopExec
# Manually force stop the process
#
body ::tycho::Exec::killProcess {{parent {}}} {
    global $statusVariableName
    if {[uplevel #0 "set $statusVariableName"]=="killed"} {
        error "Process already killed."
    }
    catch {close $fd}
    if {$parent=={}} {
        addHistory "<<Process killed>>\n"
    } else {
        addHistory "<<Process killed by $parent>>\n"
    }

    set $statusVariableName "killed"
    if {$doWhenDone!={}} {eval $doWhenDone}
}


#####################################################################
#### getHistory
# Return the contents of the history buffer, if any.
# 
body ::tycho::Exec::getHistory {{start 0.0} {end end}} {
    #return [$itk_component(history) get $start $end]
    #FIXME: return according to start and end
    return $history
}
#####################################################################
#### getHistory
# Return the contents of the history buffer, if any.
# 
body ::tycho::Exec::addHistory {line} {
    append history "$line" ;# Note: carriage return must be explicitly used!!!
    # This is for outer interface (ie. scribbling notes, etc)
    if {$doEachLine!={}} {eval $doEachLine}
}

######################################################################
#### help
# Open a help window.
#
body ::tycho::Exec::help {} {
    global ::TYCHO
    ::tycho::File::openContext \
	    [file join $TYCHO kernel doc usersGuides ExecHelp.html]
}


#####################################################################
#### readOrClose
# Read from the file descriptor.  If we are at the end of file, then
# close it.  It is expected that the name of this method will be passed
# to fileevent.
# Note that this should be a protected method, but 'fileevent' calls
# things in the global scope.
#
body ::tycho::Exec::readOrClose {fd} {
    global $statusVariableName

    incr linecount            ;# Do not exceed maxLineAllow
    # Check if the command outputs more lines than we want.
    if {$maxLineAllow != {}} {
        if {$linecount > $maxLineAllow} {
            killProcess $this
            set msg "Command '$commandToExec'\
                    exceeded maximum lines ($maxLineAllow) allowed."
            addHistory $msg
            error $msg
        }
    }

    # We append history here.
    set line [gets $fd]
    addHistory "$line\n"

    # If we are at the end of the file, close the descriptor.
    # See the man page for the fileevent tcl command.
    if [eof $fd] {
        #config -cursor $oldCursor
        if ![catch {close $fd} errMsg] {
            set $statusVariableName "normal"
	    addHistory "<<Process exited Normally>>\n"
            #if {[get autoDestroy] == "Yes" } {
            #    after 5000 delete object $this
            #}
        } else {
            set $statusVariableName "abnormal"
	    addHistory "<<Process exited Abnormally>>\n"
        }
        # Action to perform when done (ie. parse the entire output, etc...)
        if {$doWhenDone!={}} {eval $doWhenDone}
    }
}

    ###################################################################
    ###################################################################
    ####                      public procs                          ####

#####################################################################
#### execWidgetIsSupported
# Return 1 if the Exec widget will work on the current platform, otherwise
# return 0.
#
body ::tycho::Exec::execWidgetIsSupported {} {
    global tcl_platform
    global tcl_platform
    switch $tcl_platform(platform) {
	macintosh {
	    return 0
	}
	unix {
	    return 1
	}
	windows {
	    return 0
	}
    }
}
