# Definition of a basic window with a menu bar and dismiss button
#
# Author: Edward A. Lee
# Contributors: Joel King
#
# Version: $Id$
#
# Copyright (c) 1990-%Q% The Regents of the University of California.
# All rights reserved.
# 
# Permission is hereby granted, without written agreement and without
# license or royalty fees, to use, copy, modify, and distribute this
# software and its documentation for any purpose, provided that the
# above copyright notice and the following two paragraphs appear in all
# copies of this software.
# 
# IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY
# FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
# ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF
# THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.
# 
# THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE
# PROVIDED HEREUNDER IS ON AN "AS IS" BASIS, AND THE UNIVERSITY OF
# CALIFORNIA HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,
# ENHANCEMENTS, OR MODIFICATIONS.
# 
# 						PT_COPYRIGHT_VERSION_2
# 						COPYRIGHTENDKEY
#######################################################################

#### Options

#### autoSaveInterval option
# The auto-save interval in minutes.  A value of zero means no auto-save.
option add *File.autoSaveInterval 5 widgetDefault

#######################################################################
#### File
# This class defines a window that contains a menu bar with associated
# file commands at the top and a dismiss button at the bottom. It is
# designed to be the parent window for any editor that stores its
# results in files. If the data is marked modified and the object is
# destroyed, the user is queried to save the file. A safety copy of
# the file is made automatically periodically with an interval given
# by the -autosaveinterval option.  If the compiled version of Tycho is
# used (for example, running it with Ptolemy), then crash recovery files
# are also automatically created if the program crashes.
# <p>
# Three menu buttons are put at the top of the window.
# The File menu contains commands to open a file, insert a file,
# save data to a file, save as some other file name, print,
# evaluate the data, reload the last saved version,
# close the window, and exit the application.
# The Window menu contains commands to open new (blank) top-level
# windows of all types that have been registered with the File class
# using its registerEditor procedure.  It also contains commands to
# bring to the foreground all open top-level editors that have a file
# name associated with them.  Note that editors with the default name
# "NoName" do not appear on this list.
# A Help menu contains pointers to key Tycho documentation.
# <p>
# Here is an example:
# <tcl><pre>
# ::tycho::File .file
# .file centerOnScreen
# </pre></tcl>
#
class ::tycho::File {
    inherit ::tycho::Dismiss

    #### -autosaveinterval option
    # Defines the interval (in minutes) between auto-save operations.
    itk_option define -autosaveinterval autoSaveInterval AutoSaveInterval 5

    #### -data option
    # Specifies initial data to display.
    itk_option define -data data Data {}

    #### -file variable
    # Specify the name of the file associated with the data being edited.
    # NOTE: This should really be a public variable, not an itk option.
    # But the itk implementation does not recognize public variables as
    # options.  When this is fixed, change this to a public variable
    # and remove the protected variable "file".
    itk_option define -file file File "NoName"

    #### readOnly option
    # If readOnly is 0, then modifications will be permitted on
    # the file.
    # NOTE: This should really be a public variable, not an itk option.
    # But the itk implementation does not recognize public variables as
    # options.  When this is fixed, change this to a public variable.
    itk_option define -readonly readonly ReadOnly 0

    constructor {args} {}
    destructor {}

    ##########################################################################
    ####                         public methods                           ####

    #### altFile
    # Query the user for a filename, then load its contents into the current
    # editor.
    method altFile {}

    #### evaluate
    # Query the user for a filename, then evaluate its contents as 
    # Tcl commands. 
    method evaluate {}

    #### filename
    # Return the name of the file associated with the object.
    method filename {} {return $file}

    #### getReadonly
    # Return the value of the readonly option.
    method getReadonly {} 

    #### help
    # Open a help window.  This should be redefined in derived classes.
    method help {}

    #### insertData
    # Insert data.
    method insertData {data}

    #### insertFile
    # Insert the contents of a file.
    method insertFile {}

    #### markModified
    # Mark the window as containing modified data.
    method markModified {}

    #### markUnmodified
    # Mark the window as not containing modified data.
    method markUnmodified {}

    #### revisionControl
    # Check in a file using the selected revision control program command
    # if the file is writeable. Otherwise check the file out using the
    # specified revision control program command. 
    method revisionControl {}

    #### print
    # Print the contents of the file. The default behavior is an error.
    method print {}

    #### reload
    # Reload the previously saved file.  The default behavior is an error.
    method reload {}

    #### save
    # Save to a given filename, or if none is given, to the name given by
    # the file variable.
    method save {{name ""}}

    #### saveAs
    # Open the file browser to save to some other file.
    method saveAs {}

    #### saveAsFile
    # Change the associated file to the specified file name and then save.
    method saveAsFile {filename}

    #### crashSave
    # Save data to a crash recovery file.
    method saveCrash {}

    #### seeName
    # Find the point in the file identified by "name". The default
    # implementation is an error.
    method seeName {name}

    #### windowMenuAppend
    # Append a file editor to the window menu.
    method windowMenuAppend {obj label}

    #### windowMenuRemove
    # Remove a filename from the window menu.
    method windowMenuRemove {filename}

    ##########################################################################
    ####                         public procedures                        ####

    #### callAutoSave
    # If the argument is a File object, call its autoSave method.
    proc callAutoSave {obj} {}

    #### displayData
    # Display data as if it were stored in the file by the given name.
    proc displayData {data filename} {}

    #### emergencySave
    # Call the saveCrash method for all File objects.
    proc emergencySave {} {}

    #### hyperJump
    # Open a file and go to its internal point identified by name.
    proc hyperJump {filename point} {}

    #### newEditor
    # Open a new editor of the specified class.
    proc newEditor {editor} {}

    #### openWin
    # Open a file browser, and then open an editor for the file.
    proc openWin {} {}

    #### openContext
    # Open an editor to edit the file.
    # Which editor is determined by the file extension.
    proc openContext {file} {}

    #### registerEditor
    # Register file extensions and an associated editor class.
    proc registerEditor {extensions editorClass {description {}} \
	    {baseFilename {}}} {}
	
    #### windowMenuAddAll
    # Add a file editor object to the window menus of all open File objects.
    proc windowMenuAddAll {obj label} {}

    #### windowMenuRemoveAll
    # Remove a filename from the window menus of all open File objects.
    proc windowMenuRemoveAll {filename} {}

    ##########################################################################
    ####                         protected variables                      ####

    #### file variable
    # FIXME: This should be removed when we itk is fixed to understand
    # public variables.
    protected variable file "NoName"

    # This array stores object names indexed by file names so that
    # if the same file is opened a second time, we can just raise the window.
    protected common filesOpen

    #### modified variable
    # Indicates whether or not the file has been modified since it was
    # last saved.
    protected variable modified 0    

    # This is used to recall the previous filename associated with
    # the window in case the name is changed.
    protected variable previousfile

    ##########################################################################
    ####                  protected methods and procedures                ####

    #### addWindowMenuEditor
    # Add an entry to the window menu.
    protected method addWindowMenuEditor {desc command}

    #### autoSave
    # Save a backup file and arrange to be called again later.
    protected method autoSave {}

    #### checkForAutoSaveFiles
    # Check for auto-save or crash-recovery files, and return the file to open.
    protected proc checkForAutoSaveFiles {filename} {}

    #### removeBackupFiles
    # Remove auto-save and crash-recovery files, if they exist.
    protected method removeBackupFiles {}

    ##########################################################################
    ####                         private variables                        ####

    # This is used to register context-sensitive editors
    # that are indexed by the file extension.
    private common editors

    # This is used to register context-sensitive editors
    # that are indexed by the base filename.
    private common editorsBase

    # This array stores the names of all currently active objects
    # of type File.  This is used to create crash recovery files.
    private common fileObjects

    # This variable keeps track of registered editors to put them into
    # the Window menu.
    private common windowMenuEntries {}
}

#########################################################################
#########################################################################
####                          option configure                       ####

#########################################################################
#### -data configuration
# Specifies initial data to display.
#
configbody ::tycho::File::data {
    insertData $itk_option(-data)
}

#########################################################################
#### -file configuration
# Set or change the name of the file being edited. Set the window title
# and icon name to match.
#
configbody ::tycho::File::file {
    set file $itk_option(-file)
    set readOnly 0
    if {[winfo exists $prefix]} {
	if {[file exists $file] && ![file writable $file]} {
	    set readOnly 1
	}
	wm iconname $prefix [file tail $file]
    } {
	# Even if there is no window yet, we should set
	# the readOnly variable.
	if {$file != "" && [file exists $file] && ![file writable $file]} {
	    set readOnly 1
	}
    }
    configure -readonly $readOnly

    # Keep track of which files are open by name.
    # This is used to avoid opening the same file twice.
    # It is also used to maintain the Window menu entries.
    if {[info exists previousfile] && [info exists filesOpen($previousfile)]} {
	unset filesOpen($previousfile)
	windowMenuRemoveAll $previousfile
	# unmap the revcontrol window.
	set topwin [winfo toplevel $itk_component(hull)]
	if {[winfo exists $topwin.revcontrol]} {
	    wm withdraw $topwin.revcontrol
	}
	# unmap the search window.
	if {[winfo exists $topwin.search]} {
	    wm withdraw $topwin.search
	}
    }
    if {$file != "NoName"} {
	# If there is already an entry for this filename, do not overwrite it.
	if {![info exists filesOpen($file)]} {
	    set filesOpen($file) $this
	    # Add the current object to the menu entries in all open editors.
	    windowMenuAddAll $this $file
	}
	set previousfile $file
    }
}

#########################################################################
#### -readonly option configuration
# Change the window header to indicate that the file is read only.
# 
configbody ::tycho::File::readonly {
    set bool $itk_option(-readonly)
    set file $itk_option(-file)

    if [winfo exists $prefix] {
	if {$itk_option(-readonly)} {
	    $this configure -title "$file (read only)"
	    $itk_component(dismiss) configure -text "DISMISS (read only)"
	} {
	    $this configure -title "$file"
	    $itk_component(dismiss) configure -text "DISMISS"
	}
    } {
	$itk_component(dismiss) configure -text "DISMISS"
    }
}

#########################################################################
#########################################################################
####                      constructor & destructor                   ####

###################################################################
#
body ::tycho::File::constructor {args} {

    # Set up the menubar
    itk_component add menuFrame {
	frame $itk_interior.m -relief raised -bd 2
    } {
	keep -background -cursor
    }
    pack $itk_component(menuFrame) -side top -fill x \
	    -before $itk_component(childsite)
    
    # Insert items in the menubar.
    # First, a file menu.
    itk_component add fileMenuButton {
	menubutton $itk_component(menuFrame).file \
		-text File \
		-underline 0 \
		-menu $itk_component(menuFrame).file.menu
    } {
	keep -font -activebackground -cursor -activeforeground \
		-background -foreground -highlightbackground \
		-highlightcolor
    }
    
    # Next a window menu
    itk_component add windowMenuButton {
	menubutton $itk_component(menuFrame).window \
		-text Window \
		-underline 0 \
		-menu $itk_component(menuFrame).window.menu
    } {
	keep -font -activebackground -cursor -activeforeground \
		-background -foreground -highlightbackground \
		-highlightcolor
    }
    
    # Next, the help menu.
    itk_component add helpMenuButton {
	menubutton $itk_component(menuFrame).help \
		-text Help \
		-underline 0 \
		-menu $itk_component(menuFrame).help.menu
    } {
	keep -font -activebackground -cursor -activeforeground \
		-background -foreground -highlightbackground \
		-highlightcolor
    }
    
    # Arrangement of menu items
    pack $itk_component(fileMenuButton) -side left
    pack $itk_component(windowMenuButton) -side left
    pack $itk_component(helpMenuButton) -side right
    
    ##################################################################
    # File menu contents
    #
    itk_component add fileMenu {
	menu $itk_component(fileMenuButton).menu -tearoff 0
    } {
	keep -font -activebackground -cursor -activeforeground \
		-background -foreground
    }
    
    $itk_component(fileMenu) add command \
	    -label {Open...} \
	    -underline 0 \
	    -accelerator "C-x C-f" \
	    -command "File::openWin"
    
    $itk_component(fileMenu) add command \
	    -label "Switch File..."\
	    -underline 4 \
	    -accelerator "C-x C-v" \
	    -command "$this altFile"
    
    $itk_component(fileMenu) add command \
	    -label {Insert...}\
	    -underline 0 \
	    -accelerator "C-x i" \
	    -command "$this insertFile"
    
    $itk_component(fileMenu) add command \
	    -label Save \
	    -underline 0 \
	    -accelerator "C-x C-s" \
	    -command "$this save"
    
    $itk_component(fileMenu) add command \
	    -label {SaveAs...} \
	    -underline 4 \
	    -accelerator "C-x C-w" \
	    -command "$this saveAs"
    
    $itk_component(fileMenu) add command \
	    -label {Print...} \
	    -underline 0 \
	    -accelerator "C-x p" \
	    -command "$this print"
    
    $itk_component(fileMenu) add command \
	    -label Evaluate \
	    -underline 0 \
	    -accelerator "C-x C-r" \
	    -command "$this evaluate"
    
    $itk_component(fileMenu) add command \
	    -label Reload \
	    -underline 1 \
	    -command "$this reload"
    
    $itk_component(fileMenu) add command \
	    -label "Revision Control..." \
	    -underline 0 \
	    -accelerator "C-x v" \
	    -command "$this revisionControl"

    $itk_component(fileMenu) add separator
    
    $itk_component(fileMenu) add command \
	    -label Close \
	    -underline 0 \
	    -accelerator "C-x k" \
	    -command "$this nextWindow; delete object $this"
 
    if {$normalExit == 1} {
	$itk_component(fileMenu) add command \
		-label Quit \
		-underline 0 \
		-accelerator "C-x C-c" \
		-command "::tycho::TopLevel::exitProgram"
    }

    # Undo the binding in the base class, where Return dismisses
    # the window.
    bind $prefix <Return> {}
    
    ##################################################################
    # Window menu contents
    #
    itk_component add windowMenu {
	menu $itk_component(windowMenuButton).menu -tearoff 0
    } {
	keep -font -activebackground -cursor -activeforeground \
		-background -foreground
    }
    
    # Use the editors variable to construct menu entries for registered
    # editors.
    foreach entry $windowMenuEntries {
	set editor [lindex $entry 0]
	set desc [lindex $entry 1]
	addWindowMenuEditor $desc "::tycho::File::newEditor $editor"
    }
    $itk_component(windowMenu) add separator

    # use the filesOpen variable to contruct menu entries for all open
    # files.
    foreach filename [array names filesOpen] {
	# FIXME: Temporary check for Itcl bug.
	if {$filename != {junktychofileforitclbogosity}} {
	    windowMenuAppend $filesOpen($filename) $filename
	}
    }

    ##################################################################
    # Help menu contents
    #
    itk_component add helpMenu {
	menu $itk_component(helpMenuButton).menu -tearoff 0
    } {
	keep -font -activebackground -cursor -activeforeground \
		-background -foreground
    }
    
    $itk_component(helpMenu) add command \
	    -label "About Tycho" \
	    -underline 0 \
	    -command \
	    {::tycho::welcomeMessage $TychoBinaryInfo $TychoVersionInfo}
    
    $itk_component(helpMenu) add command \
	    -label "User's Guide" \
	    -underline 0 \
	    -command [code $this help]

    $itk_component(helpMenu) add command \
	    -label "Index" \
	    -underline 0 \
	    -command {::tycho::File::openContext $TYCHO/tycho.idx}
    
    # Bindings
    bind $prefix <Control-x><Control-f> "File::openWin; break"
    bind $prefix <Control-x><Control-s> "$this save; break"
    bind $prefix <Control-x><Control-v> "$this altFile; break"
    bind $prefix <Control-x><Control-w> "$this saveAs; break"
    bind $prefix <Control-x><Key-i> "$this insertFile; break"
    bind $prefix <Control-x><Key-p> "$this print; break"
    bind $prefix <Control-x><Control-r> "$this evaluate; break"
    bind $itk_component(hull) <Control-x><v> "$this revisionControl; break"

    # The following initialize options and then invoke any
    # configuration options, assuming there are options specified.
    eval itk_initialize $args

    # Identify the object for crash recovery
    set fileObjects($this) $prefix

    # Initiate the auto-save loop
    autoSave

    # Save if instructed by the window manager.
    wm protocol $prefix WM_SAVE_YOURSELF "$this saveCrash"

    # FIXME: Because of some itcl bogosity, filesOpen finds itself
    # not settable as an array.  Here we force it to be an array
    # and hope nobody uses the file name here.
    set filesOpen(junktychofileforitclbogosity) junk
}

#####################################################################
#### destructor
# If the modified flag is set, query the user to see whether the
# file should be saved.  If the user cancels the close, trigger an
# error.  This has the effect of undoing the destruction.
#
body ::tycho::File::destructor {} {
    
    if {[info exists modified] && $modified} {
	set title [file tail $file]

	set response [DialogWindow::newModal YesNoCancel .z \
		-text "Save changes to $title before closing?"]

	# If the user hits the cancel button, cancel destruction.
	# This is done by triggering an error.  I don't know of any
	# other way.
	if {$response == -1} {
	    error "File is unchanged"
	}
	if {$response == 1} {
	    # FIXME: the following never returns if there is an error.
	    $this save
	}
    }
    if {[info exists filesOpen($file)] && \
	    ($filesOpen($file) == $this || \
	    "::$filesOpen($file)" == $this || \
	    $filesOpen($file) == "::$this") } {
	unset filesOpen($file)
	windowMenuRemoveAll $file
    }

    # If an error occurred in construction, this may not exist.
    if [info exists fileObjects($this)] {
	unset fileObjects($this)
    }
    
    # Do not get rid of the backup files.  This should be done
    # only on a successful save.
    # removeBackupFiles
}

#########################################################################
#########################################################################
####                          public methods                         ####

#####################################################################
#### altFile
# Query the user for a filename, insert it into the current editor.
#
body ::tycho::File::altFile {} {
    if {$modified} {
	if [askuser "Save modifications before opening the new file?"] {
	    # update changes since last save
	    save
	}
    }
    set prevfile $itk_option(-file)
    set filename [DialogWindow::newModal FileBrowser [autoName .fileBrowser] \
	    -text "Alternate file to load:"]
    if {$filename != {}} {
	configure -file $filename
	$itk_component(text) setInsert 1.0
	reload
	windowMenuRemoveAll $prevfile
    }
}

#####################################################################
#### evaluate
# Query the user for a filename, then evaluate its contents as Tcl commands.
#
body ::tycho::File::evaluate {} {
    set filename [DialogWindow::newModal FileBrowser [autoName .fileBrowser] \
	    -text "Tcl file to evaluate:"]
    if {$filename != {}} {
	source $filename
    }
}

#####################################################################
#### getReadonly
# Return the value of the readonly option.
#
body ::tycho::File::getReadonly {} {
    return $itk_option(-readonly)
}

#########################################################################
#### help
# Open a window with help on the current widget.
# This should be redefined in derived classes.
#
body ::tycho::File::help {} {
    global TYCHO
    ::tycho::File::openContext $TYCHO/kernel/doc/usersGuides/FileHelp.html
}

#####################################################################
#### insertData
# Insert the specified data.
#
body ::tycho::File::insertData {data} {
    error "Sorry, insert data not implemented yet."
}

#####################################################################
#### insertFile
# Open a file browser to query the user for a filename, and then
# insert the contents of that file at the insertion cursor.
#
body ::tycho::File::insertFile {} {
    error "Sorry, insert file not implemented yet."
}

#####################################################################
#### markModified
# Mark the window as containing modified data.
#
body ::tycho::File::markModified {} {
    if {!$modified} {
	$itk_component(dismiss) configure -text "DISMISS (modified)"
	set modified 1
    }
}

#####################################################################
#### markUnmodified
# Mark the window as containing unmodified data.
#
body ::tycho::File::markUnmodified {} {
    if {$modified} {
	if {$itk_option(-readonly)} {
	    $itk_component(dismiss) configure -text "DISMISS (read only)"
	} {
	    $itk_component(dismiss) configure -text "DISMISS"
	}
	set modified 0
    }
}

#####################################################################
#### print
# Print the data.  The default behavior is an error.
#
body ::tycho::File::print {} {
    error "Sorry, print not implemented yet."
}

#####################################################################
#### reload
# Reload the current file.
#
body ::tycho::File::reload {} {
    error "Sorry, reload not implemented yet."
}

###################################################################
#### revisionControl
# Create a revision control object for the current file.  
#
body ::tycho::File::revisionControl {} {
    ::tycho::RevControl::setup $itk_component(hull) $this
}

#####################################################################
# save
# Save to a file, with an optional filename specified.  If no filename
# is specified, then the name given in the -file option is used.
# The default behavior does not actually save anything, since there is
# no data to save. In derived classes, this method should return 1 if
# it successfully saves, and 0 (or an error) otherwise.  Derived classes
# should also call removeBackupFiles after successfully saving the
# file, but only if the name argument is not given.  This is because the
# auto-save mechanism uses this same procedure, but passes a name to
# use to save the file.  Derived classes should also call "markUnmodified".
#
body ::tycho::File::save {{name ""}} {
    # If the argument is present, this is probably a request to save
    # a backup file, so we should not delete backup files.
    if {$name != ""} {
	removeBackupFiles
	set filename $name
    } {
	set filename $file
    }
    if {$filename == {NoName}} {
	return [saveAs]
    } {
	# For this base class, this method cannot actually save anything.
	# Thus, we issue a warning.
	warn "Tried to save to file: $filename.\nSave not implemented yet."
	return 0
    }
}

#####################################################################
#### saveAs
# Invoke the file browser to prompt the user for a file name,
# and then, if the file is writable or creatable, save the contents
# of the text window to that file.  Note that in the base class, this
# will eventually fail because we don't know how to save.
#
body ::tycho::File::saveAs {} {
    set filename [DialogWindow::newModal FileBrowser [autoName .fileBrowser] \
	    -text "Save As File:"]
    if {$filename == {NoName}} {
	error "Cannot use name NoName"
    }
    # Ignore if the user cancels
    if {$filename != {}} {
	return [saveAsFile $filename]
    }
}

#####################################################################
#### saveAsFile
# Change the associated file to the specified file name and then save.
# Return 1 if the save is successful.  Return 0 or trigger an error
# if the save is not successful.
#
body ::tycho::File::saveAsFile {filename} {
    if {[file exists $filename]} {
	if [askuser "File \"$filename\" exists.  Overwrite?"] {
	    removeBackupFiles
	    configure -file $filename
	    return [save]
	} {
	    error {Did not save file}
	}
    } {
	removeBackupFiles
	set oldname $itk_option(-file)
	configure -file $filename
	if [save] {
	    return 1
	} {
	    configure -file $oldname
	    return 0
	}
    }
}

#####################################################################
#### saveCrash
# Save a crash recovery file, which has a name constructed from the
# true file name by prepending the prefix "#crash#".
#
body ::tycho::File::saveCrash {} {
    if {$modified && $file != ""} {
	set filename [file tail $file]
	set filename [format "#crash#%s" $filename]
	set filename [format "%s/%s" [file dirname $file] $filename]
	save $filename
    }    
}

#####################################################################
#### seeName
# In derived classes, this method will go to the point in a file
# identified by the name argument.  What this means depends on what
# type of data is contained in the file.
#
body ::tycho::File::seeName {name} {
    error "Sorry, seeName not implemented. Don't know how to find point $name"
}

#####################################################################
#### windowMenuAppend
# Append the name of an open file editor to the Window menu.
# The second argument, normally a filename, gives the menu label.
#
body ::tycho::File::windowMenuAppend {obj label} {
    # Avoid entries with empty names or NoName
    if {$label != {NoName} && $label != {}} {
	$itk_component(windowMenu) add command \
		-label $label \
		-command "$obj raiseWindow"
    }
}

#####################################################################
#### windowMenuRemove
# Remove the name of an open file from the Window menu.
#
body ::tycho::File::windowMenuRemove {filename} {
    $itk_component(windowMenu) delete $filename
}

#########################################################################
#########################################################################
####                          public procedures                      ####

#####################################################################
#### callAutoSave
# Check to see whether the object whose name is passed as an argument
# exists and is a File object, and if so, call its autoSave method.
#
body ::tycho::File::callAutoSave {obj} {
    if {[info objects $obj] != "" && [$obj isa File]} {
	$obj autoSave
    }
}

#####################################################################
#### displayData
# Open an editor to display the supplied data using the editor that
# would be used if the data were stored in a file with the specified
# name. No file is referenced. If there is no editor for the specified
# extension, open a plain text editor.  Return the name of the window
# that is opened.  This procedure gives a simple way to open a registered
# editor on data that is not stored in a file.
#
body ::tycho::File::displayData {data filename} {
    set ext [file extension $filename]
    set base [file tail $filename]
    if {[info exists editors] && [info exists editors($ext)]} {
	set name [uplevel #0 [list \
		$editors($ext) [autoName .file] -data $data]]
    } elseif {[info exists editorsBase] && [info exists editorsBase($base)]} {
	set name [uplevel #0 [list \
		$editorsBase($base) [autoName .file] -data $data]]
    } else {
	set name [uplevel #0 [list \
		Edit [autoName .edit] -data $data]]
    }
    $name centerOnScreen
    return $name
}

#####################################################################
#### emergencySave
# Call the saveCrash method for all existing objects that are of
# class File, or are derived from class File.
#
body ::tycho::File::emergencySave {} {
    foreach obj [array names fileObjects] {
	$obj saveCrash
    }
}    

#####################################################################
#### hyperJump
# Given a filename and a point within the file, open
# the corresponding file, and call "seeName $point".
#
body ::tycho::File::hyperJump {filename point} {
    set obj [uplevel #0 [list ::tycho::File::openContext $filename]]
    if {$point != {}} {
	# The seeName call is postponed to give time for the widget
	# to be created. The catch is in case it is immediately deleted.
	after idle [list catch \
		[list $obj seeName $point]]
    }
}

#####################################################################
#### newEditor
# Open a new editor of the specified class at the global scope and
# map it to the screen.
#
body ::tycho::File::newEditor {editor} {
    set name [autoName .file]
    uplevel #0 $editor $name
    wm deiconify $name
}

#####################################################################
#### openWin
# Open a file browser, and then open an editor for the file.
# The editor is chosen based on the file extension, if the extension
# is recognized.  Otherwise, the TyEdit class is used to open an
# ordinary text editor.
#
body ::tycho::File::openWin {} {
    DialogWindow::new FileBrowser [autoName .fileBrowser] \
	    -command "::tycho::File::openContext " \
	    -text "Open File:"
}

#####################################################################
#### openContext
# If a context-sensitive editor has been registered for the file
# extension, or base filename that is given, use it to open the file. 
# Otherwise, just open a plain text editor.  Return the name of the 
# editor object. If a window already exists editing this file, simply
# raise it instead. New windows are always opened at the global scope.
#
body ::tycho::File::openContext {filename} {
    if {[info exists filesOpen] && \
	    [info exists filesOpen($filename)]} {
	$filesOpen($filename) raiseWindow
	return $filesOpen($filename)
    } {
	#check for existing autosave files
	set filename [checkForAutoSaveFiles $filename]
	set ext [file extension $filename]
	set base [file tail $filename]
	if {[info exists editors] && [info exists editors($ext)]} {
	    set name [uplevel #0 [list \
		    $editors($ext) [autoName .file] -file $filename]]
	} elseif {[info exists editorsBase] && [info exists \
		editorsBase($base)]} {
	    set name [uplevel #0 [list \
		    $editorsBase($base) [autoName .file] -file $filename]]
	} else {
	    set name [uplevel #0 [list \
		    Edit [autoName .edit] -file $filename]]
	}
	$name centerOnScreen
	return $name
    }
}

#####################################################################
#### registerEditor
# Register a context-sensitive editor by file extension(s), or base
# filename. This means means that an open-file command (via the
# openContext procedure in this class) will recognize the file
# extension, or base filename and open the specified editor. The editor
# is assumed to be a class derived from File, or at least to have a
# -file option. Note that the leading period is considered part of the
# extension, as in ".itcl". If a third argument is given, then the
# editor will be added to the Window menu of all File objects opened in
# the future using the value of the third argument as the menu label.
# This permits the user to open a new blank editor of the given class.
#
body ::tycho::File::registerEditor {extensions editorClass {description {}} \
	{baseFilename {}}  } {
    foreach extension $extensions {
	set editors($extension) $editorClass
    }
    foreach basename $baseFilename {
	set editorsBase($basename) $editorClass
    }
    if {$description != {}} {
	lappend windowMenuEntries [list $editorClass $description]
    }
}

#####################################################################
#### windowMenuAddAll
# If the argument is the name of a current File object, then that
# object is added to all Window menus of all current file objects.
# The second argument, normally a file name, gives the manu label.
#
body ::tycho::File::windowMenuAddAll {obj label} {
    foreach fileobj [array names fileObjects] {
	catch {$fileobj windowMenuAppend $obj $label}
    }
}

#####################################################################
#### windowMenuRemoveAll
# Remove the specified filename from the Window menu of all open
# File objects.
#
body ::tycho::File::windowMenuRemoveAll {filename} {
    foreach fileobj [array names fileObjects] {
	catch {$fileobj windowMenuRemove $filename}
    }
}

#########################################################################
#########################################################################
####                          protected methods                      ####

#####################################################################
#### addWindowMenuEditor
# Add the specified file to the window menu entry.
#
body ::tycho::File::addWindowMenuEditor {desc command} {
    $itk_component(windowMenu) add command \
	    -label $desc \
	    -command $command
}

#####################################################################
#### autoSave
# If the data has been modified, save the data to a file with the name
# given in the -file option, but with the prefix #auto#. Then arrange
# to be called later again, with the time interval given by the option
# -autosaveinterval.  A value of zero for this option disables auto-saving.
#
body ::tycho::File::autoSave {} {
    if {$modified && $file != ""} {
	set filename [file tail $file]
	set filename [format "#auto#%s" $filename]
	set filename [format "%s/%s" [file dirname $file] $filename]
	if {[catch "save $filename" message] != 0} {
	    ::tycho::warn "Auto-save failed: $message"
	}
	markModified
    }
    set interval [expr int(60000*$itk_option(-autosaveinterval))]
    if {$interval < 0 || $interval > 7200000} {
	error "Auto-save interval is out of range (object $this)"
    }
    if {$interval != 0} {
	after $interval "File::callAutoSave $this"
    }
}

#####################################################################
#### checkForAutoSaveFiles
# Check to see whether there is an auto-save or crash recovery file for
# the supplied filename that is newer than the file corresponding to
# the supplied filename. If so, query the user to see whether first the
# crash recovery file, then the autosave file should be opened. Return
# the name of the file that should be opened.
#
body ::tycho::File::checkForAutoSaveFiles {filename} {

    # Get the names of the backup and crash recovery files.
    set filetail [file tail $filename]
    set emerfile [format "%s/#crash#%s" [file dirname $filename] $filetail]
    set backfile [format "%s/#auto#%s" [file dirname $filename] $filetail]

    # See whether a backup or crash recovery files exists and is
    # newer than the file being opened.
    if {[file exists $emerfile] && \
	    [file mtime $emerfile] > [file mtime $filename]} {
	if [askuser "A crash recovery file exists for $filename. \
		\nDo you wish to open it instead?"] {
	    return $emerfile
	}
    }
    if {[file exists $backfile] && \
	    [file mtime $backfile] > [file mtime $filename]} {
	if [askuser "A newer auto-save file exists for $filename. \
		\nDo you wish to open it instead?"] {
	    return $backfile
	}
    }   

    # The original file is the file to open.
    return $filename
}

#####################################################################
#### removeBackupFiles
# Remove the backup file that gets automatically created periodically.
#
body ::tycho::File::removeBackupFiles {} {
    set savefile [format "%s/#auto#%s" [file dirname $file] [file tail $file]]
    exec rm -f $savefile
    set savefile [format "%s/#crash#%s" [file dirname $file] [file tail $file]]
    exec rm -f $savefile
}


