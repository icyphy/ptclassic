# Definition of a basic window with a menu bar and dismiss button
#
# @Author: Edward A. Lee
# @Contributors: Joel King, Farhana Sheikh
#
# @Version: $Id$
#
# @Copyright (c) 1995-%Q% The Regents of the University of California.
# All rights reserved.
# 
# Permission is hereby granted, without written agreement and without
# license or royalty fees, to use, copy, modify, and distribute this
# software and its documentation for any purpose, provided that the
# above copyright notice and the following two paragraphs appear in all
# copies of this software.
# 
# IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY
# FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
# ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF
# THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.
# 
# THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE
# PROVIDED HEREUNDER IS ON AN "AS IS" BASIS, AND THE UNIVERSITY OF
# CALIFORNIA HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,
# ENHANCEMENTS, OR MODIFICATIONS.
# 
# 						PT_COPYRIGHT_VERSION_2
# 						COPYRIGHTENDKEY
#######################################################################

#### Options

#### autoSaveInterval option
# The auto-save interval in minutes.  A value of zero means no auto-save.
option add *File.autoSaveInterval 5 widgetDefault

########################################################################
#### expandPath
# Expand a filename, returning an absolute filename with the complete path.
# The argument might begin with an environment variable, a
# global Tcl variable, or a reference to a user's home directory. If
# the argument begins with a dollar sign ($), then everything up to
# the first slash is taken to be a variable name.  If an environment
# variable exists with that name, then the dollar sign and the variable
# name are replaced with the value of the environment variable. For
# example, if the value of of the environment variable TYCHO is
# /usr/tools/tycho, then
# <pre>
#     ::tycho::expandPath \$TYCHO/tmp
# </pre>
# returns /usr/tools/tycho/tmp. If there is no such environment
# variable, but a global Tcl variable with the given name exists, then
# the value of that variable is substituted. If no such variable is
# defined as well, then the argument is taken to be a literal filename,
# and the current working directory is assumed to be its location.
# Similarly, "~user/foo" will be expanded (on Unix systems) to
# "/users/user/foo", assuming that "user" has his or her home directory
# at "/users/user". If there is no user named "user", or we are not on
# a Unix system, then "~user/foo" will be returned with the current
# working directory prepended.  In all cases, any extra spaces at the
# beginning or the end of the given path are removed.  Moreover,
# filenames are normalized before being returned.  Symbolic links
# are followed, as are fields in the path like "/../".  Thus, any
# two references to the same path should return the same string.
#
proc ::tycho::expandPath { path } {
    set path [string trim $path]
    if {[string first \$ $path] == 0} {
        global ::env
        set slash [string first / $path]
        if {$slash > 0} {
            set envvar [string range $path 1 [expr {$slash-1}]]
        } {
            set envvar [string range $path 1 end]
        }
        if [info exists env($envvar)] {
            set envval $env($envvar)
        } elseif [uplevel #0 info exists $envvar] {
            global $envvar
            set envval [set $envvar]
        } else {
            # No such variable.  Use the original form.
            set envval "\$$envvar"
        }
        if {$slash > 0} {
            set path [format "%s%s" $envval [string range $path $slash end]]
        } {
            set path $envval
        }
    } elseif {[string first ~ $path] == 0} {
        if {[catch {
            set dir [file dirname $path]
            set np [glob $dir]
        }] == 0} {
            # glob succeeded
            set path [format "%s/%s" $np [file tail $path]]
        }
    }
    # If the result is not absolute, prepend the current working directory.
    if {[string first "/" $path] != 0} {
        set path [format "%s/%s" [pwd] $path]
    }
    
    # Get a consistent filename using "cd".  Note that this may not work
    # on non-Unix machines.  The catch is in case the directory does not
    # exist.
    catch {
        set savedir [pwd]
        # If the filename itself is a directory, normalize it
        if [file isdirectory $path] {
            cd $path
            set path [pwd]
        } {
            cd [file dirname $path]
            set path [format "%s/%s" [pwd] [file tail $path]]
        }
        cd $savedir
    }
    return $path
}

# COMPATIBILITY procedure.  Use <code>::tycho::expandPath</code>.
proc ::ptkExpandEnvVar { path } {::tycho::expandPath $path}


#######################################################################
#### File
# This class defines a window that contains a menu bar with associated
# file commands at the top and a dismiss button at the bottom. It is
# designed to be the parent window for any editor that stores its
# results in files. If the data is marked modified and the object is
# destroyed, the user is queried to save the file. A safety copy of
# the file is made automatically periodically with an interval given
# by the -autosaveinterval option.  If the compiled version of Tycho is
# used (for example, running it with Ptolemy), then crash recovery files
# are also automatically created if the program crashes.
# <p>
# Three menu buttons are put at the top of the window. The "File" menu
# contains commands to open a file, insert a file, save data to a file,
# save as some other file name, print, evaluate the data, reload the
# last saved version, toggle read-only, version control, close the
# window, and exit the application. The "Window" menu contains commands
# to open new (blank) top-level windows of all types that have been
# registered with the <code>File</code> class using its
# <code>registerEditor</code> procedure. It also contains commands to
# bring to the foreground any currently open top-level editor that haa
# a file name associated with it. Note that editors with the default
# name "NoName" do not appear on this list. A Help menu contains
# pointers to key Tycho documentation.
# <p>
# Here is an example:
# <tcl><pre>
# ::tycho::File .file
# .file centerOnScreen
# </pre></tcl>
# <p>
# Derived classes should normally redefine the methods
# <code>clear</code>,
# <code>help</code>,
# <code>insertData</code>,
# <code>print</code>, and
# <code>saveText</code>.
# In order to support hypertext jumps into particular points in the
# display, the derived class may also redefine
# <code>seePoint</code>, and
# <code>currentPoint</code>.  These two should always be redefined
# as a pair, since <code>currentPoint</code> is assumed to return
# a syntax undertood by <code>seePoint</code>.
# Derived classes may also wish to override <code>reload</code>.
# For example, the text editors derived from this class overload
# <code>reload</code> to prevent it from corrupting the clipboard buffer.
#
class ::tycho::File {
    inherit ::tycho::Dismiss

    # Specify the interval (in minutes) between auto-save operations.
    itk_option define -autosaveinterval autoSaveInterval AutoSaveInterval 5

    # Specify initial data to display (ignored in this base class).
    itk_option define -data data Data {}

    # NOTE: The following should really be a public variable, not an
    # Itk option. But the Itk implementation does not recognize public
    # variables as options. When this is fixed, change this to a public
    # variable and remove the protected variable "file".

    # Specify the name of the file associated with the data being edited.
    itk_option define -file file File "NoName"

    # NOTE: This should really be a public variable, not an Itk option.
    # But the Itk implementation does not recognize public variables as
    # options.  When this is fixed, change this to a public variable.

    # Specify whether modifications will be permitted on the data.
    itk_option define -readonly readonly ReadOnly 0

    constructor {args} {}
    destructor {}

    ##########################################################################
    ####                         public methods                           ####

    # Query the user for another file to edit in the same window.
    method altFile {}

    # Save a backup file and arrange to be called again later.
    method autoSave {}

    # In derived classes, clear the data being displayed or edited.
    method clear {} {}

    # Query the user for a filename, then evaluate its contents as Tcl commands.
    method evaluate {}

    # Return the name of the file associated with the object.
    method filename {} {return $file}

    # Return 1 if the data is read-only, 0 otherwise.
    method getReadonly {} 

    # Open a help window.  Redefine in derived classes.
    method help {}

    # Open a file and go to its internal point identified by name.
    method hyperJump {filename point}

    # Insert the specified data.  Redefine in derived classes.
    method insertData {data}

    # Insert the contents of a file specified via a file browser.
    method insertFile {}

    # Mark the window as containing modified data.
    method markModified {}

    # Mark the window as containing unmodified data.
    method markUnmodified {}

    # Print the contents of the file. The default behavior is an error.
    method print {}

    # Reload from the last saved version of the file.
    method reload {}

    # Create a revision control object for the current file.  
    method revisionControl {}

    # Save to a given filename or if none is given, to the current file.
    method save {{name ""}}

    # Open the file browser to save to some other file name.
    method saveAs {}

    # Change the associated file to the specified file name and then save.
    method saveAsFile {filename}

    # Save data to a crash recovery file.
    method saveCrash {}

    # Toggle the read-only status of a file (maybe invoking revision control).
    method toggleReadOnly {}

    # Add me to the window menus of all open File objects.
    method windowMenuAddAll {label}

    # Append a file editor to the window menu.
    method windowMenuAppend {obj label}

    # Remove the name of an open file from the Window menu.
    method windowMenuRemove {filename}

    # Remove a filename from the window menus of all open File objects.
    method windowMenuRemoveAll {filename}

    ##########################################################################
    ####                         public procedures                        ####

    # If the argument is a File object, call its autoSave method.
    proc callAutoSave {obj} {}

    # Display data as if it were stored in the file by the given name.
    proc displayData {data filename} {}

    # Call the saveCrash method for all File objects.
    proc emergencySave {} {}

    # Open a new editor of the specified class.
    proc newEditor {editor} {}

    # Open a file browser, and then open an editor for the file.
    proc openWin {} {}

    # Edit a file using the file extension to select an editor.
    proc openContext {file} {}

    # Register file extensions and an associated editor class.
    proc registerEditor {extensions editorClass {description {}} \
	    {baseFilename {}}} {}
	
    ##########################################################################
    ####                  protected methods                               ####

    # Add a menu to the menu bar.
    protected method addMenu {name side before args}
    
    # Add a menu item to the specified menu.
    protected method addMenuItem {itemName inMenu args}

    # Add a separator to the specified menu.
    protected method addMenuSeparator {menu args}

    # Disable the item in the specified menu.
    protected method disableMenuItem {itemName inMenu}

    # Enable the item in the specified menu.
    protected method enableMenuItem {itemName inMenu}

    # Insert a menu item to the specified menu before the specified item.
    protected method insertMenuItem {itemName before inMenu args}

    # Remove the specified menu.
    protected method removeMenu {menu}

    # Remove the item from the specified menu.
    protected method removeMenuItem {itemName inMenu}

    # Return the data to be saved. Redefine in derived classes.
    protected method saveText {}

    ##########################################################################
    ####                         protected variables                      ####

    # FIXME: This should be removed when Itk is fixed to understand
    # public variables.

    # The current file name.
    protected variable file "NoName"

    # This array stores object names indexed by file names so that
    # if the same file is opened a second time, we can just raise the window.
    protected common filesOpen

    # Indicate whether or not the file has been modified since it was
    # last saved.
    protected variable modified 0    

    # Recall the previous filename associated with
    # the window in case the name is changed.
    protected variable previousfile {}

    ##########################################################################
    ####                  private methods                                 ####

    # Remove the backup file that gets automatically created periodically.
    private method removeBackupFiles {}

    ##########################################################################
    ####                  private procedures                              ####

    # Check for auto-save or crash-recovery files, and return the file to open.
    private proc checkForAutoSaveFiles {filename} {}

    ##########################################################################
    ####                         private variables                        ####

    # This is used to register context-sensitive editors
    # that are indexed by the file extension.
    private common editors

    # This is used to register context-sensitive editors
    # that are indexed by the base filename.
    private common editorsBase

    # This array stores the names of all currently active objects
    # of type File.  This is used to create crash recovery files.
    private common fileObjects

    # This variable keeps track of registered editors to put them into
    # the Window menu.
    private common windowMenuEntries {}

    # Class identifier
    private variable myclass {}
}

#########################################################################
#########################################################################
####                          option configure                       ####

#########################################################################
#### -data configuration
# Specifies initial data to display.
#
configbody ::tycho::File::data {
    if {$itk_option(-data) != {}} {
        insertData $itk_option(-data)
    }
}

#########################################################################
#### -file configuration
# Set or change the name of the file being edited and load the
# contents. Set the window title and icon name to match, and set the
# protected "file" variable equal to the file name.  The filename
# is expanded into an absolute filename, resolving any references
# environment variables, user home directories, etc.  See
# <code>::tycho::expandPath</code> for details about how this is done.
#
configbody ::tycho::File::file {
    set file $itk_option(-file)
    if {$itk_option(-file) != {NoName}} {
        set file [::tycho::expandPath $file]
    }
    if {[winfo exists $prefix]} {
	wm iconname $prefix [file tail $file]
        configure -title "$file"
    }
    reload

    # Keep track of which files are open by name.
    # This is used to avoid opening the same file twice.
    # It is also used to maintain the Window menu entries.
    if {$previousfile != {}} {
	windowMenuRemoveAll $previousfile
	# unmap the revcontrol window.
	set topwin [winfo toplevel $itk_component(hull)]
	if {[winfo exists $topwin.revcontrol]} {
	    wm withdraw $topwin.revcontrol
	}
	# unmap the search window.
	if {[winfo exists $topwin.search]} {
	    wm withdraw $topwin.search
	}
    }
    if {$file != "NoName"} {
        # Add the current object to the menu entries in all open editors.
        windowMenuAddAll $file
	set previousfile $file
    }
}

#########################################################################
#### -readonly option configuration
# Set whether the data can be modified.  A value of 1 means "no", whereas
# a value of 0 means "yes".
# 
configbody ::tycho::File::readonly {
    set readOnly $itk_option(-readonly)

    if [winfo exists $prefix] {
	if {$itk_option(-readonly)} {
	    $itk_component(dismiss) configure -text \
                    "DISMISS  $myclass (read only)"
	} {
	    $itk_component(dismiss) configure -text "DISMISS  $myclass"
	}
    } {
	$itk_component(dismiss) configure -text "DISMISS  $myclass"
    }
}

#########################################################################
#########################################################################
####                      constructor & destructor                   ####

###################################################################
#
body ::tycho::File::constructor {args} {

    # Store my class identifier in a private variable.
    set myclass "\[[info class] class\]"

    # Set up the menubar
    itk_component add menuFrame {
	frame $itk_interior.m -relief raised -bd 2
    } {
	keep -background -cursor
    }
    pack $itk_component(menuFrame) -side top -fill x \
	    -before $itk_component(childsite)
    
    # Insert items in the menubar.
    addMenu File left {} -underline 0
    addMenu Window left {} -underline 0
    addMenu Help right {} -underline 0

    #
    # File menu contents
    #
    
    addMenuItem {Open...} File -underline 0 -accelerator "C-x C-f" \
	    -command "::tycho::File::openWin"
    
    addMenuItem "Switch File..." File -underline 4 -accelerator "C-x C-v" \
	    -command "$this altFile"
    
    addMenuItem {Insert...} File -underline 0 -accelerator "C-x i" \
	    -command "$this insertFile"
    
    addMenuItem Save File -underline 0 -accelerator "C-x C-s" \
	    -command "$this save"
    
    addMenuItem {SaveAs...} File -underline 4 -accelerator "C-x C-w" \
	    -command "$this saveAs"
    
    addMenuItem {Print...} File -underline 0 -accelerator "C-x p" \
	    -command "$this print"
    
    addMenuItem Evaluate File -underline 0 -accelerator "C-x C-r" \
	    -command "$this evaluate"
    
    addMenuItem Reload File -underline 0 \
	    -command "$this reload"
    
    addMenuItem "Toggle Read-Only" File -underline 0 -accelerator "C-x C-q" \
	    -command "$this toggleReadOnly"

    addMenuItem "Revision Control..." File -underline 2 -accelerator "C-x v" \
	    -command "$this revisionControl"

    addMenuSeparator File
    
    addMenuItem Close File -underline 0 -accelerator "C-x k" \
	    -command "$this nextWindow; delete object $this"
 
    if {$normalExit == 1} {
        addMenuItem Quit File -underline 0 -accelerator "C-x C-c" \
                -command "::tycho::TopLevel::exitProgram"
    }

    # Undo the binding in the base class, where Return dismisses
    # the window.
    bind $prefix <Return> {}
    
    #
    # Window menu contents
    #
    
    # Use the editors variable to construct menu entries for registered
    # editors.
    foreach entry $windowMenuEntries {
	set editor [lindex $entry 0]
	set desc [lindex $entry 1]
	addMenuItem $desc Window -command "::tycho::File::newEditor $editor"
    }
    addMenuSeparator Window

    # use the filesOpen variable to construct menu entries for all open
    # files.
    foreach filename [array names filesOpen] {
	# FIXME: Temporary check for Itcl bug.
	if {$filename != {junktychofileforitclbogosity}} {
	    windowMenuAppend $filesOpen($filename) $filename
	}
    }

    #
    # Help menu contents
    #
    
    addMenuItem "About Tycho" Help -underline 0 -command \
	    {::tycho::welcomeMessage $TychoBinaryInfo $TychoVersionInfo}
    
    addMenuItem "User's Guide" Help -underline 0 \
	    -command "$this help"
    
    addMenuItem "Index" Help -underline 0 \
	    -command {::tycho::File::openContext $TYCHO/tycho.idx}
    
    # Bindings
    bind $prefix <Control-x><Control-f> "::tycho::File::openWin; break"
    bind $prefix <Control-x><Control-s> "$this save; break"
    bind $prefix <Control-x><Control-v> "$this altFile; break"
    bind $prefix <Control-x><Control-w> "$this saveAs; break"
    bind $prefix <Control-x><Key-i> "$this insertFile; break"
    bind $prefix <Control-x><Key-p> "$this print; break"
    bind $prefix <Control-x><Control-r> "$this evaluate; break"
    bind $prefix <Control-x><Control-q> "$this toggleReadOnly; break"
    bind $prefix <Control-x><v> "$this revisionControl; break"

    # The following initialize options and then invoke any
    # configuration options, assuming there are options specified.
    eval itk_initialize $args

    # Identify the object for crash recovery
    set fileObjects($this) $this

    # Initiate the auto-save loop
    autoSave

    # Save if instructed by the window manager.
    wm protocol $prefix WM_SAVE_YOURSELF "$this saveCrash"

    # FIXME: Because of some Itcl bogosity, filesOpen finds itself
    # not settable as an array.  Here we force it to be an array
    # and hope nobody uses the file name here.
    set filesOpen(junktychofileforitclbogosity) junk
}

#####################################################################
#### destructor
# If the modified flag is set, query the user to see whether the
# file should be saved.  If the user cancels the close, trigger an
# error.  This has the effect of undoing the destruction.
#
body ::tycho::File::destructor {} {
    
    if {[info exists modified] && $modified} {
	set title [file tail $file]

	set response [::tycho::DialogWindow::newModal YesNoCancel .z \
		-text "Save changes to $title before closing?"]

	# If the user hits the cancel button, cancel destruction.
	# This is done by triggering an error.  I don't know of any
	# other way.
	if {$response == -1} {
	    error "File is unchanged"
	}
	if {$response == 1} {
	    save
	}
    }
    windowMenuRemoveAll $file

    # If an error occurred in construction, this may not exist.
    if [info exists fileObjects($this)] {
	unset fileObjects($this)
    }
    
    # Do not get rid of the backup files.  This should be done
    # only on a successful save.
    # removeBackupFiles
}

#########################################################################
#########################################################################
####                          public methods                         ####

#####################################################################
#### altFile
# Query the user for a filename, and edit its contents
# using the current editor.
#
body ::tycho::File::altFile {} {
    if {$modified} {
	if [::tycho::askuser \
		"Save modifications before opening the new file?"] {
	    # update changes since last save
	    save
	}
    }
    set prevfile $itk_option(-file)
    set filename [::tycho::DialogWindow::newModal FileBrowser \
	    [::tycho::autoName .fileBrowser] \
	    -text "Alternate file to load:"]
    if {$filename != {}} {
	configure -file $filename
	windowMenuRemoveAll $prevfile
    }
}

#####################################################################
#### autoSave
# If the data has been modified, save the data to a file with the name
# given in the -file option, but with the prefix "#auto#". Then arrange
# to be called later again, with the time interval given by the option
# -autosaveinterval.  A value of zero for this option disables auto-saving.
#
body ::tycho::File::autoSave {} {
    if {$modified && $file != ""} {
	set filename [file tail $file]
	set filename [format "#auto#%s" $filename]
	set filename [format "%s/%s" [file dirname $file] $filename]
	if {[catch "save $filename" message] != 0} {
	    ::tycho::warn "Auto-save failed: $message"
	}
	markModified
    }
    set interval [expr int(60000*$itk_option(-autosaveinterval))]
    if {$interval < 0 || $interval > 7200000} {
	error "Auto-save interval is out of range (object $this)"
    }
    if {$interval != 0} {
	after $interval "::tycho::File::callAutoSave $this"
    }
}

#####################################################################
#### evaluate
# Query the user for a filename, then evaluate its contents as Tcl commands.
#
body ::tycho::File::evaluate {} {
    set filename [::tycho::DialogWindow::newModal FileBrowser \
	    [::tycho::autoName .fileBrowser] \
	    -text "Tcl file to evaluate:"]
    if {$filename != {}} {
	source $filename
    }
}

#####################################################################
#### getReadonly
# Return 1 if the data is read-only, 0 otherwise.
#
body ::tycho::File::getReadonly {} {
    return $itk_option(-readonly)
}

#########################################################################
#### help
# Open a window with help on the current widget.
# This should be redefined in derived classes.
#
body ::tycho::File::help {} {
    global ::TYCHO
    ::tycho::File::openContext $TYCHO/kernel/doc/usersGuides/FileHelp.html
}

#####################################################################
#### hyperJump
# Open a file and go to its internal point identified by name. If the
# filename is the empty string, just call <code>seePoint</code>,
# passing it the second argument. If the filename is relative (does not
# begin with "/", "~", or "$"), then prepend the directory of the file
# currently being edited or viewed. Then, expand the filename using
# <code>::tycho::expandPath</code> and open the resulting file with
# <code>::tycho::File::openContext</code>, which will choose an editor
# based on the filename extension. Finally, invoke
# <code>seePoint</code> to view the specified point within the file.
# The format for the <i>point</i> argument depends on the type of file
# being opened. For HTML files, it will normally be the name of an
# anchor in the file. For text files, it will normally be either "{line
# <i>linenumber</i>}" or "{range <i>start</i> <i>end</i>}", where
# <i>start</i> and <i>end</i> have the form
# <i>linenumber.characternumber</i>.
#
body ::tycho::File::hyperJump {filename point} {
    if {$filename != {}} {
        set char [string index $filename 0]
        if {$char != "/" && $char != "~" && $char != "\$"} {
            set filename [format "%s/%s" [file dirname $file] $filename]
        }
    }
    ::tycho::TopLevel::hyperJump $filename $point
}

#####################################################################
#### insertData
# Insert the specified data.
# In this base class, trigger an error.
#
body ::tycho::File::insertData {data} {
    error "Sorry, insert data not implemented yet."
}

#####################################################################
#### insertFile
# Insert the contents of a file.
# Open a file browser to query the user for a filename, and then
# insert the contents of that file via the method <code>insertData</code>.
#
body ::tycho::File::insertFile {} {
    set filename [::tycho::DialogWindow::newModal FileBrowser \
	    [::tycho::autoName .filebr] -text {File to Insert}]
    if {$filename != "" && $filename != "NoName"} {
	if {[file exists $filename]} {
	    if {[file readable $filename]} {
		set fd [open $filename r]
		set data [read $fd]
		close $fd
		insertData $data
                markModified
	    } {
		::tycho::warn "File is not readable: $filename"
	    }
	} {
	    ::tycho::warn "File does not exist: $filename"
	}
    }
}

#####################################################################
#### markModified
# Mark the window as containing modified data.
#
body ::tycho::File::markModified {} {
    if {!$modified} {
	$itk_component(dismiss) configure -text "DISMISS  $myclass  (modified)"
	set modified 1
    }
}

#####################################################################
#### markUnmodified
# Mark the window as containing unmodified data.
#
body ::tycho::File::markUnmodified {} {
    if {$modified} {
	if {$itk_option(-readonly)} {
	    $itk_component(dismiss) configure -text \
                    "DISMISS   $myclass  (read only)"
	} {
	    $itk_component(dismiss) configure -text "DISMISS  $myclass"
	}
	set modified 0
    }
}

#####################################################################
#### print
# Print the contents of the file. The default behavior is an error.
#
body ::tycho::File::print {} {
    error "Sorry, print not implemented yet."
}

#####################################################################
#### reload
# Reload from the last saved version of the current file. This method
# first disables read-only status (if it is set), then replaces the
# current data with data from the current file, and then sets read-only
# status based on the permissions of the file. The data is marked
# unmodified after loading the file. If the file does not exist, then
# the current data is cleared, leaving a blank slate. If the current
# file exists but is not readable, an error occurs. The actual
# replacement of the data occurs via the method
# <code>insertData</code>.
#
body ::tycho::File::reload {} {
    if {$file == "NoName" || $file == ""} {
	return 
    }
    if {$modified} {
	if {![::tycho::askuser \
		"This file has been modified. Proceed anyway?"]} {
	    return 
	}
    }
    if [file exists $file] {
        if [file readable $file] {
            configure -readonly 0
            set point [currentPoint]
            clear
            set fd [open $file r]
            set data [read $fd]
            close $fd
            insertData $data
            seePoint $point
            markUnmodified
            if {[file writable $file]} {
                configure -readonly 0
            } else {
                configure -readonly 1
            }
        } {
            error "File $file exists but is not readable"
        }
    } {
        # File does not exist.  Simply clear current data.
        configure -readonly 0
        clear
    }
}

###################################################################
#### revisionControl
# Invoke revision control.  If the file is under the control of a
# recognized revision control system (such as SCCS and RCS), then use
# that system.  Otherwise, query the user about putting the file under
# revision control.  A control panel is opened that permits the user
# to check in or check out the file, examine its revision history, etc.
#
body ::tycho::File::revisionControl {} {
    ::tycho::RevControl::setup $itk_component(hull) $this
}

#####################################################################
#### save
# Save to a file, with an optional filename specified.  If no filename
# is specified, then the name given in the -file option is used.
# Return 1 if it successfully saves, and 0 (or an error) otherwise.
#
body ::tycho::File::save {{name ""}} {
    if {$name == {}} {
	set filename $file
    } {
	set filename $name
    }
    if {$filename != {} && $filename != "NoName"} {
        set txt [saveText]
	set fd [open $filename w+]
	puts -nonewline $fd $txt
	close $fd
    } {	
	# The file has not been specified.  Invoke saveAs
	if {[saveAs] == 0} {return 0}
    }
    if {$name == ""} {
	removeBackupFiles
    }
    markUnmodified
    return 1
}

#####################################################################
#### saveAs
# Invoke the file browser to prompt the user for a file name,
# and then, if the file is writable or creatable, save the contents
# of the editor to that file.  Note that in the base class, this
# will eventually fail because we do not know how to save.
#
body ::tycho::File::saveAs {} {
    set filename [::tycho::DialogWindow::newModal FileBrowser \
	    [::tycho::autoName .fileBrowser] \
	    -text "Save As File:"]
    if {$filename == {NoName}} {
	error "Cannot use name NoName"
    }
    # Ignore if the user cancels
    if {$filename != {}} {
	return [saveAsFile $filename]
    }
}

#####################################################################
#### saveAsFile
# Change the associated file to the specified file name and then save.
# Return 1 if the save is successful.  Return 0 or trigger an error
# if the save is not successful.
#
body ::tycho::File::saveAsFile {filename} {
    if {[file exists $filename]} {
	if [::tycho::askuser "File \"$filename\" exists.  Overwrite?"] {
	    removeBackupFiles
            if [save $filename] {
                configure -file $filename
                return 1
            }
	} {
	    error {Did not save file}
	}
    } {
	removeBackupFiles
	set oldname $itk_option(-file)
	if [save $filename] {
            configure -file $filename
	    return 1
	}
    }
    return 0
}

#####################################################################
#### saveCrash
# Save data to a crash recovery file.
# The crash recovery filename is constructed from the true file name
# by prepending the prefix "#crash#".
#
body ::tycho::File::saveCrash {} {
    if {$modified && $file != ""} {
	set filename [file tail $file]
	set filename [format "#crash#%s" $filename]
	set filename [format "%s/%s" [file dirname $file] $filename]
	save $filename
    }    
}

#####################################################################
#### toggleReadOnly
# Toggle the read-only status of the file.  If the file is under
# revision control (e.g. SCCS or RCS), then check in or check out
# the file.
#
body ::tycho::File::toggleReadOnly {} {
    set revclass [::tycho::RevControl::whichRevClass $this]
    if {$revclass != {}} {
        if [getReadonly] {
            $revclass::checkOut $this
        } {
            $revclass::checkIn $this
        }
    } {
        # NOTE: Unix-only implementation here.
        if [getReadonly] {
            exec chmod +w [filename]
            configure -readonly 0
        } {
            if {$modified} {
                if [::tycho::askuser \
                        "Save modifications before making file read-only?"] {
                    # update changes since last save
                    save
                }
            }
            exec chmod -w [filename]
            configure -readonly 1
        }
    }
}

#####################################################################
#### windowMenuAddAll
# Add me to all "Window" menus of all current file objects.
# The argument, normally a file name, gives the menu label.
# If a menu entry already exists with the given label, leave it alone
# and ignore the call.
#
body ::tycho::File::windowMenuAddAll {label} {
    if {![info exists filesOpen($file)]} {
        set filesOpen($label) $this
        foreach fileobj [array names fileObjects] {
            catch {$fileobj windowMenuAppend $this $label}
        }
    }
}

#####################################################################
#### windowMenuAppend
# Append the name of an open file editor to the "Window" menu.
# The second argument, normally a filename, gives the menu label.
# This method really just provides specialized public access to the
# <code>addMenuItem</code> protected method.
#
body ::tycho::File::windowMenuAppend {obj label} {
    # Avoid entries with empty names or NoName
    if {$label != {NoName} && $label != {}} {
        addMenuItem $label Window -command "$obj raiseWindow"
    }
}

#####################################################################
#### windowMenuRemove
# Remove the name of an open file from the "Window" menu.
# This just provides specialized public access to the protected method
# <code>removeMenuItem</code>.
#
body ::tycho::File::windowMenuRemove {filename} {
    removeMenuItem $filename Window
}

#####################################################################
#### windowMenuRemoveAll
# Remove the specified filename from the Window menu of all open
# <code>File</code> objects.  The specified filename must match
# exactly the label given in the call to <code>windowMenuAddAll</code>
# that created the entry in the first place, and the object referenced
# by the menu must be this one.
#
body ::tycho::File::windowMenuRemoveAll {filename} {
    if {[info exists filesOpen] && \
            [info exists filesOpen($filename)] && \
            $filesOpen($filename) == $this} {
	unset filesOpen($filename)
	foreach fileobj [array names fileObjects] {
	    catch {$fileobj windowMenuRemove $filename}
	}
    }
}

#########################################################################
#########################################################################
####                          public procedures                      ####

#####################################################################
#### callAutoSave
# Check to see whether the object whose name is passed as an argument
# exists and is a File object, and if so, call its autoSave method.
#
body ::tycho::File::callAutoSave {obj} {
    if {[info objects $obj] != "" && [$obj isa ::tycho::File]} {
	$obj autoSave
    }
}

#####################################################################
#### displayData
# Open an editor to display the supplied data using the editor that
# would be used if the data were stored in a file with the specified
# name. No file is referenced. If there is no editor for the specified
# extension, open a plain text editor.  Return the name of the window
# that is opened.  This procedure gives a simple way to open a registered
# editor on data that is not stored in a file.
#
body ::tycho::File::displayData {data filename} {
    set ext [file extension $filename]
    set base [file tail $filename]
    if {[info exists editors] && [info exists editors($ext)]} {
	set name [uplevel #0 [list \
		$editors($ext) [::tycho::autoName .file] -data $data]]
    } elseif {[info exists editorsBase] && [info exists editorsBase($base)]} {
	set name [uplevel #0 [list \
		$editorsBase($base) [::tycho::autoName .file] -data $data]]
    } else {
	set name [uplevel #0 [list \
		::tycho::Edit [::tycho::autoName .edit] -data $data]]
    }
    $name centerOnScreen
    return $name
}

#####################################################################
#### emergencySave
# Call the saveCrash method for all existing objects that are of
# class File, or are derived from class File.
#
body ::tycho::File::emergencySave {} {
    foreach obj [array names fileObjects] {
	$obj saveCrash
    }
}    

#####################################################################
#### newEditor
# Open a new editor of the specified class at the global scope and
# map it to the screen.
#
body ::tycho::File::newEditor {editor} {
    set name [::tycho::autoName .file]
    uplevel #0 $editor $name
    wm deiconify $name
}

#####################################################################
#### openWin
# Open a file browser, and then open an editor for the file.
# The editor is chosen based on the file extension, if the extension
# is recognized.  Otherwise, the <code>Edit</code> class is used to open an
# ordinary text editor.
#
body ::tycho::File::openWin {} {
    ::tycho::DialogWindow::new FileBrowser [::tycho::autoName .fileBrowser] \
	    -command "::tycho::File::openContext " \
	    -text "Open File:"
}

#####################################################################
#### openContext
# If a context-sensitive editor has been registered for the file
# extension, or base filename that is given, use it to open the file. 
# Otherwise, just open a plain text editor.  Return the name of the 
# editor object. If a window already exists editing this file, simply
# raise it instead. New windows are always opened at the global scope.
# File names are expanded using <code>::tycho::expandPath</code>,
# making them absolute and unique.
#
body ::tycho::File::openContext {filename} {
    set filename [::tycho::expandPath $filename]
    if {[info exists filesOpen] && \
	    [info exists filesOpen($filename)]} {
	$filesOpen($filename) raiseWindow
	return $filesOpen($filename)
    } {
	#check for existing autosave files
	set filename [checkForAutoSaveFiles $filename]
        if {![file exists $filename]} {
            if {![::tycho::askuser \
                    "File $filename does not exist.  Open a blank editor?"]} {
                return
            }
        }
	set ext [file extension $filename]
	set base [file tail $filename]
	if {[info exists editors] && [info exists editors($ext)]} {
	    set name [uplevel #0 [list \
		    $editors($ext) [::tycho::autoName .file] -file $filename]]
	} elseif {[info exists editorsBase] && [info exists \
		editorsBase($base)]} {
	    set name [uplevel #0 [list \
		    $editorsBase($base) \
		    [::tycho::autoName .file] -file $filename]]
	} else {
	    set name [uplevel #0 [list \
		    ::tycho::Edit [::tycho::autoName .edit] -file $filename]]
	}
	$name centerOnScreen
	return $name
    }
}

#####################################################################
#### registerEditor
# Register a context-sensitive editor by file extension(s), or base
# filename. This means means that an open-file command (via the
# <code>openContext</code> procedure in this class) will recognize the
# file extension, or base filename and open the specified editor. The
# editor is assumed to be a class derived from File, or at least to
# have a -file option. Note that the leading period is considered part
# of the extension, as in ".itcl". If a third argument is given, then
# the editor will be added to the "Window" menu of all
# <code>File</code> objects opened in the future using the value of the
# third argument as the menu label. This permits the user to open a new
# blank editor of the given class.
#
body ::tycho::File::registerEditor {extensions editorClass {description {}} \
	{baseFilename {}}  } {
    foreach extension $extensions {
	set editors($extension) $editorClass
    }
    foreach basename $baseFilename {
	set editorsBase($basename) $editorClass
    }
    if {$description != {}} {
	lappend windowMenuEntries [list $editorClass $description]
    }
}

#########################################################################
#########################################################################
####                          protected methods                      ####

#####################################################################
#### addMenu
# Add a menu to the menu bar.  The first argument is the name of the
# menu.  This should be a single word, with the first character 
# capitalized.  The second argument should have value either "left"
# or "right".  It determines on which side of the menu bar the menu
# will be packed.  The third argument should be either an empty string
# or the name of a menu before which this menu button should be packed.
# If the string is empty, then the menu is button is placed in the next
# logical position. The remaining arguments are passed unchanged to the Tk
# <code>menubutton</code> command.
#
body ::tycho::File::addMenu {name side before args} {
    
    # Avoid adding new menus with the same name.
    if [info exists itk_component(menu$name)] {
        error "Menu $name already exists."
    }

    # Create the new menu button.
    itk_component add menuButton$name {
	eval menubutton $itk_component(menuFrame).menuButton$name \
		-text "$name" \
		-menu $itk_component(menuFrame).menuButton$name.menu \
		$args
    } {
	keep -font -activebackground -cursor -activeforeground \
		-background -foreground -highlightbackground \
		-highlightcolor
    }

    if {$before != {}} {
        if {![info exists itk_component(menu$before)]} {
            error "Menu $before does not exist."
        }
        pack $itk_component(menuButton$name) -side $side \
                -before $itk_component(menuButton$before)
    } {
        pack $itk_component(menuButton$name) -side $side
    }

    # New menu contents
    itk_component add menu$name {
	menu $itk_component(menuButton$name).menu -tearoff 0
    } {
	keep -font -activebackground -cursor -activeforeground \
		-background -foreground
    }
}

#####################################################################
#### addMenuItem
# Add a menu item to the specified menu. The first argument is the
# label to use in the menu for the item. By convention, this should
# have the first character of each word capitalized. The second
# argument should be the name of a menu created with
# <code>addMenu</code>. The remaining arguments are passed unchanged to
# the Tk <i>menu</i> <code>add command</code> directive.  If a menu
# item already exists with the given name, then it is configured using
# the arguments after the second one.
#
body ::tycho::File::addMenuItem {itemName inMenu args} {
    
    if {![info exists itk_component(menu$inMenu)]} {
	error "Menu $inMenu does not exist."
    }
    
    # check if itemName does not already exists
    if [catch {set check [$itk_component(menu$inMenu) index "$itemName"]}] {
	
	# create a new menu item 
	eval $itk_component(menu$inMenu) add command \
		[list -label "$itemName"] \
		$args
	
    } {
	# if it does then link it to cmd
	eval $itk_component(menu$inMenu) entryconfigure "$itemName" $args
    }
}

#####################################################################
#### addMenuSeparator
# Add a separator to the specified menu. The first argument is the name
# of the menu. The remaining arguments are passed unchanged to the Tk
# <i>menu</i> <code>add separator</code> command.
#
body ::tycho::File::addMenuSeparator {menu args} {
    eval $itk_component(menu$menu) add separator $args
}

#####################################################################
#### disableMenuItem
# Disable the item in the specified menu.
#
body ::tycho::File::disableMenuItem {itemName inMenu} {

    if {![info exists itk_component(menu$inMenu)]} {
	error "Menu $inMenu does not exist."
    }
    
    # check if itemName exists
    if [catch {set check [$itk_component(menu$inMenu) index "$itemName"] } ] {
	error "Menu item $itemName does not exist."
    } {
	$itk_component(menu$inMenu) entryconfigure "$itemName" -state disabled
    }
}

#####################################################################
#### enableMenuItem
# Enable the item in the specified menu.
#
body ::tycho::File::enableMenuItem {itemName inMenu} {

    if {![info exists itk_component(menu$inMenu)]} {
	error "Menu $inMenu does not exist."
    }
    
    # check if itemName exists
    if [catch {set check [$itk_component(menu$inMenu) index "$itemName"] } ] {
	error "Menu item $itemName does not exist."
    } {
	$itk_component(menu$inMenu) entryconfigure "$itemName" -state normal
    }
}

#####################################################################
#### insertMenuItem
# Insert a menu item to the specified menu. The first argument is the
# label to use in the menu for the item. By convention, this should
# have the first character of each word capitalized. The second
# argument is the label of an existing menu item before which the new
# item should be inserted. The third arguments is the name of a menu
# created with <code>addMenu</code>. The remaining arguments are passed
# unchanged to the Tk <i>menu</i> <code>add command</code> directive.
# If a menu item already exists with the given name, then it is
# configured using the arguments after the second one.
#
body ::tycho::File::insertMenuItem {itemName before inMenu args} {
    
    if {![info exists itk_component(menu$inMenu)]} {
	error "Menu $inMenu does not exist."
    }

    # Check validity of the "before" argument.
    if [catch {set check [$itk_component(menu$inMenu) index "$before"]}] {
        error "Menu item $before does not exist."
    }

    # check if itemName does not already exists
    if [catch {set check [$itk_component(menu$inMenu) index "$itemName"]}] {
	
	# create a new menu item 
	eval $itk_component(menu$inMenu) insert \
                [list $before] command \
		[list -label "$itemName"] \
		$args
	
    } {
	# if it does then link it to cmd
	eval $itk_component(menu$inMenu) entryconfigure "$itemName" $args
    }
}

#####################################################################
#### removeMenu
# Remove the specified menu.
#
body ::tycho::File::removeMenu {menu} {

    if {![info exists itk_component(menuButton$menu)]} {
	error "Menu $menu does not exist."
    }
    destroy $itk_component(menuButton$menu)
}

#####################################################################
#### removeMenuItem
# Remove the item in the specified menu.
#
body ::tycho::File::removeMenuItem {itemName inMenu} {

    if {![info exists itk_component(menu$inMenu)]} {
	error "Menu $inMenu does not exist."
    }
    
    # check if itemName exists
    if [catch {set check [$itk_component(menu$inMenu) index "$itemName"] } ] {
	error "Menu item $itemName does not exist."
    } {
	$itk_component(menu$inMenu) delete "$itemName"
    }
}

#####################################################################
#### saveText
# Return the text to save.  In this base class, trigger an error,
# since we don't know how to save.  This should be redefined in derived
# classes.
#
body ::tycho::File::saveText {} {
    error "Tried to save to file: $file.\nSave not implemented yet."
}

#########################################################################
#########################################################################
####                          private methods                        ####

#####################################################################
#### removeBackupFiles
# Remove the backup file that gets automatically created periodically,
# if it exists.  Also remove the crash-recovery file, if it exists.
#
body ::tycho::File::removeBackupFiles {} {
    set savefile [format "%s/#auto#%s" [file dirname $file] [file tail $file]]
    # NOTE: Unix-only implementation here.
    exec rm -f $savefile
    set savefile [format "%s/#crash#%s" [file dirname $file] [file tail $file]]
    exec rm -f $savefile
}


#########################################################################
#########################################################################
####                          private procedures                     ####

#####################################################################
#### checkForAutoSaveFiles
# Check to see whether there is an auto-save or crash recovery file for
# the supplied filename that is newer than the file corresponding to
# the supplied filename. If so, query the user to see whether first the
# crash recovery file, then the autosave file should be opened. Return
# the name of the file that should be opened.
#
body ::tycho::File::checkForAutoSaveFiles {filename} {

    # Get the names of the backup and crash recovery files.
    set filetail [file tail $filename]
    set emerfile [format "%s/#crash#%s" [file dirname $filename] $filetail]
    set backfile [format "%s/#auto#%s" [file dirname $filename] $filetail]

    # See whether a backup or crash recovery files exists and is
    # newer than the file being opened.
    if {[file exists $emerfile] && \
	    [file mtime $emerfile] > [file mtime $filename]} {
	if [::tycho::askuser "A crash recovery file exists for $filename. \
		\nDo you wish to open it instead?"] {
	    return $emerfile
	}
    }
    if {[file exists $backfile] && \
	    [file mtime $backfile] > [file mtime $filename]} {
	if [::tycho::askuser "A newer auto-save file exists for $filename. \
		\nDo you wish to open it instead?"] {
	    return $backfile
	}
    }   

    # The original file is the file to open.
    return $filename
}

