# File browser.
#
# @Author: Edward A. Lee
# @Contributors: Based on a Tcl/Tk version by Wei-Jen Huang and
# 	Mario Jorge Silva.
#
# Version: $Id$
#
# @Copyright (c) 1990-%Q% The Regents of the University of California.
# All rights reserved.
# 
# Permission is hereby granted, without written agreement and without
# license or royalty fees, to use, copy, modify, and distribute this
# software and its documentation for any purpose, provided that the
# above copyright notice and the following two paragraphs appear in all
# copies of this software.
# 
# IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY
# FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
# ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF
# THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.
# 
# THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE
# PROVIDED HEREUNDER IS ON AN "AS IS" BASIS, AND THE UNIVERSITY OF
# CALIFORNIA HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,
# ENHANCEMENTS, OR MODIFICATIONS.
# 
# 						PT_COPYRIGHT_VERSION_2
# 						COPYRIGHTENDKEY
#######################################################################

# NOTE:  I considered using the file browser in the iwidgets library,
# which is more like the standard Motif file browser.  I rejected it for
# aesthetic reasons, settling on this simpler browser.  This one is
# fashioned after the file browser in FrameMaker.


##########################################################################
#### queryfilename
# Query the user for a filename and return it.  This procedure brings up
# a file browser, and returns only when that file browser is dismissed.
# The first argument is a text string used as a label in the file browser.
# The optional second argument is an initial filename to display in the
# entry box.  If it is not specified, then the most recently used file name
# is displayed instead.
# <p>
# This procedure indirectly calls <code>update</code>, a Tk utility
# that processes pending events, including mouse events. If this
# procedure is called from within an Itcl object, directly or
# indirectly, it may be necessary to take precautions to prevent the
# calling object from being deleted during the call. Because of a
# defect in at least some versions of Itcl, failure to do so can result
# in catastrophic failure of the application (a core dump). In Tycho
# objects, the <code>safeEval</code> method should be used to evaluate
# this procedure or any method or procedure that in turn calls this
# procedure. If the procedure is called from the top level or from a
# Tcl procedure that is not itself called from within an Itcl object,
# then there is no cause for worry.
#
proc ::tycho::queryfilename {string {default {}}} {
    set nm [::tycho::autoName .fileBrowser]
    uplevel #0 [list ::tycho::FileBrowser $nm -text $string]
    if {$default != {}} {
        $nm configure -default $default
    }
    return [::tycho::Dialog::wait $nm]
}

##########################################################################
#### FileBrowser
# This file browser displays a list of the files in the current
# directory, permitting the user to select a file or directory by
# clicking or by typing the name in an entry box. File completion (only
# in the current directory) is supported via the Tab key, as is
# glob-style pattern matching. The file browser has a "Help" button and
# a "New Directory" button. When the user selects a directory, the
# listbox is normally updated to reflect the contents of that
# directory. However, if a Tycho editor has been registered by
# contents, extension, or name, then that editor is invoked instead
# (see the register commands in the File class). When the user has
# selected a file, the file browser self-destructs. If the -command
# option is specified, then the value of the option is taken as a
# command to execute before self destructing. The filename selected by
# the user (with the complete path, and which may represent a file that
# does not exist) is appended to the command as an argument.
# <p>
# For example, the following command will query the user for a file name,
# and then post that filename in top-level window:
# <tcl><pre>
# ::tycho::FileBrowser .w -command ::tycho::post
# .w centerOnScreen
# </pre></tcl>
# <p>
# The <code>FileBrowser</code> class maintains its own notion of the
# current working directory that is not necessarily the same as the
# current working directory of the Tcl interpreter. Each instance of
# the <code>FileBrowser</code> updates this when the user selects a new
# directory. If multiple file browsers are open at once, they navigate
# the file system independently. But the most recently selected
# directory will then be the default directory of any newly created
# file browser.
#
# For information about the difference between Unix, Mac and Windows filenames
# see the tcl filename documentation.  In the Itcl2.2 distribution, this
# file is at itcl2.2/tcl7.6/doc/filename.n, and is in Unix Man page format.
#
class ::tycho::FileBrowser {
    inherit ::tycho::ListBrowser

    constructor {args} {}
    destructor {}

    ##################################################################
    ####                     public methods                       ####
   
    # Complete the partially entered item.
    method complete {{case 0}}

    # Open a help window.
    method help {}

    # Make a new directory and go to it.
    method mkdir {}

    ##################################################################
    ####                     public procs                         ####

    # Set the global current working directory.
    proc setCWD {cwd} {set CWD $cwd}

    # Set the global filename that appears by default.
    proc setLastFile {name} {set fileLastOpened $name}

    ##################################################################
    ####                   protected methods                      ####

    # Process a file or directory selection.
    protected method processItem {filename}

    # Fill the listbox with file and directory names.
    protected method updateListbox {}

    ##################################################################
    ####                   protected variables                    ####

    # The last file opened.
    protected common fileLastOpened {}
    # The directory last visited.
    protected common CWD

    # A local version of the CWD is kept in case multiple file browsers
    # are open at once (each has to have its own notion of the current
    # working directory).
    protected variable localCWD

    # The contents of the entry after the last completion.
    # If tab is hit again with the same entry, the directory will
    # be changed (ala Emacs)
    protected variable lastCompletion
}

######################################################################
#
body ::tycho::FileBrowser::constructor {args} {
    
    # The text to insert at the top of the file browser
    configure -text "Select File:"
    
    global ::env
    
    if {! [info exists CWD]} {
      # First FileBrowser window constructed.
      # If the environment variable PTPWD exists, it gives the directory.
      # Otherwise, we issue the Tcl command pwd.
      if [info exists env(PTPWD)] {
          set CWD $env(PTPWD)
      } {
          set CWD [pwd]
      }
    }
    set localCWD $CWD

    # Current directory display.
    itk_component add dir {
	label $itk_component(childsite).dir -text $localCWD -width 35 -anchor e
    } {
	keep -background -cursor -foreground
	rename -font -messagefont messageFont Font
    }
    pack $itk_component(dir) -side top -fill x -after $itk_component(listscroll)
    
    # Create directory button.
    $itk_component(bbox) add mkdir \
	    -text "New Directory" \
	    -command "$this mkdir" \
	    -row 1 -column 0

    # Process any unevaluated arguments.
    eval itk_initialize $args

    # Subscribe to the preference set
    preference subscribeoptions $this \
	    -width  fileBrowserWidth \
	    -height fileBrowserHeight
    if [::tycho::preference get dialogs fileBrowserUseLastDirectory] {
	# If the we prefer to always have the FileBrowser open
	# the last directory we visted.

        # In case updateListbox inserts into the entry; to avoid repetition
        clear entry
        insert entry $fileLastOpened
    } else {
	# If we would like the FileBrowser to always open the 
	# same directory as the current file.
	if {$itk_option(-default) != {} && \
		[file pathtype $itk_option(-default)] == "absolute" } {
	    set default $itk_option(-default)
	    if ![file isdirectory $default] {
		set default [file dirname $default]
	    }
	    if [file isdirectory $default] {
		set CWD $default 
		set localCWD $CWD
                $itk_component(dir) config -text $CWD
		updateListbox
	    }
        }
    }
}


    ##################################################################
    ##################################################################
    ####                     public methods                       ####

#####################################################################
#### complete
# Complete a partially entered item. On the first invocation, this
# method finds an entry in the listbox that has the contents of the
# entry box as a prefix. Glob-style rules are used, so the entry can be
# a pattern (* for any substring, ? for any single character, [chars]
# for a set of characters, or \x for a single character. If there is
# more than one matching entry, then all matching entries are selected
# in the listbox. The selected entries can then be scrolled with the up
# and down arrow keys. If the method is invoked again without an
# intervening invocation of <code>breakCompleteSequence</code>, then it
# scrolls through the selected entries as if the down arrow had been
# pressed. If the optional argument is given and has a non-zero value,
# then the match is case sensitive.  Otherwise, it is not case sensitive.
# Return 0 if no matching entry is found, 1 if one matching
# entry is found, and 2 if more than one matching entry is found.
#
# If there is more than one matching entry, we increase the length of the
# pattern to consist of all of the initial common characters of the matching
# string.  For example, if the pattern is "Foo" and we have "FooBarBaz" and
# "FooBarFrob", then the pattern is increased to "FooBar".
#
# This implementation differs from the parent in that it attempts to complete
# filenames in directories other than the current one. This does not change
# the directory, only increases the length of the pattern to coincide with
# common characters.
#
# Hitting tab again after such a completion WILL change the directory, however.
# For example: tycho/ke <Tab> tycho/kernel/ <Tab> kernel/ <Tab> kernel/
# Should the last tab change directories again? Return will do that...
#
body ::tycho::FileBrowser::complete {{case 0}} {
    if {[file dirname [get entry]] == "."} {
        return [::tycho::ListBrowser::complete $case]
    }
    
    global tcl_platform

    # not in current ListBrowser. Check if in another directory
    global tcl_platform
    # set separator by platform
    switch $tcl_platform(platform) {
        macintosh {
            set sep ":"
        }
        unix {
            set sep "/"
        }
        windows {
            set sep "\\"
        }
    }

    set pattern "[get entry]"

    if [catch {set lastCompletion}] {
        set lastCompletion {#bogusvalue#}
    }

    # check if tab has been hit twice. If so, change directory.
    if {$lastCompletion == $pattern} {
        if {[string index $pattern \
                [expr [string length $pattern] - 1]] == $sep} {
            # it's a complete directory
            set localCWD [::tycho::expandPath \
                    [file join $localCWD $pattern]]
            updateListbox
            $itk_component(dir) config -text $localCWD
            setEntry {}
            return
        } else {
            # it's a directory/something
            set localCWD [::tycho::expandPath \
                    [file join $localCWD [file dirname $pattern]]]
            updateListbox
            $itk_component(dir) config -text $localCWD
            setEntry [file tail $pattern]
            return [complete $case]
        }
    }

    set dir [file dirname $pattern]
    set pattern [file tail $pattern]*
    
    # NOTE: don't tolower dirname, assume it's in proper case
    # otherwise, can't complete beyond upper case directories
    # because the glob has to have an exact dirname
    if !$case {
        set pattern [string tolower "$pattern"]
    }

    # get the length of the directory _name_ (i.e. /export/rice/rice1/...)
    set dirlen [string length [glob -nocomplain [file join $localCWD $dir]]]
    set dirlen [expr $dirlen + 1]
    
    set matches {}
    
    set files [glob -nocomplain [file join $localCWD $dir *]]
    foreach name "$files" {
        set name [string range $name $dirlen end]
        if $case {
            set nm $name
        } else {
            set nm [string tolower $name]
        }
        if [string match $pattern $nm] {
            lappend matches $name
        }
    }    
    switch [llength $matches] {
        0 {
            # no matches, send annoying beep
            bell
            return 0
        }
        1 {
            # found exactly one match, replace entry contents
            set temp [lindex $matches 0]
            if [file isdir [file join $localCWD $dir $temp]] {
                # it's a directory
                set lastCompletion [file join $dir $temp]$sep
                setEntry $lastCompletion
            } else {
                # just a file
                set lastCompletion [file join $dir $temp]
                setEntry $lastCompletion
            }
            return 1
        }
        default {
            # more than 1 match, send annoying beep, complete partially:

            # Set the entry widget to the longest common string among all the
            # matches. Start with the first match, and then slowly increase the
            # length of the pattern until we find another match that's different
            set firstMatch [lindex $matches 0]
            set matchFailed 0
            for {set end [expr [string length $pattern] - 1]} \
                    { $end <= [string length $firstMatch]} \
                    { incr end} {
                if !$case {
                    set testPattern [string tolower \
                            [string range $firstMatch 0 $end]]
                } else {
                    set testPattern [string range $firstMatch 0 $end]
                }
                foreach match $matches {
                    if !$case {
                        set match [string tolower $match]
                    }
                    if  { "$testPattern" != "[string range $match 0 $end]"} {
                        set matchFailed 1
                        break
                    }
                }
                if { $matchFailed == 1 } {
                    incr end -1
                    break
                }
            }
            set lastCompletion [file join $dir [string range $firstMatch 0 $end]]
            setEntry $lastCompletion
            return 2
        }
    }
}

######################################################################
#### help
# Open a help window.
#
body ::tycho::FileBrowser::help {} {
    global ::TYCHO
    ::tycho::File::openContext \
	    [file join $TYCHO kernel doc usersGuides FileBrowserHelp.html]
}

######################################################################
#### mkdir
# Make a new directory and list its contents in the list box.
# Also, make this new directory the common working directory.
#
body ::tycho::FileBrowser::mkdir {} {
    set dirname [safeEval ::tycho::queryinfo "Directory name" "$localCWD/" 80]
    if {$dirname != {}} {
	file mkdir $dirname
	processItem $dirname
    }
}

    ##################################################################
    ##################################################################
    ####                   protected methods                      ####

######################################################################
#### processItem
# Check and process the user selection. If the argument is the name of a
# file, then the command specified with the -command option is invoked
# with that filename as an argument, and a 1 is returned. If the argument
# is a directory name, then the listbox is updated with the contents
# of the directory and a 0 is returned. If the argument is an
# empty string, then nothing is done and a zero is returned. If the
# specified filename exists but is not readable, an error is triggered.
# If the filename does not exist as either a file or a directory, then
# the command given by the -command option is invoked on that file. If
# the entry is invalid for some reason, the user is warned and the
# method returns 0.
#
body ::tycho::FileBrowser::processItem {filename} {
    global tcl_platform
    if {$filename == ""} {return 0}
   
    if { "$tcl_platform(platform)" == "windows" } {
	if ![regexp {^[A-Za-z]:} $filename] {
	    set file [file join $localCWD $filename]
	} {
	    set file $filename
	}
    } else {
	# If the name is relative, prepend with current path.
	if [::tycho::isRelative $filename] {
	    set file [file join $localCWD $filename]
	} {
	    set file $filename
	}
    }

    # Expand to absolute path.
    set file [::tycho::expandPath $file]

    # If expansion failed, trigger an error
    if { "$tcl_platform(platform)" == "windows" } {
	if ![regexp {^[A-Za-z]:} $file] {
	    error "Cannot expand $filename"
	}
    } else {
	if [::tycho::isRelative $file] {
	    error "Cannot expand $filename"
	}
    }
    # If the file does not exist, check to see whether the
    # directory exists.  If it does, execute the command given by -command
    # (which will probably create the file).  Otherwise, trigger an error.
    if {! [file exist $file]} {
	set dir [file dirname $file]
	if {[file exist $dir] && [file isdir $dir]} {
	    execCommand -command $file
	    set fileLastOpened $filename
	    return 1
	} {
	    safeEval ::tycho::warn "Directory does not exist: $dir"
	    return 0
	}
    } 
    
    # If the file does exist, and is a directory
    if {[file isdir $file] && [::tycho::File::registeredCommands $file] == {}} {
	if {[file readable $file] && [file executable $file]} {
	    
            set CWD [::tycho::expandPath $file]
            $itk_component(dir) config -text $CWD
            set localCWD $CWD
            set fileLastOpened ""
            updateListbox
            return 0
	} else {
	    safeEval ::tycho::warn \
		    "Directory \"[string trimright $file /]\" is unreadable"
	    return 0
	}
    } else {
	# It's a plain file or a directory with a registered editor
	if {[file readable $file]} {
	    execCommand -command $file
	    # Store last file opened
	    set fileLastOpened $filename
	    return 1
	} {
	    safeEval ::tycho::warn "\"$file\" is unreadable"
	    return 0
	}
    }
}

######################################################################
#### updateListbox
# Fill the listbox with filenames. Classify directories and files.
# Directories are inserted at the top and are arranged alphabetically.
# Files are listed next, also alphabetically.
#
body ::tycho::FileBrowser::updateListbox {} {
    global tcl_platform
    # clear the list box
    $itk_component(listbox) delete 0 end
    
    # Get a list of filenames in the current working directory
    set files [glob -nocomplain [file join $localCWD *]]
    
    # Split the filename list into directories and plain files
    set dirList ""
    set fileList ""
    foreach file $files {
	set tail [file tail $file]
	if [file isdirectory $file] {
	    lappend dirList $tail
	} {
	    lappend fileList $tail
	}
    }
    
    set dirList [lsort $dirList]
    set fileList [lsort $fileList]
    
    # Insert directories, then files into the listbox
    switch $tcl_platform(platform) {
	macintosh {
	    foreach dir $dirList {
		$itk_component(listbox) insert end "$dir:"
	    }
	    set updir "::"
	}
	unix {
	    foreach dir $dirList {
		$itk_component(listbox) insert end "$dir/"
	    }
	    set updir "../"
	}
	windows {
	    foreach dir $dirList {
		$itk_component(listbox) insert end "$dir\\"
	    }
	    set updir "..\\"
	}
    }

    foreach fname $fileList {
	$itk_component(listbox) insert end "$fname"
    }
    
    clear entry
    
    set dirLength [llength $dirList]
    set fileLength [llength $fileList]
    
    if {$localCWD != [::tycho::rootDir $localCWD] } {
	$itk_component(listbox) insert 0 $updir
    }
    
    # Choose intelligently which default file or directory
    # to put in the entry box.
    if {($dirLength == 1) && ($fileLength == 0)} {
	insert entry [lindex $dirList 0]
    } elseif {($dirLength == 0) && ($fileLength == 1)} {
	insert entry [lindex $fileList 0]
    } elseif {($dirLength == 0) && ($fileLength == 0)} {
	if {$localCWD != [::tycho::rootDir $localCWD] } {
	    insert entry "$updir"
	}
    }
}
