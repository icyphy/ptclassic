# Ptolemy Tycho class that exec's a process and displays the output
#
# @Author: Christopher Hylands and Kevin Chang
#
# @Version: $Id$
#
# @Copyright (c) 1996-1997 The Regents of the University of California.
# All rights reserved.
#
# Permission is hereby granted, without written agreement and without
# license or royalty fees, to use, copy, modify, and distribute this
# software and its documentation for any purpose, provided that the above
# copyright notice and the following two paragraphs appear in all copies
# of this software.
#
# IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY
# FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
# ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF
# THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.
#
# THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE
# PROVIDED HEREUNDER IS ON AN "AS IS" BASIS, AND THE UNIVERSITY OF
# CALIFORNIA HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,
# ENHANCEMENTS, OR MODIFICATIONS.
# 
#                                        PT_COPYRIGHT_VERSION_2
#                                        COPYRIGHTENDKEY
#######################################################################

#######################################################################
#### Monitor
# inherits from Exec, with tk widgets added. This function is added
# for fully backward compatibility with the original Exec.
# <p>
# <b>Simple examples on using the Monitor:</b>
# <tcl><pre>
#     set win [::tycho::autoName .execExample]
#     ::tycho::Monitor $win -command {ls -al}
#     $win centerOnScreen
#     ::tycho::Dialog::wait $win
#     ::tycho::inform "We waited until the Exec window was closed"
# </pre></tcl>
# In the above example, we bring up the Exec window and then wait  
# until the user closes it.
#
# In another example, we automatically start up the subprocess, and then
# close the window if the subprocess completed without an error
# <tcl><pre>
#     set win [::tycho::autoName .execExample]
#     ::tycho::Monitor $win &#92
#        -command {ls -al} -autostart 1 -autodestroy 1
# </pre></tcl>
# If the make in the above example had returned an error, then the window
# would not have been destroyed.
#
# <hr>
# <b>There are many ways to interface with the Monitor:</b><br>
# Examples below show how to interface with the windows.
# This is exactly how the Compile class parses output.
# The variable "output" now contains the exactly lines in Monitor.
# <tcl><pre>
#   set win [::tycho::autoName .execExample]
#   ::tycho::Monitor $win -command {ls -al} -autostart 1 -autodestroy 0
# </pre></tcl>
#
# The next set of examples show how to read in the input, parse, 
# change screen, etc. In this particular example, we changed the
# attribute for the file owner (ie. changing color and underline).
# <tcl><pre> 
# set text $win.history.text
# set output [$win.history get 0.0 end]
# set output [split $output \n]
# set lineno 0
# foreach line $output {
#     incr lineno
#     # Typical format of a file:
#     # lrwxrwxrwx  5 root 28 Feb 25 18:33 README -> /users/README
#     if {[regexp {([-a-zA-Z]+) +([0-9]+) +([a-zA-Z]+).*} $line match &#92
#             perm lnk usr]} {
#         set strstart [string first $usr $line]
#         set strend   [expr $strstart+[string length $usr]]
#         $text tag add color0 $lineno.$strstart $lineno.$strend
#         $text tag configure color0 -foreground red -underline 1
#     }
# }
# </pre></tcl>
class ::tycho::Monitor {
    inherit ::tycho::Query ::tycho::Exec

    ###################################################################
    ####                            options                        ####

    # If non-zero, close widget if the subprocess exits with an ok status.
    itk_option define -autodestroy autodestroy Autodestroy 0

    # If non-zero, start the subprocess automatically
    itk_option define -autostart autostart Autostart 0

    # If modal, then just keep waiting
    itk_option define -modal modal Modal 0

    # Command to be executed.
    itk_option define -command command Command "make"

    # Directory to execute the command in.
    itk_option define -dir dir Dir {}

    constructor {args} {}

    destructor {}

    ###################################################################
    ####                      public methods                       ####
    
    # similar to execProcess, except execute in the monitor.
    public method execProcessInMonitor {} {}

    # We want to make sure that only private function can write
    public method insertLine {line} {}

    # Save the settings, such as autostart, autodestroy
    # so that we'll remember the setting next time we start up
    public method saveSetting {} {}

    # If a monitor has error line reported, jump to the editor and its line
    public method jumpToLine {monitorLine editorLine fname} {}
    
    # Uses jumpToLine to jump to the next reported error.
    public method jumpNextError {} {}

    # Set the error count so that jumpNextError will jump correctly.
    public method setErrorCount {num}
    
    ###################################################################
    ####                            public variables               ####

    # Count the number of errors in this execution
    public variable errorCount 0

    # Remember where the errors are located
    public variable errorList {}

    ###################################################################
    ####                           private variables               ####

    # Variable to keep track so that the same error line isn't highlighted.
    private variable previousErrorLine -1

    # Keep track of the line number in monitor
    private variable monitorLine 0
}


#######################################################################
#### -autodestroy configuration
# If non-zero, destroy the widget if the process exits with an 'ok'
# status
#
configbody ::tycho::Monitor::autodestroy {
    if {$itk_option(-autodestroy) == 0} {
        insert autoDestroy 0
    } else {
        insert autoDestroy 1
    }
}

#######################################################################
#### -autostart configuration
# 
configbody ::tycho::Monitor::autostart {
    if {$itk_option(-autostart)==0} {
        insert autoStart 0
    } else {
        insert autoStart 1
    }
}

#######################################################################
#### -modal configuration
#
configbody ::tycho::Monitor::modal {
    # Current, nothing is done, this should be done outside the Monitor class.
}

#######################################################################
#### -command configuration
# Command to be Executed.
#
configbody ::tycho::Monitor::command {
    clear commandToExec
    insert commandToExec $itk_option(-command)
}

#######################################################################
#### -dir configuration
# The directory that we should exec from.  If the value of this option
# is {}, then we don't change the current directory.  Otherwise,
# we cd to the value of this option.
#
configbody ::tycho::Monitor::dir {
    clear dirToExecFrom
    insert dirToExecFrom $itk_option(-dir)
}

#######################################################################
#### constructor
body ::tycho::Monitor::constructor {args} {
    # This is used to initialize the interface between Exec and Monitor
    doEachLine {$this insertLine "$line"}

    # Original Tk stuff here
    configure -queries [list \
            {line commandToExec {Command to Exec:} make } \
            {line dirToExecFrom {Directory to Exec from:} {}} \
            {check autoDestroy {Close window automatically:} 0} \
            {check autoStart {Start execution automatically:} 0}]

    eval itk_initialize $args

    # If the command option has not been set, set the default now.
    # This has to be done in the constructor rather than in the class
    # definition (as a default) because "$this" is known here.
    if {$itk_option(-command) == {}} {
	configure -command {make}
    }

    $itk_component(bbox) buttonconfigure ok \
	    -text {Exec <Ret>} \
            -command "$this execProcessInMonitor"

    $itk_component(hull) addButton next \
            -text {Next Error} \
            -command "$this jumpNextError"

    $itk_component(hull) addButton stop \
            -text {Stop} \
            -command "$this killProcess"
    
    $itk_component(bbox) add help \
	    -text "Help" \
	    -command "$this help"

    $itk_component(bbox) buttonconfigure cancel \
	    -text {Close <Esc>}

    if {![info exists itk_component(history)] || \
            ![winfo exists $itk_component(history)]} {
        # We have not yet created the history window, so do so now.
        itk_component add history {
            ::tycho::Edit $itk_component(hull).history -textheight 15
        } {
            keep -readonly -textwidth -background \
                    -highlightbackground -highlightcolor -selectforeground \
                    -cursor -insertbackground -textforeground -textfont \
                    -textbackground
        }
        pack $itk_component(history) -expand yes -fill both \
                -after $itk_component(querysite)
        $itk_component(history) configure -readonly 1 -save 0
        # FIXME: add key binding for C-x C-r
    }

    # Make the entry boxes wide so we can see the entire command
    configure -entrywidth 80

    wm resizable $prefix 1 1
    # NOTE: There seems to be no way to find out the actual window size at this
    # point.  The commands "wm reqwidth" and "wm width" return 1, even after
    # a "tkwait visibility" and an "update".  So we just set some reasonable
    # minimum size.
    wm minsize $prefix 10 10

    # If we are running under the test suite, then autostart and autodestroy
    global TY_TESTSUITE
    if [info exists TY_TESTSUITE] {
	#set itk_option(-autostart) 1
	set itk_option(-autodestroy) 1
	#configure -autostart 1
	configure -autodestroy 1
    }

    # If autostart is not equal to zero, then start the subprocess
    # This should be at the end of the constructor
    if {$itk_option(-autostart) == 1} {
        $this centerOnScreen
        $this execProcessInMonitor
    }

    configure -autostart 

    return $this
}

#######################################################################
#### destructor
#
body ::tycho::Monitor::destructor {} {
    # Adding this close seems to hang the window manager
    #close $fd
    # Unregister our fileevent handler
    catch {fileevent $fd readable {}}

    # Mark the editor as unmodified so that we are not prompted as
    # to whether we want to save it.
    if {[info exists itk_component(history)] && \
            [winfo exists $itk_component(history)]} {
        #$itk_component(history) configure -readonly 0
        #$itk_component(history) clear
        $itk_component(history) markUnmodified
    }
    catch {unset ::tycho::Monitor::$statusVariableName}
}


    ##################################################################
    ##################################################################
    ####                     public methods                       ####

#######################################################################
#### saveSetting
# Called by each button binding. However, this should not be in the
# preference, but rather, by the invocation of the constructor of Monitor.
# This method currently does not do anything.
#
body ::tycho::Monitor::saveSetting {} {
    # Don't move it to preference.
}

#######################################################################
#### jumpNextError
# Make sure we don't jump too far. errorList has the following format:
# { {cLineNum eLineNum} {cLineNum eLineNum} ... }
# Where cLinNum is the compiler's line number, along with
# eLineNum, which is the editor's line number.
#
body ::tycho::Monitor::jumpNextError {} {
    # NOTE: errorCount=$errorCount   errorList=$errorList
    if {$errorCount!=-1 && $errorCount<[llength $errorList]} {
        # Find out where in the list my information is located.
        # This has the format {{1 2 asdf.cc} {5 10 fdsa.cc} ...}
        set entry [lindex $errorList $errorCount]
        set monitorLine [lindex $entry 0]
        set editorLine [lindex $entry 1]
        set fname [lindex $entry 2]
        jumpToLine $monitorLine $editorLine $fname
        incr errorCount
    } else {
        tycho::inform "No more errors!"
    }
}

#######################################################################
#### jumpToLine
# This will open file context, and jump to entry number.
# eLineNum = editor's line number (where error occured)
# cLineNum = compiler's line number (where error reported)
# fname = filename of the error source code.
#
body ::tycho::Monitor::jumpToLine {monitorLine editorLine fname} {
    # FIXME: directory could potentially be anywhere, specified in Makefile.
    # Name of our editor/viewer
    set fileToOpen [file join [get dirToExecFrom] $fname]
    set editorName [::tycho::File::openContext $fileToOpen]
    set editorName [string trim $editorName :]

    # Jump to the line in the compile/exec widget
    set history $itk_component(history)
    if {[winfo exists $history]} {
        $history seeFragment "line $monitorLine"
    }

    # Jump to the line in editor
    $editorName seeFragment "line $editorLine"
}


#######################################################################
#### insertLine
# In the constructor, doEachLine is set as "$this insertLine $line" so that
# during each input, this method will be called. This method is responsible
# for updating the history.text widget interactively, as well as colorization
# of the error and warning messages. Later on, this functionaility will
# be moved to MonitorC and MonitorJava to handle different coloring and
# interaction.
#
body ::tycho::Monitor::insertLine {line} {
    set text $itk_component(history).text
    #set monitorLine [lindex [split [$text index insert] .] 0]
    incr monitorLine

    # Need to lock up the output of the executable
    $itk_component(history) configure -readonly 0
    # The following line causes trouble when the user changes the
    # cursor position!
    #$itk_component(history) insertData "$line"
    $text insert $monitorLine.0 $line
    $itk_component(history) center
    $itk_component(history) configure -readonly 1

    # Now, if we have to, modify the line (ie. change color, etc)
    if {[regexp {^([^:]+):([0-9]+): (.+)$} $line tmp fname editorLine msg] \
            && $previousErrorLine!=$editorLine} {
        set previousErrorLine $editorLine

        incr errorCount
        # This ensures only one line per many lines of error output
        if {[regexp {(warning): (.+)} $msg]} {
            #FIXME: Change me to preference
            set color {purple}
        } else {
            #FIXME: Change me to preference
            set color {red}
            lappend errorList [list $monitorLine $editorLine $fname]
        }
        $text tag add error$errorCount \
                $monitorLine.0 $monitorLine.[expr [string length $line]-1]
        $text tag configure error$errorCount -foreground $color -underline 0
        # Two actions to the error binding:
        # 1) jump to the lines (and highlight)
        # 2) update internal count, so Next button will know where to jump
        $text tag bind error$errorCount <Double-Button-1> \
                "$this jumpToLine $monitorLine $editorLine $fname;\
                $this setErrorCount $errorCount"
    }
}

#######################################################################
#### setErrorCount
# This method is called by each click on the error/warning lines, so
# that when NextError button is pressed, it'll know exactly where to
# jump to.
#
body ::tycho::Monitor::setErrorCount {count} {
    set errorCount $count
}


#######################################################################
#### execProcessInMonitor
# This simply calls the non-graphical Exec's execProcess. Also, it
# reads the autoDestroy flag and determins whether this widget should
# automatically exit upon successful execution.
#
body ::tycho::Monitor::execProcessInMonitor {} {
    set monitorLine 0
    set oldCursor [lindex [config -cursor] end]
    config -cursor {watch}
    ::tycho::safeUpdate $this

    # Clear both history logs before executing
    $itk_component(history) configure -readonly 0
    $itk_component(history) clear
    $itk_component(history) configure -readonly 1
    $this clearHistory
    
    $this execProcess [get commandToExec] [get dirToExecFrom]

    if {[get autoDestroy]==1} {
        # ASSERT([$this getSatusWait]!="running")       always the case
        if {[$this getStatusWait]=="normal"} {
            # If returned correctly, it's okay to exit this window
	    # Wrap this in a catch in case we already destroyed the
	    # parent window, which will cause this window to be destroyed.
	    # see tycho/editors/textedit/test/testEditC.itcl
            after 2500 "catch {delete object $this}"
        } else {
            insertLine "<<NOTE: exit status is [$this getStatusWait],\
                    will not autodestroy.>>"
        }
    }
    # Make sure everything's done, then reset the error count
    $this getStatusWait
    set errorCount 0
    
    config -cursor $oldCursor
}

    ##################################################################
    ##################################################################
    ####                   protected methods                      ####

