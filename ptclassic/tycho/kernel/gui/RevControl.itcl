# Definition of the class which handles revision control.
#
# @Authors: Joel King and Edward A. Lee
#
# @Version: $Id$
#
# @Copyright (c) 1995-%Q% The Regents of the University of California.
# All rights reserved.
# 
# Permission is hereby granted, without written agreement and without
# license or royalty fees, to use, copy, modify, and distribute this
# software and its documentation for any purpose, provided that the
# above copyright notice and the following two paragraphs appear in all
# copies of this software.
# 
# IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY
# FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
# ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF
# THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.
# 
# THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE
# PROVIDED HEREUNDER IS ON AN "AS IS" BASIS, AND THE UNIVERSITY OF
# CALIFORNIA HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,
# ENHANCEMENTS, OR MODIFICATIONS.
# 
# 						PT_COPYRIGHT_VERSION_2
# 						COPYRIGHTENDKEY
#######################################################################

# Types of revision control software, in order of preference.
# It is assumed that for each type listed, there is a class defined
# called RevControl$type, where $type is the type, and that this
# class is derived from RevControl.
option add *revisionControlTypes {SCCS RCS} widgetDefault

#######################################################################
#### RevControl
# Base class for revision control objects. The main entry point is is
# the procedure <code>setup</code>, which will create a revision
# control window of the appropriate type. The list of revision control
# types is given by the option "revisionControlTypes", which lists them
# in order of preference (e.g. "SCCS RCS", which is the default value).
# It is assumed that for each type listed, there is a class defined
# called <code>RevControl$</code><i>type</i>, where $<i>type</i> is the
# type, and that this class is derived from <code>RevControl</code>.
#
class ::tycho::RevControl {
    inherit ::tycho::DialogWindow

    constructor {args} {}
    destructor {}

    ###################################################################
    ####                         options                           ####

    # Specify the File object under version control.
    itk_option define -object object Object ""

    ###################################################################
    ####                      public methods                       ####

    # Check in the file and update revision control information.
    method checkInAndUpdate {}

    # Check out the file and update revision control information.
    method checkOutAndUpdate {}

    # Put the file under revision control.
    method initializeRevControl {} 

    # Unedit the file, reverting to the previously checked in version.
    method unedit {}

    # View the version control history.
    method viewHistory {} {error "Sorry, not implemented yet"}

    ###################################################################
    ####                      public procs                         ####

    # Check in the file associated with the given File object.
    proc checkIn {object} {}

    # Check out the file associated with the given File object.
    proc checkOut {object} {}

    # Return 1 if the given file is under revision control, 0 otherwise.
    proc isUnderRevControl {file} {return 0}

    # Make a revision control object of the specified type.
    proc makeRev {type editorWin editorObj} {}

    # Setup revision control for an editor of type File.
    proc setup {editorWin editorObj} {}

    # Return the revision control class controlling a File object, if any.
    proc whichRevClass {obj} {}

    ###################################################################
    ####                   protected methods                       ####

    # Enable one of "checkin" or "checkout" buttons and make it the default.
    protected method enableButton {button}

    # Return 1 if the file is checked out, 0 otherwise.
    protected method isCheckedOut {} {return 0}

    # Update the history information, if it is on display.
    protected method updateHistory {}

    ###################################################################
    ####                  protected procs                          ####

    # Change to the given directory with appropriate error checks.
    protected proc cdDir {dir} {}

    # Query the user for comments (to be used on checkin).
    protected proc getComments {} {}

    ###################################################################
    ####                  protected variables                      ####

    # The text widget object that we are associated with.
    protected variable textobject {}

    # The object that we are associated with.
    protected variable object {}

    # The file that we are associated with.
    protected variable file {}
}

#########################################################################
#### -object configuration
# Specify the File object under version control.
# If the specified object is not a <code>::tycho::File</code> object,
# or does not exist, then trigger an error.
# 
configbody ::tycho::RevControl::object {
    set object $itk_option(-object)
    # NOTE: It would be nice to check:
    #     [uplevel #0 info objects $object] == {}
    # However, "info" in itcl is basically broken.  It does not
    # understand scoping annotations like a prefix "::".
    if {$object == {} || ![$object isa ::tycho::File]} {
	error "You must specify a File object with the -object option"
    }
    set file [$object cget -file]
    configure -title "Revision control for $file"
    set retval [isUnderRevControl $file]
    initializeRevControl
    if [isCheckedOut] {
	enableButton checkin
    } {
	enableButton checkout
    }
}
    
###################################################################
#### constructor
#
body ::tycho::RevControl::constructor {args} {
    eval itk_initialize $args

    addButton checkin -text "Checkin" -command "$this checkInAndUpdate"
    addButton checkout -text "Checkout" -command "$this checkOutAndUpdate"
    addButton history -text "History" -command "$this viewHistory"
    addButton unedit -text "Unedit" -command "$this unedit"
    addButton cancel -text "Close <Esc>" -command \
	   "$this nextWindow; delete object $this"

    bind $itk_component(hull) <Escape> "$this invoke cancel"
}

###################################################################
#### checkInAndUpdate
# Check in the file, update the state of the control buttons,
# and update the history information, if it is being viewed.
#
body ::tycho::RevControl::checkInAndUpdate {} {
    # Procs are not virtual. Itcl bug?
    [info class]::checkIn $object
    if {![isCheckedOut]} {
        enableButton checkout
        updateHistory
    }
}

###################################################################
#### checkOutAndUpdate
# Check out the file, update the state of the control buttons,
# and update the history information, if it is being viewed.
#
body ::tycho::RevControl::checkOutAndUpdate {} {
    # Procs are not virtual. Itcl bug?
    [info class]::checkOut $object
    if [isCheckedOut] {
        enableButton checkin
        updateHistory
    }
}

###################################################################
#### initializeRevControl 
# Put the file under revision control.
#
body ::tycho::RevControl::initializeRevControl {} {
    if {$file == {}} {
	error "Revision control: no file specified"
    }
}

###################################################################
#### unedit
# Query the user for confirmation, then unedit the file, reverting to
# the previously checked in version.  This base class method
# only does the query.  If the user does not confirm, exit with
# a silent error.
#
body ::tycho::RevControl::unedit {} {
    if {$file == {}} {
	error "Revision control: no file specified"
    }
    if [::tycho::askuser \
	    "Are you sure you want to discard your changes (if any)?"] {
	enableButton checkout
    } {
        ::tycho::silentError
        # error "Unedit cancelled"
    }
}


###################################################################
###################################################################
####                     public procs                          ####

###################################################################
#### checkIn
# Check in the file associated with the specified File object.
#
body ::tycho::RevControl::checkIn {object} {
    if {$object == {}} {
        error "No object specified for check in"
    }
    if {![$object isa ::tycho::File]} {
        error "Cannot check in object $object: Not a ::tycho::File."
    }
    set file [$object filename]
    if {$file == {}} {
	error "checkIn: no file associated with the object $object"
    }
    if [$object isModified] {
	if [::tycho::askuser "Save modifications before checking in?"] {
	    $object save 
	}
    }
}

###################################################################
#### checkOut
# Check out the file associated with the specified File object.
#
body ::tycho::RevControl::checkOut {object} {
    if {$object == {}} {
        error "No object specified for check out"
    }
    if {![$object isa ::tycho::File]} {
        error "Cannot check out object $object: Not a ::tycho::File."
    }
    set file [$object filename]
    if {$file == {}} {
	error "checkOut: no file associated with the object $object"
    }
}

###################################################################
#### makeRev
# Make a revision control object of the specified type.
# The first argument is the type (SCCS, RCS, ...),
# the second argument is the window name for the editor, and
# the third argument is the editor object, which must be an
# instance of <code>::tycho::File</code> or a class derived from that.
#
body ::tycho::RevControl::makeRev {type editorWin editorObj} {
    # Create a revision control window
    uplevel #0 " \
	    $type $editorWin.revcontrol \
	    -object $editorObj \
	    -geometry +0+0 \
	    -before $editorWin"
    wm deiconify $editorWin.revcontrol
}

###################################################################
#### setup
# Setup revision control for an editor. The arguments are the name of
# the top-level editor window and the name of the editor object, which
# must be an instance of <code>::tycho::File</code> or a class derived
# from that.
#
body ::tycho::RevControl::setup {editorWin editorObj} {

    # If a rev control window is already open, use it.
    if [winfo exists $editorWin.revcontrol] {
	wm deiconify $editorWin.revcontrol
	raise $editorWin.revcontrol
	$editorWin.revcontrol focusin
	return
    }

    set pref [option get . revisionControlTypes Tycho]
    set revclass [whichRevClass $editorObj]

    # If the file is not under revision control, query the user
    # for permission to put it under revision control.
    if {$revclass == {}} {
	set dlg [::tycho::autoName .rev]
	::tycho::DialogWindow $dlg -text \
		"This file is not currently under revision control.\
		Do you want it placed under revision control?"

	set default {}
	foreach type $pref {
	    $dlg addButton $type -text "Yes ($type)" -command \
		    [code "::tycho::RevControl::makeRev \
                    ::tycho::RevControl$type $editorWin \
		    $editorObj; delete object $dlg"]
	    if {$default == {}} {
		$dlg default $type
		set default $type
	    }
	}
	$dlg addButton no -text "No <Esc>" -command [code "delete object $dlg"]
	bind $dlg <Escape> [code "delete object $dlg"]
	$dlg centerOnScreen
    } else {
	::tycho::RevControl::makeRev $revclass $editorWin $editorObj
    }
}

###################################################################
#### whichRevClass
# Return the name of a suitable revision control class if the given
# object is under revision control. Otherwise, return an empty string.
# The object must be a <code>::tycho::File</code> object.
#
body ::tycho::RevControl::whichRevClass {obj} {
    if {![$obj isa ::tycho::File]} {
        error "Cannot check revision control for $obj: Not a ::tycho::File."
    }
    set pref [option get . revisionControlTypes Tycho]
    set filename [$obj filename]
    set revclass {}

    # Step through possible revision control systems and determine
    # whether they control the file.
    foreach type $pref {
	if [::tycho::RevControl$type::isUnderRevControl $filename] {
	    set revclass "::tycho::RevControl$type"
	    break
	}
    }
    return $revclass
}

###################################################################
###################################################################
####                     protected methods                     ####

###################################################################
#### enableButton
# Enable one of "checkin" or "checkout" buttons and make it the default.
# The argument must be one of "checkin" or "checkout".
# The other button is disabled.
#
body ::tycho::RevControl::enableButton {button} {
    if {$button == {checkin}} {
	$itk_component(bbox) buttonconfigure checkin -state normal
	default checkin
	$itk_component(bbox) buttonconfigure checkout -state disabled
    } {
	$itk_component(bbox) buttonconfigure checkout -state normal
	default checkout
	$itk_component(bbox) buttonconfigure checkin -state disabled
    }
}

#####################################################################
#### updateHistory
# Update the history information, if it is on display.
# This does nothing in the base class.
# 
body ::tycho::RevControl::updateHistory {} {
}

###################################################################
###################################################################
####                     protected procs                       ####

#####################################################################
#### cdDir
# Change to the given directory with appropriate error checks.
# 
body ::tycho::RevControl::cdDir {dir} {
    if {[file isdirectory $dir] && [file executable $dir]} {
	cd $dir
    } else {
	error "The directory \"$dir\" is not writable."
    }
}

#####################################################################
#### getComments
# Open a dialog box to query the user for comments.
# 
body ::tycho::RevControl::getComments {} {
    set list [::tycho::DialogWindow::newModal EntryQuery \
	    [::tycho::autoName .getcomment] \
	    -queries {{body {Comment:} {} 5}}  \
	    -entrywidth 60]
    set comments [lindex [lindex $list 0] 1]
    return [join [split $comments "\n"] "\\\n"]
}

