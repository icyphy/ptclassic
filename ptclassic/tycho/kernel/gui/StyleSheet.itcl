#########################################################################
# Version: $Id$
# Author: John Reekie
#
# @Copyright (c) 1996-%Q% The Regents of the University of California.
# All rights reserved.
# 
# Permission is hereby granted, without written agreement and without
# license or royalty fees, to use, copy, modify, and distribute this
# software and its documentation for any purpose, provided that the
# above copyright notice and the following two paragraphs appear in all
# copies of this software.
# 
# IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY
# FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
# ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF
# THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.
# 
# THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE
# PROVIDED HEREUNDER IS ON AN "AS IS" BASIS, AND THE UNIVERSITY OF
# CALIFORNIA HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,
# ENHANCEMENTS, OR MODIFICATIONS.
# 
# 						PT_COPYRIGHT_VERSION_2
# 						COPYRIGHTENDKEY
##########################################################################


##########################################################################
#### StyleSheet
#
# <b>This class is under development.</b>
#
# The <i>StyleSheet</i> class provides a mechanism for widgets
# to have configuration options controlled by a central
# database.
#
# A style sheet has three types:
#
# <dl>
#
# <dt><b>stylesheet</b> _name_:
# <dd>Within a style sheet, a StyleSheet model contains multiple
# stylesheets. One of them must be named "master," while the
# others can have any arbitrary name. Style sheets cannot
# be nested. They have the following attributes:
# <ul>
#   <li><b>-description</b> <i>description</i>: An HTML description
#   of the stylesheet in HTML which will be displayed in help windows.
#   <li><b>-label</b> <i>label</i>: A brief string describing
#   the group. By convention, groups are only made available
#   in the preference user interface if they have a description.
# </ul>
#
# <dt><b>group</b> _name_:
# <dd>Preferences within a style sheet can be divided into groups.
# Groups are just a structuring mechanism for preferences, and
# can be arbitrarily nested. Groups cannot appear at the
# top level of a model. Groups have the following attributes:
# <ul>
#   <li><b>-description</b> <i>description</i>: An HTML description of
#   the group in HTML which will be displayed in help windows.
#   <li><b>-label</b> <i>label</i>: A brief string describing
#   the group. By convention, groups are only made available
#   in the preference user interface if they have a description.
# </ul>
# 
# <dt><b>preference</b> _name_ _value:
# <dd>A widget preference. Preferences cannot appear at the
# top level of a model, but can appear anywhere within a
# style sheet. Preferences cannot contain other items.
# They have the following attributes:
# <ul>
# <li><b>-label</b> <i>label</i>: A brief string describing
# the preference. By convention, preferences are only made available
# in the preferences user interface if they have a description.
#
# <li><b>-description</b> <i>description</i>: An HTML description of
# the preference which will be displayed in help windows.
#
# <li><b>-type</b> <i>type</i>: The "type" of the preference. This
# will be used by the preference editor to decide how to display
# and edit the preference. Legal types are:
# <ul>
#   <li><b>string</b>: Can be any arbitrary value. This is the default.
#   <li><b>number</b>: A number.
#   <li><b>integer</b>: An integer.
#   <li><b>boolean</b>: A boolean value.
#   <li><b>choice</b>: A small set of (arbitrary) possible values. These
#   are intended for display by radiobuttons.
#   <li><b>set</b>: A larger set of (arbitrary) possible values. These
#   are intended for display by an option menu.
#   <li><b>font</b>: A font value, specified as a list {_family_ _size_
#   _style_}. The second and third elements can be omitted -- see FontManager
#   for details.
#   <li><b>color</b>: A symbolic color value.
# </ul>
#
# <li><b>-values</b> <i>list</i>: A list representing
# the set of legal values of
# the parameters. Valid for _choice_ and _set_ types.
#
# </ul>
#
# </ul>
# 
class ::tycho::StyleSheet {
    inherit ::tycho::DataModel

    constructor {args} {}
    destructor {}

    #################################################################
    ####                     public methods                      ####

    # Add a new style sheet, group, or preference
    method add {type name args}

    # Set the value of a preference
    method assign {name value}

    # Get a preference value
    method get {name {convert 0}}

    # Get an option of an item
    method itemcget {name option}

    # Get options of an item
    method itemconfigure {name {option {}} args}

    # Return names in a given context
    method names {group}

    # Notify of a data change
    method notify {mode args}

    # Subscribe to the style sheet
    method subscribe {mode args}

    # Unsubscribe from a style sheet
    method unsubscribe {group widget args}

    #################################################################
    ####                  protected variables                    ####

    # For each widget, the subscribed options
    protected variable _subscribedoptions
}


########################################################################
#### constructor
#
body ::tycho::StyleSheet::constructor {args} {
   
    # Evaluate options
    eval configure $args

    # Define the stylesheet type
    definetype stylesheet \
            -label {} \
            -description {} \
            -rootonly 1
    
    # Define the group type
    definetype group \
            -label {} \
            -description {} \
            -nonroot 1

    # Define the preference type
    definetype preference \
            -valued 1 \
            -leaf 1 \
            -nonroot 1 \
            -label {} \
            -description {} \
            -type string \
            -values {}
}

########################################################################
#### assign
#
# Assign a value to an existing preference. Flag an error if the
# preference does not exist. Return the inverse command.
#
body ::tycho::StyleSheet::assign {name value} {
	# Build the preference type
	set type stylesheet
	for {set i [llength $name]} {i > 2} {incr i -1} {
		lappend type group
	}
	lappend type preference

	# Make sure that the preference exists, creating it from
	# the master if necessary
    _verify $type $name

    # Assign it and return the inverse command
    list assign $name [$_data assign $type $name $value]
}

########################################################################
#### get
#
# Get the value of an preference. Go up the hierarchy
# until data is found.
#
body ::tycho::StyleSheet::get {group preference {convert 0}} {
    set found 1
    if { [::info exists _value($group.$preference)] } {
	set value $_value($group.$preference)

    } elseif { [::info exists _uplink($group.$preference)] } {
	set group $_uplink($group.$preference)
	set value $_value($group.$preference)

    } else {
	set found 0
	foreach g $_heritage($group) {
	    if { [::info exists _value($g.$preference)] } {
		# Found one: set up links
		set _uplink($group.$preference) $g
		if { ! [::info exists _downlinks($g.$preference)] } {
		    set _downlinks($g.$preference) [list $group]
		} elseif { \
			[lsearch -exact $_downlinks($g.$preference) $group] \
			== -1 } {
		    lappend _downlinks($g.$preference) $group
		}
		set value $_value($g.$preference)
		set found 1
		set group $g
		break
	    }
	}
    }
    if { ! $found } {
	error "Preference '$preference' not accessible from group '$group'.\n\
		This error can be caused by the preference manager\n\
		becoming confused about the time stamps on the preferences\
		files.\n\
		Removing ~/.Tycho/.preferences and restarting Tycho might\
		fix this problem."
    }
    # Translate if requested
    if { $convert } {
	array set temp $_attrs($group.$preference)
	switch -exact $temp(-type) {
	    "font" {
		set value [eval ::tycho::font $value]
	    }
	    "color" {
		set value [eval ::tycho::color $value]
	    }
	}
    }
    return $value
}

########################################################################
#### group
#
# Create a new preference group.  See the class
# comment at the top of this document for the legal attributes.
#
# Note that the <code>::tycho::preference</code> procedure does not
# provide access to this method because groups cannot be added
# once preference entries have been read from the object. This
# is because of the way that the relationships between preferences
# in different groups are cached for effiency -- see
# how the uplink and downlink variables are used in the code.
#
body ::tycho::StyleSheet::group {group body} {
    # Create a list of ancestors. Unfortunately, we have to
    # scan through the body to get the -inherits option
    set t [lsearch -exact $body -inherits]
    if { $t == -1 } {
	set _heritage($group) {}
    } else {
	set _heritage($group) [lindex $body [expr $t+1]]
	foreach p $_heritage($group) {
	    set _heritage($group) [concat $_heritage($group) $_heritage($p)]
	}
    }
    # Add the group and parse the preferences in the body
    _addentity "group" {} $group $group {} [list $body]
    return
}

########################################################################
#### groupcget
#
# Return an attribute of a group.
#
body ::tycho::StyleSheet::groupcget {group attr} {
    _verify group {} $group
    _itemcget group {} $group $attr
}

########################################################################
#### groups
#
# Return a list of preference groups.
#
body ::tycho::StyleSheet::groups {} {
    _roots group
}

########################################################################
#### initialize
#
# Initialize the widget with its files and user-defined preferences.
#
body ::tycho::StyleSheet::initialize {df sf uf} {
    # Configure options
    configure -sourcefile $df -statefile $sf

    # Load the data
    load

    # Catch incompatibilities cause by a change in the internal
    # structure of Models (4/23/97). Try and read an internal array
    # and if that fails then reload from the data file
    if { ! [::info exists _info([list preference fonts textFont])] \
        || ! [::info exists _info([list preference java javaHome])] } {
	puts "Removing outdated $sf"
	file delete [::tycho::expandPath $sf]
	_clear
	load -statefile {}
    }

    # If the user doesn't have a preferences state file, create it now
    if { ! [file exists [::tycho::expandPath $sf]] } {
	save
    }

    # If the user has a preferences file, source it
    if { [file exists [::tycho::expandPath $uf]] } {
	source [::tycho::expandPath $uf]
    }
}


########################################################################
#### notify
#
# This method is called by publish{} to notify subscribers of a change.
# This method is overridden in order that not only the widgets subscribed
# to this preference, but also widgets subscribed to the same preference
# in descendent groups, are notified.
#
body ::tycho::StyleSheet::notify \
	{subscriber command group preference args} {
    set index $group.$preference

    # Do this index
    eval [list chain $subscriber $command $index] $args
    
    # Do in descendents
    if { [::info exists _downlinks($index)] } {
	::tycho::assign group preference [split $index "."]
	foreach g $_downlinks($index) {
	    eval [list chain $subscriber $command $g.$preference] $args
	}
    }
}

########################################################################
#### prefcget
#
# Return an attribute of a preference.
#
body ::tycho::StyleSheet::prefcget {group preference attr} {
    _verify preference $group $preference
    _itemcget preference $group $preference $attr
}

########################################################################
#### preferences
#
# Return a list of preferences in the given group.
#
body ::tycho::StyleSheet::preferences {group} {
    _verify group {} $group
    _children preference $group
}

########################################################################
#### subscribeoptions
#
# Subscribe to options. The arguments are a list of option-name
# preference-name pairs. This makes direct access to the internal
# subscription array to keep option subscription as fast as possible.
# Generate an error if the group does not exist.
#
body ::tycho::StyleSheet::subscribeoptions {widget group args} {
    _verify group {} $group

    # Add all subscriptions that are not excluded, and, for each,
    # collect the current value.
    set arglist {}
    foreach {option preference} $args {
	if { ! [::info exists _exclusions($widget,$option)] } {
	    # Subscribe
	    set _subscription($widget,$group.$preference) \
		    "$widget ::itk::Archetype::configure $option \
		    \[$this get $group $preference 1\]"
	    # Remember
	    set _subscribedoptions($widget,$option) $group.$preference
	    # Current value
	    lappend arglist $option [get $group $preference 1]
    	}
    }
    # Update the widget now
    eval $widget ::itk::Archetype::configure $arglist
}

########################################################################
#### unsubscribeoptions
#
# Unsubscribe options from preferences. The optional arguments are a
# list of _option_ (NB: not preference) names -- if there are
# none, the widget is unsubscribed completely.
#
body ::tycho::StyleSheet::unsubscribeoptions {widget group args} {
    if { $args == "" } {
	# Unsubscribe from all options 
	unsubscribe $widget
	foreach i [array names _exclusions $widget,*] {
	    unset _exclusions($i)
	}
	foreach i [array names _subscribedoptions $widget,*] {
	    unset _subscribedoptions($i)
	}
    } else {
	foreach option $args {
	    if [::info exists _subscribedoptions($widget,$option)] {
		unsubscribe $widget $_subscribedoptions($widget,$option)
		unset _subscribedoptions($widget,$option)
	    }
	}
    }
}
