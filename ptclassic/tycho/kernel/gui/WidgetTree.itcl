#
# Widgettree
# ----------------------------------------------------------------------
# Implements an unfolding tree of widgets, with a button at each
# node to open and close the node. Each level of the tree can
# contain either a series of leaf and nodes, or a single leaf
# widget. This widget is designed for implementing unfolding
# preference and dialog boxes as well as viewers of tree-like
# structures.
#
## WISH LIST:
#   This section lists possible future enhancements.  
#
#   1) Generally the Widgettree should be used together with
#      a Scrolledframe widget. It would be nice if the widget
#      would adjust itself in the scrolled frame so that when
#      a node of the tree is opened, it scrolls so that it
#      is entirely visible in the window. Perhaps widgettree
#      should inherit from or contain a scrolled frame.
#
# ----------------------------------------------------------------------
#  AUTHOR: H. John Reekie              EMAIL: johnr@eecs.berkeley.edu
#
#  $Id$
# ----------------------------------------------------------------------
#
# Copyright (c) 1997 The Regents of the University of California.
# All rights reserved.
# 
# Permission is hereby granted, without written agreement and without
# license or royalty fees, to use, copy, modify, and distribute this
# software and its documentation for any purpose, provided that the
# above copyright notice and the following two paragraphs appear in all
# copies of this software.
# 
# IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY
# FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
# ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF
# THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.
# 
# THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE
# PROVIDED HEREUNDER IS ON AN "AS IS" BASIS, AND THE UNIVERSITY OF
# CALIFORNIA HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,
# ENHANCEMENTS, OR MODIFICATIONS.
# 
# 						PT_COPYRIGHT_VERSION_2
# 						COPYRIGHTENDKEY
#######################################################################

#
# Usual options.
#
itk::usual Widgettree {
    keep -disabledforeground -highlightthickness -borderwidth \
	    -font -highlightcolor -background \
	    -foreground -activebackground -cursor -activeforeground 
}

# ------------------------------------------------------------------
##                            WIDGETTREE
# ------------------------------------------------------------------
#
# Implements an unfolding tree of widgets, with a button at each
# node to open and close the node. Each level of the tree can
# contain either a series of leaf and nodes, or a single leaf
# widget. This widget is designed for implementing unfolding
# preference and dialog boxes as well as viewers of tree-like
# structures.
#
class iwidgets::Widgettree { 
    inherit itk::Widget

    constructor {args} {}
    destructor {}

    public variable closedbitmap @arrowclose.xbm
    public variable openedbitmap @arrowopen.xbm
    public variable closecommand ""
    public variable createcommand ""
    public variable opencommand ""
    public variable indent 24

    public method add {type tag args}
    public method close {tag}
    public method create {type tag args}
    public method hide {tag}
    public method open {tag}

    private variable _type         ;# Widget type, or "node"
    private variable _row          ;# Grid row of each item added with add{}
    private variable _state        ;# State of each item: open, closed, or leaf
    private variable _path         ;# mapping from tag to Tk widget
    private variable _nextrow      ;# The next available row in each node
    private variable _itemoptions  ;#Options for individual items

    method debug {args} {
        eval $args
    }
}

#
# Use option database to override default resources.
#
# option add *Widgettree.thickness 3 widgetDefault ???

#
# Provide a lowercase access method for the Widgettree class
#
proc ::iwidgets::widgettree { args } {
    uplevel ::iwidgets::Widgettree $args
}

# ------------------------------------------------------------------
##                        CONSTRUCTOR
# ------------------------------------------------------------------
body iwidgets::Widgettree::constructor {args} {
    # The counter for top-level items
    set _nextrow() 0

    # Set the grid column options for the top level frame
    grid columnconfigure $itk_interior 0 -minsize $indent -weight 0
    grid columnconfigure $itk_interior 1 -weight 1

    # Configure options
    eval itk_initialize $args
}

# ------------------------------------------------------------------
##                             OPTIONS
# ------------------------------------------------------------------

# ----------------------------------------------------------------------
## OPTION -closedbitmap
#
# Specify the bitmap to display in the open/close button of
# closed tree nodes. The bitmap may be specified in any of the
# forms accepted by Tk_GetPixmap.
# ----------------------------------------------------------------------
configbody iwidgets::Widgettree::closedbitmap {
    foreach tag [array names _state] {
        if { $_state($tag) == "closed" } {
            $itk_component(${tag}button) configure \
                    -bitmap $closedbitmap
        }
    }
}

# ----------------------------------------------------------------------
## OPTION -closecommand
#
# Specify a command to execute when a node of the tree is closed.
# If this command is null, clicking on the open-close button will
# close the node; if not, the command will be executed in the global
# scope with the tag of the node appended, and the node will not
# close automatically.
# ----------------------------------------------------------------------
configbody iwidgets::Widgettree::closecommand {
}

# ----------------------------------------------------------------------
## OPTION -createcommand
#
# Specify a command to execute when a node of the tree is opened
# if the node does not currently contain any widgets. The command is
# executed at the global scope with the tag of the node appended.
# The command should use the add{}, place{}, or create{} methods
# to create the contents of the node. If the command is null, the
# node is opened anyway but nothing will be displayed.
# ----------------------------------------------------------------------
configbody iwidgets::Widgettree::createcommand {
}

# ----------------------------------------------------------------------
## OPTION -indent
#
# Specify the minimum indent for each level of the tree. This
# option is needed in order that each level is indented correctly,
# regardless of the presence or not of open-close buttons at
# each level. It sets the minimum indent, not the actual indent:
# if either *-closedbitmap* or *-openedbitmap* makes an
# open-close button wider than the specified indent, that width
# will be used instead. (There is no reasonable way to avoid this,
# since that's hoe Tk's grid manager works.) The default value is
# pixels.
# ----------------------------------------------------------------------
configbody iwidgets::Widgettree::indent {
    grid columnconfigure $itk_interior 0 -minsize $indent
    foreach t [array names _path] {
	if [regexp {^(open|closed)$} $_state($t)] {
	    grid columnconfigure $_path($t) 0 -minsize $indent
	}
    }
}

# ----------------------------------------------------------------------
## OPTION -openbitmap
#
# Specify the bitmap to display in the open/close button of
# open tree nodes. The bitmap may be specified in any of the
# forms accepted by Tk_GetPixmap.
# ----------------------------------------------------------------------
configbody iwidgets::Widgettree::openedbitmap {
    foreach tag [array names _state] {
        if { $_state($tag) == "open" } {
            $itk_component(${tag}button) configure \
                    -bitmap $openedbitmap
        }
    }
}

# ----------------------------------------------------------------------
## OPTION -opencommand
#
# Specify a command to execute when a node of the tree is opened
# and the node already contains one or more child widgets. The
# command is executed at the global scope with the tag of the node
# appended. The node is opened and its contents displayed after
# the command returns.
# ----------------------------------------------------------------------
configbody iwidgets::Widgettree::opencommand {
}

# ------------------------------------------------------------------
##                            METHODS
# ------------------------------------------------------------------


# ------------------------------------------------------------------
## METHOD: add type tag ?option value...?
#
# Add a new widget to a node of the tree. The first argument is
# its tag, and the second is its type. Tags can be hierarchical,
# as in *foo.bar*, provided that the parent node has previously
# been created (in this case, *foo*). The special type <b>node</b>
# is used to create a new node, in which case the following special
# options are recognised:
# <ul>
# <li><b>-opencommand</b> _command_: This option overrides the default
# value of <b>-opencommand</b> given to this Widgettree.
# <li><b>-closecommand</b> _command_: This option overrides the default
# value of <b>-closecommand</b> given to this Widgettree.
# <li><b>-createcommand</b> _command_: This option overrides the default
# value of <b>-createcommand</b> given to this Widgettree.
# </ul>
# Any other options are passed directly to the constructor of the
# the node label. Usually, the options will include at least the
# <b>-text</b> option.
#
# Any other value of _type_ is assumed to be the type of the widget
# to create. The following options will be treated specially:
# <ul>
# <li><b>-options</b> _optionspec_: This option which can be used
# to override the <b>usual</b> option handling for the component.
# The value of *-options* is appended to the string "usual\n",
# so that the usual options specified for the Widgettree
# are propagated to the created widget, and any additional
# <b>keep</b>, <b>rename</b>, or <b>ignore</b> commands specified
# in *-options* are also processed. For example, if adding a
# widget that has a <b>-labelfont</b> option instead of a
# <b>-font</b> options, one might write
# <pre>
#   $win create radiobox size -options {
#       rename -labelfont -font font Font
#   }
# </pre>
# </ul>
# Any other options are passed directly to the constructor of the
# specified widget type.
#
# The returned value from this method is always the tag. 
# If needed, the Tk path of a created widget
# can be accessed by passing _tag_ to the <b>component</b> method.
# Note that, in the case, of nodes, this method will attempt to
# access the frame in which child nodes are placed, and will fail
# if no child node has been created with add{} or create{}.
#
# ------------------------------------------------------------------    
body iwidgets::Widgettree::add {type tag args} {
    # Decompose the tag
    regexp {^((([^\.]+)?.*)?\.)?([^\.]+)$} $tag _ _ parent _ tail

    # This is a hierarchical tag. If the parent is a node
    # but there is no parent frame, create one
    if { $parent != "" } {
        if ![::info exists _path($parent)] {
            if [::info exists _row($parent)] {
		# Create the frame
		itk_component add $parent {
		    frame $itk_interior.$parent
		}
		# Remember it
		set _path($parent) $itk_component($parent)
		set _type($parent) "node"

		# If the parent node is open, display it
		if { $_state($parent) == "open" } {
		    grid $itk_component($parent) \
			    -row [expr $_row($parent)+1] \
			    -column 1 \
			    -sticky nw
		}
		# Configure column size/weight
		grid columnconfigure $itk_component($parent) 0 \
			-minsize $indent -weight 0
		grid columnconfigure $itk_component($parent) 1 \
			-weight 1
            } else {
                error "Parent doesn't exist: $parent"
            }
        } elseif { $_state($parent) == "leaf" } {
            # Check that the parent is actually a node.
            error "Cannot add to type $_type($parent)"
        }
    }

    # Process according to type
    if { $type == "node" } {
	# Don't need to extract options now, but do make sure the
	# option list is valid
	array set junk $args
	set _itemoptions($tag) $args

	# Create the open/close button and the label
	itk_component add ${tag}button {
	    button $itk_interior.${tag}button \
		    -command "$this open $tag" \
		    -borderwidth 1 \
		    -bitmap $closedbitmap
	}
	grid $itk_component(${tag}button) \
                -row $_nextrow($parent) \
                -column 0 \
		-sticky nw
	
	# Create the accompanying label
	itk_component add ${tag}label {
	    eval label $itk_interior.${tag}label $args
	}
	grid $itk_component(${tag}label) \
                -row $_nextrow($parent) \
                -column 1 \
                -sticky nw
        
	# Remember the parameters of this node
	set _nextrow($tag) 0
   	set _row($tag) $_nextrow($parent)
        set _state($tag) closed

	# Update the row counter. Note that we increment it by
	# two so that when the button is opened, the new widget
	# can be placed in the intervening row
	incr _nextrow($parent) 2

    } else {
	# Extract options
	set options "\nusual\n"
	array set opts $args
	if [::info exists opts(-options)] {
	    append options $opts(-options)
	    unset opts(-options)
	    set args [array get opts]
	}
	# Create the widget
	itk_component add $tag {
	    eval $type $itk_interior.$tag $args
	} $options

        # Grid it
	grid $itk_component($tag) \
                -row $_nextrow($parent) \
                -column 1 \
                -sticky nw

	# Remember the parameters of this item
	set _row($tag) $_nextrow($parent)
        set _state($tag) leaf
        set _type($tag) $type

	# Update the row counter
	incr _nextrow($parent)
    }
    return $tag
}

# ------------------------------------------------------------------
## METHOD: close tag
#
# Close a node of the tree. If the *-closecommand* option is
# not null, it is evaluated with the tag appended, and the
# node is _not_ closed. The close command can choose to perform
# any action it likes (such as user confirmation), and must
# explicitly close the node with the hide{} method. If the
# *-closecommand* option is not null, the node is just closed.
# ------------------------------------------------------------------
body iwidgets::Widgettree::close {tag} {
    set _state($tag) closed

    array set opts $_itemoptions($tag)
    if [::info exists opts(-closecommand)] {
	set cmd $opts(-closecommand)
    } else {
	set cmd $closecommand
    }
    if { $cmd != "" } {
        # If there's a command, execute it
        uplevel #0 $cmd $tag
    } else {
        # Otherwise just close the node
        hide $tag
    }
}

# ------------------------------------------------------------------
## METHOD: create type tag ?option value ...?
#
# Create a new widget and make it into the only child of a node
# of the tree. The _type_ argument is the Tk widget type, and
# _tag_ is the tag of the node.  Remaining arguments are an
# option-value list, from which the following special options will
# be extracted:
# <ul>
# <li><b>-options</b> _optionspec_: This option which can be used
# to override the <b>usual</b> option handling for the component.
# The value of *-options* is appended to the string "usual\n",
# so that the usual options specified for the Widgettree
# are propagated to the created widget, and any additional
# <b>keep</b>, <b>rename</b>, or <b>ignore</b> commands specified
# in *-options* are also processed. For example, if adding a
# widget that has a <b>-labelfont</b> option instead of a
# <b>-font</b> options, one might write
# <pre>
#   $win create radiobox size -options {
#       rename -labelfont -font font Font
#   }
# </pre>
# </ul>
# Any other options are passed directly to the constructor of the
# specified widget type.  The returned value is the tag. If
# needed, the Tk path of the created widget can be accessed
# by passing _tag_ to the <b>component</b> method.
# ------------------------------------------------------------------
body iwidgets::Widgettree::create {type tag args} {
    # Extract the -options option
    set options "\nusual\n"
    array set opts $args
    if [::info exists opts(-options)] {
	append options $opts(-options)
	unset opts(-options)
	set args [array get opts]
    }

    # Create the widget
    itk_component add $tag {
        eval $type $itk_interior.$tag $args
    } $options

    # Remember it
    set _path($tag) $itk_component($tag)
    set _type($tag) $type

    # If the parent node is open, display it
    if { $_state($tag) == "open" } {
        grid $itk_component($tag) \
                -row [expr $_row($tag)+1] \
                -column 1 \
                -sticky nw \
		-pady 4
    }
    return $itk_interior.$tag
}

# ------------------------------------------------------------------
## METHOD: hide tag
#
# Unconditionally close a node of the tree. This
# should normally be called only from within the *-closecommand*
# option.
#
# ------------------------------------------------------------------
body iwidgets::Widgettree::hide {tag} {
    # Hide the widget, making sure it exists first
    if [::info exists _path($tag)] {
        grid remove $itk_component($tag)
    }
    # Change the button
    $itk_component(${tag}button) configure \
            -bitmap $closedbitmap \
            -command "$this open $tag"

    # Make sure state is correct
    set _state($tag) closed
}

# ------------------------------------------------------------------
## METHOD: open tag
#
# Open a node of the tree and display a widget there. If a widget
# doesn't exist for this node and *-createcommand* is not null,
# call it with the tag of this widget appended. The value of
# *-createcommand* is firstly found from the local option given
# to this node in a previous call to add{}, or if that is null,
# than from the value given to this Widgettree. *-createcommand*
# can sensibly do one of two things:
# <ol>
# <li>Call add{} to a widget or node to the tree.
# This will cause another level of the tree to be created below
# this one, and each call to add{} will ads an item to that level.
# <li>Call create{} with the widget tag as the first argument.
# This will cause the specified widget to be created as the single
# widget at this level of the tree.
# </ol>
#
# If the widget already exists, then *-opencommand* is called with
# the widget path appended. Again *-opencommand* is found first from
# the item options and then from the Widgettree options.
# *-opencommand* can manipulate the widget any way it likes --
# including deleting it and creating a new one as for *-createcommand*.
# Then the widget is displayed in the widget hierarchy.
# ------------------------------------------------------------------
body iwidgets::Widgettree::open {tag} {
    # Before doing anything, set the state so that any
    # calls back to the widget know to display components
    set _state($tag) open

    # If the widget doesn't exist, execute *-createcommand*.
    array set opts $_itemoptions($tag)
    if ![::info exists _path($tag)] {
	if [::info exists opts(-createcommand)] {
	    set cmd $opts(-createcommand)
	} else {
	    set cmd $createcommand
	}
        if { $cmd != "" } {
            uplevel #0 $cmd $tag
        }
    } else {
	# If it does exist, call *-opencommand* and than grid it
	if [::info exists opts(-opencommand)] {
	    set cmd $opts(-opencommand)
	} else {
	    set cmd $opencommand
	}
        if { $cmd != "" } {
            uplevel #0 $cmd $tag
        }
        grid $itk_component($tag)
    }
    # Configure the button
    $itk_component(${tag}button) configure \
	    -bitmap $openedbitmap \
	    -command "$this close $tag"
}
