# Definition of a text widget that displays formatted HTML.
#
# @Author: Edward A. Lee
# @Contributor: Stephen Uhler (HTML library), 
#
# @Version: $Id$
#
# @Copyright (c) 1995-%Q% The Regents of the University of California.
# All rights reserved.
# 
# Permission is hereby granted, without written agreement and without
# license or royalty fees, to use, copy, modify, and distribute this
# software and its documentation for any purpose, provided that the
# above copyright notice and the following two paragraphs appear in all
# copies of this software.
# 
# IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY
# FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
# ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF
# THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.
# 
# THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE
# PROVIDED HEREUNDER IS ON AN "AS IS" BASIS, AND THE UNIVERSITY OF
# CALIFORNIA HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,
# ENHANCEMENTS, OR MODIFICATIONS.
# 
# 						PT_COPYRIGHT_VERSION_2
#
# Portions of the code in this file are modified from the HTML library
# by Stephen Uhler (of Sun Microsystems), and "surfit", written by
# members of the PASTIME project at the Australian National University.
# The copyrights below apply to those versions:
#
#	Copyright (c) 1996 Australian National University and
#	Sun Microsystems
#
#--------
#
#	PASTIME Project
#	Cooperative Research Centre for Advanced Computational Systems
#	COPYRIGHT NOTICE AND DISCLAIMER.
#
#	Copyright (c) 1995 ANU and CSIRO
#	on behalf of the participants in
#	the CRC for Advanced Computational Systems (ACSys)
#
# This software and all associated data and documentation ("Software")
# was developed for research purposes and ACSys does not warrant that 
# it is error free or fit for any purpose.  ACSys disclaims all liability
# for all claims, expenses, losses, damages and costs any user may incur 
# as a result of using, copying or modifying the Software.
#
#
# 						COPYRIGHTENDKEY
#######################################################################

# FIXME: Known bugs
# - The rendering is quite slow.  Needs to be speeded up.
# - The Tcl extension should use more standard HTML syntax.
# - Embedded windows should be supported.

# Load the HTML library, if necessary, and make adjustments.
if {[info commands HMinit_win] == {}} {
    uplevel #0 {
	source [file join $TYCHO lib html_library html_library.tcl]

	# Make format adjustments -- better than the default
	set HMtag_map(h2) {size 20 weight bold}
	set HMtag_map(h3) {size 20 style i}
	set HMtag_map(h4) {size 16 weight bold}
	set HMtag_map(h5) {size 16 style i}

        set HMinitialtag_map $HMtag_map(hmstart)
        unset HMtag_map(hmstart)
    }
}

#######################################################################
#### HTML
# This widget parses HTML using the library by Stephen Uhler and
# displays it in a Tk text widget. Only local file accesses are
# currently supported (no HTTP, FTP, etc). The HTML source can be
# specified using the -data option or indirectly using the -file
# option. If the HTML will have references to other files (such as
# image files) that are relative, then the reference directory should
# be specified using the -directory option if the -data option was
# used.  Otherwise, the directory is inferred from the -file option.
# 
class ::tycho::HTML {
    inherit ::tycho::Edit

    ###################################################################
    ####                       options                             ####

    # The directory for relative references to images and the like,
    itk_option define -directory directory Directory {}

    # Override the slowNetwork preference for this html browswer.
    itk_option define -image image Image 0

    # Offset from the nominal 14 points for the font sizes.
    itk_option define -size size Size 2

    constructor {args} {}
    destructor {}

    ###################################################################
    ####                      public methods                       ####

    # Prompt the user for a file name and load in place of the current file.
    method altFile {}

    # Start up appletviewer on the current file.
    method appletViewer {}

    # Go back to the previous view.
    method back {}

    # Clear the window.
    method clear {}

    # Execute Tcl code embedded in the HTML.
    method execTcl {x y}

    # Open a help window.
    method help {}

    # Open a file and go to its internal point identified by name.
    method hyperJump {filename {point {}} {push 1}}

    # Insert the specified data.
    method insertData {data}

    # Insert the contents of the directory.
    method insertDirectoryContents {dirname}

    # Return 1 if rendering is in progress, and 0 otherwise.
    method isRendering {} {return $isrendering}

    # Return 1 if the slowNetwork preference is set.
    method isSlowNetwork {}

    # Return the reference directory.
    method lastDirectory {}

    # Display the link destination in the status bar
    method linkEnter {xpos ypos}

    # Open the source file using an HTML editor.
    method openSource {}

    # Print the selection or the entire contents.
    method print {}

    # Raise the HTML browser window and the source window (if any).
    method raiseWindow {}

    # Reload from the last saved version of the file.
    method reload {}

    # Go to the specified hypertext reference, line, or range.
    method seeFragment {point}

    # Indicate whether rendering is currently in progress.
    method setRendering {val} {set isrendering $val}

    # Request that rendering stop.  Note that it does not occur immediately.
    method stopRendering {}

    # Return the full path name of the text window.
    method textWinName {}

    # Add a file editor object to the window menus of all open File objects.
    method windowMenuAddAll {label}

    # Remove a filename from the window menus of all open File objects.
    method windowMenuRemoveAll {filename}

    ###################################################################
    ####                      public procedures                    ####

    # Render the given text for a particular HTML object.
    proc render {obj {html {}}} {}

    ###################################################################
    ####                     protected methods                     ####

    # Access the "viewhtml" preferences
    protected method preference {mode args}

    # Configure the popup menu depending on the current context
    protected method configureContextMenu {}

    ###################################################################
    ####                      protected variables                  ####

    # Indicate whether a rendering operation is in progress.
    protected variable isrendering 0

    ###################################################################
    ####                      private methods                      ####

    # Return 1 if the sourcewin window is a valid source window.
    private method sourcewinIsMine {}

    # Return 1 if the extension is the extension of an image file.
    private method isAnImageFileExtension {extension}

    ###################################################################
    ####                     private variables                     ####

    # Keep count of the number of calls to seeFragment
    private variable seecount 0

    # Keep track of the requested size adjustment.
    private common sizeName

    # Keep track of the current source window for the current file.
    private variable sourcewin {}

    # Store the name of our stack object
    private variable stack {}

    # The name of the global array used to store the state of the window.
    private variable stateArrayName {}
}

#########################################################################
#### -size configuration
# The size of normal text will be 14 points plus the size adjustment
# set with this option.
#
configbody ::tycho::HTML::size {
    HMset_state [textWinName] -size $itk_option(-size)
}

###################################################################
#
body ::tycho::HTML::constructor {args} {

    # Set the view "type" for the Window menu
    set viewType "html"

    # Add buttons to the toolbar, if it exists.
    # FIXME: need a forward command.
    # FIXME: should the user be allowed to change the home window?
    
    toolbar button back {Go back to the previously viewed page} \
            -text Back -command "$this back"
    
    global ::TYCHO
    
    toolbar button home {Go to the Tycho home page} \
            -text Home -command "$this hyperJump \
	    [file join \$TYCHO doc index.html]"
    
    toolbar button reload {Reload and reparse from the file} \
            -text Reload -command "$this reload"
    
    toolbar button open {Open a new file} \
            -text Open -command "$this altFile"
    
    toolbar button find {Find text or a pattern on this page} \
            -text Find -command "$this search"
    
    toolbar button stop {Abort rendering} \
            -text Stop -command "$this stopRendering"

    set text $itk_component(text)

    # Initialize the text window.  The returned value is supposed to be
    # the global variable used to store the state of the window, but isn't.
    HMinit_win $text

    # Add a binding for links to display the destination.
    $text tag bind link <Enter> "$this linkEnter %x %y"
    $text tag bind link <Leave> "$this statusbar puts {}"

    # Modifications on configuration in the HTML library:
    $text tag configure link -underline 1

    # Additions:
    $text tag configure subscript -offset -6
    $text tag configure superscript -offset +6

    set stateArrayName HM$text

    eval itk_initialize $args

    # Subscribe to the preference set
    preference subscribeoptions $this \
	    -textfont textFont \
	    -textforeground textForeground \
	    -textbackground textBackground \
	    -relief textRelief \
	    -textwidth textWidth \
	    -textheight textHeight

    # Setup Special menu
    menubar addMenu Special -underline 0

    menubar add "Appletviewer" Special -underline 0 \
            -command "$this appletViewer"
    # This causes us to require that Exec.itcl be read in at startup
    if ![::tycho::Exec::execWidgetIsSupported] {
	menubar disable Appletviewer
    }


    if {$itk_option(-directory) == {}} {
        configure -directory [file dirname $file]
    }

    bind $text <space> "$this scroll 1; break"

    # Double clicks normally select text, something we don't want here.
    bind $text <Double-Button-1> {break}

    array set sizes {tiny -2 small 0 medium 2 large 4 huge 8}
    if {$myMenubar != {}} {
        foreach size {tiny small medium large huge} {
            $myMenubar add [lindex $size 0] Format \
		    -type radiobutton \
                    -variable [scope sizeName($this)] \
                    -command \
                    "$this configure -size $sizes($size); \
                    ::tycho::HTML::render $this"
        }
    }

    set sizeName($this) [preference get fontSize]
    configure -size $sizes($sizeName($this))

    # Modify the menu commands appropriately.
    if {$myMenubar != {}} {
        $myMenubar disable {Undo/Redo}
        $myMenubar disable {Cut}
        $myMenubar disable {Paste}
        $myMenubar disable "Font..."
        $myMenubar delete "Fill Region"
        $myMenubar delete "Right Fill Column"
        $myMenubar delete "Set Fill Prefix"
        $myMenubar delete "Lower Case"
        $myMenubar delete "Upper Case"
        $myMenubar delete "Capitalize"

        $myMenubar insert "Open Source" "Switch File..." \
                -underline 1 -accelerator {C-x s} \
                -command "$this openSource"
        
        $myMenubar delete "Insert..."
        $myMenubar delete "Save"
        $myMenubar delete "SaveAs..."
        $myMenubar delete "Evaluate"
        $myMenubar delete "Revision Control..."
        $myMenubar delete "Toggle Read-Only"
    }
    bind $prefix <Control-x><Key-s> "$this openSource; break"
    # disable certain bindings
    bind $prefix <Control-x><Control-s> {bell; break}
    bind $prefix <Control-x><Control-w> {bell; break}
    bind $prefix <Control-x><Control-v> {bell; break}
    bind $prefix <Control-x><Control-q> {bell; break}
    bind $prefix <Control-x><Key-i> {bell; break}
    bind $prefix <Control-x><Key-v> {bell; break}

    configure -readonly 1
    focusin

    # Create a stack to store where we've been.
    set stack [::tycho::Stack #auto]

    # Add myself to the list of open files. 
    windowMenuAddAll $file

    # Disable auto-save.
    configure -save 0

    # Make the insertion cursor invisible.
    $text configure -insertofftime 0
    $text configure -insertbackground [$text cget -background]

    toolbar entry location Location $file "$this hyperJump"

    # Put some space around the text
    $text configure -padx 0.25c -pady 0.25c

}

###################################################################
#
body ::tycho::HTML::destructor {} {
    stopRendering
    if [sourcewinIsMine] {
	# Schedule this for after destruction is complete because the
	# base class destructor removes the menu entry.
	after idle "$sourcewin windowMenuAddAll $file"
    }
    catch {unset sizeName($this)}
    if {[info exists stack] && [info objects $stack] != {}} {
	delete object $stack
    }
}

    ###################################################################
    ###################################################################
    ####                      public methods                       ####

###################################################################
#### altFile
# Query the user for a filename, and if the selected file has the
# extension ".html", ".htm", or "htl", insert its contents in place of the
# currently displayed HTML.  Otherwise, view its contents in a new window.
#
body ::tycho::HTML::altFile {} {
    set filename [safeEval ::tycho::queryfilename {Alternate file to load:}]
    if {$filename != {}} {
	hyperJump $filename
    }
}
#####################################################################
#### appletViewer
# Start up appletviewer on the current file
#
body ::tycho::HTML::appletViewer {} {
     set w [::tycho::autoName .appletViewer]
     ::tycho::Exec $w \
	     -command "appletviewer $file" \
	     -dir [file dirname $file] \
	     -entrywidth 80
     $w centerOnScreen
}

#####################################################################
#### back
# Go back to the previous view, popping it off the stack.
#
body ::tycho::HTML::back {} {
    set ref [$stack pop]
    if {$ref == {}} {return}
    set filename [lindex $ref 0]
    set point [lindex $ref 1]
    # Use the optional third argument to avoid being recorded for
    # backtracking.
    hyperJump $filename $point 0
}

#####################################################################
#### clear
# Clear the current text.
#
body ::tycho::HTML::clear {} {
    HMreset_win [textWinName]
    deleteRange 1.0 end
}

#####################################################################
#### execTcl
# Execute the Tcl code under the "current" mark.
# The Tcl code is simply the largest contiguous region of text tagged
# "tcl".  The code is executed in the global scope, and the result is
# displayed.
#
body ::tycho::HTML::execTcl {x y} {
    set cmd [getTaggedText tcl]
    if {$cmd != {}} {
	set result [uplevel #0 $cmd]
        if {$result != {}} {
            set tags [[textWinName] tag names @$x,$y]
            if {[lsearch -exact $tags tclq] < 0} {
                safeEval ::tycho::inform "Returned:\n$result"
            } {
                putStatus "Returned: $result"
            }
        } {
            putStatus "null string returned"
        }
    }
}

#########################################################################
#### help
# Open a help window.
#
body ::tycho::HTML::help {} {
    global ::TYCHO
    ::tycho::File::openContext \
	    [file join $TYCHO kernel doc usersGuides HTMLHelp.html]
}

#####################################################################
#### hyperJump
# Open a file and go to its internal point identified by name. If the
# filename has the extension ".html", ".htm", or "htl", and this window
# is inside a <code>Displayer</code> object, then open it in
# this same window. If the filename is the empty string, then move the
# view to a location within the same file. If filename is relative
# (does not begin with "/", "~", or "$"), then prepend the directory of
# the file currently being viewed. Then, expand the filename using
# <code>::tycho::expandPath</code> and open the resulting file with
# <code>::tycho::File::openContext</code>, which will choose an editor
# based on the filename extension. Finally, invoke
# <code>seeFragment</code> to view the specified point within the file.
# The format for the <i>point</i> argument depends on the type of file
# being opened. For HTML files, it will normally be the name of an
# anchor in the file or specified "yview" location within the file. For
# text files, it will normally be either "{line <i>linenumber</i>}" or
# "{range <i>start</i> <i>end</i>}", where <i>start</i> and <i>end</i>
# have the form <i>linenumber.characternumber</i>. If the third
# argument, which is optional, has value 0, then the jump is not
# recorded for backtracking.
#
# NOTE: This method really should support the syntax "filename#fragment"
# in the filename argument.  Someday.
#
body ::tycho::HTML::hyperJump {filename {point {}} {push 1}} {
    if {$filename != {}} {

	# Use isRelative, not 'file pathtype' so that we handle paths
	# that start with ~ and $.
	if [::tycho::isRelative $filename] {
            set filename [format "%s/%s" [file dirname $file] $filename]
        }
        set filename [::tycho::expandPath $filename]

        # If the file is a directory, open "index.html" in that directory,
        # if it exist, otherwise display the contents of the directory.
        if [file isdirectory $filename] {
            set newfilename [format "%s/%s" $filename index.html]
            if ![file exists $newfilename] {
                # For backtracking
                if $push {
                    $stack push [list $file [currentPoint]]
                }
                configure -directory [file dirname $filename]
                configure -file $filename
                toolbar clear location
                toolbar insert location $filename
                # Reset the insertion cursor to the origin, or else we will
                # try to preserve the point in the file.
                $itk_component(text) mark set insert 1.0

                if {$point != {}} {
                    after 200 [list $this seeFragment $point]
                }
		insertDirectoryContents $filename
		return
            } else {
                set filename $newfilename
                unset newfilename
            }
        }


        # If the filename has the ".html", ".htm", or ".htl" extension, open it
        # in this window (unless it is already open in another window or
        # we are not inside a Displayer).
        set ext [file extension $filename]
        if {($ext == ".html" || $ext == ".htm" || $ext == ".htl" || \
            [isAnImageFileExtension $ext]) && \
                $myDisplayer != {}} {

            # Special care is required here because there might be a
            # source file open for either the old or the new file. If
            # there is a source file for the old HTML file, it will now
            # appear in the "Window" menu. If there is one for the new
            # file, it should now be removed from the Window menu (the
            # HTML browser widget will take its place).

            # If the destination file is already open, raise it.
            if {[info exists filesOpen($filename)] && \
                    [eval $filesOpen($filename) isa ::tycho::HTML]} {
                ::tycho::File::hyperJump $filename $point
                return
            }

            # If the destination file does not exist, issue a message.
            if ![file readable $filename] {
                ::tycho::warn \
                        "File does not exist or is not readable:\n$filename"
                return
            }

            # For backtracking
            if $push {
                $stack push [list $file [currentPoint]]
            }

            configure -directory [file dirname $filename]
            configure -file $filename
            toolbar clear location
            toolbar insert location $filename

            # Reset the insertion cursor to the origin, or else we will
            # try to preserve the point in the file.
            $itk_component(text) mark set insert 1.0

            # Handle Image files specially
	    if [isAnImageFileExtension $ext] {
		insertData "<img src=\"$filename\" alt=\"$filename\">"
	    } else {
                reload
            }

            if {$point != {}} {
                after 200 [list $this seeFragment $point]
            }
            configure -readonly 1
            return
        }
    } {
        # For backtracking
        if $push {
            $stack push [list {} [currentPoint]]
        }
    }

    # The file is not an HTML file, or is not specified,
    # so defer to File.
    ::tycho::File::hyperJump $filename $point
}

#####################################################################
#### insertData
# Insert the specified data, cancelling any previous rendering.
#
body ::tycho::HTML::insertData {data} {
    stopRendering
    # This is done in the background so that construction completes.
    # The time delays seems to be necessary to ensure that the window
    # gets mapped immediately.
    after 100 [list ::tycho::HTML::render $this $data]
}

#####################################################################
#### insertDirectoryContents
# Insert the contents of the the directory 'dirname' into the html
# widget.  We use this if the user visits a directory that does not
# have a index.html file so that the user can see the contents of the
# directory.
#
body ::tycho::HTML::insertDirectoryContents {dirname} {
    clear
    set toc "<h1>Contents of [::tycho::simplifyPath $dirname]</h1>\n\
            <pre><A HREF=\"..\">.. Up to higher level directory</A>"

    # A string with 20 spaces, that we use to left justify the links
    # We print the contents of the file inside a preformatted block
    # so that we can align the text properly.
    set spaceString "                   "

    set dirFiles [lsort [glob -nocomplain $dirname/*]]
    foreach dirFile $dirFiles {
        # If the filename is over 20 chars long, truncate it and add ...
        set shortName [file tail $dirFile]
        if [file isdirectory $dirFile] {
            # FIXME Unixism?  We are adding a / here, what about mac and windows
            set shortName "$shortName/"
        }
        if {[string length $shortName] > 20} {
            set shortName "[string range $shortName 0 16]..."
        }
        if [catch {file stat $dirFile stat} msg] {
            set toc [format \
                    "%s<br><A HREF=\"%s\">%s</A>%s  Couldn`t stat\n" \
                    $toc $dirFile \
                    $shortName \
                    [string range $spaceString \
                    1 [expr {20 - [string length $shortName]}]] \
                ]
        } else {
            set toc [format \
                    "%s<br><A HREF=\"%s\">%s</A>%s %6s %s\n" \
                    $toc $dirFile \
                    $shortName \
                    [string range $spaceString \
                    1 [expr {20 - [string length $shortName]}]] \
                    $stat(size) \
                    [clock format $stat(mtime)]]
        }
    }
    insertData $toc
}

#####################################################################
#### lastDirectory
# Return the directory for relative references to images and the like.
#
body ::tycho::HTML::lastDirectory {} {
    return $itk_option(-directory)
}

#####################################################################
#### linkEnter
# Display the link destination in the status bar for the link below
# the specified mouse position.
#
body ::tycho::HTML::linkEnter {xpos ypos} {
    set tags [$itk_component(text) tag names @$xpos,$ypos]
    set link [lindex $tags [lsearch -glob $tags L:*]]
    # regsub -all {[^L]*L:([^ ]*).*}  $tags {\1} link
    regsub L: $link {} link
    statusbar puts $link
}

#####################################################################
#### openSource
# Open the source file using an editor specialized for editing HTML.
#
body ::tycho::HTML::openSource {} {
    # If a source window already exists, just raise it.
    if [sourcewinIsMine] {
	$sourcewin raiseWindow
	return
    }
    set obj [::tycho::view EditHTML -file $file]
    set sourcewin $obj
}

#####################################################################
#### print
# Print the selection or, if there is no selection, the entire contents.
# At the moment, this first warns the user that it is not fully implemented,
# querying him or her to see whether to proceed.  Then, it
# queries the user for the print command to use.  A temporary file is
# created and then deleted to do the printing.  The name of that file
# will be appended to the end of the command specified by the user before
# it is invoked.
#
body ::tycho::HTML::print {} {
    if [safeEval ::tycho::askuser {Printing HTML is not fully implemented. \
            A fairly crude facsimile of the text only will be printed. \
            Proceed?}] {
        ::tycho::Edit::print
    }
}

#####################################################################
#### raiseWindow
# Raise this window and also the source window, if it is open.
#
body ::tycho::HTML::raiseWindow {} {
    if [sourcewinIsMine] {
	$sourcewin raiseWindow
    }
    ::tycho::TWidget::raiseWindow
}

#####################################################################
#### reload
# Reload from the last saved version of the current file. This method
# first disables read-only status (if it is set), then replaces the
# current data with data from the current file, and then sets read-only
# status. The data is marked unmodified after loading the file, and the
# clipboard is restored to its form prior to the reload. The actual
# replacement of the data occurs via the method
# <code>insertData</code>.
#
body ::tycho::HTML::reload {} {
    # Handle Image files specially
    set ext [file extension $file]
    if {($ext == ".gif" || $ext == ".ppm" || $ext == ".pgm" || \
            $ext == ".xbm") && $myDisplayer != {}} {
        clear
        insertData "<img src=\"$file\" alt=\"$file\">"
    } else {
        ::tycho::File::reload
    }
    # Mark read-only to prevent modifications.
    configure -readonly 1
}

#####################################################################
#### seeFragment
# Goto the specified hypertext reference, line number, or range.
# The <i>point</i> argument can take any of three forms:
# <pre>
#    {line <i>linenumber</i>}
#    {range <i>startindex endindex</i>}
#    {yview <i>fraction</i>}
#    <i>name</i>
# </pre>
# In the first three forms, the point is a list beginning with the keyword
# "line", "range", or "yview".  If the point has neither of these forms, then
# it is interpreted as the name of named anchor in the HTML file.
# In all cases, the background color of the matching text is changed
# temporarily.  Notice that this will not be visible if the "range" form
# is used and the two indices are equal.  As a side effect, the selection
# (if there is one) is cleared.
#
body ::tycho::HTML::seeFragment {point} {
    set text $itk_component(text)
    if {[llength $point] == 2 && [lindex $point 0] == {line}} {
        # First form: A line number.
        set ln [lindex $point 1]
        set sidx [$text index "$ln.0"]
        set eidx [$text index "$ln.0 lineend +1 char"]
    } elseif {[llength $point] == 3 && [lindex $point 0] == {range}} {
        # Second form: A range of indexes
        set sidx [lindex $point 1]
        set eidx [lindex $point 2]
    } elseif {[llength $point] == 2 && [lindex $point 0] == {yview}} {
        # Third form: a yview spec.
        $text yview moveto [lindex $point 1]
        return
    } {
        # Third form: a named anchor.
        ::tycho::safeUpdate $prefix
        HMgoto $text $point
        return
    }
    if {$sidx != {} && $eidx != {}} {
        # If rendering is in progress, the point may not exist yet.
        if {[$text compare $sidx >= end]} {
            if {$seecount < 40} {
                incr seecount
                after 400 [code evalIfExists $this seeFragment $point]
                return
            } {
                # Give up.  Probably point will never be visible.
                set sidx end
                set eidx end
            }
        }
        set seecount 0
	$text tag add hypertarget $sidx $eidx
	$text tag configure hypertarget \
		-background [preference get targetColor]
	$text tag configure hypertarget \
		-foreground black
	component text mark set insert $sidx; 	\
                selection clear -displayof $text; $text see insert
        after 8000 [list catch \
               [list $text tag delete hypertarget]]
    }
}

#####################################################################
#### isSlowNetwork
# Return 1 if the slowNetwork preference is set and the -image itk_option
# is null.  If -image is set, then we assume the user really does want
# to see the image.
#
body ::tycho::HTML::isSlowNetwork {} {
    if {$itk_option(-image) != 0 } { 
	return 0
    } else {
	return [preference get slowNetwork]
    }
}

#####################################################################
#### stopRendering
# Stop the rendering.  This simply disables the HMrender proc by
# setting a flag that causes HMrender to return immediately without
# doing anything.
#
body ::tycho::HTML::stopRendering {} {
    # The HTML library version 0.3 has a bug where HMset_state win -stop 1
    # does not properly set the stop bit in the control array.  So
    # instead, we set it directly.
    # HMset_state [textWinName] -stop 1
    upvar #0 $stateArrayName var
    set var(stop) 1
}

#####################################################################
#### textWinName
# Return the full path name of the text widget. Note that this path
# name is defined as a command at the global scope. This is intended
# only to be used for interfacing to legacy Tcl/Tk code that interacts
# directly with a Tk text widget. A null string is returned if for some
# reason the text window name does not exist (due to an error in
# construction).
#
body ::tycho::HTML::textWinName {} {
    if [info exists itk_component(text)] {
	return $itk_component(text)
    } {
	return {}
    }
}

#####################################################################
#### windowMenuAddAll
# Add me to the window menus of all open File objects.
# This is redefined in order to coordinate the source window, which
# may be open.
#
body ::tycho::HTML::windowMenuAddAll {label} {
    # Reclaim the source window, if it is open.
    if {[info exists filesOpen($label)]} {
        set sourcewin $filesOpen($label)
        $sourcewin windowMenuRemoveAll $label
    } {
        set sourcewin {}
    }
    ::tycho::File::windowMenuAddAll $label
}

#####################################################################
#### windowMenuRemoveAll
# Remove a filename from the window menus of all open File objects.
# This is redefined in order to coordinate the source window, which
# may be open.
#
body ::tycho::HTML::windowMenuRemoveAll {filename} {
    ::tycho::File::windowMenuRemoveAll $filename
    if [sourcewinIsMine] {
        $sourcewin windowMenuAddAll $filename
        set sourcewin {}
    }
}

    ###################################################################
    ###################################################################
    ####                      public procedures                    ####

#####################################################################
#### render
# Render the given HTML text in the given <code>HTML</code> window.
# If the given HTML text is not given or is a null string, then use the
# value of the -data option for the given object as the text.
# This is a procedure rather than a method because the object it operates
# on may be destroyed during the rendering process.  It should be invoked
# in the background, using "after", not in the constructor!
# Otherwise, the constructor does not complete until rendering is
# finished.  Moreover, the "update" calls in the rendering are dangerous
# in a constructor.
#
body ::tycho::HTML::render {obj {html {}}} {

    if {[info objects $obj] == {} || ![$obj isa ::tycho::HTML]} {return}

    if {$html == {}} {
        set html [$obj cget -data]
    }
    # Cancel previous rendering if necessary.
    if [$obj isRendering] {
        $obj stopRendering
        # Allow some time for rendering to complete.
        after 100 [list ::tycho::HTML::render $obj $html]
        return
    }

    $obj setRendering 1

    # Get the name of the Tk text widget.
    set tktext [$obj textWinName]
    $tktext configure -state normal
    
    # Remove all existing text in the widget.
    $tktext delete 1.0 end
    
    # Put the insertion cursor at the top
    $tktext mark set insert 1.0
    $tktext mark gravity insert left
    HMreset_win $tktext

    # Note that the following parsing operation results in many
    # calls to update, which can result in the widget $this being destroyed.
    HMparse_html $html "HMrender $tktext"

    # The catch is in case the object no longer exists
    catch {
	$obj setRendering 0
    }

    # FIXME: The following removes the insertion cursor, which
    # is good, but disables all the navigation bindings, which
    # is bad.  Perhaps those bindings can be redone in the
    # HTML class.
    # $tktext configure -state disabled
}


#########################################################################
#########################################################################
####                    protected methods                            ####

#####################################################################
#### preference
# Access the preferences associated with this widget. This method
# overrides the default method in ::tycho::TWidget to access the
# "viewhtml" preferences.
#
body ::tycho::HTML::preference {mode args} {
    eval ::tycho::preference $mode "viewhtml" $args
}

#####################################################################
#### configureContextMenu
# Configure the popup menu according to context. For HTML viewers, this
# looks for a corresponding itcl file and offers to open that if it
# finds one.
#
body ::tycho::HTML::configureContextMenu {} {
    ::tycho::TWidget::configureContextMenu

    if { $itk_option(-file) != "" && $itk_option(-file) != "NoName" } {
	set link [file split $itk_option(-file)]
	set path [lrange $link 0 [expr [llength $link] - 4]]
	set fname [join [concat \
		[lreplace [split [lindex $link end] .] end end] "itcl"] .]
	set link [eval file join $path $fname]

	if { [file exists $link] } {
	    contextmenu add "Open source" \
		    -command "$this hyperJump $link"
	}
    }
}

#########################################################################
#########################################################################
####                     private methods                             ####

#####################################################################
#### sourcewinIsMine
# Return 1 if the sourcewin window is the source window for the
# currently open HTML text. Otherwise, return 0.
#
body ::tycho::HTML::sourcewinIsMine {} {
    if {$sourcewin != {}} {
        # Test to see whether the window still exists.
        # We use catch here because other Itcl methods seem to be too tricky.
        if [catch {$sourcewin isModified}] {
            return 0
        }
	return 1
    } {
	return 0
    }
}

#####################################################################
#### isAnImageFileExtension
# Return 1 if the extension is the extension of an image file.
#
body ::tycho::HTML::isAnImageFileExtension {ext} {
    return [expr {($ext == ".gif" || $ext == ".ppm" || $ext == ".pgm" || \
		    $ext == ".xbm") && $myDisplayer != {}}]
}


    ###################################################################
    ###################################################################
    ####         modifications to the HTML library                 ####

# Instead of blindly inserting newlines, as done in the original
# library, we only insert them if they are not already there.
# The following table indicates how many newlines are desired
# by the tag. It replaces "HMinsert_map" in the original library.

array set HMinsert_space_map {
	blockquote 2 /blockquote 1
	br	1
	dd	1 /dd	1
	dl	1 /dl	1
	dt	1
	form 1	/form 1
	h1	2	/h1	2
	h2	2	/h2	2
	h3	2	/h3	2
	h4	2	/h4	2
	h5	1	/h5	1
	h6	1	/h6	1
	li   1
	/dir 1
	/ul 1
	/ol 1
	/menu 1
	p	2
	pre 1	/pre 2
}

array set HMparam_map {
    -foreground S_fgcolor
    -background S_bgcolor
}

#######################################################################
# The following empty procedures prevent calls to "unknown", which
# is very expensive.  This makes the HTML parser significantly faster.

foreach tag {
    !-- a address applet author b banner
    base big blockquote body br caption center
    cite code dd dfn div dl dt em form h1 h2 h3 h4 h5 h6 head hr
    html i img input isindex kbd li link map meta ol option p param
    pre samp script select small strike strong style sub sup table
    td textarea th title tr tt u ul var
    /a /address /applet /author /b /banner /big /blockquote /body /caption
    /center /cite /code /dfn /div /dl /em /form /h1 /h2 /h3
    /h4 /h5 /h6 /head /html /i /kbd /map /ol /p /pre /samp /select
    /small /strike /strong /sub /sup /table /textarea /title /tt /u /ul /var
} {
    if {[info proc HMtag_$tag] == {}} {
        proc HMtag_$tag {win param text} {}
    }
}

#######################################################################
#### HMcurrent_tags
# extract set of current text tags
# tags starting with T map directly to text tags, all others are
# handled specially.  There is an application callback, HMset_font
# to allow the application to do font error handling.
# Modified by EAL for greater efficiency.  Avoid calls that set
# fonts or get fonts if they've occurred before.
#
proc HMcurrent_tags {win} {
    upvar #0 HM$win var

    set family [lindex $var(family) end]
    set size [lindex $var(size) end]
    set weight [lindex $var(weight) end]
    set style [lindex $var(style) end]
    set S_adjust_size [lindex $var(S_adjust_size) end]
    set font "font:$family:$size:$weight:$style:$S_adjust_size"

    # Avoid repeatedly configuring the same font tag.
    global HMfont_tag_done
    if ![info exists HMfont_tag_done($win$font)] {
        set xfont [HMx_font $family $size $weight $style $S_adjust_size]
        HMset_font $win $font $xfont
        set HMfont_tag_done($win$font) $xfont
    } {
        set xfont $HMfont_tag_done($win$font)
    }
    set indent [llength $var(indent)]
    incr indent -1
    lappend tags $font indent$indent
    foreach tag [array names var T*] {
        lappend tags [lindex $var($tag) end]
    }
    set var(font) $font
    set var(xfont) $xfont
    set var(level) $indent
    return $tags
}

#######################################################################
#### HMgoto
# Modify Uhler's implementation
# to not get confused by the presense of the keyword in a value.
#
# extract a value from parameter list (this needs a re-do)
# returns "1" if the keyword is found, "0" otherwise
#   param:  A parameter list.  It should alredy have been processed to
#           remove any entity references
#   key:    The parameter name
#   val:    The variable to put the value into (use key as default)

proc HMextract_param {param key {val ""}} {

    if {$val == ""} {
        upvar $key result
    } else {
        upvar $val result
    }
    set ws "    \n\r"
    
    # look for name=value combinations.  Either (') or (") are
    # valid delimeters    (for emacs highlighting) ;#"
    if {[regsub -nocase [format {.*%s[%s]*=[%s]*"([^"]*).*} $key $ws $ws] \
            $param {\1} value] ||
    [regsub -nocase [format {.*%s[%s]*=[%s]*'([^']*).*} $key $ws $ws] \
            $param {\1} value] ||
    [regsub -nocase [format {.*%s[%s]*=[%s]*([^%s]+).*} $key $ws $ws $ws] \
            $param {\1} value] } {
        set result $value
        return 1
    }
    
    # now look for valueless names
    # I should strip out name=value pairs, so we don't end up with "name"
    # inside the "value" part of some other key word - some day
    
    set bad \[^=a-zA-Z\]+
    # NOTE: Fixed to ignore if there is an "=".  EAL
    # FIXME: There is a case where this will fail.  If you have
    # <tag key1=value key2>, where key2 is valueless tag, the valueless
    # tag will not be identified.
    if {[regexp -nocase  "^\[^=\]*$bad$key$bad" -$param-]} {
        return 1
    } else {
        return 0
    }
}

#######################################################################
#### HMgoto
# Modify Uhler's implementation
# to support names with spaces and to make it more robust.
#
# The application should call here with the fragment name
# to cause the display to go to this spot.
# If the target exists, go there (and do the callback),
# otherwise schedule the goto to happen when we see the reference.
#
proc HMgoto {win where {callback HMwent_to}} {
    upvar #0 HM$win var
    if {[regexp "N:$where" [$win mark names]]} {
	catch {$win see "N:$where"}
	update
	eval $callback $win [list $where]
	return 1
    } else {
	set var(goto) $where
	return 0
    }
}

#######################################################################
#### HMinit_state
# initialize the window's state array
# Parameters beginning with S_ are NOT reset
#  adjust_size:		global font size adjuster
#  unknown:		character to use for unknown entities
#  tab:			tab stop (in cm)
#  stop:		enabled to stop processing
#  update:		how many tags between update calls
#  tags:		number of tags processed so far
#  symbols:		Symbols to use on un-ordered lists
#  bgcolor:             The background color.
#  fgcolor:             The foreground color.
#
proc HMinit_state {win} {
    upvar #0 HM$win var
    array set tmp [array get var S_*]
    catch {unset var}
    array set var {
        stop 0
        tags 0
        fill 0
        list list
        S_adjust_size 0
        S_tab 1.5
        S_unknown \xb7
        S_update 10
        S_symbols O*=+-o\xd7\xb0>:\xb7
        S_insert HTMLInsert
        linkfg blue
    }
    set var(S_bgcolor) [$win cget -background]
    set var(S_fgcolor) [$win cget -foreground]
    array set var [array get tmp]
    set var(bgcolor) $var(S_bgcolor)
    set var(fgcolor) $var(S_fgcolor)
}

#######################################################################
#### HMlink_callback
# Override the HTML library definition for the hyperlink callback
# function. This does not at this time support HTTP, but does support
# files and names within a file. If the window lies within an HTML
# widget, and the link is to another HTML file, then we reuse the same
# window to display the referenced file. Otherwise, we open a new
# window.
#
proc HMlink_callback {win href} {

    if {![winfo exists $win]} {return}

    # Get the name of the HTML widget.
    set HTML [uplevel #0 winfo command [winfo megawidget $win]]

    if [regexp {^http:|^ftp:|^gopher:|^news:|^mailto:|^telnet:|^wais:} $href] {
	if [::tycho::askuser "OK to invoke netscape to view $href?"] {
	    if [catch {exec netscape -remote openURL($href) &} errMsg] {
		::tycho::ErrorMessage .netscapeError -text $errMsg
		wm deiconify .netscapeError
	    }
	}
	return
    }

    if {![regexp {(file:)?([^#]*)#(.+)} $href dummy noise file fragment]} {
	regexp {(file:)?([^#]*)} $href dummy noise file
	set fragment {}
    }

    # Got a reference to a file (or if file == {}, a local point).
    uplevel #0 [list $HTML hyperJump $file $fragment]
}

#######################################################################
#### HMrender
# HMrender gets called for every html tag
#   win:   The name of the text widget to render into
#   tag:   The html tag (in arbitrary case)
#   not:   a "/" or the empty string
#   param: The un-interpreted parameter list
#   text:  The plain text until the next html tag
# If the tag has an entry in the HMtag_map, then that entry is used
# to change the state (font, size, etc.).  If there is a
# procedure called HMtag_$tag, then that procedure is invoked.
#
proc HMrender {win tag not param text} {
    upvar #0 HM$win var
    if {$var(stop)} return
    global HMtag_map HMinsert_space_map HMlist_elements
    set tag [string tolower $tag]
    set text [HMmap_esc $text]
    
    # manage compact rendering of lists
    if {[info exists HMlist_elements($tag)]} {
        # NOTE: mod EAL.  Syntax error in the original.
        set list "list [expr {[HMextract_param $param compact] ? {compact} : {list}}]"
    } else {
        set list ""
    }
    
    # adjust (push or pop) tag state
    if [info exists HMtag_map($tag)] {
        HMstack $win $not "$HMtag_map($tag) $list"
    }
    
    set insert $var(S_insert)
    # insert white space (with current font).  NOTE: modified by EAL.
    if [info exists HMinsert_space_map($not$tag)] {
        set ins $insert
        # Skip if we are the top of the widget.
        if ![$win compare $ins == 1.0] {
            set spaces $HMinsert_space_map($not$tag)
            for {set ind $spaces} {$ind > 0} {incr ind -1} {
                set curline [$win get "$ins linestart" "$ins lineend"]
                set ins [$win index "$ins -1 line"]
                if [regexp {^[ 	]*$} $curline] {
                    incr spaces -1
                } {
                    break
                }
            }
            while {$spaces > 0} {
                incr spaces -1
                $win insert $insert "\n" "space $var(font)"
            }
        }
    }
    # If we are in fill mode, trim the text.
    if [lindex $var(fill) end] {
        # If the current line contains only spaces, remove them.
        set curline [$win get "$insert linestart" "$insert lineend"]
        if [regexp {^ *$} $curline] {
            # Check for embedded windows
            if {[$win dump -window "$insert linestart" "$insert lineend"] \
                    == {}} {
                $win delete "$insert linestart" "$insert lineend"
            }
        }
        if [$win compare $insert == "$insert linestart"] {
            set text [string trimleft $text]
        }
        set text [HMzap_white $text]
    }
    
    # generic mark hook
    # NOTE: mod EAL
    # catch {HMmark $not$tag $win $param text} err
    
    # do any special tag processing
    # Need a ignore unrecognized HTML tags.  Here we check explictly.
    # Could use a catch alternatively, but that tends to hide errors.
    # FIXME: Change to a catch for release.
    if {[info proc HMtag_$not$tag] != {}} {
        HMtag_$not$tag $win $param text
    }
    
    # add the text with proper tags
    set tags [HMcurrent_tags $win]
    $win insert $var(S_insert) $text $tags
    
    # We need to do an update every so often to insure interactive response.
    # This can cause us to re-enter the event loop, and cause recursive
    # invocations of HMrender, so we need to be careful.
    if {!([incr var(tags)] % $var(S_update))} {
        update
    }
}

#######################################################################
#### HMset_image
# An image callback function, called by the HTML library when it encounters
# and image. Read in an image if we don't already have one and
# call back to library for display.
#
# HMtag_image calls this and passes a label as the handle.
# This function in turn calls HMgot_image
#
proc HMset_image {win handle src} {
    # Get the name of the HTML widget.
    set HTML [uplevel #0 winfo command [winfo megawidget $win]]

    # If the slowNetwork misc preference is set, then don't display images.
    if {[$HTML isSlowNetwork] == 0} {
        if {[string match /* $src]} {
            set image $src
        } else {
            set image [uplevel #0 $HTML lastDirectory]/$src
        }

        update
        if {[string first " $image " " [image names] "] >= 0} {
            HMgot_image $handle $image
        } else {
            set type photo
            if {[file extension $image] == ".bmp"} {set type bitmap}
            catch {image create $type $image -file $image} image
            HMgot_image $handle $image
        }
    }
}

#######################################################################
#### HMstack
# Push or pop tags to/from stack.
# Each orthogonal text property has its own stack, stored as a list.
# The current (most recent) tag is the last item on the list.
# Push is {} for pushing and {/} for popping.
# Fixed by EAL to not fail on poping empty stack.
#
proc HMstack {win push list} {
    upvar #0 HM$win var
    array set tags $list
    if {$push == ""} {
        foreach tag [array names tags] {
            lappend var($tag) $tags($tag)
        }
    } else {
        foreach tag [array names tags] {
            catch {set var($tag) [lreplace $var($tag) end end]}
        }
    }
}

#######################################################################
#### HMtag_body
# This code is modified from "surfit".
# HTML 3.2 introduces various attributes for the BODY tag.
# BACKGROUND (Tk 4.1 cannot support this), BGCOLOR, TEXT, LINK, VLINK, ALINK
#
proc HMtag_body {win param text} {
    upvar #0 HM$win var
    if {[HMextract_param $param bgcolor]} {
        set color [::tycho::color $bgcolor grey]
        $win configure -background $color
        set var(bgcolor) $color
        # Make the insertion cursor invisible
        $win configure -insertbackground $color
    }
    
    set savetext $text
    if {[HMextract_param $param text]} {
        set color [::tycho::color $text black]
        $win configure -foreground $color
        set var(fgcolor) $color
    }
    set text $savetext

    if {[HMextract_param $param link]} {
        set color [::tycho::color $link blue]
        set var(linkfg) $color
        $win tag configure link -foreground $color
    }
}

#######################################################################
#### HMtag_color
# This proc is directly from Stephen Uhler's sample, with only slight
# modifications. A new HTML tag, inserted just for fun. Change the
# color of the text. Use HTML tags of the form: <color value=blue> ...
# </color> The color has lower priority than all other tags.
# NOTE: This is not standard HTML.  Use <font color=foo> instead.
#
proc HMtag_color {win param text} {
	set value black
	HMextract_param $param value
	set value [::tycho::color $value black]
	$win tag configure $value -foreground $value
	$win tag lower $value
	HMstack $win "" "Tcolor $value"
}

proc HMtag_/color {win param text} {
	HMstack $win / "Tcolor {}"
}

#######################################################################
#### HMtag_dt
# Modify the original to permanently remove the indent introduced by
# tag_dl.  NOTE: This assumes well-structured definition lists.
# I'm not sure what will happen with badly constructed HTML.
#
proc HMtag_dt {win param text} {
	upvar #0 HM$win var
	upvar $text data
        # The depth of the indent is determined by depth of the "indent" stack.
        HMstack $win {/} "indent {}"
	incr var(level) -1
	set level $var(level)
	$win insert $var(S_insert) "$data" \
		"hi [lindex $var(list) end] indent$level $var(font)"
	set data {}
}

#######################################################################
#### HMtag_dd
# Modify the original to reinsert the indent removed by
# tag_dt.  This indent will be removed later by tag_/dd.
# NOTE: This assumes well-structured definition lists.
# I'm not sure what will happen with badly constructed HTML.
#
proc HMtag_dd {win param text} {
	upvar #0 HM$win var
	upvar $text data
        # The depth of the indent is determined by depth of the "indent" stack.
        # The value "1" is irrelevant, but some value is needed.
        HMstack $win {} "indent 1"
	incr var(level) 1
	set level $var(level)
	$win insert $var(S_insert) "$data" \
		"hi [lindex $var(list) end] indent$level $var(font)"
	set data {}
}

#######################################################################
#### HMtag_font
# The following is modified from surfit.
#
proc HMtag_font {win param text} {
    upvar #0 HM$win var
    if {[HMextract_param $param size]} {
        HMstack $win "" "size [expr [lindex $var(size) end] + $size]"
    } else {
        HMstack $win "" [list size [lindex $var(size) end]]
    }
    if {[HMextract_param $param color]} {
        set color [::tycho::color $color black]
        HMstack $win "" "Tcolor color$color"
        $win tag configure color$color -foreground $color
    } else {
        HMstack $win "" [list Tcolor black]
    }
}

proc HMtag_/font {win param text} {
    upvar #0 HM$win var
    HMstack $win "/" [list size {}]
    HMstack $win "/" [list Tcolor black]
}

#######################################################################
#### HMtag_menu
# Use a simple "-" rather than "->".
#
proc HMtag_menu {win param text} {
	upvar #0 HM$win var
	set var(menu) -
	set var(compact) 1
}

#######################################################################
#### HMtag_tcl {win param text} 
# Set up an extension to HTML in which the delimitters <tcl> ... </tcl>
# are understood to enclose a section of Tcl code. This code is
# highlighted in the document, and double clicking on it causes the enclosed
# Tcl code to be executed. The code is executed at the global scope.
# Normally, this tag will be used together with the standard <pre>...</pre>
# HTML tag to prevent the text from filling and wrapping.

proc HMtag_tcl {win param text} {

    upvar #0 HM$win var

    # Get the name of the HTML window and widget command.
    set HTML [winfo megawidget $win]
    set HTMLcommand [winfo command $HTML]

    # Set the color
    set color [::tycho::preference get viewhtml tclColor]
    $win tag configure tcl -foreground $color
    $win tag bind tcl <Double-Button-1> \
            "uplevel #0 $HTMLcommand execTcl %x %y; break"
    if {[HMextract_param $param quiet]} {
        set var(Ttclq) tclq
    }

    # Reduce the size because courier fonts on X window systems
    # are absurdly large.  Also tag the text "tcl".
    HMstack $win {} "Ttcl tcl size [expr [lindex $var(size) end] - 2]"
}

proc HMtag_/tcl {win param text} {
    upvar #0 HM$win var
    if {[info exists var(Ttclq)]} {
        unset var(Ttclq)
    }
    HMstack $win / "Ttcl {} size {}"
}

#######################################################################
#### HMx_font
# Generate an X font name using the FontManager class in Tycho.
# Also, cache font requests locally for additional efficiency
# (this yields about an 18% speed improvement in rendering).
#
proc HMx_font {family size weight style {adjust_size 0}} {
    global HMx_font_cache
    set cachename "$family.$size.$weight.$style.$adjust_size"
    if [info exists HMx_font_cache($cachename)] {
        return $HMx_font_cache($cachename)
    }
    # The HTML library seems to call this with empty strings for arguments.
    # I don't know why.  We have to handle that situation.
    if {$size == {}} {return fixed}
    incr size $adjust_size
    set result [::tycho::xfont $family $size $weight $style]
    set HMx_font_cache($cachename) $result
    return $result
}

#######################################################################
#### HMtag_hmstart
# Modify to not depend on being in the HMtag_map array.
#
proc HMtag_hmstart {win param text} {
	upvar #0 HM$win var
        global HMinitialtag_map
        HMstack $win {} $HMinitialtag_map
	$win mark gravity $var(S_insert) left
	$win insert end "\n " last
	$win mark gravity $var(S_insert) right
}

#######################################################################
#### HMtag_hr
# Improve the horizontal rule a bit.
#
proc HMtag_hr {win param text} {
	upvar #0 HM$win var
	$win insert $var(S_insert) "\n" space "\n\n\n" \
		thin "\t" "thin hr" "\n\n\n" thin
	$win tag configure hr -background black
}

#######################################################################
#### HMtag_sub
# Subscripts.
#
proc HMtag_sub {win param text} {
    upvar #0 HM$win var
    HMstack $win "" \
            [list Tsubscript subscript size [expr [lindex $var(size) end] - 2]]
}

proc HMtag_/sub {win param text} {
    HMstack $win "/" [list Tsubscript {} size {}]
}

#######################################################################
#### HMtag_sup
# Superscripts.
#
proc HMtag_sup {win param text} {
    upvar #0 HM$win var
    HMstack $win "" \
            [list Tsuperscript superscript \
            size [expr [lindex $var(size) end] - 2]]
}

proc HMtag_/sup {win param text} {
    HMstack $win "/" [list Tsuperscript {} size {}]
}

#######################################################################
#### HMwent_to
# Override the library function to put the start of the named region
# at the top of the window and to temporarily change the background color.
#
proc HMwent_to {win where {count 0} {color {}}} {
    if {![winfo exists $win]} {return}
    if {$count >= 6} return
    if {$count == 0} {
        set range [$win tag nextrange "N:$where" 1.0]
        if {$range != {}} {
            # Put the start of the named region at the top of the window.
            # (The following sometimes puts the line we want to see one line
            # above the visible part of the window. Hence the correction after).
            set start [expr int([lindex $range 0])]
            set length [expr int([$win index end])]
            set fraction [expr "$start.0/$length"]
            $win yview moveto $fraction

            # The following ensures the item in question is in view.
            $win see [lindex $range 0]
        }
    }

    if {$color == {}} {
        set color [::tycho::preference get viewhtml targetColor]
    }

    # Temporarily change the background color
    upvar #0 HM$win var
    $win tag configure "N:$where" -background $color -foreground black
    after 8000 [list catch [list \
            $win tag configure "N:$where" -background {} -foreground {}]]
    update
}

#######################################################################
#### Table handling
# FIXME: This code is temporary, pending proper table handling.
# It does not render the table, which is relatively hard to do, but
# tries to format the text in such a way that table entries are at least
# distinguished from one another.

#######################################################################
#### HMtag_/tr
# For a table item, if the text does not end in a period, add a period.
#
proc HMtag_/td {win param text} {
    upvar #0 HM$win var
    set line [$win get "$var(S_insert) linestart" $var(S_insert)]
    if {![regexp {\.[ 	]*$} $line]} {
        $win insert $var(S_insert) "."
    }
}

# Tags for the rudimentary table support:
set HMtag_map(tr) {indent 1}
set HMinsert_space_map(tr) 1

# Increase the tab stops from 1 to 1.5 cm.
HMset_state -tab 1.5

