# Definition of a text widget that displays formatted HTML.
#
# @Author: Edward A. Lee
# @Contributor: Stephen Uhler (HTML library), 
#
# @Version: $Id$
#
# @Copyright (c) 1995-%Q% The Regents of the University of California.
# All rights reserved.
# 
# Permission is hereby granted, without written agreement and without
# license or royalty fees, to use, copy, modify, and distribute this
# software and its documentation for any purpose, provided that the
# above copyright notice and the following two paragraphs appear in all
# copies of this software.
# 
# IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY
# FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
# ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF
# THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.
# 
# THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE
# PROVIDED HEREUNDER IS ON AN "AS IS" BASIS, AND THE UNIVERSITY OF
# CALIFORNIA HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,
# ENHANCEMENTS, OR MODIFICATIONS.
# 
# 						PT_COPYRIGHT_VERSION_2
#
# Portions of the code in this file are modified from the HTML library
# by Stephen Uhler (of Sun Microsystems), and "surfit", written by
# members of the PASTIME project at the Australian National University.
# The copyrights below apply to those versions:
#
#	Copyright (c) 1996 Australian National University and
#	Sun Microsystems
#
#--------
#
#	PASTIME Project
#	Cooperative Research Centre for Advanced Computational Systems
#	COPYRIGHT NOTICE AND DISCLAIMER.
#
#	Copyright (c) 1995 ANU and CSIRO
#	on behalf of the participants in
#	the CRC for Advanced Computational Systems (ACSys)
#
# This software and all associated data and documentation ("Software")
# was developed for research purposes and ACSys does not warrant that 
# it is error free or fit for any purpose.  ACSys disclaims all liability
# for all claims, expenses, losses, damages and costs any user may incur 
# as a result of using, copying or modifying the Software.
#
#
# 						COPYRIGHTENDKEY
#######################################################################

# FIXME: Known bugs
# - The rendering is quite slow.  Needs to be speeded up.
# - The Tcl extension should use more standard HTML syntax.
# - Embedded windows should be supported.

# Load the HTML library, if necessary, and make adjustments.
if {[info commands HMinit_win] == {}} {
    uplevel #0 {
	source [file join $TYCHO lib html_library html_library.tcl]

	# Make format adjustments -- better than the default
	set HMtag_map(h2) {size 20 weight bold}
	set HMtag_map(h3) {size 20 style i}
	set HMtag_map(h4) {size 16 weight bold}
	set HMtag_map(h5) {size 16 style i}

        set HMinitialtag_map $HMtag_map(hmstart)
        unset HMtag_map(hmstart)
    }
}

#######################################################################
#### HTML
# This widget parses HTML using the library by Stephen Uhler and
# displays it in a Tk text widget. Only local file accesses are
# currently supported (no HTTP, FTP, etc). The HTML source can be
# specified using the -data option or indirectly using the -file
# option. If the HTML will have references to other files (such as
# image files) that are relative, then the reference directory should
# be specified using the -directory option if the -data option was
# used.  Otherwise, the directory is inferred from the -file option.
# 
class ::tycho::HTML {
    inherit ::tycho::Edit

    ###################################################################
    ####                       options                             ####

    # The directory for relative references to images and the like,
    itk_option define -directory directory Directory {}

    # Override the slowNetwork preference for this html browswer.
    itk_option define -image image Image 0

    # If true (the default), underline hyperlinks.
    itk_option define -underlinelinks underlineLinks UnderlineLinks 1

    # The default display font -- currently an X font, but should
    # be made symbolic in Tk 8.0
    itk_option define -displayfont displayFont Font [::tycho::font Times 14]

    # The default constant-width font -- currently an X font, but should
    # be made symbolic in Tk 8.0
    itk_option define -cwfont cwFont Font [::tycho::font Courier 14]

    constructor {args} {}
    destructor {}

    ###################################################################
    ####                      public methods                       ####

    # Prompt the user for a file name and load in place of the current file.
    method altFile {}

    # Start up appletviewer on the current file.
    method appletViewer {}

    # Go back to the previous view.
    method back {}

    # Clear the window.
    method clear {}
 
    # Decrease the current font size in this widget.
    method downSize {}
    
    # Execute Tcl code embedded in the HTML.
    method execTcl {x y}

    # Go forward to a previously-seen view.
    method forward {}

    # Open a help window.
    method help {}

    # Opening an HTTP connection. This returns the file name of the HTTP file.
    method httpget {url}

    # This is called by file event handler, from httpget.
    method httpread {fd tmpfd}

    # Set the global http status to "running" or "normal" or "abnormal"
    method httpsetstatus {status}

    # Wait until httpget is done.
    method httpwait {}

    # Open a file and go to its internal point identified by name.
    method hyperJump {filename {point {}} {push 1}}

    # Insert the specified data.
    method insertData {data}

    # Insert the contents of the directory.
    method insertDirectoryContents {dirname}

    # Return 1 if rendering is in progress, and 0 otherwise.
    method isRendering {} {return $isrendering}

    # Return 1 if the slowNetwork preference is set.
    method isSlowNetwork {}

    # Return the reference directory.
    method lastDirectory {}

    # Display the link destination in the status bar
    method linkEnter {xpos ypos}

    # Open the source file using an HTML editor.
    method openSource {}

    # Print the selection or the entire contents.
    method print {}

    # Raise the HTML browser window and the source window (if any).
    method raiseWindow {}

    # Reload from the last saved version of the file.
    method reload {}

    # Go to the specified hypertext reference, line, or range.
    method seeFragment {point}

    # Indicate whether rendering is currently in progress.
    method setRendering {val} {set isrendering $val}

    # Request that rendering stop.  Note that it does not occur immediately.
    method stopRendering {}

    # Return the full path name of the text window.
    method textWinName {}
  
    # Increase the current font size in this widget.
    method upSize {}

    # Add a file editor object to the window menus of all open File objects.
    method windowMenuAddAll {label}

    # Remove a filename from the window menus of all open File objects.
    method windowMenuRemoveAll {filename}

    ###################################################################
    ####                      public procedures                    ####

    # Render the given text for a particular HTML object.
    proc render {obj {html {}}} {}

    # Used with httpget
    public variable statusVariableName {}

    ###################################################################
    ####                     protected methods                     ####

    # Access the "viewhtml" preferences
    protected method preference {mode args}

    # Configure the popup menu depending on the current context
    protected method configureContextMenu {}
   
    ###################################################################
    ####                      protected variables                  ####

    # Indicate whether a rendering operation is in progress.
    protected variable isrendering 0

    ###################################################################
    ####                      private methods                      ####

    # Push a new file onto the stack.
    private method pushNextHTMLFile {}

    # Return 1 if the sourcewin window is a valid source window.
    private method sourcewinIsMine {}

    # Return 1 if the extension is the extension of an image file.
    private method isAnImageFileExtension {extension}

    ###################################################################
    ####                     private variables                     ####

    # Size modification for quick font changes  
    private variable fontOffset 0
    
    # Keep count of the number of calls to seeFragment
    private variable seecount 0

    # Keep track of the current source window for the current file.
    private variable sourcewin {}

    # The "stack" of traversed files. This is really just a Tcl list.
    private variable stack {}

    # The current position in the "stack"
    private variable stackpos 0

    # The name of the global array used to store the state of the window.
    private variable stateArrayName {}
}

#########################################################################
#### -cwfont configuration
# Parse the given X font to figure out what font family, size,
# and style to use for constant-width fonts, and modify the
# HMtag_map array accordingly.
#
configbody ::tycho::HTML::cwfont {
    global HMtag_map

    set f [::tycho::FontManager::parseFont $itk_option(-cwfont)]

    # Get the initial font attributes used by the renderer
    # and overwrite the family, size, and style
    switch -exact [string tolower [lindex $f 2]] {
	"roman" {
	    set weight medium
	    set style r
	}
	"bold" {
	    set weight bold
	    set style r
	}
	"italic" {
	    set weight medium
	    set style i
	}
	"bolditalic" {
	    set weight bold
	    set style i
	}
    }
    # Process each tag -- "tcl" is treated specially in HMtag_tcl
    foreach tag {code kbd pre tt} {
	array set temp $HMtag_map($tag)
	# Remove spaces from family name
	set temp(family) [join [lindex $f 0] ""]
	set temp(size) [lindex $f 1]
	# "kbd" tag is always bold
	if { $tag != "kbd" } {
	    set temp(weight) $weight
	}
	set temp(style) $style
	set HMtag_map($tag) [array get temp]
    }

    # Re-render the window. In theory, all that should be necessary
    # is to change the font attributes for all tags, but...
    ::tycho::HTML::render $this
}

#########################################################################
#### -displayfont configuration
# Parse the given X font to figure out what font family, size,
# and style to use for the display font, then set it in the
# HMinitialtag_map array.
#
configbody ::tycho::HTML::displayfont {
    global HMinitialtag_map

    set f [::tycho::FontManager::parseFont $itk_option(-displayfont)]
    
    # Get the initial font attributes used by the renderer
    # and overwrite the family, size, and style
    array set temp $HMinitialtag_map
    # Remove spaces from family name
    set temp(family) [join [lindex $f 0] ""]
    set temp(size) [lindex $f 1]
    switch -exact [string tolower [lindex $f 2]] {
	"roman" {
	    set temp(weight) medium
	    set temp(style) r
	}
	"bold" {
	    set temp(weight) bold
	    set temp(style) r
	}
	"italic" {
	    set temp(weight) medium
	    set temp(style) i
	}
	"bolditalic" {
	    set temp(weight) bold
	    set temp(style) i
	}
    }
    set HMinitialtag_map [array get temp]

    # Re-render the window. In theory, all that should be necessary
    # is to change the font attributes for all tags, but...
    ::tycho::HTML::render $this
}

#########################################################################
#### -underlinelinks configuration
# Set the text format for the "link" tag to turn underlining on or off.
#
configbody ::tycho::HTML::underlinelinks {
    # Modifications on configuration in the HTML library:
    $itk_component(text) tag configure link \
	    -underline $itk_option(-underlinelinks)
}

###################################################################
#
body ::tycho::HTML::constructor {args} {

    # Set the view "type" for the Window menu
    set viewType "html"

    # Add buttons to the toolbar, if it exists.
    # FIXME: should the user be allowed to change the home window?
    
    toolbar button back \
	    -description {Go back to the previously-viewed page} \
            -text Back -command "$this back" -state disabled
    
    toolbar button forward \
	    -description {Go forward to the next previously-viewed page} \
            -text Forward -command "$this forward" -state disabled
    
    global ::TYCHO
    
    toolbar button home \
	    -description {Go to the Tycho home page} \
            -text Home -command "$this hyperJump \
	    [file join \$TYCHO doc index.html]"
    
    toolbar button reload \
	    -description {Reload and reparse from the file} \
            -text Reload -command "$this reload"
    
    toolbar button open \
	    -description {Open a new file} \
            -text Open -command "$this altFile"
    
    toolbar button find \
	    -description {Find text or a pattern on this page} \
            -text Find -command "$this search"
    
    toolbar button stop \
	    -description {Abort rendering} \
            -text Stop -command "$this stopRendering"

    set text $itk_component(text)

    # Initialize the text window.  The returned value is supposed to be
    # the global variable used to store the state of the window, but isn't.
    HMinit_win $text

    # Add a binding for links to display the destination.
    $text tag bind link <Enter> "$this linkEnter %x %y"
    # If we don't have a <Motion> tag for the link, then if we have several
    # links stacked on top of each other horizontally, the status bar
    # is not updated as we move the mouse from link to link (see tynt.html).
    $text tag bind link <Motion> "$this linkEnter %x %y"
    $text tag bind link <Leave> "$this statusbar puts {}"

    # Additions:
    $text tag configure subscript -offset -6
    $text tag configure superscript -offset +6

    set stateArrayName HM$text

    eval itk_initialize $args

    # Subscribe to the preference set
    preference subscribeoptions $this \
	    -textfont textFont \
	    -displayfont displayFont \
	    -cwfont cwFont \
	    -textforeground textForeground \
	    -textbackground textBackground \
	    -relief textRelief \
	    -textwidth textWidth \
	    -textheight textHeight \
	    -underlinelinks underlineLinks

    if {$itk_option(-directory) == {}} {
        configure -directory [file dirname $file]
    }

    bind $text <space> "$this scroll 1; break"

    # Scroll using cursor keys w/o waiting for invisible cursor to move.
    bind $text <Up> "$text yview scroll -1 units; break"
    bind $text <Down> "$text yview scroll 1 units; break"

    # Double clicks normally select text, something we don't want here.
    bind $text <Double-Button-1> {break}


    # Setup Special menu
    menubar addMenu Special -underline 0

    menubar add "Appletviewer" Special -underline 0 \
            -command "$this appletViewer"
    global tcl_platform
    if {$tcl_platform(platform) == "macintosh"} {
	menubar disable Appletviewer
    }

    # Modify the menu commands appropriately.
    if {$myMenubar != {}} {
        $myMenubar disable {Undo/Redo}
        $myMenubar disable {Cut}
        $myMenubar disable {Paste}
        $myMenubar disable "Font..."
        $myMenubar delete "Fill Region"
        $myMenubar delete "Right Fill Column"
        $myMenubar delete "Set Fill Prefix"
        $myMenubar delete "Lower Case"
        $myMenubar delete "Upper Case"
        $myMenubar delete "Capitalize"

        $myMenubar insert "Open Source" "Switch File..." \
                -underline 1 -accelerator {C-x s} \
                -command "$this openSource"

        # delete entire Format bar (to remove Separators)
        $myMenubar delete Format

        # then re-create it
        $myMenubar addMenu Format -underline 1
 
        # with font size control
        $myMenubar command "Bigger Font" Format -underline 0\
                -accelerator "C-+" -command "$this upSize"
        $myMenubar command "Smaller Font" Format -underline 0\
                -accelerator "C--" -command "$this downSize"

    }

    bind $prefix <Control-x><Key-s> "$this openSource; break"
    # disable certain bindings
    bind $prefix <Control-x><Control-s> {bell; break}
    bind $prefix <Control-x><Control-w> {bell; break}
    bind $prefix <Control-x><Control-v> {bell; break}
    bind $prefix <Control-x><Control-q> {bell; break}
    bind $prefix <Control-x><Key-i> {bell; break}
    bind $prefix <Control-x><Key-v> {bell; break}

    # Add bindings for forward and back
    bind $itk_component(text) <Meta-Left> "$this back"
    bind $itk_component(text) <Control-Left> "$this back"
    bind $itk_component(text) <Meta-Right> "$this forward"
    bind $itk_component(text) <Control-Right> "$this forward"

    configure -readonly 1
    focusin

    # Add myself to the list of open files. 
    windowMenuAddAll $file

    # Disable auto-save.
    configure -save 0

    # Make the insertion cursor invisible.
    $text configure -insertofftime 0
    $text configure -insertbackground [$text cget -background]

    # Add the entry widget displaying the current page
    toolbar entry location Location $file "$this hyperJump"

    # Put some space around the text
    $text configure -padx 0.25c -pady 0.25c

}

###################################################################
#
body ::tycho::HTML::destructor {} {
    stopRendering
    if [sourcewinIsMine] {
	# Schedule this for after destruction is complete because the
	# base class destructor removes the menu entry.
	after idle "$sourcewin windowMenuAddAll $file"
    }
}

    ###################################################################
    ###################################################################
    ####                      public methods                       ####

###################################################################
#### altFile
# Query the user for a filename, and if the selected file has the
# extension ".html", ".htm", or "htl", insert its contents in place of the
# currently displayed HTML.  Otherwise, view its contents in a new window.
#
body ::tycho::HTML::altFile {} {
    set filename [safeEval ::tycho::queryfilename {Alternate file to load:}]
    if {$filename != {}} {
	hyperJump $filename
    }
}
#####################################################################
#### appletViewer
# Start up appletviewer on the current file
#
body ::tycho::HTML::appletViewer {} {
     ::tycho::execModal "appletviewer $file" [file dirname $file]
}

#####################################################################
#### back
# Go back to the previous view, popping it off the stack.
#
body ::tycho::HTML::back {} {
    # If there's nowhere to go...
    if { $stackpos <= 0 } {
	return
    }
    # Update the current file with the current position
    if { [llength $stack] > $stackpos } {
        set stack [lreplace $stack $stackpos $stackpos \
                [list $file [currentPoint]]]
    } else {
        lappend stack [list $file [currentPoint]]
    }

    # Move back one position
    incr stackpos -1
    set ref [lindex $stack $stackpos]

    # Disable the back button if there are no more to go
    # forwards to. Enable the forward button.
    if { $stackpos <= 0 } {
        toolbar disable back
    }
    toolbar enable forward

    # Jump to the file
    set filename [lindex $ref 0]
    set point [lindex $ref 1]
    # Use the optional third argument to avoid being recorded for
    # backtracking.
    hyperJump $filename $point 0
}

#####################################################################
#### clear
# Clear the current text.
#
body ::tycho::HTML::clear {} {
    HMreset_win [textWinName]
}

#####################################################################
#### downSize 
# Decrease the font size of the current widget. 
# Redefined from ::tycho::Edit
#
body ::tycho::HTML::downSize {} {
    if {$fontOffset > 0} {
        set fontOffset [expr $fontOffset - 1 - ($fontOffset / 2)]
    } else {
        incr fontOffset -2
    }
    HMset_state [textWinName] -size $fontOffset
    render $this
}

#####################################################################
#### execTcl
# Execute the Tcl code under the "current" mark.
# The Tcl code is simply the largest contiguous region of text tagged
# "tcl".  The code is executed in the global scope, and the result is
# displayed.
#
body ::tycho::HTML::execTcl {x y} {
    set cmd [getTaggedText tcl]
    if {$cmd != {}} {
	set result [uplevel #0 $cmd]
        if {$result != {}} {
            set tags [[textWinName] tag names @$x,$y]
            if {[lsearch -exact $tags tclq] < 0} {
                safeEval ::tycho::inform "Returned:\n$result"
            } {
                putStatus "Returned: $result"
            }
        } {
            putStatus "null string returned"
        }
    }
}

#####################################################################
#### forward
# Go forward to a previously seen and backed-over view.
#
body ::tycho::HTML::forward {} {
    # Is there a window to move to?
    if { $stackpos >= [expr [llength $stack] - 1] } {
	return
    }
    # Update the current position
    set stack [lreplace $stack $stackpos $stackpos [list $file [currentPoint]]]

    # Move forwards
    incr stackpos
    set ref [lindex $stack $stackpos]

    # Disable the forward button if there are no more to go
    # forwards to. Enable the back button.
    if { $stackpos >= [expr [llength $stack] - 1] } {
        toolbar disable forward
    }
    toolbar enable back

    # Jump to the file
    set filename [lindex $ref 0]
    set point [lindex $ref 1]
    # Use the optional third argument to avoid being recorded for
    # backtracking.
    hyperJump $filename $point 0
}

#########################################################################
#### help
# Open a help window.
#
body ::tycho::HTML::help {} {
    global ::TYCHO
    ::tycho::File::openContext \
	    [file join $TYCHO kernel doc usersGuides HTMLHelp.html]
}

#########################################################################
#### httpget
# Opening an HTTP connection. This returns the file name of the HTTP file.
#
body ::tycho::HTML::httpget {url} {
    # FIXME: need to find out where to collect protocols that Tycho
    # understands:
    set accept {text/*}

    #puts "Going to get url: $url"
    # 
    # The following is verbatim from Surfit: vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
    if {[regexp -nocase {^http://([^/:]*)(:([^/]+))?(.*)} $url match \
            host optport port path]} {
        if {$host == {}} {set host $localhost}	;# Supply reasonable default
        if {$port == {}} {set port 80}		;# HTTP default service
        if {$path == {}} {set path /}
    } else {
        # Recover from malformed URL
        if {![string match */* $var(path)]} {
            # Assume only the hostname:port has been given
            regexp {([^:]*)(:(.*))?} $var(path) all host optport port
            if {$host == {}} {set host localhost}
            if {$port == {}} {set port 80}
            set path /
        } else {
            error "no hostname given in URL \"$url\""
        }
    }
    puts "$host:$port, GET $path HTTP/1.0"
    if {[catch {socket -async $host $port} fd]} {
        unset $fd
        error "Can't open $host, $port"
    }
    # Surfit ends here ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    # Wait until finished reading HTTP file
    set tmpFile [::tycho::tmpFileName cache].html
    set tmpfd [open $tmpFile "w"]
    set statusVariableName [::tycho::autoName httpgetStatus]
    httpStatus $statusVariableName "running"

    # connect now!
    fconfigure $fd -blocking no -translation crlf
    puts $fd "GET $path HTTP/1.0\
            User-Agent: Tycho Jr. Beta\
            Accept-Encoding: $accept"
    puts $fd ""
    flush $fd
    fconfigure $fd -translation auto

    ::tycho::safeUpdate $this
    fileevent $fd w {}
    fileevent $fd r "$this httpread $fd $tmpfd"

    # Wait until the entire http file is here!
    httpwait

    return $tmpFile
}

#########################################################################
#### httpwait
# Wait until the variable name has been changed.
body ::tycho::HTML::httpwait {} {
    global $statusVariableName
    puts "status: $statusVariableName"
    if {[uplevel #0 "set $statusVariableName"]=="running"} {
        tkwait variable $statusVariableName
    }
    return [uplevel #0 "set $statusVariableName"]
}

#########################################################################
#### httpsetstatus
# Helper function to set the global variable
# This is used so that tkwait can wait for
# the global variable to change from "running" to either
# "normal" or "abnormal"

proc httpStatus {name value} {
    global $name
    set $name $value
}

#########################################################################
#### httpread
# This is called by file event handler, from httpget.
#
body ::tycho::HTML::httpread {fd tmpfd} {
    if [eof $fd] {
        httpStatus $statusVariableName "done"
	catch {close $fd}
	catch {close $tmpfd}
	puts "closing $fd $tmpfd"
    } else {
	gets $fd line
	#puts ">$line"
        puts $tmpfd $line
    }
}

#####################################################################
#### hyperJump
# Open a file and go to its internal point identified by name. If the
# filename has the extension ".html", ".htm", or "htl", and this window
# is inside a <code>Displayer</code> object, then open it in
# this same window. If the filename is the empty string, then move the
# view to a location within the same file. If filename is relative
# (does not begin with "/", "~", or "$"), then prepend the directory of
# the file currently being viewed. Then, expand the filename using
# <code>::tycho::expandPath</code> and open the resulting file with
# <code>::tycho::File::openContext</code>, which will choose an editor
# based on the filename extension. Finally, invoke
# <code>seeFragment</code> to view the specified point within the file.
# The format for the <i>point</i> argument depends on the type of file
# being opened. For HTML files, it will normally be the name of an
# anchor in the file or specified "yview" location within the file. For
# text files, it will normally be either "{line <i>linenumber</i>}" or
# "{range <i>start</i> <i>end</i>}", where <i>start</i> and <i>end</i>
# have the form <i>linenumber.characternumber</i>. If the third
# argument, which is optional, has value 0, then the jump is not
# recorded for backtracking.
#
# NOTE: This method really should support the syntax "filename#fragment"
# in the filename argument.  Someday.
#

body ::tycho::HTML::hyperJump {filename {point {}} {push 1}} {
    if {$filename != {}} {
        # If this is a http link, make sure to download it to our
        # "cache" first. FIXME: Right now there's no cache, just temporary
        # files.
        if {[regexp -nocase {^http://} $filename]} {
            # Translate from a http file to a local file (later cache).
            set filename [httpget $filename]
            puts "filename:$filename, done:[$this httpwait]"

            hyperJump $filename
            reload
            return
        }
	# Use isRelative, not 'file pathtype' so that we handle paths
	# that start with ~ and $.
	if [::tycho::isRelative $filename] {
            set filename [format "%s/%s" [file dirname $file] $filename]
        }
        set filename [::tycho::expandPath $filename]

        # If the file is a directory, open "index.html" in that directory,
        # if it exists, otherwise display the contents of the directory.
        if [file isdirectory $filename] {
            set newfilename [format "%s/%s" $filename index.html]
            if [file exists $newfilename] {
                set filename $newfilename
                unset newfilename
            } else {
		global ptolemyfeature
		if { $ptolemyfeature(octtools) && \
                        [file exists [file join \
                        $filename schematic {contents;}]]} {
		    # If Ptolemy is present, then open this as a facet
                    ::pvOpenWindow [::ptkOpenFacet \
			    $filename schematic contents]
		    return
		}

		# Display a listing of the file
                # For backtracking
                if $push {
                    pushNextHTMLFile
                }
                configure -directory [file dirname $filename]
                configure -file $filename
                toolbar clear location
                toolbar insert location $filename
                # Reset the insertion cursor to the origin, or else we will
                # try to preserve the point in the file.
                $itk_component(text) mark set insert 1.0

                if {$point != {}} {
                    after 200 [list $this seeFragment $point]
                }
		insertDirectoryContents $filename
		return
            }
        }


        # If the filename has the ".html", ".htm", or ".htl" extension, open it
        # in this window (unless it is already open in another window or
        # we are not inside a Displayer).
        set ext [file extension $filename]
        if {($ext == ".html" || $ext == ".htm" || $ext == ".htl" || \
            [isAnImageFileExtension $ext]) && \
                $myDisplayer != {}} {

            # Special care is required here because there might be a
            # source file open for either the old or the new file. If
            # there is a source file for the old HTML file, it will now
            # appear in the "Window" menu. If there is one for the new
            # file, it should now be removed from the Window menu (the
            # HTML browser widget will take its place).

            # If the destination file is already open, raise it.
            if {[info exists filesOpen($filename)] && \
                    [eval $filesOpen($filename) isa ::tycho::HTML]} {
                ::tycho::File::hyperJump $filename $point
                return
            }

            # If the destination file does not exist, issue a message.
            if ![file readable $filename] {
                ::tycho::warn \
                        "File does not exist or is not readable:\n$filename"
                return
            }

            # For backtracking
            if $push {
                pushNextHTMLFile
            }

	    # If the file does not have <body bgcolor="xxx">, then reset
	    # to the default colors
	    upvar #0 $stateArrayName var
	    $itk_component(text) configure \
                    -insertbackground $var(S_bgcolor) \
		    -background $var(S_bgcolor) \
		    -foreground $var(S_fgcolor)

            configure -directory [file dirname $filename]
            configure -file $filename
            toolbar clear location
            toolbar insert location $filename

            # Reset the insertion cursor to the origin, or else we will
            # try to preserve the point in the file.
            $itk_component(text) mark set insert 1.0

            # Handle Image files specially
	    if [isAnImageFileExtension $ext] {
		insertData "<img src=\"$filename\" alt=\"$filename\">"
	    } else {
                reload
            }

            if {$point != {}} {
                after 200 [list $this seeFragment $point]
            }
            configure -readonly 1
            return
        }
    } {
        # For backtracking
        if $push {
            pushNextHTMLFile
        }
    }

    # The file is not an HTML file, or is not specified,
    # so defer to File.
    ::tycho::File::hyperJump $filename $point
}

#####################################################################
#### insertData
# Insert the specified data, cancelling any previous rendering.
#
body ::tycho::HTML::insertData {data} {
    stopRendering
    # This is done in the background so that construction completes.
    # The time delays seems to be necessary to ensure that the window
    # gets mapped immediately.
    after 100 [list ::tycho::HTML::render $this $data]
}

#####################################################################
#### insertDirectoryContents
# Insert the contents of the the directory 'dirname' into the html
# widget.  We use this if the user visits a directory that does not
# have a index.html file so that the user can see the contents of the
# directory.
#
body ::tycho::HTML::insertDirectoryContents {dirname} {
    clear
    set toc "<h1>Contents of [::tycho::simplifyPath $dirname]</h1>\n\
            <pre><A HREF=\"..\">.. Up to higher level directory</A>"

    # A string with 20 spaces, that we use to left justify the links
    # We print the contents of the file inside a preformatted block
    # so that we can align the text properly.
    set spaceString "                   "

    set dirFiles [lsort [glob -nocomplain $dirname/*]]
    foreach dirFile $dirFiles {
        # If the filename is over 20 chars long, truncate it and add ...
        set shortName [file tail $dirFile]
        if [file isdirectory $dirFile] {
            # FIXME Unixism?  We are adding a / here, what about mac and windows
            set shortName "$shortName/"
        }
        if {[string length $shortName] > 20} {
            set shortName "[string range $shortName 0 16]..."
        }
        if [catch {file stat $dirFile stat} msg] {
            set toc [format \
                    "%s<br><A HREF=\"%s\">%s</A>%s  Couldn`t stat\n" \
                    $toc $dirFile \
                    $shortName \
                    [string range $spaceString \
                    1 [expr {20 - [string length $shortName]}]] \
                ]
        } else {
            set toc [format \
                    "%s<br><A HREF=\"%s\">%s</A>%s %6s %s\n" \
                    $toc $dirFile \
                    $shortName \
                    [string range $spaceString \
                    1 [expr {20 - [string length $shortName]}]] \
                    $stat(size) \
                    [clock format $stat(mtime)]]
        }
    }
    insertData $toc
}

#####################################################################
#### lastDirectory
# Return the directory for relative references to images and the like.
#
body ::tycho::HTML::lastDirectory {} {
    return $itk_option(-directory)
}

#####################################################################
#### linkEnter
# Display the link destination in the status bar for the link below
# the specified mouse position.
#
body ::tycho::HTML::linkEnter {xpos ypos} {
    set tags [$itk_component(text) tag names @$xpos,$ypos]
    set link [lindex $tags [lsearch -glob $tags L:*]]
    # regsub -all {[^L]*L:([^ ]*).*}  $tags {\1} link
    regsub L: $link {} link
    statusbar puts $link
}

#####################################################################
#### openSource
# Open the source file using an editor specialized for editing HTML.
#
body ::tycho::HTML::openSource {} {
    # If a source window already exists, just raise it.
    if [sourcewinIsMine] {
	$sourcewin raiseWindow
	return
    }
    set obj [::tycho::view EditHTML -file $file]
    set sourcewin $obj
}

#####################################################################
#### print
# Print the selection or, if there is no selection, the entire contents.
# At the moment, this first warns the user that it is not fully implemented,
# querying him or her to see whether to proceed.  Then, it
# queries the user for the print command to use.  A temporary file is
# created and then deleted to do the printing.  The name of that file
# will be appended to the end of the command specified by the user before
# it is invoked.
#
body ::tycho::HTML::print {} {
    if [safeEval ::tycho::askuser {Printing HTML is not fully implemented. \
            A fairly crude facsimile of the text only will be printed. \
            Proceed?}] {
        ::tycho::Edit::print
    }
}

#####################################################################
#### raiseWindow
# Raise this window and also the source window, if it is open.
#
body ::tycho::HTML::raiseWindow {} {
    if [sourcewinIsMine] {
	$sourcewin raiseWindow
    }
    ::tycho::TWidget::raiseWindow
}

#####################################################################
#### reload
# Reload from the last saved version of the current file. This method
# first disables read-only status (if it is set), then replaces the
# current data with data from the current file, and then sets read-only
# status. The data is marked unmodified after loading the file, and the
# clipboard is restored to its form prior to the reload. The actual
# replacement of the data occurs via the method
# <code>insertData</code>.
#
body ::tycho::HTML::reload {} {
    # Handle Image files specially
    set ext [file extension $file]

    if [isAnImageFileExtension $ext] {
        clear
        insertData "<img src=\"$file\" alt=\"$file\">"
    } else {
        ::tycho::File::reload
    }
    # Mark read-only to prevent modifications.
    configure -readonly 1
}

#####################################################################
#### seeFragment
# Goto the specified hypertext reference, line number, or range.
# The <i>point</i> argument can take any of three forms:
# <pre>
#    {line <i>linenumber</i>}
#    {range <i>startindex endindex</i>}
#    {yview <i>fraction</i>}
#    <i>name</i>
# </pre>
# In the first three forms, the point is a list beginning with the keyword
# "line", "range", or "yview".  If the point has neither of these forms, then
# it is interpreted as the name of named anchor in the HTML file.
# In all cases, the background color of the matching text is changed
# temporarily.  Notice that this will not be visible if the "range" form
# is used and the two indices are equal.  As a side effect, the selection
# (if there is one) is cleared.
#
# Note that when moving from one point to another in the same HTML
# file, this method may sometimes appear not to do anything. This
# is because the method only makes the point visible, rather than
# moving it to the top of the window as, say, Netscape does. This
# should perhaps be altered.
#
body ::tycho::HTML::seeFragment {point} {
    set text $itk_component(text)
    if {[llength $point] == 2 && [lindex $point 0] == {line}} {
        # First form: A line number.
        set ln [lindex $point 1]
        set sidx [$text index "$ln.0"]
        set eidx [$text index "$ln.0 lineend +1 char"]
    } elseif {[llength $point] == 3 && [lindex $point 0] == {range}} {
        # Second form: A range of indexes
        set sidx [lindex $point 1]
        set eidx [lindex $point 2]
    } elseif {[llength $point] == 2 && [lindex $point 0] == {yview}} {
        # Third form: a yview spec.
        $text yview moveto [lindex $point 1]
        return
    } {
        # Third form: a named anchor.
        ::tycho::safeUpdate $prefix
        HMgoto $text $point
        return
    }
    if {$sidx != {} && $eidx != {}} {
        # If rendering is in progress, the point may not exist yet.
        if {[$text compare $sidx >= end]} {
            if {$seecount < 40} {
                incr seecount
                after 400 [code evalIfExists $this seeFragment $point]
                return
            } {
                # Give up.  Probably point will never be visible.
                set sidx end
                set eidx end
            }
        }
        set seecount 0
	$text tag add hypertarget $sidx $eidx
	$text tag configure hypertarget \
		-background [preference get targetColor]
	$text tag configure hypertarget \
		-foreground black
	component text mark set insert $sidx; 	\
                selection clear -displayof $text; $text see insert
        after 8000 [list catch \
               [list $text tag delete hypertarget]]
    }
}

#####################################################################
#### isSlowNetwork
# Return 1 if the slowNetwork preference is set and the -image itk_option
# is null.  If -image is set, then we assume the user really does want
# to see the image.
#
body ::tycho::HTML::isSlowNetwork {} {
    if {$itk_option(-image) != 0 } { 
	return 0
    } else {
	return [preference get slowNetwork]
    }
}

#####################################################################
#### stopRendering
# Stop the rendering.  This simply disables the HMrender proc by
# setting a flag that causes HMrender to return immediately without
# doing anything.
#
body ::tycho::HTML::stopRendering {} {
    # The HTML library version 0.3 has a bug where HMset_state win -stop 1
    # does not properly set the stop bit in the control array.  So
    # instead, we set it directly.
    # HMset_state [textWinName] -stop 1
    upvar #0 $stateArrayName var
    set var(stop) 1
}

#####################################################################
#### textWinName
# Return the full path name of the text widget. Note that this path
# name is defined as a command at the global scope. This is intended
# only to be used for interfacing to legacy Tcl/Tk code that interacts
# directly with a Tk text widget. A null string is returned if for some
# reason the text window name does not exist (due to an error in
# construction).
#
body ::tycho::HTML::textWinName {} {
    if [info exists itk_component(text)] {
	return $itk_component(text)
    } {
	return {}
    }
}

#####################################################################
#### upSize
# Increase the font size in the current widget.
# Redefined from ::tycho::Edit
#
body ::tycho::HTML::upSize {} {
    if {$fontOffset > 0} {
        set fontOffset [expr ($fontOffset / 2) + 1 + $fontOffset]
    } else {
        incr fontOffset 2
    }        
    HMset_state [textWinName] -size $fontOffset
    render $this
}


#####################################################################
#### windowMenuAddAll
# Add me to the window menus of all open File objects.
# This is redefined in order to coordinate the source window, which
# may be open.
#
body ::tycho::HTML::windowMenuAddAll {label} {
    # Reclaim the source window, if it is open.
    if {[info exists filesOpen($label)]} {
        set sourcewin $filesOpen($label)
        $sourcewin windowMenuRemoveAll $label
    } {
        set sourcewin {}
    }
    ::tycho::File::windowMenuAddAll $label
}

#####################################################################
#### windowMenuRemoveAll
# Remove a filename from the window menus of all open File objects.
# This is redefined in order to coordinate the source window, which
# may be open.
#
body ::tycho::HTML::windowMenuRemoveAll {filename} {
    ::tycho::File::windowMenuRemoveAll $filename
    if [sourcewinIsMine] {
        $sourcewin windowMenuAddAll $filename
        set sourcewin {}
    }
}

    ###################################################################
    ###################################################################
    ####                      public procedures                    ####

#####################################################################
#### render
# Render the given HTML text in the given <code>HTML</code> window.
# If the given HTML text is not given or is a null string, then use the
# value of the -data option for the given object as the text.
# This is a procedure rather than a method because the object it operates
# on may be destroyed during the rendering process.  It should be invoked
# in the background, using "after", not in the constructor!
# Otherwise, the constructor does not complete until rendering is
# finished.  Moreover, the "update" calls in the rendering are dangerous
# in a constructor.
#
body ::tycho::HTML::render {obj {html {}}} {

    if {[info objects $obj] == {} || ![$obj isa ::tycho::HTML]} {return}

    if {$html == {}} {
        set html [$obj cget -data]
    }
    # Cancel previous rendering if necessary.
    if [$obj isRendering] {
        $obj stopRendering
        # Allow some time for rendering to complete.
        after 100 [list ::tycho::HTML::render $obj $html]
        return
    }

    $obj setRendering 1

    # Get the name of the Tk text widget.
    set tktext [$obj textWinName]
    $tktext configure -state normal
    
    # Remove all existing text in the widget.
    $tktext delete 1.0 end
    
    # Put the insertion cursor at the top
    $tktext mark set insert 1.0
    $tktext mark gravity insert left
    HMreset_win $tktext

    # Note that the following parsing operation results in many
    # calls to update, which can result in the widget $this being destroyed.
    HMparse_html $html "HMrender $tktext"

    # The catch is in case the object no longer exists
    catch {
	$obj setRendering 0
    }

    # FIXME: The following removes the insertion cursor, which
    # is good, but disables all the navigation bindings, which
    # is bad.  Perhaps those bindings can be redone in the
    # HTML class.
    # $tktext configure -state disabled
}


#########################################################################
#########################################################################
####                    protected methods                            ####

#####################################################################
#### preference
# Access the preferences associated with this widget. This method
# overrides the default method in ::tycho::TWidget to access the
# "viewhtml" preferences.
#
body ::tycho::HTML::preference {mode args} {
    eval ::tycho::preference $mode "viewhtml" $args
}

#####################################################################
#### configureContextMenu
# Configure the popup menu according to context. For HTML viewers, this
# looks for a corresponding itcl file and offers to open that if it
# finds one.
#
body ::tycho::HTML::configureContextMenu {} {
    ::tycho::TWidget::configureContextMenu

    if { $itk_option(-file) != "" && $itk_option(-file) != "NoName" } {
	set link [file split $itk_option(-file)]
	set path [lrange $link 0 [expr [llength $link] - 4]]
	set fname [join [concat \
		[lreplace [split [lindex $link end] .] end end] "itcl"] .]
	set link [eval file join $path $fname]

	if { [file exists $link] } {
	    contextmenu add "Open source" \
		    -command "$this hyperJump $link"
	}
    }
}

#########################################################################
#########################################################################
####                     private methods                             ####

#####################################################################
#### pushNextHTMLFile
# Return 1 if the sourcewin window is the source window for the
# currently open HTML text. Otherwise, return 0.
#
body ::tycho::HTML::pushNextHTMLFile {} {
    # Clear windows from this one ahea
    if { [llength $stack] > [expr $stackpos + 1] } {
        set stack [lreplace $stack $stackpos end]
    }

    # Set this one again, updating with the current point
    lappend stack [list $file [currentPoint]]

    # Move the stack pointer up
    incr stackpos

    # Disable the "forward" button, enable the "back" button
    toolbar disable forward
    toolbar enable back
}

#####################################################################
#### sourcewinIsMine
# Return 1 if the sourcewin window is the source window for the
# currently open HTML text. Otherwise, return 0.
#
body ::tycho::HTML::sourcewinIsMine {} {
    if {$sourcewin != {}} {
        # Test to see whether the window still exists.
        # We use catch here because other Itcl methods seem to be too tricky.
        if [catch {$sourcewin isModified}] {
            return 0
        }
	return 1
    } {
	return 0
    }
}

#####################################################################
#### isAnImageFileExtension
# Return 1 if the extension is the extension of an image file.
#
body ::tycho::HTML::isAnImageFileExtension {ext} {
    return [expr {($ext == ".gif" || $ext == ".ppm" || $ext == ".pgm" || \
		    $ext == ".xbm") && $myDisplayer != {}}]
}


    ###################################################################
    ###################################################################
    ####         modifications to the HTML library                 ####

# Instead of blindly inserting newlines, as done in the original
# library, we only insert them if they are not already there.
# The following table indicates how many newlines are desired
# by the tag. It replaces "HMinsert_map" in the original library.

array set HMinsert_space_map {
	blockquote 2 /blockquote 1
	br	1
	dd	1 /dd	1
	dl	1 /dl	1
	dt	1
	form 1	/form 1
	h1	2	/h1	2
	h2	2	/h2	2
	h3	2	/h3	2
	h4	2	/h4	2
	h5	1	/h5	1
	h6	1	/h6	1
	li   1
	/dir 1
	/ul 1
	/ol 1
	/menu 1
	p	2
	pre 1	/pre 2
}

array set HMparam_map {
    -foreground S_fgcolor
    -background S_bgcolor
}

#######################################################################
# The following empty procedures prevent calls to "unknown", which
# is very expensive.  This makes the HTML parser significantly faster.

foreach tag {
    !-- a address applet author b banner
    base big blockquote body br caption center
    cite code dd dfn div dl dt em form h1 h2 h3 h4 h5 h6 head hr
    html i img input isindex kbd li link map meta ol option p param
    pre samp script select small strike strong style sub sup table
    td textarea th title tr tt u ul var
    /a /address /applet /author /b /banner /big /blockquote /body /caption
    /center /cite /code /dfn /div /dl /em /form /h1 /h2 /h3
    /h4 /h5 /h6 /head /html /i /kbd /map /ol /p /pre /samp /select
    /small /strike /strong /sub /sup /table /textarea /title /tt /u /ul /var
} {
    if {[info proc HMtag_$tag] == {}} {
        proc HMtag_$tag {win param text} {}
    }
}

#######################################################################
#### HMcurrent_tags
# extract set of current text tags
# tags starting with T map directly to text tags, all others are
# handled specially.  There is an application callback, HMset_font
# to allow the application to do font error handling.
# Modified by EAL for greater efficiency.  Avoid calls that set
# fonts or get fonts if they've occurred before.
#
proc HMcurrent_tags {win} {
    upvar #0 HM$win var

    set family [lindex $var(family) end]
    set size [lindex $var(size) end]
    set weight [lindex $var(weight) end]
    set style [lindex $var(style) end]
    set S_adjust_size [lindex $var(S_adjust_size) end]
    set font "font:$family:$size:$weight:$style:$S_adjust_size"

    # Avoid repeatedly configuring the same font tag.
    global HMfont_tag_done
    if ![info exists HMfont_tag_done($win$font)] {
        set xfont [HMx_font $family $size $weight $style $S_adjust_size]
        HMset_font $win $font $xfont
        set HMfont_tag_done($win$font) $xfont
    } {
        set xfont $HMfont_tag_done($win$font)
    }
    set indent [llength $var(indent)]
    incr indent -1
    lappend tags $font indent$indent
    foreach tag [array names var T*] {
        lappend tags [lindex $var($tag) end]
    }
    set var(font) $font
    set var(xfont) $xfont
    set var(level) $indent
    return $tags
}

#######################################################################
#### HMextract_param
# Modify Uhler's implementation
# to not get confused by the presense of the keyword in a value.
#
# extract a value from parameter list (this needs a re-do)
# returns "1" if the keyword is found, "0" otherwise
#   param:  A parameter list.  It should alredy have been processed to
#           remove any entity references
#   key:    The parameter name
#   val:    The variable to put the value into (use key as default)

proc HMextract_param {param key {val ""}} {

    if {$val == ""} {
        upvar $key result
    } else {
        upvar $val result
    }
    set ws "    \n\r"
    
    # look for name=value combinations.  Either (') or (") are
    # valid delimeters    (for emacs highlighting) ;#"
    if {[regsub -nocase [format {.*%s[%s]*=[%s]*"([^"]*).*} $key $ws $ws] \
            $param {\1} value] ||
    [regsub -nocase [format {.*%s[%s]*=[%s]*'([^']*).*} $key $ws $ws] \
            $param {\1} value] ||
    [regsub -nocase [format {.*%s[%s]*=[%s]*([^%s]+).*} $key $ws $ws $ws] \
            $param {\1} value] } {
        set result $value
        return 1
    }
    
    # now look for valueless names
    # I should strip out name=value pairs, so we don't end up with "name"
    # inside the "value" part of some other key word - some day
    
    set bad \[^=a-zA-Z\]+
    # NOTE: Fixed to ignore if there is an "=".  EAL
    # FIXME: There is a case where this will fail.  If you have
    # <tag key1=value key2>, where key2 is valueless tag, the valueless
    # tag will not be identified.
    if {[regexp -nocase  "^\[^=\]*$bad$key$bad" -$param-]} {
        return 1
    } else {
        return 0
    }
}

#######################################################################
#### HMgoto
# Modify Uhler's implementation
# to support names with spaces and to make it more robust.
#
# The application should call here with the fragment name
# to cause the display to go to this spot.
# If the target exists, go there (and do the callback),
# otherwise schedule the goto to happen when we see the reference.
#
proc HMgoto {win where {callback HMwent_to}} {
    upvar #0 HM$win var

    # Note that javadoc produces tags like NamedObj(java.lang.String)
    # which contains the magic symbols: ( and ),
    # so we can't use regexp or string match, we must use lsearch -exact
    if {[lsearch -exact [$win mark names] "N:$where" ] != -1} {
	catch {$win see "N:$where"}
	update
	eval $callback $win [list $where]
	return 1
    } else {
	set var(goto) $where
	return 0
    }
}

#######################################################################
#### HMinit_state
# initialize the window's state array
# Parameters beginning with S_ are NOT reset
#  adjust_size:		global font size adjuster
#  unknown:		character to use for unknown entities
#  tab:			tab stop (in cm)
#  stop:		enabled to stop processing
#  update:		how many tags between update calls
#  tags:		number of tags processed so far
#  symbols:		Symbols to use on un-ordered lists
#  bgcolor:             The background color.
#  fgcolor:             The foreground color.
#
proc HMinit_state {win} {
    upvar #0 HM$win var
    array set tmp [array get var S_*]
    catch {unset var}
    array set var {
        stop 0
        tags 0
        fill 0
        list list
        S_adjust_size 0
        S_tab 1.5
        S_unknown \xb7
        S_update 10
        S_symbols O*=+-o\xd7\xb0>:\xb7
        S_insert HTMLInsert
        linkfg blue
        dlindent 0
    }
    set var(S_bgcolor) [$win cget -background]
    set var(S_fgcolor) [$win cget -foreground]
    array set var [array get tmp]
    set var(bgcolor) $var(S_bgcolor)
    set var(fgcolor) $var(S_fgcolor)
}

#######################################################################
#### HMlink_callback
# Override the HTML library definition for the hyperlink callback
# function. This does not at this time support HTTP, but does support
# files and names within a file. If the window lies within an HTML
# widget, and the link is to another HTML file, then we reuse the same
# window to display the referenced file. Otherwise, we open a new
# window.
#
proc HMlink_callback {win href} {

    if {![winfo exists $win]} {return}

    # Get the name of the HTML widget.
    set HTML [uplevel #0 winfo command [winfo megawidget $win]]

    if [regexp {^http:|^ftp:|^gopher:|^news:|^mailto:|^telnet:|^wais:} \
	    $href] {
	if ![::tycho::askuser "OK to invoke netscape to view $href?"] {
            # The user said no, so just return
            return
        } {
            # The user said yes
            global tcl_platform
	    switch $tcl_platform(platform) {
                unix {
                    if [catch \
		        {::tycho::tyexec netscape -remote openURL($href) &} \
			    errMsg] {
			::tycho::ErrorMessage .netscapeError -text $errMsg
			wm deiconify .netscapeError
		    }
		}
                windows {
		    # FIXME: It would be nice if we could open up
		    # a URL in a windows netscape without restarting netscape
		    # each time, but this requires 
		    # DDE or OLE.  For more info, search the Netscape
		    # website for 'openURL', or look at
		    # http://home.netscape.com/newsref/std/x-remote.html
                    if [catch {::tycho::tyexec netscape $href &} errMsg] {
                        ::tycho::ErrorMessage .netscapeError -text $errMsg
                        wm deiconify .netscapeError
                    }
                }
		default {
                    ::tycho::ErrorMessage .netscapeError -text \
                            "Sorry, exec is not supported on the \
			    $tcl_platform(platform) platform."
                    wm deiconify .netscapeError
		}
	    }
            return
	}
    }

    if {![regexp {(file:)?([^#]*)#(.+)} $href dummy noise file fragment]} {
	regexp {(file:)?([^#]*)} $href dummy noise file
	set fragment {}
    }

    # Got a reference to a file (or if file == {}, a local point).
    uplevel #0 [list $HTML hyperJump $file $fragment]
}

#######################################################################
#### HMrender
# HMrender gets called for every html tag
#   win:   The name of the text widget to render into
#   tag:   The html tag (in arbitrary case)
#   not:   a "/" or the empty string
#   param: The un-interpreted parameter list
#   text:  The plain text until the next html tag
# If the tag has an entry in the HMtag_map, then that entry is used
# to change the state (font, size, etc.).  If there is a
# procedure called HMtag_$tag, then that procedure is invoked.
#
proc HMrender {win tag not param text} {
    upvar #0 HM$win var
    if {$var(stop)} return
    global HMtag_map HMinsert_space_map HMlist_elements
    set tag [string tolower $tag]
    set text [HMmap_esc $text]
    
    # manage compact rendering of lists
    if {[info exists HMlist_elements($tag)]} {
        # NOTE: mod EAL.  Syntax error in the original.
        set list "list [expr {[HMextract_param $param compact] ? {compact} : {list}}]"
    } else {
        set list ""
    }
    
    # adjust (push or pop) tag state
    if [info exists HMtag_map($tag)] {
        HMstack $win $not "$HMtag_map($tag) $list"
    }
    
    set insert $var(S_insert)
    # insert white space (with current font).  NOTE: modified by EAL.
    if [info exists HMinsert_space_map($not$tag)] {
        set ins $insert
        # Skip if we are the top of the widget.
        if ![$win compare $ins == 1.0] {
            set spaces $HMinsert_space_map($not$tag)
            for {set ind $spaces} {$ind > 0} {incr ind -1} {
                set curline [$win get "$ins linestart" "$ins lineend"]
                if [regexp {^[ 	]*$} $curline] {
                    # If there is an embedded window, the line is not blank.
                    if {[$win dump -window "$ins linestart" "$ins lineend"] \
                            == {}} {
                        incr spaces -1
                    }
                } {
                    break
                }
                set ins [$win index "$ins -1 line"]
            }
            while {$spaces > 0} {
                incr spaces -1
                $win insert $insert "\n" "space $var(font)"
            }
        }
    }
    # If we are in fill mode, trim the text.
    if [lindex $var(fill) end] {
        # If the current line contains only spaces, remove them.
        set curline [$win get "$insert linestart" "$insert lineend"]
        if [regexp {^ *$} $curline] {
            # Check for embedded windows
            if {[$win dump -window "$insert linestart" "$insert lineend"] \
                    == {}} {
                $win delete "$insert linestart" "$insert lineend"
            }
        }
        if [$win compare $insert == "$insert linestart"] {
            set text [string trimleft $text]
        }
        set text [HMzap_white $text]
    }
    
    # generic mark hook
    # NOTE: mod EAL
    # catch {HMmark $not$tag $win $param text} err
    
    # do any special tag processing
    # Need a ignore unrecognized HTML tags.  Here we check explictly.
    # Could use a catch alternatively, but that tends to hide errors.
    # FIXME: Change to a catch for release.
    if {[info proc HMtag_$not$tag] != {}} {
        HMtag_$not$tag $win $param text
    }
    
    # add the text with proper tags
    set tags [HMcurrent_tags $win]
    $win insert $var(S_insert) $text $tags
    
    # We need to do an update every so often to insure interactive response.
    # This can cause us to re-enter the event loop, and cause recursive
    # invocations of HMrender, so we need to be careful.
    if {!([incr var(tags)] % $var(S_update))} {
        update
    }
}

#######################################################################
#### HMset_image
# An image callback function, called by the HTML library when it encounters
# and image. Read in an image if we don't already have one and
# call back to library for display.
#
# HMtag_image calls this and passes a label as the handle.
# This function in turn calls HMgot_image
#
proc HMset_image {win handle src} {
    # Get the name of the HTML widget.
    set HTML [uplevel #0 winfo command [winfo megawidget $win]]

    # If the slowNetwork misc preference is set, then don't display images.
    if {[$HTML isSlowNetwork] == 0} {
        # if it's an absolute path
        if {[file pathtype $src] == "absolute"} {
            set image $src
        } else {     
            # if it begins $PTOLEMY, $TYCHO, ~eal, etc.
            if {[string match \$* $src] || [string match ~* $src]} {
                set image [::tycho::expandPath $src]
            } else {
                set image [file join [uplevel #0 $HTML lastDirectory] $src]
            }
        }

        update
        if {[string first " $image " " [image names] "] >= 0} {
            HMgot_image $handle $image
        } else {
            set type photo
            if {[file extension $image] == ".bmp"} {set type bitmap}
            catch {image create $type $image -file $image} image
            HMgot_image $handle $image
        }
    }
}


#######################################################################
#### HMstack
# Push or pop tags to/from stack.
# Each orthogonal text property has its own stack, stored as a list.
# The current (most recent) tag is the last item on the list.
# Push is {} for pushing and {/} for popping.
# Fixed by EAL to not fail on popping empty stack.
#
proc HMstack {win push list} {
    upvar #0 HM$win var
    array set tags $list
    if {$push == ""} {
        foreach tag [array names tags] {
            lappend var($tag) $tags($tag)
        }
    } else {
        foreach tag [array names tags] {
            catch {set var($tag) [lreplace $var($tag) end end]}
        }
    }
}

#######################################################################
#### HMtag_body
# This code is modified from "surfit".
# HTML 3.2 introduces various attributes for the BODY tag.
# BACKGROUND (Tk 4.1 cannot support this), BGCOLOR, TEXT, LINK, VLINK, ALINK
#
proc HMtag_body {win param text} {
    upvar #0 HM$win var
    if {[HMextract_param $param bgcolor]} {
        set color [::tycho::color $bgcolor grey]
        $win configure -background $color
        set var(bgcolor) $color
        # Make the insertion cursor invisible
        $win configure -insertbackground $color
    }
    
    set savetext $text
    if {[HMextract_param $param text]} {
        set color [::tycho::color $text black]
        $win configure -foreground $color
        set var(fgcolor) $color
    }
    set text $savetext

    if {[HMextract_param $param link]} {
        set color [::tycho::color $link blue]
        set var(linkfg) $color
        $win tag configure link -foreground $color
    }
}

#######################################################################
#### HMtag_color
# This proc is directly from Stephen Uhler's sample, with only slight
# modifications. A new HTML tag, inserted just for fun. Change the
# color of the text. Use HTML tags of the form: <color value=blue> ...
# </color> The color has lower priority than all other tags.
# NOTE: This is not standard HTML.  Use <font color=foo> instead.
#
proc HMtag_color {win param text} {
	set value black
	HMextract_param $param value
	set value [::tycho::color $value black]
	$win tag configure $value -foreground $value
	$win tag lower $value
	HMstack $win "" "Tcolor $value"
}

proc HMtag_/color {win param text} {
	HMstack $win / "Tcolor {}"
}

# If you mess with the dl code, make sure that the javadoc output looks ok.
# See also $TYCHO/kernel/test/dltest.html
#
# Here's a summary of how the HTML dl code works.  This is a little
# long winded, but this code is very tricky.
#
# The variable HM$win is an array of stacks.  
# The indent is saved on a stack and gets pushed and popped depending
# on the level of indentation. 
# HMstack $win {} "indent 1" pushes 1 onto the stack.
# HMstack $win / "indent 1" pops the current value off the stack
# To read the stack, do:
# upvar $0 HM$win var; puts $var(indent)
#
# The HTMLcurrent_tag proc sets level which is also saved in HM$win.
# In general, level is derived from the length of indent, which is a list.
# level and indent are tightly coupled, if you change one, you have to
# consider the other.  level is also used in 
# $TYCHO/lib/html_library/html_library.tcl
#
# sawdd is a flag that is set to 1 once we have seen a dd.  sawdd is
# used to increment the indentation only once in the case of multiple dds
#
# When we see a dl flag, we savethe value of the indent stack as 'dlindent',
# which is in turn a stack.  
# To determine the level of indentation when we get a dt, dd or /dl
# we copy the saved value into indent and act accordingly.
# For dt, we decrement the indent stack
# For dd, we increment if this is the first dd, otherwise we leave it be
# For dl, we decrement the indent stack, and pop the dl stack.
#

#######################################################################
#### HMtag_dl
# When we see a dl, we save the current indent stack, and set sawdd to 0.
#
proc HMtag_dl {win param text} {
    upvar #0 HM$win var
    # Save the current indent level on the stack.
    HMstack $win {} "dlindent [list $var(indent)]"

    # For some reason, level is not keeping up with changes to indent.
    # Get the new level.
    set level [llength $var(indent)]
    incr level -1
    set var(level) $level

    # sawdd is 1 if we've seen dd.
    set var(sawdd) 0
}

#######################################################################
#### HMtag_/dl
# When we see a /dl, we restore our saved stack and set level accordingly.
#
proc HMtag_/dl {win param text} {
    upvar #0 HM$win var
    upvar $text data

    # Set the current indent to the indent we saved when we saw dl
    set var(indent) [lindex $var(dlindent) end]

    # Get the new level.
    HMstack $win / "indent {}"
    set level [llength $var(indent)]
    incr level -1
    set var(level) $level

    # Pop the saved value off the stack, we are done with it.
    HMstack $win / "dlindent {}"

    $win insert $var(S_insert) "$data" \
            "hi [lindex $var(list) end] indent$level $var(font)"
    set data {}
}

#######################################################################
#### HMtag_dt
# Modify the original to permanently remove the indent introduced by
# tag_dl.
# Pop the indent stack, set sawdd to 0, output the data, and push
# the indent stack.
#
proc HMtag_dt {win param text} {
    upvar #0 HM$win var
    upvar $text data
    # When we see a dd, we will set sawdd to 1.
    set var(sawdd) 0

    # Set the current indent to the indent we saved when we saw dl.
    set var(indent) [lindex $var(dlindent) end]

    # Pop an the indent stack.
    # The depth of the indent is determined by depth of the "indent" stack.
    HMstack $win {/} "indent {}"

    # Get the new level.
    set level [llength $var(indent)]
    incr level -1
    set var(level) $level

    # Note that we might have blank data at this point, since we could
    # have '<dt> <b>  <b>', so we need to leave the indent set at
    # the right place.
    $win insert $var(S_insert) "$data" \
            "hi [lindex $var(list) end] indent$level $var(font)"
    set data {}
}

#######################################################################
#### HMtag_dd
# Modify the original to reinsert the indent removed by
# tag_dt.  This indent will be removed later by tag_/dd.
# If we have not yet seen a dd, then push the indent stack.
#
proc HMtag_dd {win param text} {
    upvar #0 HM$win var
    upvar $text data
    if {$var(sawdd) == 0} {
        # If we have not yet seen a dd, then indent one level.
        set var(sawdd) 1

        # Set the current indent to the indent we saved when we saw dl.
        set var(indent) [lindex $var(dlindent) end]

        # Get the new level
        set level [llength $var(indent)]
        incr level -1
        set var(level) $level

        # Push something onto the "indent" stack.
        # The value "1" is irrelevant, but some value is needed.
        # The depth of the indent is determined by depth of the "indent" stack.
        #HMstack $win {} "indent 1"
	#incr var(level) 

    }
    set level $var(level)
    $win insert $var(S_insert) "$data" \
            "hi [lindex $var(list) end] indent$level $var(font)"
    set data {}
}

#######################################################################
#### HMtag_font
# The following is modified from surfit.
#
proc HMtag_font {win param text} {
    upvar #0 HM$win var
    if {[HMextract_param $param size]} {
        HMstack $win "" "size [expr [lindex $var(size) end] + $size]"
    } else {
        HMstack $win "" [list size [lindex $var(size) end]]
    }
    if {[HMextract_param $param color]} {
        set color [::tycho::color $color black]
        HMstack $win "" "Tcolor color$color"
        $win tag configure color$color -foreground $color
    } else {
        HMstack $win "" [list Tcolor black]
    }
}

proc HMtag_/font {win param text} {
    upvar #0 HM$win var
    HMstack $win "/" [list size {}]
    HMstack $win "/" [list Tcolor black]
}

#######################################################################
#### HMtag_img
# Like the original HMtag_img, but we don't barf on align=right
# 
#           Inline Images
# This interface is subject to change
# Most of the work is getting around a limitation of TK that prevents
# setting the size of a label to a widthxheight in pixels
#
# Images have the following parameters:
#    align:  top,middle,bottom
#    alt:    alternate text
#    ismap:  A clickable image map
#    src:    The URL link
# Netscape supports (and so do we)
#    width:  A width hint (in pixels)
#    height:  A height hint (in pixels)
#    border: The size of the window border
#
proc HMtag_img {win param text} {
	upvar #0 HM$win var

	# get alignment
	array set align_map {top top    middle center    bottom bottom}
	set align bottom		;# The spec isn't clear what the default should be
	HMextract_param $param align
	catch {set align $align_map([string tolower $align])}

	# FIXME: we can't handle right alignment of images.
	if {[string tolower $align] == "right" } {
	    set align bottom
	}

	# get alternate text
	set alt "<image>"
	HMextract_param $param alt
	set alt [HMmap_esc $alt]

	# get the border width
	set border 1
	HMextract_param $param border

	# see if we have an image size hint
	# If so, make a frame the "hint" size to put the label in
	# otherwise just make the label
	set item $win.$var(tags)
	# catch {destroy $item}
	if {[HMextract_param $param width] && [HMextract_param $param height]} {
		frame $item -width $width -height $height
		pack propagate $item 0
		set label $item.label
		label $label
		pack $label -expand 1 -fill both
	} else {
		set label $item
		label $label 
	}

	$label configure -relief ridge -fg orange -text $alt
	catch {$label configure -bd $border}
	$win window create $var(S_insert) -align $align -window $item -pady 2 -padx 2

	# add in all the current tags (this is overkill)
	set tags [HMcurrent_tags $win]
	foreach tag $tags {
		$win tag add $tag $item
	}

	# set imagemap callbacks
	if {[HMextract_param $param ismap]} {
		# regsub -all {[^L]*L:([^ ]*).*}  $tags {\1} link
		set link [lindex $tags [lsearch -glob $tags L:*]]
		regsub L: $link {} link
		global HMevents
		regsub -all {%} $link {%%} link2
		foreach i [array names HMevents] {
			bind $label <$i> "catch \{%W configure $HMevents($i)\}"
		}
		bind $label <1> "+HMlink_callback $win $link2?%x,%y"
	} 

	# now callback to the application
	set src ""
	HMextract_param $param src
	HMset_image $win $label $src
	return $label	;# used by the forms package for input_image types
}

#######################################################################
#### HMtag_menu
# Use a simple "-" rather than "->".
#
proc HMtag_menu {win param text} {
	upvar #0 HM$win var
	set var(menu) -
	set var(compact) 1
}

#######################################################################
#### HMtag_tcl {win param text} 
# Set up an extension to HTML in which the delimitters <tcl> ... </tcl>
# are understood to enclose a section of Tcl code. This code is
# highlighted in the document, and double clicking on it causes the enclosed
# Tcl code to be executed. The code is executed at the global scope.
# Normally, this tag will be used together with the standard <pre>...</pre>
# HTML tag to prevent the text from filling and wrapping.

proc HMtag_tcl {win param text} {

    upvar #0 HM$win var

    # Get the name of the HTML window and widget command.
    set HTML [winfo megawidget $win]
    set HTMLcommand [winfo command $HTML]

    # Set the color
    set color [::tycho::preference get viewhtml tclColor]
    $win tag configure tcl -foreground $color
    $win tag bind tcl <Double-Button-1> \
            "uplevel #0 $HTMLcommand execTcl %x %y; break"
    if {[HMextract_param $param quiet]} {
        set var(Ttclq) tclq
    }

    # We used to reduce the size here to compensate for the
    # difference in size of Courier and Times fonts. Now that
    # the size is set by user preferences we let the user
    # set it. Also tag the text "tcl".
    HMstack $win {} "Ttcl tcl size [lindex $var(size) end]"
}

proc HMtag_/tcl {win param text} {
    upvar #0 HM$win var
    if {[info exists var(Ttclq)]} {
        unset var(Ttclq)
    }
    HMstack $win / "Ttcl {} size {}"
}

#######################################################################
#### HMx_font
# Generate an X font name using the FontManager class in Tycho.
# Also, cache font requests locally for additional efficiency
# (this yields about an 18% speed improvement in rendering).
#
proc HMx_font {family size weight style {adjust_size 0}} {
    global HMx_font_cache
    set cachename "$family.$size.$weight.$style.$adjust_size"
    if [info exists HMx_font_cache($cachename)] {
        return $HMx_font_cache($cachename)
    }
    # The HTML library seems to call this with empty strings for arguments.
    # I don't know why.  We have to handle that situation.
    if {$size == {}} {return fixed}
    incr size $adjust_size
    set result [::tycho::xfont $family $size $weight $style]
    set HMx_font_cache($cachename) $result
    return $result
}

#######################################################################
#### HMtag_hmstart
# Modify to not depend on being in the HMtag_map array.
#
proc HMtag_hmstart {win param text} {
	upvar #0 HM$win var
        global HMinitialtag_map
        HMstack $win {} $HMinitialtag_map
	$win mark gravity $var(S_insert) left
	$win insert end "\n " last
	$win mark gravity $var(S_insert) right
}

#######################################################################
#### HMtag_hr
# Improve the horizontal rule a bit.
#
proc HMtag_hr {win param text} {
	upvar #0 HM$win var
	$win insert $var(S_insert) "\n" space "\n\n\n" \
		thin "\t" "thin hr" "\n\n\n" thin
	$win tag configure hr -background black
}

#######################################################################
#### HMtag_sub
# Subscripts.
#
proc HMtag_sub {win param text} {
    upvar #0 HM$win var
    HMstack $win "" \
            [list Tsubscript subscript size [expr [lindex $var(size) end] - 2]]
}

proc HMtag_/sub {win param text} {
    HMstack $win "/" [list Tsubscript {} size {}]
}

#######################################################################
#### HMtag_sup
# Superscripts.
#
proc HMtag_sup {win param text} {
    upvar #0 HM$win var
    HMstack $win "" \
            [list Tsuperscript superscript \
            size [expr [lindex $var(size) end] - 2]]
}

proc HMtag_/sup {win param text} {
    HMstack $win "/" [list Tsuperscript {} size {}]
}

#######################################################################
#### HMwent_to
# Override the library function to put the start of the named region
# at the top of the window and to temporarily change the background color.
#
proc HMwent_to {win where {count 0} {color {}}} {
    if {![winfo exists $win]} {return}
    if {$count >= 6} return
    if {$count == 0} {
        set range [$win tag nextrange "N:$where" 1.0]
        if {$range != {}} {
            # Put the start of the named region at the top of the window.
            # (The following sometimes puts the line we want to see one line
            # above the visible part of the window. Hence the correction after).
            set start [expr int([lindex $range 0])]
            set length [expr int([$win index end])]
            set fraction [expr "$start.0/$length"]
            $win yview moveto $fraction

            # The following ensures the item in question is in view.
            $win see [lindex $range 0]
        }
    }

    if {$color == {}} {
        set color [::tycho::preference get viewhtml targetColor]
    }

    # Temporarily change the background color
    upvar #0 HM$win var
    $win tag configure "N:$where" -background $color -foreground black
    after 8000 [list catch [list \
            $win tag configure "N:$where" -background {} -foreground {}]]
    update
}

#######################################################################
#### Table handling
# FIXME: This code is temporary, pending proper table handling.
# It does not render the table, which is relatively hard to do, but
# tries to format the text in such a way that table entries are at least
# distinguished from one another.

#######################################################################
#### HMtag_/tr
# For a table item, if the text does not end in a period, add a period.
#
proc HMtag_/td {win param text} {
    upvar #0 HM$win var
    set line [$win get "$var(S_insert) linestart" $var(S_insert)]
    if {![regexp {\.[ 	]*$} $line]} {
        $win insert $var(S_insert) "."
    }
}

# Tags for the rudimentary table support:
set HMtag_map(tr) {indent 1}
set HMinsert_space_map(tr) 1

# Increase the tab stops from 1 to 1.5 cm.
HMset_state -tab 1.5

