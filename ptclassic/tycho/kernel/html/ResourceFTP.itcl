# A Resource for receiving on FTP daemon on default port 21
# 
# @Author: Kevin Chang
#
# @Version: $Id$
# 
# @Copyright (c) %Q% The Regents of the University of California.
# All rights reserved.
#
# Permission is hereby granted, without written agreement and without
# license or royalty fees, to use, copy, modify, and distribute this
# software and its documentation for any purpose, provided that the above
# copyright notice and the following two paragraphs appear in all copies
# of this software.
#
# IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY
# FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
# ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF
# THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.
#
# THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE
# PROVIDED HEREUNDER IS ON AN "AS IS" BASIS, AND THE UNIVERSITY OF
# CALIFORNIA HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,
# ENHANCEMENTS, OR MODIFICATIONS.
# 
#                                        PT_COPYRIGHT_VERSION_2
#                                        COPYRIGHTENDKEY
#######################################################################

#######################################################################
#### ResourceFTP
#
class ::tycho::ResourceFTP {
    inherit ::tycho::Resource

    constructor {args} {}
    destructor {}

    #####################################################################
    ####                          options                            ####

    ###################################################################
    ####                         public methods                    ####

    # Close the resource. Calls ftpinit to send out the message.
    method close {}

    # Return the eof of file status
    method eof {}

    # Read a string from a streamable resource
    method gets {{varName {}}}
    
    # Not open by default
    method isopen {} {return 0}

    # if there's timeout on protocol, we can't connect to the ftp server.
    method ftptimeout {oldstate}

    # Open the resource. Enable puts.
    method open {{path {}}}

    # Get the progress of sending ftp
    method progress {} {return $progress}

    # Write a string to a streamable resource.
    # Can't write into HTTP file! Read permission of off
    method puts {string}

    # Get a cached copy of the data
    method cachefile {}

    ###################################################################
    ####                           public procs                    ####

    # Change the permissions of a resource
    proc chmod {permissions path}

    # Return the content type of the current file
    proc contenttype {path}

    # Delete a resource
    proc delete {path}

    # Return a directory listing
    proc dirlist {path}

    # See if the server or hostname exists
    proc exists {path}

    # Create a new directory
    proc mkdir {path}

    # Create a new resource object
    proc new {path args}

    # Get the status of a resource
    proc stat {path varName}

    # Return the type of a given file
    proc type {path}

    ###################################################################
    ####                         protected methods                 ####

    # Puts a string to console of the debug option is set
    protected method debugputs {string}

    # Initiate a connection on the FTP server. Called by open.
    public method ftpinit {{url {}}}

    # Protocol handler for ftp server. Called by ftpinit. 
    public method ftphandler {}

    # Abort in the middle of ftphandler transaction.
    public method ftpabort {message}

    # DATA port to receive. This includes LIST and RETR
    public method ftpdataportinit {}


    public method ftpdataport {fd location port}

    ###################################################################
    ####                        protected commons                  ####

    ###################################################################
    ####                        protected variables                ####

    # The url this object is accessing
    protected variable currentURL {}

    # The progress, can be used with the statusbar
    protected variable progress 0.0

    # The state of transfer 
    protected variable state {DISCONNECTED}

    # By all UNIX default (/etc/services), 21 is the port to open.
    protected variable _socketid {}

    # Attribute of the FTP server and the file/directory.
    protected variable ftpserver {}
    protected variable ftpport "21"
    protected variable ftppath /
    protected variable ftpfile {}
    protected variable ftpsize 0

    # Attribute of the current connection (FTP client). Attributes
    # are set after "fconfigure _socketid -sockname", which returns:<br>
    # <tt>n1.n2.n3.n4  client_name  unique_16_bit_client_socket</tt>
    protected variable _dataport 0
    protected variable _dataaddr 127.0.0.1

    # Transfer could be either file or directory (two distince FTP commands).
    protected variable ftptype {directory}

    # Attribute of myself (FTP client)
    protected variable _myusername {anonymous}
    protected variable _mypassword {tycho@}

    ###################################################################
    ####                         private variables               ####
    
    # Debug status. Print if 1
    private variable debug 1

    # True if the file is open
    private variable fileIsOpen 0

    # Timeout for sending/receiving protocol message. Default 2 seconds
    private variable timeout 2000
}


#######################################################################
#### constructor
#
# For each HTTP GET, an object is created and destroyed.
#
body ::tycho::ResourceFTP::constructor {args} {
    eval configure $args

}

#######################################################################
#### destructor
#
body ::tycho::ResourceFTP::destructor {} {
    # If we're still loading, forget it
}

#########################################################################
#########################################################################
####                      public methods                             ####

#####################################################################
#### close
body ::tycho::ResourceFTP::close {} {
    if !$fileIsOpen {
	error "File \"$this\" is not open."
    }

    return 1
}

#####################################################################
#### open
# Open a connection for ftp on port 21.
#
body ::tycho::ResourceFTP::open {{path {}}} {
    if {$path=={}} {
        set currentURL [path]
    }

    if { ! [exists $currentURL] } {
	error "File $url does not exist"
    }

    if {$fileIsOpen} {error "File is already open!"}

    set fileIsOpen 1
    set progress 0.0
    return 1
}

#####################################################################
#### puts
body ::tycho::ResourceFTP::puts {string} {
    if {!$fileIsOpen} {error "File is not open."}
    lappend ftpbuffer $string
}

#########################################################################
#########################################################################
####                          public procedures                      ####

#####################################################################
#### exists
# Check if the given URL exists. If the URL has already been
# accessed before, use the data obtained from the earlier
# load. Otherwise open the URL and download just the header.
# Returns 0 if the server cannot be accessed or if the file
# does not exist on the server.
#
body ::tycho::ResourceFTP::exists {url} {
    # Do we already know if it exists?
    return 1
}

#####################################################################
#### new
# Create a new HTTP object.
#
body ::tycho::ResourceFTP::new {path args} {
    #::puts "::tycho::ResourceFTP::new $path $args"
    uplevel #0 ::tycho::ResourceFTP [::tycho::autoName ResourceFTP] \
	    $args
}

#########################################################################
#########################################################################
####                     protected methods                           ####

#########################################################################
#### debugputs
# Puts a string to the console if the *-debug* option is set.
#
body ::tycho::ResourceFTP::debugputs {string} {
    if $debug {
	::puts $string
    }
}

proc ftp {site} {
    set obj [::tycho::ResourceFTP [::tycho::autoName ftp]]
    $obj ftpinit $site
    return $obj
}


#########################################################################
#### ftpinit
# Opening a ftp connection, and set the fileevent.
#
body ::tycho::ResourceFTP::ftpinit {{url {}}} {
    # Parse URL into hostname, port, and path
    if {$url!={}} {set currentURL $url}

    # Setup destination according to url:
    #       server             path        file
    #       v                  v           v
    # ftp://www.servername.com/path1/path2/file.tar.gz
    set ftppath   [::tycho::url path $currentURL]
    set ftpfile   [::tycho::url tail $currentURL]

    set ftpserver [::tycho::url server $currentURL]
    set ftpport   [lindex [split $ftpserver :] 1]
    set ftpserver [lindex [split $ftpserver :] 0]
    if {$ftpport=={}} {set ftpport 21}

    # The following is needed because path returns the following:
    #   tycho::url path ftp://server.com/p1/p2/file1 == p1/p2/file1
    #
    # The correct path is:
    #   tycho::url path ftp://server.com/p1/p2/file1 == p1/p2/
    regsub [::tycho::url tail $currentURL] $ftppath {} ftppath

    # If trailing char is /, then it is a directory. Else, probably file.
    if [regexp {^.*/} $currentURL] {set ftptype "dir"} {set ftptype "file"}

    debugputs "$ftpserver:$ftpport   path:$ftppath   file:$ftpfile"

    # Connect to server
    if {[catch {socket -async $ftpserver $ftpport} _socketid]} {
	catch {unset $_socketid}
	error "Can't open $ftpserver, $ftpport"
    }

    # Set my port information
    set tmpinfo [fconfigure $_socketid -sockname]
    set _dataaddr [lindex $tmpinfo 0]   ;# Client location
    set _dataport [lindex $tmpinfo 2]   ;# Client's port connecting to server

    set state USER

    # Set up the file events for incoming data
    ::fileevent $_socketid w {}
    ::fileevent $_socketid readable \
            [list @scope ::tycho::ResourceFTP [list $this ftphandler]]
    #"[list catch [list @scope ::tycho::ResourceFTP [list $this ftphandler]]]"

    ::fconfigure $_socketid -blocking no    ;#-translation crlf
    ::fconfigure $_socketid -translation auto
}

#########################################################################
#### ftphandler
# The following is the handshake protocol between the client and
# the server. When the ftphandler gets the expected state from
# the server, it'll send out the right data.
# <pre>
# State          Expect from Server             Send/"Action"
# -----          ------------------             -----------
#
# </pre>
body ::tycho::ResourceFTP::ftphandler {} {
    if {[::eof $_socketid] && $state!="DISCONNECTED"} {
        error "FTP handshaking failed"
    }
    # Line will contain the status
    ::gets $_socketid line
    debugputs "$state> $line"

    # This returns the status number. 200-299 is okay (just like HTTP)
    # Need to use regexp instead of lindex because some servers return
    # number followed by - (ie. 200- This is just a comment).
    if {![regexp {^([0-9]+) .*} $line _ status]} {
        return
    }

    set cmd {}
    # The following is a state machine
    switch -- $state {
        DISCONNECTED {
            ftpabort "DISCONNECTED: Error, should not expect incoming message"
            set progress -1
        }

        USER {
            # USER 220 messier.eecs.berkeley.edu FTP server
            if [regexp -nocase {^22[0-9] .*} $line] {
                set cmd "USER $_myusername"
                set state PASS
                after $timeout "eval $this ftptimeout $state"
            }
            set progress 0.1
        }

        PASS {
            # 331 Guest login ok, send ident as password.
            if [regexp -nocase {^33[0-9] .*} $line] {
                set cmd "PASS $_mypassword"
                set state PWD
                after $timeout "eval $this ftptimeout $state"
            }
        }

        PWD {
            # 230 Guest login ok, access restrictions apply.
            if [regexp -nocase {^23[0-9] .*} $line] {
                set cmd "PWD"
                set state PASV
                after $timeout "eval $this ftptimeout $state"
            }
        }

        PASV {
            # 257 "/" is current directory.
            if [regexp -nocase {^25[0-9] .*} $line] {
                set cmd "PASV"
                set state SIZE
                after $timeout "eval $this ftptimeout $state"
            }
        }

        SIZE {
            # 227 Entering Passive Mode (128,32,240,78,165,11)
            if [regexp -nocase {^22[0-9] .*} $line] {
                set cmd "SIZE [::tycho::url join $ftppath $ftpfile]"
                set state PORT
                after $timeout "eval $this ftptimeout $state"
            }
        }

        PORT {
            # Setup a ftpdataport
            if {[ftpdataportinit]<=0} {
                ftpabort "$status> Could not open up a client socket"
                return
            }
            set tmpport [join [split $_dataaddr .] ,]
            set p1 [expr $_dataport / 256]        ;# upper 8 bits
            set p2 [expr $_dataport - ($p1*256)]  ;# lower 8 bits
            set cmd "PORT $tmpport,$p1,$p2"
            if {$ftptype=="file"} {
                set state TYPE
            } elseif {$ftptype=="dir"} {
                set state CWD
            }
            after $timeout "eval $this ftptimeout $state"

            # 213 5000
            # 500 SIZE not a good command
            if [regexp -nocase {^2[0-9][0-9] .*} $line] {
                set ftpsize [lindex $line 1]
            } else {
                set ftpsize 0
            }
        }

        TYPE {
            # 200 PORT command successful.
            if [regexp -nocase {^22[0-9] .*} $line] {
                set cmd "RETR [::tycho::url join $ftppath $ftpfile]"
                set state RETR
                after $timeout "eval $this ftptimeout $state"
            }
        }

        CWD {
            # 200 PORT command successful.
            if [regexp -nocase {^20[0-9] .*} $line] {
                set cmd "CWD $ftppath"
                set state LIST
                after $timeout "eval $this ftptimeout $state"
            }
        }
        LIST {
            # 250 CWD command successful.
            if [regexp -nocase {^25[0-9] .*} $line] {
                set cmd "LIST"
                after $timeout "eval $this ftptimeout $state"
            }
        }

    }
    # The following is required because Tcl will buffer all output
    if {$cmd!={}} {
        debugputs "$state> $cmd"
        ::puts $_socketid $cmd
        ::flush $_socketid
    }

    if {$status>=400 && !($state=="CWD" || $state=="TYPE")} {
        # we have $status now, check if it's error
        ftpabort "$state> ERROR: $line"
    }
}

#########################################################################
#### ftpdataportinit
# Open up a socket (client) so that server can send data into
# the socket. The socket number is determined by 
# (the current socket connecting to the server) + 1 + (n tries)
#
#
# Return ftpdataport's file descriptor if successfully opened up a socket.
# 0 if failed n times.
body ::tycho::ResourceFTP::ftpdataportinit {} {
    # Try to open up socket 15 times.
    set n 15

    # Port incremental amount. If a port is already taken, increment
    set iamount 1
    set _dataport [expr $_dataport + $iamount]
    while {$n > 0} {
        debugputs "Going to open up port $_dataport"
        
        socket -server \
                "@scope ::tycho::ResourceFTP $this ftpdataport" \
                $_dataport

        if {0} {
            debugputs "SUCCESS: [fconfigure $dataid -sockname]"

            fconfigure $dataid -blocking no -translation auto
            return $dataid
        }
        incr n -1
        # Increase the port amount more will increase the probability
        # of hitting an empty port.
        set _dataport [expr ($_dataport + [incr iamount $iamount])%(256*256)]
    }
    return 0
}

#########################################################################
#### ftpdataport
#
body ::tycho::ResourceFTP::ftpdataport {fd location port} {
    if [eof $fd] {
        catch {close $fd}
        return
    }
    ::gets $fd line
    ::puts "$fd $location $port> $line"
}

#########################################################################
#### ftptimeout
# After certain amount of time, we hope that the state has transitioned.
# Otherwise, there's a timeout on the network or on the server, and
# we have to stop the transaction. This method will compare the oldstate
# with the current state.
#
body ::tycho::ResourceFTP::ftptimeout {oldstate} {
    if {$oldstate==$state} {
        debugputs "Timeout on $currentURL, state $oldstate"
        error "Timeout on $currentURL, state $oldstate"
    }
}

#########################################################################
#### ftpabort
# When the protocol fails, output an error message, and close socket
#
body ::tycho::ResourceFTP::ftpabort {message} {
    catch {::close $_socketid}
    set state DISCONNECTED
    set fileIsOpen 0
    error $message
}

