# Subclass of Resource
# 
# @Author: Kevin Chang
#
# @Version: $Id$
# 
# @Copyright (c) %Q% The Regents of the University of California.
# All rights reserved.
#
# Permission is hereby granted, without written agreement and without
# license or royalty fees, to use, copy, modify, and distribute this
# software and its documentation for any purpose, provided that the above
# copyright notice and the following two paragraphs appear in all copies
# of this software.
#
# IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY
# FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
# ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF
# THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.
#
# THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE
# PROVIDED HEREUNDER IS ON AN "AS IS" BASIS, AND THE UNIVERSITY OF
# CALIFORNIA HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,
# ENHANCEMENTS, OR MODIFICATIONS.
# 
#                                        PT_COPYRIGHT_VERSION_2
#                                        COPYRIGHTENDKEY
#######################################################################

#######################################################################
#### ResourceHTTP
# This provides an abstraction of remote file for anything that
# uses Resource. Using this class, attributes are abstracted away
# from functionalities which include: cache, updating cache, HTTP
# protocol, socket error, etc.
#
class ::tycho::ResourceHTTP {
    inherit ::tycho::Resource

    constructor {args} {}
    destructor {}

    #####################################################################
    ####                          options                            ####

    # Debugging flag
    public variable debug 0

    # Command to execute on each line received
    public variable notifycommand ""

    ###################################################################
    ####                         public methods                    ####

    # Close the resource.
    method close {} {}

    # Return the content type of the current file
    method contenttype {}

    # Return the end of file status
    method eof {}

    # Test if a given resource exists.
    # FIXME: Currently we need to "open" first.
    # FIXME: This doesn't work yet.
    # method exists {path}

    # Return the current file type
    # method filetype {} {return HTTP}

    # Read a string from a streamable resource
    # Takes in variable name as input, and outputs the string length.
    # If no argument, then just return the string.
    method gets {{arg1 {}} {arg2 {}}}

    # Return true if a given path is a file
    # FIXME FIXME FIXME FIXME FIXME FIXME FIXME FIXME FIXME FIXME FIXME FIXME
    # I stronly think that "filetype" can replace this method
    # because filetype returns "file", "http", "ftp", "weld", etc...
    method isfile {path} {return 0}

    # Open the resource. Make a connection and download entire file into cache.
    # Return positive number if successful, and 0 to negative if not.
    method open {path {mode "r"}}

    # Get the current full resource path
    method path {} {}

    # Write a string to a streamable resource.
    # Can't write into HTTP file! Read permission of off
    method puts {} {error "Cannot write to HTTP file."}

    # Return a string containing the data in a streamable resource 
    method read {}

    # Return 1 if this resource is streamable
    method streamable {}

    # Return the progess indicator, as a decimal number. 1.0 is full.
    method progress {}

    ###################################################################
    ####                           public procs                    ####

    # Change the permissions of a resource
    proc chmod {permissions path}

    # Delete a resource
    proc delete {path}

    # Test if a given resource exists
    proc exists {path}

    # Return files at a given path
    proc glob {pattern}

    # Create a new directory
    proc mkdir {path}

    # Create a new resource object
    proc new {path}

    # Query properties of a file
    proc query {path option}

    # Source the file as Tcl
    proc source {path}

    # Get the status of a resource
    proc stat {path varName}

    # Return the type of a given file
    proc type {path}

    ###################################################################
    ####                         protected methods                 ####

    # Puts a string to console of the debug option is set
    protected method debugputs {string}

    # Abort an HTTP GET
    protected method httpabort {}

    # Test is currently performing a GET
    protected method httpbusy {}

    # Clean up after completing a get
    protected method httpdone {}

    # Notify client of an incoming line and get ready for the next one
    protected method httpnotify {}

    # Initiate an HTTP get. Type is file or header.
    protected method httpget {url type}

    # Parse a url
    protected method httpparse {url}

    # The file event handler
    protected method httpread {}

    # Wait until an HTTP GET completes.
    protected method httpwait {}

    # FIXME
    method info {} {
	concat [array get _forwarding] [array get _statinfo]
    }

    ###################################################################
    ####                        protected commons                  ####

    # The cache file associated with this URL
    protected common _cachefile

    # A forwarding address associated with some URLs
    protected common _forwarding

    # The status info obtained from a given URL
    protected common _statinfo

    # The current status of an http get. This is a common array
    # so that tkwait can access it. Can be "header," "body,"
    # "abort," or "done".
    protected common _httpstatus

    ###################################################################
    ####                        protected variables                ####

    # The url this object is accessing
    protected variable currentURL {}

    # The get mode: "file" or "header"
    protected variable getmode {}

    # The name of the cache file associated with this HTTP
    protected variable cachefile {}

    # The index of the get. FIXME: Not being used yet (performance issue)
    protected variable idx 0
    # Instead, the following variable is used!
    # This is the cache file id, used for [$this gets] and [$this eof]
    protected variable cachefd {}

    # The id of the http socket
    protected variable socketid {}

    # Returning status of a http get. 200 by default is "normal"
    protected variable status -1

    # The last modified date of this http file. Used for caching purpose.
    protected variable lastmodified {}

    # Content type of this http file.
    protected variable contenttype {}

    # The content length of this http file.
    protected variable contentlength {}

    # The content loaded so far
    protected variable contentloaded 0

    # Location of this file, if the returning status is 300-399 (forward)
    protected variable forwardlocation {}

    # FIXME: need to find out where to collect protocols that Tycho
    # understands:
    protected variable accept {text/*}

    ###################################################################
    ####                         private variables               ####
}


#######################################################################
#### constructor
#
# For each HTTP GET, an object is created and destroyed.
#
body ::tycho::ResourceHTTP::constructor {args} {
    eval configure $args
}

#######################################################################
#### destructor
#
body ::tycho::ResourceHTTP::destructor {} {
    catch {::close $socketid}
    catch {::close $cachefd}
}

#########################################################################
#########################################################################
####                      public methods                             ####

#####################################################################
#### close
body ::tycho::ResourceHTTP::close {} {
    set tmp $cachefd
    set cachefd -1
    return [expr ![catch {::close $tmp}]]
}

#####################################################################
#### contenttype
# Return the content type of the open file.
body ::tycho::ResourceHTTP::contenttype {} {
    return $contenttype
}

#####################################################################
#### eof
body ::tycho::ResourceHTTP::eof {} {
    ::eof $cachefd
}

#####################################################################
#### gets
body ::tycho::ResourceHTTP::gets {{arg1 {}} {arg2 {}}} {
    # If two arguments are passed, just use arg2 because
    # arg1 is simply a bogus file ID
    if {$arg2!={}} {
        set arg1 $arg2
    }
    # Enclose brackets around so that in "uplevel" it is evaluated safely
    set line [list [::gets $cachefd]]
    if {$arg1!={}} {
        uplevel "set $arg1 $line"
        # If argument is passed then we want to return number of char
        return [string length $line]
    }
    return $line
}

#####################################################################
#### open
# URL should be in the following format: 
#
body ::tycho::ResourceHTTP::open {url {mode "r"}} {
    if {$mode!="r"} {
        return -1
    }

    # Parse the url into separated variables
    httpparse $url

    # One status variable per open
    set httpGlobalStatus [::tycho::autoName httpgetStatus]
    global $httpGlobalStatus
    httpSetStatus $httpGlobalStatus "running"

    # Setup a file without extension. After getting the file, then
    # rename to the proper extension.
    set cachefile [::tycho::tmpFileName Cache]
    set cachefd [::open $cachefile "w"]
    debugputs "cache file = $cachefile"

    # Get the cache file associated with the above URL.
    # Note that httpget could potentially call itself recursively
    # until we get the correct HTTP file.
    httpget "entirefile"

    # Wait until the entire http file is here on local drive
    httpwait

    # At this point, we know what file type we have,
    # so setup cache file
    if {[regexp {^text} $contenttype] && \
            [file extension [path]]=={}} {
        # This is type html (probably index.html)
        file rename -force $cachefile $cachefile.html
        set cachefile $cachefile.html
    } else {
        # Use old default type
        file rename -force $cachefile $cachefile[file extension [path]]
        set cachefile $cachefile[file extension [path]]
    }
    debugputs "cache file = $cachefile"
    catch {::close $cachefd}


    # If the get status is not within 200-299 then get isn't successful
    if {$status>=200 && $status<300} {
        # Successful
        set cachefd [::open $cachefile]
        return 1
    } else {
        # Error!
        return [expr -$status]
    }
}

#####################################################################
#### path
body ::tycho::ResourceHTTP::path {} {
    if {$port==80} {
        return "http://$hostname$path"
    } else {
        return "http://$hostname$path:$port"
    }
}

#########################################################################
#### progress
# Get the current progress of a non-blocking read. Won't make sense
# if not called during a non-blocking read.
#
body ::tycho::ResourceHTTP::progress {} {
    expr $contentloaded / $contentlength.0
}

#####################################################################
#### read
body ::tycho::ResourceHTTP::read {} {

}

#####################################################################
#### streamable
body ::tycho::ResourceHTTP::streamable {} {
    return 1
}

#########################################################################
#########################################################################
####                          public procedures                      ####

#####################################################################
#### chmod
body ::tycho::ResourceHTTP::chmod {permissions path} {
    error "FIXME"
}

#####################################################################
#### exists
# Check if the file is readable or not on the network. This is
# almost identical to "open"
body ::tycho::ResourceHTTP::exists {url} {
    # If we already have a cache file, then it exists
    if { [::info exists _cachefile($url)] } {
	return 1
    }
    # Otherwise try getting the header
    httpget header

::puts "::tycho::ResourceHTTP::exists $url"
    # Parse the url into separated variables
    httpparse $url

    # One status variable per open
    set httpGlobalStatus [::tycho::autoName httpgetStatus]
    global $httpGlobalStatus
    httpSetStatus $httpGlobalStatus "running"

    # Note that httpget could potentially call itself recursively
    # until we get the correct HTTP file.
    httpget header

    # Wait until we have the header
    httpwait

    # If the get status is not within 200-299 then get isn't successful
    if {$status>=400 && $status<500} {
        return 0
    } else {
        return 1
    }
}

#####################################################################
#### glob
# FIXME: not implemented yet. Need to parse output crazy!!!
body ::tycho::ResourceHTTP::glob {path} {
    puts "FIXME: ::tycho::ResourceHTTP::glob"
    return {}
}

#########################################################################
#### httpSetStatus
# Helper function to set the global variable
# This is used so that tkwait can wait for
# the global variable to change from "running" to either
# "normal" or "abnormal"
#
proc httpSetStatus {name value} {
    global $name
    set $name $value
}

#####################################################################
#### new
body ::tycho::ResourceHTTP::new {path} {
    uplevel #0 ::tycho::ResourceHTTP [::tycho::autoName resourcehttp]
}

#####################################################################
#### query
body ::tycho::ResourceHTTP::query {path option} {
    # Check for "remote"
    if { $option == "remote" } {
	return 0
    }
    # Check for valid option
    if { [lsearch {executable exists isdirectory \
	    isfile readable writable} $option] >= 0 } {
	switch -exact -- $option {
	    "readable" {
		exists $path
	    }
	    "writable" {
		return 0
	    }
	    default {
		error "Unknown option \"$option\" on $path"
	    }
	}
    }
}

#####################################################################
#### source
body ::tycho::ResourceHTTP::source {path} {
    error "FIXME"
    # source $cachefile
}

#####################################################################
#### stat
body ::tycho::ResourceHTTP::stat {path varName} {
    error "FIXME"
}

#########################################################################
#########################################################################
####                     protected methods                           ####

#########################################################################
#### debugputs
# Puts a string to the console if the *-debug* option is set.
#
body ::tycho::ResourceHTTP::debugputs {string} {
    if $debug {
	::puts $string
    }
}

#########################################################################
#### httpabort
# Cancel the current GET. Any data that has been obained will
# still be in the cache file, but it may be incomplete.
#
body ::tycho::ResourceHTTP::httpabort {} {
    # First see that there is a GET running
    if ![::info exists _httpstatus($currentURL)] {
	return
    }
    # Set the status so that httpdone knows what to do
    set _httpstatus($currentURL) "abort"

    # Terminate with httpdone. This will enable any
    # threads hanging off tkwait to continue.
    httpdone
}

#########################################################################
#### httpbusy
# Return true if the HTTP GET is still running.
#
body ::tycho::ResourceHTTP::httpbusy {} {
    expr { [::info exists _httpstatus($currentURL)] \
	    && $_httpstatus($currentURL) != "done" }
}

#########################################################################
#### httpdone
# Clean up after getting a header or file.
#
body ::tycho::ResourceHTTP::httpdone {} {
    # Close socket
    debugputs "Closing $socketid"
    ::close $socketid
    set socketid ""

    # Close cache file
    if { $getmode == "file" } {
	debugputs "Closing $cachefd"
	::close $cachefd
	set cachefd ""
    }

    # Update length
    set contentloaded $contentlength

    # Copy some local data to common arrays
    set _cachefile($currentURL) $cachefile
    set _statinfo($currentURL) [list \
	    -mtime $lastmodified \
	    -size $contentlength \
	    -type $contenttype]

    # To be picky, let's check that the content size is the
    # same as what we actually got...
    if { $_httpstatus($currentURL) != "abort" && $getmode == "file" } {
	if { [::file size $cachefile] != $contentlength } {
	   if $debug {
	       # debugputs "Received HTTP file size ([::file size \
		       $cachefile]) \
		    is not the same as content length ($contentlength)"
	   }
	}
    }

    # Set the status
    set _httpstatus($currentURL) "done"

    # One last update of notifycommand
    if { $notifycommand != "" } {
	uplevel #0 $notifycommand
    }
}

#########################################################################
#### httpget
# Opening an HTTP connection, and set the right fileevent depending on
# the type argument, which can be either "file" or "header". 
#
body ::tycho::ResourceHTTP::httpget {url type} {
    debugputs "\nHTTP GET $url $type"

    # Parse URL into hostname, port, and path
    set currentURL $url
    ::tycho::assign hostname port path [httpparse $url]

    # Surfit starts here vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
    if {[catch {socket -async $hostname $port} socketid]} {
        catch {unset $socketid}
        error "Can't open $host, $port"
    }
    # Surfit ends here ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    debugputs "Connect $hostname:$port on $socketid"

    # Create the cache file if getting the whole file.
    if { $type == "file" && $cachefd == "" } {
	set cachefile [::tycho::tmpFileName httpCache]
	set cachefd [::open $cachefile "w"]
	debugputs "Cache file $cachefile on $cachefd"
    }
    set _httpstatus($url) "header"  ;# Initially we're getting the header
    set status -1                   ;# Initial status - ?
    set getmode $type               ;# header or file
    set contentloaded 0             ;# how much is loaded
    set contentlength 1             ;# in case of progress{}

    # Set up the file events for incoming data
    ::fileevent $socketid w {}
    ::fileevent $socketid readable \
	    "@scope ::tycho::ResourceHTTP [list $this httpread]"

    # Request the URL
    # FIXME: Need to figure out how to set the Accept-Encoding field
    ::fconfigure $socketid -blocking no -translation crlf
    ::puts $socketid "GET $path HTTP/1.0\n\
            User-Agent: Tycho Jr. Beta\n\
            Accept-Encoding: $accept"
    ::puts $socketid ""
    ::flush $socketid
    ::fconfigure $socketid -translation auto

    debugputs "-> GET $path HTTP/1.0"
    debugputs "-> User-Agent: Tycho Jr. Beta"
    debugputs "-> Accept-Encoding: $accept"
    debugputs "->"
}

#########################################################################
#### httpnotify
# This is called by the httpread event handler. It connects
# the fileevent, and, if the *-notifycommand* option is not
# null, executes it.  *-notifycommand* need not invoke any kind
# of updates to keep the user interface "live", but it doesn't
# matter if it does.
#
body ::tycho::ResourceHTTP::httpnotify {} {
    if { $notifycommand != "" } {
	uplevel #0 $notifycommand
    }
    after idle "::fileevent $socketid readable \
	    \"@scope ::tycho::ResourceHTTP [list $this httpread]\""
}

#########################################################################
#### httpparse
# Parse a url into the hostname, port, and return them
# as a three-element list.
#
body ::tycho::ResourceHTTP::httpparse {url} {
    set _port 80
    set _hostname {}
    set _path /

    # The following parses the url into hostname, port, and path
    # The following is verbatim from Surfit: vvvvvvvvvvvvvvvvvvvvvvvvvvvv
    if {[regexp -nocase {^http://([^/:]*)(:([^/]+))?(.*)} $url match \
            hosttmp optport porttmp pathtmp]} {
        if {$hosttmp!={}} {set _hostname $hosttmp} ;# Supply reasonable default
        if {$porttmp!={}} {set _port $porttmp}     ;# HTTP default service
        if {$pathtmp!={}} {set _path $pathtmp}
    } else {
        # Recover from malformed URL
        if {![string match */* $url]} {
            # Assume only the hostname:port has been given
            regexp {([^:]*)(:(.*))?} $url match \
                    hosttmp optport porttmp
            if {$hosttmp != {}} {set _hostname $hosttmp}
            if {$porttmp != {}} {set _port $porttmp}
            set _path /
        } else {
            error "no hostname given in URL \"$url\""
        }
    }
    return [list $_hostname $_port $_path]
}

#########################################################################
#### httpread
# This is called by the file event handler, from httpget. This will get
# just the header info or the whole file and save it to a temporary
# cache file, depending on the *getmode* variable.
#
# Parse the possible header information:
# <pre>
# HTTP/1.0 200 Document follows
# Date: Wed, 21 May 1997 00:54:29 GMT
# Server: NCSA/1.4.1
# Content-type: text/html
# Last-modified: Fri, 16 May 1997 21:18:58 GMT
# Content-length: 8215
#
# HTTP/1.0 302 Found
# Date: Wed, 21 May 1997 01:17:59 GMT
# Server: NCSA/1.4
# Location: http://HTTP.CS.Berkeley.EDU/~kchang/
# Content-type: text/html
# 
# HTTP/1.0 404 Not Found
# Date: Wed, 21 May 1997 01:20:18 GMT
# Server: NCSA/1.4
# Content-type: text/html
# Last-modified: Mon, 12 May 1997 18:46:57 GMT
# Content-length: 683
# </pre>
#
body ::tycho::ResourceHTTP::httpread {} {
    # If at eof, we're done
    if [::eof $socketid] {
	httpdone
	return
    }
    # Disconnect the file handler. This is the only way
    # I can find of keeping the user interface live when
    # connected to a fast server. (Using any kind of update
    # in the file handler is no good, because the handler
    # gets called recursively and Tcl bombs out with a stack
    # overflow.)
    ::fileevent $socketid readable {}

    # Get a line
    ::gets $socketid line

    # Currently reading header or body?
    if { $_httpstatus($currentURL) == "header" } {
	# Header mode, the information about this http get.
	if { $line == {} } {
	    # End of header is denoted by an empty line
	    debugputs "            <-"
	    set _httpstatus($currentURL) "body"

	    # Check status codes
	    if {$status==404} {
		# FIXME: need to remember this as "not exists"
		error "File $currentURL does not exist"
	    } elseif {$status>=300 && $status<=399} {
		# If the header return status is 300-399, then we need to 
		# automatically forward the HTTP location. This is done 
		# under all the smart browsers such as Internet Explorer 
		# and Netscape, and is almost always done transparently
		# to the user.
		debugputs "Closing $socketid"
		::close $socketid
		set _forwarding($currentURL) $forwardlocation
		httpget $forwardlocation $getmode

	    } elseif { $getmode == "header" } {
		# If in header-only mode, we're done!
		httpdone
	    }
	} else {
	    debugputs "            <- $line"
	    # Parse the possible header fields (see comment for
	    # this method)
	    regexp {^HTTP/[0-9]+.[0-9]+ ([0-9]+)} $line match status
	    regexp -nocase {^Last-modified: (.+)} $line match lastmodified
	    regexp -nocase {^Content-type: (.+)} $line match contenttype
	    regexp -nocase {^Location: (.+)} $line match forwardlocation
	    regexp -nocase {^Content-length: ([0-9]+)} $line match contentlength
	}
    } elseif { $_httpstatus($currentURL) == "body" } {
	# Body mode (content of http get), write to the cache file.
	# Note that we only do this if the status _is_ "body," in
	# case an abort is in progress.
	set contentloaded [expr $contentloaded + [string length $line] + 1]
	::puts $cachefd $line
    }
    # Update client-specified command and reconnect the file handler
    httpnotify
}

#########################################################################
#### httpwait
# Wait until the current GET completes
body ::tycho::ResourceHTTP::httpwait {} {
    # Wait until the status becomes "done"
    while { $_httpstatus($currentURL) != "done" } {
        tkwait variable _httpstatus($currentURL)
    }
    return
}
