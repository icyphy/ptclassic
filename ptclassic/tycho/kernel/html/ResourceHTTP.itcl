# Subclass of Resource
# 
# @Author: Kevin Chang
#
# @Version: $Id$
# 
# @Copyright (c) %Q% The Regents of the University of California.
# All rights reserved.
#
# Permission is hereby granted, without written agreement and without
# license or royalty fees, to use, copy, modify, and distribute this
# software and its documentation for any purpose, provided that the above
# copyright notice and the following two paragraphs appear in all copies
# of this software.
#
# IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY
# FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
# ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF
# THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.
#
# THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE
# PROVIDED HEREUNDER IS ON AN "AS IS" BASIS, AND THE UNIVERSITY OF
# CALIFORNIA HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,
# ENHANCEMENTS, OR MODIFICATIONS.
# 
#                                        PT_COPYRIGHT_VERSION_2
#                                        COPYRIGHTENDKEY
#######################################################################

#######################################################################
#### ResourceHTTP
# This provides an abstraction of remote file for anything that
# uses Resource. Using this class, attributes are abstracted away
# from functionalities which include: cache, updating cache, HTTP
# protocol, socket error, etc.
#
class ::tycho::ResourceHTTP {
    inherit ::tycho::Resource

    constructor {args} {}
    destructor {}

    #####################################################################
    ####                          options                            ####

    ###################################################################
    ####                         public methods                    ####

    # Close the resource.
    method close {} {::close $cachefd; set cachefd -1}

    # Return the content type of the current file
    method contenttype {} {return $contenttype}

    # Return the end of file status
    method eof {} {return [::eof $cachefd]}

    # Test if a given resource exists.
    # FIXME: Currently we need to "open" first.
    # FIXME: This doesn't work yet.
    method exists {path}

    # Return the current file type 
    method filetype {} {return HTTP}

    # Read a string from a streamable resource
    # Takes in variable name as input, and outputs the string length.
    # If no argument, then just return the string.
    method gets {{arg1 {}} {arg2 {}}}

    # Return files at a given path.
    # FIXME: Doesn't work yet.
    method glob {path}

    # Return true if a given path is a file
    # FIXME FIXME FIXME FIXME FIXME FIXME FIXME FIXME FIXME FIXME FIXME FIXME
    # I stronly think that "filetype" can replace this method
    # because filetype returns "file", "http", "ftp", "weld", etc...
    method isfile {path} {return 0}

    # Open a new resource
    method new {{path {}}}

    # Open the resource. Make a connection and download entire file into cache.
    # Return positive number if successful, and 0 to negative if not.
    method open {path {mode "r"}}

    # Get the current full resource path
    method path {} {}

    # Write a string to a streamable resource.
    # Can't write into HTTP file! Read permission of off
    method puts {} {error "Cannot write to HTTP file."}

    # Return a string containing the data in a streamable resource 
    method read {}

    # Return true if a given resource is readable
    # If the HTTP file exists, then it's readable.
    method readable {path} {return [exists]}

    # Source a streamable resource as a Tcl script
    method source {{path {}}} {source $cachefile}

    # Get the status of a resource
    method stat {path varName}

    # Return 1 if this resource is streamable
    method streamable {}

    # Return true if a resource is writable
    method writable {{path {}}} {return 0}

    ###################################################################
    ####                      public variables                     ####

    # Used with httpget
    public variable httpGlobalStatus {}

    ###################################################################
    ####                         protected methods                 ####

    # Opening an HTTP connection and return the tmp HTTP cache file name.
    method httpget {}

    # This is called by file event handler, from httpget.
    method httpread {fd tmpfd}

    # Parse url and decode the names into protected variables
    method httpparse {url}

    # Set the global http status to "running" or "normal" or "abnormal"
    method httpsetstatus {status}

    # Wait until httpget is done.
    method httpwait {}

    ###################################################################
    ####                        protected variables                ####

    # The full name of the current file (or directory)
    #protected variable currentFile

    # The name of the host name. Format is:<br>
    # <tt>HTTP://$hostname$path:$port</tt>
    protected variable hostname {}
    
    # The name of path in the hostname
    protected variable path /

    # The name of the HTTP port. Default is 80
    protected variable port 80

    # The name of the cache file associated with this HTTP
    protected variable cachefile {}

    # The index of the get. FIXME: Not being used yet (performance issue)
    protected variable idx 0
    # Instead, the following variable is used!
    # This is the cache file id, used for [$this gets] and [$this eof]
    protected variable cachefd -1

    # Whether we are getting the header or not (header mode or body mode)
    protected variable isheader 1

    # Returning status of a http get. 200 by default is "normal"
    protected variable status -1

    # The last modified date of this http file. Used for caching purpose.
    protected variable lastmodified {}

    # Content type of this http file.
    protected variable contenttype {}

    # Location of this file, if the returning status is 300-399 (forward)
    protected variable forwardlocation {}

    # FIXME: need to find out where to collect protocols that Tycho
    # understands:
    protected variable accept {text/*}

    ###################################################################
    ####                         private variables               ####
}


#######################################################################
#### constructor
#
body ::tycho::ResourceHTTP::constructor {args} {
    eval configure $args
}

#######################################################################
#### destructor
#
body ::tycho::ResourceHTTP::destructor {} {
    close
}

#########################################################################
#########################################################################
####                      public methods                             ####

#####################################################################
#### close
body ::tycho::ResourceHTTP::close {} {
    
}

#####################################################################
#### exists
body ::tycho::ResourceHTTP::exists {[ath} {
    return ($status>=200 && $status<300)
}

#####################################################################
#### gets
body ::tycho::ResourceHTTP::gets {{arg1 {}} {arg2 {}}} {
    # If two arguments are passed, just use arg2 because
    # arg1 is simply a bogus file ID
    if {$arg2!={}} {
        set arg1 $arg2
    }
    # Enclose brackets around so that in "uplevel" it is evaluated safely
    set line [list [::gets $cachefd]]
    if {$arg1!={}} {
        uplevel "set $arg1 $line"
        # If argument is passed then we want to return number of char
        return [string length $line]
    }
    return $line
}

#####################################################################
#### glob
# FIXME: not implemented yet. Need to parse output crazy!!!
body ::tycho::ResourceHTTP::glob {path} {
    return {}
}

#####################################################################
#### isfile
body ::tycho::ResourceHTTP::isfile {path} {
    return 0
}

#####################################################################
#### new
body ::tycho::ResourceHTTP::new {{path {}}} {
    set new [[info class] [::tycho::autoName resource]]
    if { $path == "" } {
	$new open $currentFile
    } else {
	$new open $path
    }
    return $new
}

#####################################################################
#### open
# URL should be in the following format: 
#
body ::tycho::ResourceHTTP::open {url {mode "r"}} {
    if {$mode!="r"} {
        return -1
    }

    # Parse the url into separated variables
    httpparse $url

    # One status variable per open
    set httpGlobalStatus [::tycho::autoName httpgetStatus]
    global $httpGlobalStatus
    #uplevel #0 "set $httpGlobalStatus running"
    httpSetStatus $httpGlobalStatus "running"

    # Get the cache file associated with the above URL.
    # Note that httpget could potentially call itself recursively
    # until we get the correct HTTP file.
    httpget

    # Wait until the entire http file is here on local drive
    httpwait

    # If the get status is not within 200-299 then get isn't successful
    if {$status>=200 && $status<300} {
        # Successful
        set cachefd [::open $cachefile]
        return 1
    } else {
        # Error!
        return [expr -$status]
    }
}

#####################################################################
#### path
body ::tycho::ResourceHTTP::path {} {
    if {$port==80} {
        return "HTTP://$hostname$path"
    } else {
        return "HTTP://$hostname$path:$port"
    }
}

#####################################################################
#### read
body ::tycho::ResourceHTTP::read {} {

}

#####################################################################
#### readable
body ::tycho::ResourceHTTP::readable {{path {}}} {
    return 1
}

#####################################################################
#### source
body ::tycho::ResourceHTTP::source {{path {}}} {

}

#####################################################################
#### stat
body ::tycho::ResourceHTTP::stat {path varName} {

}

#####################################################################
#### streamable
body ::tycho::ResourceHTTP::streamable {} {
    return 1
}

#####################################################################
#### writable
body ::tycho::ResourceHTTP::writable {{path {}}} {
    return 0
}

#########################################################################
#########################################################################
####                     protected methods                           ####

#########################################################################
#### httpparse
# Parse a url, and move them to status, last modified, contenttype, etc...
#
body ::tycho::ResourceHTTP::httpparse {url} {
    # Reset the status from the header of HTTP protocol
    set cachefile {}
    set port 80
    set status 200
    set lastmodified {}
    set contenttype {}
    set forwardlocation {}

    # The following parses the url into hostname, port, and path
    # The following is verbatim from Surfit: vvvvvvvvvvvvvvvvvvvvvvvvvvvv
    if {[regexp -nocase {^http://([^/:]*)(:([^/]+))?(.*)} $url match \
            hosttmp optport porttmp pathtmp]} {
        if {$hosttmp!={}} {set hostname $hosttmp} ;# Supply reasonable default
        if {$porttmp!={}} {set port $porttmp}     ;# HTTP default service
        if {$pathtmp!={}} {set path $pathtmp}
    } else {
        # Recover from malformed URL
        if {![string match */* $url]} {
            # Assume only the hostname:port has been given
            regexp {([^:]*)(:(.*))?} $url match \
                    hosttmp optport porttmp
            if {$hosttmp != {}} {set hostname $hosttmp}
            if {$porttmp != {}} {set port $porttmp}
            set path /
        } else {
            error "no hostname given in URL \"$url\""
        }
    }
    # Surfit ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
}

#########################################################################
#### httpget
# Opening an HTTP connection. This returns the file name of the 
# temporary HTTP file (later on cache). This method assumes that
# hostname, port, and path are set.
#
body ::tycho::ResourceHTTP::httpget {} {
    # Surfit starts here vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
    if {[catch {socket -async $hostname $port} fd]} {
        catch {unset $fd}
        error "Can't open $host, $port"
    }
    # Surfit ends here ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    # connect now!
    fconfigure $fd -blocking no -translation crlf
    ::puts $fd "GET $path HTTP/1.0\n\
            User-Agent: Tycho Jr. Beta\n\
            Accept-Encoding: $accept"
    ::puts $fd ""
    ::flush $fd
    fconfigure $fd -translation auto

    # Wait until finished reading HTTP file
    set cachefile [::tycho::tmpFileName Cache].html
    set tmpfd [::open $cachefile "w"]
    set isheader 1    ;# Initially we're getting the header first

    ::tycho::safeUpdate $this
    fileevent $fd w {}
    fileevent $fd r "$this httpread $fd $tmpfd"
}

#########################################################################
#### httpread
# This is called by file event handler, from httpget.
#
body ::tycho::ResourceHTTP::httpread {fd tmpfd} {
    global $httpGlobalStatus
    if [::eof $fd] {
        # Got the HTTP file, now check to see if everything's valid.
	catch {::close $fd}
	catch {::close $tmpfd}

        # If returning status is 300-399, then we need to automatically
        # forward the HTTP location. This is done under all the smart
        # browsers such as Internet Explorer and Netscape, and is almost
        # always done transparent to the user.
        if {$status>=300 && $status<=399} {
            # Need to determine the new location.
            httpparse "$forwardlocation"
            # Second attempt to get the file
            after idle "$this httpget"
            return
        }
        httpSetStatus $httpGlobalStatus done
        #uplevel #0 "set $httpGlobalStatus done"
    } else {
	::gets $fd line
        if {$isheader==1} {
            # Header mode, the information about this http get.
            if {$line=={}} {
                # End of header is denoted by an empty line
                set isheader 0
                return
            } else {
                # Parse the possible header information:
                #HTTP/1.0 200 Document follows
                #Date: Wed, 21 May 1997 00:54:29 GMT
                #Server: NCSA/1.4.1
                #Content-type: text/html
                #Last-modified: Fri, 16 May 1997 21:18:58 GMT
                #Content-length: 8215
                #
                #HTTP/1.0 302 Found
                #Date: Wed, 21 May 1997 01:17:59 GMT
                #Server: NCSA/1.4
                #Location: http://HTTP.CS.Berkeley.EDU/~kchang/
                #Content-type: text/html
                # 
                #HTTP/1.0 404 Not Found
                #Date: Wed, 21 May 1997 01:20:18 GMT
                #Server: NCSA/1.4
                #Content-type: text/html
                #Last-modified: Mon, 12 May 1997 18:46:57 GMT
                #Content-length: 683
                regexp {^HTTP/1.0 ([0-9]+)} $line match status
                regexp {^Last-modified: (.+)} $line match lastmodified
                regexp {^Content-type: (.+)} $line match contenttype
                regexp {^Location: (.+)} $line match forwardlocation
            }
        } else {
            # Body mode (content of http get), write to the cache file.
            ::puts $tmpfd $line
        }
    }
}

#########################################################################
#### httpwait
# Wait until the variable name has been changed.
body ::tycho::ResourceHTTP::httpwait {} {
    global $httpGlobalStatus
    # Keep waiting until we are done fetching the http file.
    #after 2000 "set $httpGlobalStatus done"
    while {[uplevel #0 "set $httpGlobalStatus"]!="done"} {
        tkwait variable $httpGlobalStatus
    }
    return [uplevel #0 "set $httpGlobalStatus"]
}


    ###################################################################
    ####                        public procs                       ####

#########################################################################
#### httpsetstatus
# Helper function to set the global variable
# This is used so that tkwait can wait for
# the global variable to change from "running" to either
# "normal" or "abnormal"

proc httpSetStatus {name value} {
    global $name
    set $name $value
}
