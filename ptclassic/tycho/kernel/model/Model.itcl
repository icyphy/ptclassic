##########################################################################
# Version: $Id$
# Author: John Reekie, Edward A. Lee
#
# Copyright (c) 1996 The Regents of the University of 'California'.
#  rights reserved.
# 
# Permission is hereby granted, without written agreement and without
# license or royalty fees, to use, copy, modify, and distribute this
# software and its documentation for any purpose, provided that the above
# copyright notice and the following two paragraphs appear in all copies
# of this software.
# 
# IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY
# FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
# ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF
# THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.
# 
# THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE
# PROVIDED HEREUNDER IS ON AN "AS IS" BASIS, AND THE UNIVERSITY OF
# CALIFORNIA HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,
# ENHANCEMENTS, OR MODIFICATIONS.
#                                                         COPYRIGHTENDKEY
##########################################################################


##########################################################################
#### Model
#
# This class is the abstract superclass of Tycho's implementation of the 
# _model_ component of the model-view user interface architecture.  The 
# model-view architecture is a derivation of the well-known 
# model-view-controller architecture developed as part of Smalltalk and 
# seemingly discussed in just about every book on object-oriented 
# architectures and design techniques.  The model-view derivation combines 
# MVC's view and controller into a single abstraction -- the key forcees 
# driving this change are the increased control functionality provided 
# these days by widgets in UI frameworks (including Tk) and the increased 
# amount of direct manipulation and feedback, which makes the 
# functionality of the view and controller more tightly coupled -- 
# see the book _Designing Object-oriented User Interfaces_, Dave Collins,
# 1995.
#
# The _Model_ class is subclassed to provide application-specific (or 
# application-related, at least), information models.  (The corresponding 
# view class in Tycho is named _View_.) This abstract superclass supports 
# multiple views using the ``publish-and-subscribe'' design pattern (known 
# as the ``Observer'' pattern in books such as Gamma _et al's_ `Design 
# Patterns.'' It also incorporates two additional factors not essential 
# to, but very useful to, the model abstraction: persistence and a 
# command history.
#
# Multiple views can _subscribe_ to the same model -- when any view 
# changes the data in the model, the other subscribed views are notified 
# of the change.  (Note: I always use ``notify'' instead of ``update'' to 
# avoid possible confusion with Tk's update{} procedure.) The notification 
# model is what is known as the ``push'' model: when data is changed, the 
# subscribers are informed of the type of the change _and_ the changed 
# data.  Some subclasses may choose to implement instead a ``pull'' model, 
# in which subscribers query the model for changed information.  All data 
# is accessed by means of an _index_.  Depending on the functionality 
# implemented by specific subclasses, this index could a simple integer or 
# string key, or somehting more complex: a region of a file between two 
# positions, a regular expression indicating the text associated with a 
# particular method, or some other symbolic representation of a portion of 
# or position within the data contained by one of these objects.  
# Different subclasses support subscription of varying complexity -- for 
# example, an object may be able to subscribe to changes only of a certain 
# type.  By default, subscription and notification uses glob-style 
# pattern-matching to provide flexible and reasonably-efficient (in Tcl) 
# access to indexes.
#
# Persistent data is an important aspect of information models: the user 
# opens and closes windows, but the information model, representing the 
# user's conceptual understanding of the semantics of the operations he or 
# she performs via the user interface, is persistent across window 
# openings and closings, and even across invocations of the application 
# program.  It is supported by the three options *-sourcefile*, 
# *-datafile*, and *-imagefile*.  These are all file names, and any may be 
# used, depending on the subclass and the particular application.  The 
# "source" is a file containing information needed to build the data and 
# is never modified by the data object; the "file" is a file containing 
# the same information, but can be written by the data object: it is thus 
# the same as the usual *-file* option to the Tycho editors; the "image" 
# is a file containing the data in a form that can be rapidly 
# reconstructed by the data object.  The image is a simple Tcl 
# implementation of the ``Memento'' design pattern (Gamma _et al_).
#
# A key aspect of a user interface that encourages user interaction and 
# exploration is the ability to ``undo'' any operation.  This class 
# implements a reasonably flexible, unbounded, undo and redo 
# mechanism, so that any change to a model can be undone and redone.  The 
# undo history implemented by this class is linear -- an interesting 
# extension of the history mechanism is to make it tree-structured, for 
# applications such as design exploration, where a designer may want to 
# try out a number of different design paths and "milestone" significant 
# designs in a tree or forest of alternative designs.
#
# <i>(Edward has pointed out the relation between persistence, undo, 
# and version control. We need to work out a good abstraction for
# these mechanisms.)</i>
#
# An alternative (better?) class structure is certainly possible: split 
# the undo history into a separate class.  (This would make it an instance 
# of the ``CommandServer'' pattern of Buschmann et al's _A System of 
# Patterns_.) This would be more flexible -- for example, substituting a 
# tree-structured history for the linear history would be straightforward.  
# There is some close coupling between the history and the persistence 
# (the history is saved in the image) which makes it convenient to combine 
# them into one class.  Perhaps after some usage this issue should be 
# examined to see whether to split the history out.
#
# The methods in the _Model_ classes fall into six groups:
#
# <ul>
# <li>Change commands: add{}, replace{}, dataconfigure{}, delete{}, 
#     execute{}, and so on.
#     These are the commands that are available for undo/redo
#     and publishing. In this abstract superclass, only the exceute{} 
#     command (which executes a list of commands) is implemented: other 
#     commands must be provided by subclasses. Suggested commands are :
#    
#     <ul>
#     <li>*add* _index_ _data_ _args_: Add new data at the given index.
#          Some subclasses may not allow this operation if data already
#          exists at the given index, while others will just insert
#          additional data at that index. If the data subclass accepts
#          data options, then following arguments are option values.
#     <li>*replace* _index_ _data_: Replace the data at the given index
#          with new data. Some subclasses may not allow this operation
#          if data does not exist at the given index; others will.
#     <li>*create* _index_ _args_: Create some kind of data with the given
#          index, where the additional arguments describe how to create
#          the data. This method is appropriate for models of graphical
#          diagrams. <i>See note below regarding returned values.</i>
#     <li>*dataconfigure* _index_ ?_option? ?_value? ...: Configure options of
#          data at the given index. This method is appropriate in any 
#          model in which some data can be given additional attributes.
#          It is often renamed according to the model: entryconfigure{},
#          itemconfigure{}, textconfigure{}, and so on.
#     </ul>
#
#     Every data change command 
#     must return an _inverse_ command -- that is, a command that can be 
#     executed (in the scope of the model object) to undo the change.
#     Some commands may choose to return the null string if the command
#     failed.    
#     <b>Note</b>: Commands such as create{} cannot return a new 
#     identifier, since they must return an inverse command. This shifts
#     the onus onto the client to provide names for new graphical objects
#     (for example), but is not difficult (after all, that's what Tk
#     widgets require).
#    
# <li>Access commands: get{}, match{}, indexes{}.
#     All of these are abstract and must be 
#     overridden by subclasses. Most subclasses will also define a 
#     function called datacget{} or something similar, which can be used
#     to access configuration options of data.
#    
# <li>Persistence commands: load{}, describe{}, and  
#     write{}. load{} and write{} must never be overridden; 
#     describe{} usually is.
#    
# <li>Publish-subscribe commands: subscribe{}, unsubscribe{}, and publish{}.
#     None of these must ever be overridden (except in special
#     circumstances, such as the _Publisher_ and _WidgetPreferences_ 
#     classes).
#   
# <li>Undo-redo commands: record{}, undo{}, redo{}, markHistory{},
#     clearHistory{}, and 
#     compactHistory{}. These commands manipulate the undo history in various
#     ways. None of these must ever be overridden (except in special
#     circumstances, such as the _Publisher_ and _WidgetPreferences_ 
#     classes).
#
# <li>Protected methods: notify{}, and writeData{}. All 
#     of these do sensible things by default, although subclasses may
#     choose to override them to change behavior or for efficiency.
# </ul>
#
class ::tycho::Model {
    inherit ::tycho::Object

    constructor {args} {}
    destructor {}
    
    #################################################################
    ####                        options                          ####

    # The name of this data object
    public variable dataname ""

    # The file that this data is based on
    public variable datafile {}

    # The file used for storing this data
    public variable imagefile {}

    # The immutable file that this data is based on
    public variable sourcefile {}

    # A flag saying whether this model is persistent
    public variable persistent 0

    # A script to that changes the default notification mechanism
    public variable notifyscript {}

    #################################################################
    ####                     public methods                      ####

    # Clear the undo history
    method clearHistory {args}
    
    # Compact a portion of the undo history
    method compactHistory {from to publish {command {}} {inverse {}}}
    
    # Describe data matched by the given pattern
    method describe {pattern args}

    # Execute a list of data change commands
    method execute {commands}

    # Return some data given a symbolic index
    method get {index}

    # Return a list of indexes that match a pattern
    method indexes {pattern args}

    # Load data into the object
    method load {{description {}}}

    # Get or set a mark in the undo history
    method markHistory {{markname {}} {position current}}

    # Return a list of index-data pairs based on a pattern
    method match {pattern args}

    # Publish a change in data
    method publish {whoiam command index args}

    # Record a change in data
    method record {command index args}

    # Redo changes to the data
    method redo {{distance 1}}

    # Subscribe to data changes that match an index pattern
    method subscribe {whoiam pattern {whattodo {}}}

    # Undo changes to the data
    method undo {{distance 1}}

    # Unsubscribe from data changes
    method unsubscribe {whoiam {pattern {}}}

    # Write the data to a file
    method write {{file {}} {image {}}}

    #################################################################
    ####                  protected methods                      ####

    # Notify the subscribers of a change in data
    protected method notify {whoiam command pattern args}

    # Write data to a data file and image file.
    protected method writeData {fd id}

    #################################################################
    ####                  protected variables                    ####

    # The array of undo commands
    protected variable undoCommands

    # A flag marking this model as having been modified
    protected variable modified

    # The array of redo commands
    protected variable redoCommands

    # The array of flags indicating whether an undo/redo command was published
    protected variable publishable
    
    # The array of subscriptions. Each array index is an index pattern,
    # and each element is a flat subscriber-script list
    protected variable subscriptions
    
    # The marks in the redo/undo history
    protected variable historyMark
}


########################################################################
#### constructor
#
body ::tycho::Model::constructor {args} {
    # Initialize history marks
    set historyMark(current) 0
    set historyMark(first) 0
    set historyMark(last) 0
    set historyMark(opened) 0
    set historyMark(published) 0
    set historyMark(saved) 0

    # Initialize the first node of the history
    set undoCommands(0) "execute {}"
    set redoCommands(0) "execute {}"
    set publishable(0) 0

    # Evaluate options
    eval configure $args

    # If there is no dataname, supply a default
    if { $dataname == "" } {
	set dataname [::info namespace tail $this]
    }
}

########################################################################
#### destructor
#
body ::tycho::Model::destructor {} {
    # If the model is persistent and modified, save it
    # FIXME: Need to really work out the logic of persistence and
    # loading and writing.
    if { $persistent && $modified } {
	write
    }
}

########################################################################
#### clearHistory
#
# Clear the undo history. The first argument is the command to clear
# from, the second the one to clear to. The arguments can be omitted,
# in which case they default to "first" and "last." The commands in
# the history are deleted from the one _after_ the "from" mark up
# to _and including_ the "to" mark. (The "first" command is a null
# command, so you don't have to worry about that fact that you cannot
# actually delete it.)
#
# If the "from" mark is not earlier than the "to" mark, there will
# be no error generated, but no commands will be cleared either.
# If either mark does not exist, then an error will be generated.
# Any marks that point to a deleted command will be changed to point
# to the "from" mark. (Any marks that are above the "to" mark still
# point to  the same commands, although the actual index of that
# command will have changed.)
#
# The two indexes can also be raw integer indexes into the history,
# but this is intended for internal use only.
#
body ::tycho::Model::clearHistory {{from first} {to last}} {
    # Get the indexes corresponding to the marks
    if { ! [info exists historyMark($from)] } {
	error "Unknown mark $from in $dataname"
    }
    if { ! [info exists historyMark($to)] } {
	error "Unknown mark $to in $dataname"
    }
    if { ! [string match {[0-9]*} $from] } {
	set fromindex $historyMark($from)
    } else {
	set fromindex $from
    }
    if { ! [string match {[0-9]*} $to] } {
	set toindex $historyMark($to)
    } else {
	set toindex $to
    }

    # Do nothing if from is not earlier than to
    if { $fromindex >= $toindex } {
	return
    }

    # Clear the commands
    set i [expr $fromindex + 1]
    while { $i <= $toindex } {
	unset undoCommands($i)
	unset redoCommands($i)
	unset publishable($i)
	incr i
    }

    # Because the history indexes are contiguous, we have to shift
    # any commands above "to" down to fill in the gap left by the
    # deleted commands. (Note: i is already set to "to + 1")
    set delta [expr $toindex - $fromindex] 
    while { $i <= $historyMark(last) } {
	set undoCommands([expr $i - $delta]) $undoCommands($i)
	set redoCommands([expr $i - $delta]) $redoCommands($i)
	set publishable([expr $i - $delta]) $publishable($i)

	unset undoCommands($i)
	unset redoCommands($i)
	unset publishable($i)
	incr i
    }

    # If any marks got clobbered, set them to "from". Any marks
    # above "to" are shifted down the right amount.
    foreach {mark index} [array get historyMark] {
	if { $index > $fromindex || $index <= $toindex } {
	    set historyMark($mark) $fromindex
	} elseif { $index > $toindex } {
	    set historyMark($mark) [expr $index - $delta]
	}
    }
}

########################################################################
#### compactHistory
#
# Compact a portion of the undo history. The first two arguments are the 
# marks of the command to compact from and the command to compact to: commands
# from _the one after_ "from" up to _and including_ "to" are compacted
# into a single command. The third
# argument is a flag indicating whether the compacted command is to
# be marked as publishable: if it is, then an undo or redo of the 
# compacted command will be published. If the
# fourth and fifth arguments are supplied, they are the commands that
# replace the
# compacted commands; without these command, this method will construct
# composite commands based on the execute{} method.
#
# Any valid marks can be specified -- see clearHistory{} for
# more information. The "from" mark must be earlier than the
# "to" mark: an error will be flagged if it is not.
# If either mark does not exist, then an error will be generated.
#
body ::tycho::Model::compactHistory {from to publish {command {}} {inverse {}}} {
    # Get the indexes corresponding to the marks
    if { ! [info exists historyMark($from)] } {
	error "Unknown mark $from in $dataname"
    }
    if { ! [info exists historyMark($to)] } {
	error "Unknown mark $to in $dataname"
    }
    set fromindex $historyMark($from)
    set toindex   $historyMark($to)

    # Flag an error if from is not earlier than to
    if { $fromindex >= $toindex } {
	error "Cannot compact from $from ($fromindex) to $to (toindex) in $dataname"
    }
    
    # Build composite commands if not supplied
    if { $command == "" } {
	set command "execute \{\n"
	set inverse "execute \{\n"
	set i [expr $fromindex + 1]
	while { $i <= $toindex } {
	    append command "    " redoCommands($i) "\n"
	    append inverse "    " undoCommands($i) "\n"
	}
	append command "\}\n"
	append inverse "\}\n"
    }
    
    # Put the new command into the history
    set redoCommands($toindex) $command
    set undoCommands($toindex) $inverse
    set publishable($toindex) $publish

    # Clear the compacted commands
    clearHistory $from [expr $toindex - 1]
}

########################################################################
#### describe
#
# Return a "description" of the data with indexes that match the
# given pattern. By default, the indexes are matched using glob-style 
# matching. The form taken by the returned result varies; it is also
# supposed to be opaque to clients, so do not rely on it having any
# particular form! It is, however, guaranteed to be understood
# by the load{} method, so can be used to efficiently clone objects
# or create representations to be regenerated at some later time.
# Most subclasses will implement this
# method so that all data is returned given the pattern "*".
#
# Additional arguments may be supported by some subclasses to select
# the kind of pattern-matching (*-regexp*) or the contents of data
# returned (for example, whether or not to include the undo history
# in the result.)
#
# The default method given here generates a description of the undo
# history. Subclasses
# should override this method and then call it
# explicitly if they need to include the undo history in their output.
#
body ::tycho::Model::describe {pattern args} {
    set result "# The undo history of $dataname\n"
    append result "array set undoCommands [list [array get undoCommands]]\n"
    append result "array set redoCommands [list [array get redoCommands]]\n"
    append result "array set publishable  [list [array get publishable]]\n"
    append result "array set historyMark  [list [array get historyMark]]\n"

    return $result
}

########################################################################
#### execute
#
# Execute a list of commands and return the inverse command. This
# method simplifies merging of undo commands.
#
body ::tycho::Model::execute {commands} {
    set inverse [list execute]
    foreach cmd $commands {
	lappend inverse [eval $cmd]
    }
    return $inverse
}

########################################################################
#### get
#
# Get data at the specified index. What the index means is 
# entirely dependent on the specific subclass. Note that the index
# is not pattern-matched: use the match{} method for that.
#
# This method must be overridden by subclasses.
#
body ::tycho::Model::get {index} {
    abstractMethod get
}

########################################################################
#### load
#
# Load data into the object. If no argument is given, then the
# object loads itself using the most recent of the *-datafile*, *-sourcefile*,
# and *-imagefile* options. If an argument is given, then it loads that
# data. The form of the description varies, but all Model subclasses
# can be reproduced by loading the data returned by "describe *".
#
# Note that none of the *-datafile*, *-sourcefile*, or *-imagefile* options
# cause the data to be reloaded when they are changed: this must be done
# explicitly by a) deleting the data and b) calling this method.
# In all cases, a load _adds_ (or overwrites) data already in this
# class, so if a load is intended to give an object all of its data
# then must first be cleared (depending on the paricular subclass, this
# may require one or many calls to delete{}). (It would probably just
# be faster to delete the object and create a new one.)
#
body ::tycho::Model::load {{description {}}} {
    # If there's no description, get it from a file
    if { $description == "" } {
	# Remember this position
	set historyMark(opened) $historyMark(current)

	# Load the most recently-written file
	# FIXME: Figure out which file is newest	
	source $newestFile

    } else {
	eval [list $description]
    }
}

########################################################################
#### indexes
#
# Return a list of indexes, where each index matches the
# given pattern using glob-style matching. If no matches are found, an
# empty list will be returned. The exact form of the indexes depends
# on the subclass: if the subclass has discrete and exclusive indexes,
# then the returned indexes are simply the ones that match the pattern;
# if it has continuous or overlapping indexes, then it is up to the
# subclass to decide what to return.
#
# Some subclasses support the additional argument *-regexp* to select
# regular-expression matching instead of glob-style matching.
#
# This method must be overridden by subclasses.
#
body ::tycho::Model::indexes {pattern args} {
    abstractMethod indexes
}

########################################################################
#### markHistory
#
# Place a mark in the undo history. The first argument is the name of
# the mark to set. The second is the name of the mark to set it to;
# if omitted, it defaults to "current." The data classes 
# maintained the following marks, which can be the second argument to
# this method but not the first:
# <ul>
# <li>*current*: The most recent command executed.
# <li>*root*: The first command in the history.
# <li>*published*: The most recently published command.
# <li>*saved*: The last command before the last save to files.
# <li>*opened*: The last command before the file was last opened.
# </ul>
#
# (Note the policy with marking commands: the command marked is the
# last one executed to get to the state represented by the given
# mark. Thus, the "current" command is the most recently-executed
# one: to undo, execute the inverse of that command; to redo,
# re-execute the following command.)
#
# If _position_ is the empty string, clear the mark.
# An error is flagged if _position_ is not empty and not a mark
# in the history. <b>Note</b>: Do not assume that a value of zero
# is the position of the first command in the undo history. Note also that
# mark names are unique: you cannot have more than one mark of the same
# name.
#
# If no arguments at all are supplied, return a list containing the
# names of all marks.
#
# Marks are a powerful and general mechanism for manipulating the undo
# history. For example, if a client wishes to makes a series of
# incremental changes but have the undo mechanism treat all those
# changes as a single change, it can set a mark before the incremental
# changes, and either i) make sure that it calls undo{} and redo{}
# using the marks it has set, or ii) _compact_ the history since that
# mark into a single command (see the compactHistory{} method).
#
body ::tycho::Model::markHistory {{markname {}} {position current}} {
    # Return all mark names
    if { $markname == "" } {
	return [array names historyMark]
    }

    if { $position == "" } {
	# Delete a mark
	unset historyMark($markname)
    } else {
	if { ! [::info exists historyMark($position)] } {
	    error "Mark $position unknown in $dataname"
	}
	# Set a mark
	set historyMark($mark) $historyMark($position)
    }
}

########################################################################
#### match
#
# Return a flat list of index-value pairs, where each index matches the
# given pattern using glob-style matching. If no matches are found, an
# empty list will be returned. Most subclasses will implement this
# method so that all data is returned given the pattern "*".
#
# Additional arguments may be supported by some subclasses to select
# the kind of pattern-matching (*-regexp*) or the format of returned
# data (for example, return a list of index-(value-option) pairs instead
# of index-value-option triples).
#
# This method must be overridden by subclasses.
#
body ::tycho::Model::match {pattern args} {
    abstractMethod match
}

########################################################################
#### publish
#
# Publish data. This is the same as recording it, except that 
# the change is forwarded to any subscribers (via their own
# publish{} method) that have subscribed to the given index
# (or, in some subclasses, an overlapping index).
#
body ::tycho::Model::publish {whoiam command index args} {
    # Record the command
    eval [list record $command $index] $args

    # Mark command as publishable
    set publishable($historyMark(current)) 1

    # Remember where it happened
    set historyMark(published) $historyMark(current)

    # Notify subscribers.
    eval [list notify $whoiam $command $index] $args
}

########################################################################
#### record
#
# Execute a command on this data object and record the command and
# its inverse for undoing.
#
body ::tycho::Model::record {command index args} {
    # Clear the redo future if needed
    if { $historyMark(current) < $historyMark(last) } {
	clearHistory current last
    }

    # Record the command
    incr historyMark(current)
    incr historyMark(last)
    set redoCommands($historyMark(current)) \
	    [concat [list $command $index] $args]
    set publishable($historyMark(current)) 0

    # Execute the command and record its inverse
    set undoCommands($historyMark(current)) \
	    [eval $this $command [list $index] $args]
    # Mark command as not publishable
    set publishable($historyMark(current)) 0

    # Mark model as modified
    set modified 1

puts [array get undoCommands]
}

########################################################################
#### redo
#
# Redo a data change. If an argument is given and it is an integer,
# redo that many steps, or until the end of the redo future is reached.
# If not an integer, the argument must be a mark, and commands are redone
# up to _and including_ the marked command. Flag an error if the mark
# does not exist. If the mark is not later than the current position,
# then do nothing. 
#
# As each command is redone, the change is published if the original
# command was published. 
#
# Return the number of steps redone.
#
body ::tycho::Model::redo {{distance 1}} {
    # If a mark is given, figure out the distance
    if { ! [string match {[0-9]*} $distance] } {
	# Check that the mark exists
	if { ! [::info exists historyMark($distance)] } {
	    error "Unknown mark $distance in $dataname"
	}
	set distance [expr $historyMark($distance) - $historyMark($current)]
    }
puts "$historyMark(last) - $historyMark(current)"
    # Go forward only as far as the last command
    if { $distance > $historyMark(last) - $historyMark(current) } {
	set distance [expr $historyMark(last) - $historyMark(current)]
    }

    # Mark model as modified
    set modified 1

    # Redo the commands
    set count 0
    while { $count < $distance } {
	# Adjust indexes
	incr historyMark(current)
	incr count

	# Execute the command
	eval $this $redoCommands($historyMark(current))

	# Publish if publishable
	if { $publishable($historyMark(current)) } {
	    eval notify noone $redoCommands($historyMark(current))
	}
    }
    return $count
}

########################################################################
#### subscribe
#
# Subscribe to data that matches an index pattern. The first argument
# is the name of the subscriber; the second is a pattern to match against
# the symbolic index of changed data to determine whether to notify
# this subscriber. By default, when data is published, the
# subscriber's publish{} method is called with the data change
# command (add, replace, dataconfigure, or delete) and its arguments
# as arguments. If the third argument is supplied, it is applied
# (at the global context) to four arguments: the subscriber, the
# command name, the index, and the remaining arguments. 
#
# Note that the index is
# not necessarily the same as the index used when the data is 
# subscribed to: for example, a subscriber could subscribe to
# all the data in a text data object, but would be notified
# on every character insertion. See the notify{} method for
# a description of the matching process.
#
# To subscribe to all changes, simply use the pattern "*".
#
body ::tycho::Model::subscribe {whoiam pattern {whattodo {}}} {
    lappend subscriptions($pattern) $whoiam $whattodo
}

########################################################################
#### undo
#
# Undo a data change. If an argument is given and it is an integer,
# undo that many steps, or until the start of the undo history. If not
# an integer, the argument must be a mark, and commands are undone
# back to _but not including_ the marked command. If the mark is not earlier
# in the history than the current position, do nothing. If the mark
# does not exist, flag an error. 
#
# As each command is undone, the change is published if the original
# command was published. 
#
# Return the number of steps undone.
#
body ::tycho::Model::undo {{distance 1}} {
    # If a mark is given, figure out the distance
    if { ! [string match {[0-9]*} $distance] } {
	# Check that the mark exists
	if { ! [::info exists historyMark($distance)] } {
	    error "Unknown mark $distance in $dataname"
	}
	set distance [expr $historyMark($current) - $historyMark($distance)]
    }

    # Go back only as far as the first command (but don't actually
    # execute the first command, since it is a null command)
    if { $distance > $historyMark(current) - $historyMark(first) } {
	set distance [expr $historyMark(current) - $historyMark(first)]
    }
puts "distance = $distance"
    # Mark model as modified
    set modified 1

    # Undo the commands
    set count 0
    while { $count < $distance } {
puts [array get undoCommands]
	# Execute the command
	eval $this $undoCommands($historyMark(current))

	# Publish if publishable
	if { $publishable($historyMark(current)) } {
	    eval notify noone $undoCommands($historyMark(current))
	}

	# Adjust indexes
	incr historyMark(current) -1
	incr count
    }
    return $count
}

########################################################################
#### unsubscribe
#
# Unsubscribe from data at a given index. The subscriber is 
# removed from the subscription list for that index. Note that 
# the index must exactly match an index given to
# the subscribe{} method: it cannot be used to implement
# an exclusion mechanism (one cannot, for example, say "I have
# already subscribed to all character insertions, and I want
# to unsubscribe from all insertions of carriage returns").
#
# If the _pattern_ argument is not supplied, the subscriber is
# unsubscribed from all patterns it has subscribed to. (Note:
# this operation is slow.)
#
body ::tycho::Model::unsubscribe {whoiam {pattern {}}} {
    if { $pattern != "" } {
	# Unsubscribe from a given pattern
	array set temp $subscriptions($pattern)
	unset temp($whoiam)
	set subscriptions($pattern) [array get temp]
    } else {
	# Unsubscribe from all patterns
	foreach pattern [array names subscriptions] {
	    array set temp $subscriptions($pattern)
	    unset temp($whoiam)
	    set subscriptions($pattern) [array get temp]
	}
    }
}

########################################################################
#### write
#
# Write the data to a file. With no arguments given, this method
# writes to both files given by the *-datafile* and *-imagefile* options.
# If either option is not given, then that option is ignored.
# If the file does not exist, then this method attempts to create
# it. If it cannot create the file given by *-datafile*, it flags an 
# error; if it cannot create the file given by *-imagefile*, it 
# proceeds silently.
#
# The file given by *-datafile* is written in a "user-editable" form:
# depending on the particular subclass, it may be just plain text,
# or it may be a series of method calls that reconstruct the 
# data. The file given by the *-imagefile* option contains information
# in whatever form the particular subclass finds useful, and
# may include code that "clones" the data object quickly, as 
# well as the undo/redo history of that data. Subscription
# information is _not_ written to the image file.
#
# If the _file_ or _image_ arguments are given, they are used
# instead of the *-datafile* and *-imagefile* options.
#
# <i>Do not override this method: override writeData{} instead.</i>
#
body ::tycho::Model::write {{file {}} {image {}}} {
    # Remember this position
    set historyMark(saved) $historyMark(current)
    
    # Get the right files
    if { $file == "" } {
	set file $datafile
    }
    if { $image == "" } {
	set image $imagefile
    }
    
    # Open files
    # FIXME: Check that the file can be opened for writing
    set id [open $image "w"]
    set fd [open $file "w"]

    # Write signature to the image file
    puts $id "# This is a Tycho image file for $dataname\n"
    
    # Write data specific to the subclass
    writeData $fd $id
    
    # Close the files
    close $fd
    close $id
    
    # Clear modified flag
    set modified 0
}


########################################################################
########################################################################
####                     protected methods

########################################################################
#### notify
#
# Notify subscribers except _whoiam_ with the given change in data.
# Matching is done using glob-style pattern-matching. The
# default notification method is very direct: if _index_ matches an
# index pattern to which the subscriber is subscribed, the given command
# is called directly in the subscriber. This behavior can be changed by
# setting the *-notifyscript* option, which must be a function-script
# that can be applied to four arguments: the subscriber, the command name,
# the index, and a list of remaining arguments. Individual subscribers
# may themselves choose a different otification mechanism when they
# subscribe by providing the *whattodo* argument to subscribe{}.
#
# Although subscribers are supposed to
# unsubscribe themselves before dying, this doesn't always happen
# (especially when debugging!). So this method checks that the subscriber
# still exists, and if it doesn't, prints an error message to the console
# and unsubscribes the offending subscriber.
# Obviously, this is not something you want to happen very often:
# if messages are being printed then there is a bug in the client
# code which should be fixed (instead of complaining about the
# Model object printing to the console).
#
body ::tycho::Model::notify {whoiam command index args} {
    # Scan for subscribers with a pattern that matches the index
    foreach pattern [array names subscriptions] {
	if { ! [string match $pattern $index] } {
	    continue
	}
	foreach {subscriber script} $subscriptions($pattern) {
	    # Don't notify the caller
	    if { $subscriber == $whoiam } {
		continue
	    }
	    # Unsubscribe if the subscriber no longer exists!
	    if { [::info which -command $subscriber] == "" } {
		puts "Error: subscriber $subscriber to $dataname no longer exists"
		unsubscribe $subscriber
		continue
	    }
	    if { $script != "" } {
		# if there's a script supplied by the subscriber, apply it
		uplevel #0 apply [list $script $subscriber $command $index] $args
	    } elseif { $notifyscript != "" } {
		# Or if there's a global script, apply that
		uplevel #0 apply [list $notifyscript $subscriber $command $index] $args
	    } else {
		# By default, call the subscriber directly
		uplevel #0 $subscriber $command [list $index] $args
	    }
	}
    }
}

########################################################################
#### writeData
#
# Write data to a data file and an image file. The two arguments
# are the file descriptors of the open data and image files respectively.
# Either of the file descriptors may be null, but not both.
#
# This default method will be adequate for many subclasses: it uses
# <pre>match * -alloptions</pre> to get the data to write
# to the data file, and <pre>describe *</pre> to get the description
# to write to the image file. Subclasses should overwrite this method if
# this generates inappropriate data or if the data is likely to be
# large, in which case overriding this method to directly write
# to the file rather than generating huge strings which are then
# written to the file is likely to be more efficient.
#
body ::tycho::Model::writeData {fd id} {
    if { $fd != "" } {
	puts $fd [match * -alloptions]
    }
    if { $id != "" } {
	puts $id [describe *]
    }
}
