#
# Widgettree
# ----------------------------------------------------------------------
# Widgettree implements an unfolding tree of widgets, with a button at each
# node to open and close the node. The widget is designed for
# implementing unfolding preference and dialog boxes as well as
# viewers of tree-like structures.
#
## WISH LIST:
#   This section lists possible future enhancements.  
#
#   1) Generally the Widgettree should be used together with
#      a Scrolledframe widget. It would be nice if the widget
#      would adjust itself in the scrolled frame so that when
#      a node of the tree is opened, it scrolls so that it
#      is entirely visible in the window. What we need is
#      a see{} command.
#   2) Same deal as above: the tree must adjust itself in the scrolled
#      frame to make the button with the focus visible.
#
## BUGS:
#   This section lists known bugs:
#
#   1) There are some bad artifacts when opening and closing nodes if
#      the scroll bars are present. These must be fixed.
#   2) Something is wrong with the way that options work...
#   3) The locate{} method is broken.
#
# ----------------------------------------------------------------------
#  AUTHOR: H. John Reekie              EMAIL: johnr@eecs.berkeley.edu
#
#  Inspired by the SubPanel and MultiPanel widgets written by
#  Farhana Sheikh and Cliff Cordeiro of UC Berkeley. Widgettree
#  is contributed to [incr Widgets] by the Tycho project at UC
#  Berkeley: http://ptolemy.eecs.berkeley.edu/tycho.
#
#  $Id$
# ----------------------------------------------------------------------
#
# Copyright (c) 1997 The Regents of the University of California.
# All rights reserved.
# 
# Permission is hereby granted, without written agreement and without
# license or royalty fees, to use, copy, modify, and distribute this
# software and its documentation for any purpose, provided that the
# above copyright notice and the following two paragraphs appear in all
# copies of this software.
# 
# IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY
# FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
# ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF
# THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.
# 
# THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE
# PROVIDED HEREUNDER IS ON AN "AS IS" BASIS, AND THE UNIVERSITY OF
# CALIFORNIA HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,
# ENHANCEMENTS, OR MODIFICATIONS.
# 
# 						PT_COPYRIGHT_VERSION_2
# 						COPYRIGHTENDKEY
#######################################################################

#
# Usual options.
#
itk::usual Widgettree {
    keep -disabledforeground -highlightthickness -borderwidth \
	    -font -highlightcolor -background \
	    -foreground -activebackground -cursor -activeforeground
}

# ------------------------------------------------------------------
##                            WIDGETTREE
# ------------------------------------------------------------------
#
# Widgettree implements an unfolding tree of widgets, with a button at
# each node to open and close the node. The widget is designed for
# implementing unfolding preference and dialog boxes as well as
# viewers of tree-like structures. Each item in the tree is referenced
# by a tag, which is constructed in the same manner as hierarchical
# Tk widget names, but without the leading period. Widgets can be added
# to the tree either when the Widgettree is created or as each node
# is opened. Default bindings provides traversal through the tree using
# the cursor and return keys.
#
class iwidgets::Widgettree { 
    inherit itk::Widget

    constructor {args} {}
    destructor {}

    public variable closedbitmap @arrowclose.xbm
    public variable openedbitmap @arrowopen.xbm
    public variable closecommand ""
    public variable createcommand ""
    public variable opencommand ""
    public variable indent 24

    itk_option define -padx padX PadX 0
    itk_option define -pady padY PadY 0
    itk_option define -traversal traversal Traversal 1

    itk_option define -activebackground activeBackground Foreground "#ececec"
    itk_option define -activeborderwidth activeBorderWidth BorderWidth 2 
    itk_option define -activeforeground activeForeground Background black
    itk_option define \
	    -disabledforeground disabledForeground DisabledForeground #a3a3a3 
    itk_option define \
	    -font font Font "-Adobe-Helvetica-Bold-R-Normal--*-120-*-*-*-*-*-*"
    itk_option define -foreground foreground Foreground Black

    public method add      {type tag args}
    public method close    {tag}
    public method delete   {tag}
    public method hide     {tag}
    public method itemcget {tag option}
    public method itemconfigure {tag {option {}} args}
    public method load     {tag contents {level 1}}
    public method locate   {x y {tag {}}}
    public method names    {{tag {}}}
    public method open     {tag}
    public method options  {type {optioncmds _}}
    public method traverse {mode {tag {}}}
    public method type     {tag}

    private method _mkNodeFrame {tag}  ;# Make the containing frame

    private variable _options   ;# Option commands for each _type_
    private variable _children  ;# Children of each node
    private variable _type      ;# Type of each widget, or "node"
    private variable _tag       ;# Mapping from widget path to tag
    private variable _row       ;# Grid row of each item
    private variable _state     ;# State of each node: "open" or "closed"
    private variable _nextrow   ;# The next available row in each node

    method debug {args} {
        eval $args
    }
}

#
# Use option database to override default resources.
#
# option add *Widgettree.thickness 3 widgetDefault ???

#
# Provide a lowercase access method for the Widgettree class
#
proc ::iwidgets::widgettree { args } {
    uplevel ::iwidgets::Widgettree $args
}

# ------------------------------------------------------------------
##                        CONSTRUCTOR
# ------------------------------------------------------------------
body iwidgets::Widgettree::constructor {args} {
    # The counter for top-level items
    set _nextrow() 0

    # Set the grid column options for the top level frame
    grid columnconfigure $itk_interior 0 -minsize $indent -weight 0
    grid columnconfigure $itk_interior 1 -weight 1

    # Add borderwidth and relief options
    itk_option add hull.borderwidth hull.relief

    # Configure options
    eval itk_initialize $args
}

# ------------------------------------------------------------------
##                             OPTIONS
# ------------------------------------------------------------------

# ----------------------------------------------------------------------
## OPTION -closedbitmap
#
# The bitmap to display in the open/close button of
# closed tree nodes. The bitmap may be specified in any of the
# forms accepted by Tk_GetPixmap.
# ----------------------------------------------------------------------
configbody iwidgets::Widgettree::closedbitmap {
    foreach tag [array names _state] {
        if { $_state($tag) == "closed" } {
            $itk_component(${tag}button) configure -bitmap $closedbitmap
        }
    }
}

# ----------------------------------------------------------------------
## OPTION -closecommand
#
# The command to execute when a node of the tree is closed.
# If this command is null, clicking on the open-close button will
# close the node; if not, the node tag is appended
# to the command and the command is executed at the global scope,
# and the node will not close automatically.
# ----------------------------------------------------------------------
configbody iwidgets::Widgettree::closecommand {
}

# ----------------------------------------------------------------------
## OPTION -createcommand
#
# The command to execute when a node of the tree is opened
# if the node does not currently contain any widgets. The node tag is appended
# to the command and the command is executed at the global scope.
# The command should use the <b>add</b> method to create the contents of
# the node. If the command is null, the node is opened but
# nothing will be displayed.
# ----------------------------------------------------------------------
configbody iwidgets::Widgettree::createcommand {
}

# ----------------------------------------------------------------------
## OPTION -indent
#
# The minimum indent for each level of the tree. This
# option is needed in order that each level is indented correctly,
# regardless of the presence or not of open-close buttons at
# each level. It sets the minimum indent, not the actual indent:
# if either <b>-closedbitmap</b> or <b>-openedbitmap</b> makes an
# open-close button wider than the specified indent, that width
# will be used instead. (There is no reasonable way to avoid this,
# since that's how Tk's grid manager works.) The default value is
# 24 pixels.
# ----------------------------------------------------------------------
configbody iwidgets::Widgettree::indent {
    grid columnconfigure $itk_interior 0 -minsize $indent
    foreach tag [array names _state] {
	if [::info exists itk_component($tag)] {
	    grid columnconfigure $itk_component($tag) 0 -minsize $indent
	}
    }
}

# ----------------------------------------------------------------------
## OPTION -openbitmap
#
# The bitmap to display in the open/close button of
# open tree nodes. The bitmap may be specified in any of the
# forms accepted by Tk_GetPixmap.
# ----------------------------------------------------------------------
configbody iwidgets::Widgettree::openedbitmap {
    foreach tag [array names _state] {
        if { $_state($tag) == "open" } {
            $itk_component(${tag}button) configure -bitmap $openedbitmap
        }
    }
}

# ----------------------------------------------------------------------
## OPTION -opencommand
#
# The command to execute when a node of the tree is opened
# and the node already has children. The node tag is appended
# to the command and the command is executed at the global scope.
# The node is opened after the command returns.
# ----------------------------------------------------------------------
configbody iwidgets::Widgettree::opencommand {
}

# ----------------------------------------------------------------------
## OPTION -padx
#
# The padding to use when packing widgets. Widgets are packed
# with the <b>-padx</b> option to the Tk grid command set to this value.
# To override this value for individual widgets, call <b>grid</b> directly
# with the component widget. For example:
# # <pre>
#   grid configure [$widgettree component size] -padx 4
# </pre>
# Note that changing this option will return _all_ widgets
# to this padding value, even if the padding has explicitly been
# overridden as just described. 
# ----------------------------------------------------------------------
configbody iwidgets::Widgettree::padx {
    foreach tag [array names _state] {
	if [::info exists itk_component($tag)] {
	    grid configure $itk_component($tag) \
		    -padx $itk_option(-padx)
	}
    }
}

# ----------------------------------------------------------------------
## OPTION -pady
#
# The padding to use when packing widgets. Widgets are packed
# with the <b>-pady</b> option to the Tk grid command set to this value.
# To override this value for individual widgets, call <b>grid</b> directly
# with the component widget. For example:
# # <pre>
#   grid configure [$widgettree component size] -pady 4
# </pre>
# Note that changing this option will return _all_ widgets
# to this padding value, even if the padding has explicitly been
# overridden as just described. 
# ----------------------------------------------------------------------
configbody iwidgets::Widgettree::pady {
    foreach tag [array names _state] {
	if [::info exists itk_component($tag)] {
	    grid configure $itk_component($tag) \
		    -pady $itk_option(-pady)
	}
    }
}

# ----------------------------------------------------------------------
## OPTION -traversal
#
# Specify whether or not to support Tab and cursor traversal through
# the tree. If true, the tab and cursor keys can be used to
# navigate through the tree (see <i>Tree Traversal</i>. The
# default is true. Note that this option is not called <b>-takefocus</b>
# because that allows the focus to go to the hull, which we don't want.
# ----------------------------------------------------------------------
configbody iwidgets::Widgettree::traversal {
    if !$itk_option(-traversal) {
        # If this widget had the focus, remove it
        if [string match $itk_component(hull)* \
                [focus -lastfor $itk_component(hull)]] {
            focus [winfo toplevel $itk_component(hull)]
        }
    }
}

# ------------------------------------------------------------------
##                            METHODS
# ------------------------------------------------------------------


# ------------------------------------------------------------------
## METHOD: _mkNodeFrame tag
#
# Create the frame for an individual node. This method is called the
# first time an item is added to a node, not when the node itself
# is created. This strategy reduces the time to create each node
# of the tree.
# ------------------------------------------------------------------    
body iwidgets::Widgettree::_mkNodeFrame {tag} {
    # Create the frame
    itk_component add $tag {
	frame $itk_interior.$tag
    }
    # Remember the reverse mapping
    set _tag($itk_interior.$tag) $tag

    # If the node is open, display its contents
    if { $_state($tag) == "open" } {
	grid $itk_interior.$tag \
		-row [expr $_row($tag)+1] \
		-column 1 \
		-sticky nw
    }
    # Configure internal column size and weight
    grid columnconfigure $itk_interior.$tag 0 -minsize $indent -weight 0
    grid columnconfigure $itk_interior.$tag 1 -weight 1
}

# ------------------------------------------------------------------
## METHOD: add type tag ?option value...?
#
# Add a new widget to the tree. The first argument is the widget type,
# and the second is a tag to give it. Raise an error if an item with
# _tag_ already exists. Tags are hierarchical, as in *foo.bar*. The
# special type <b>node</b> is used to create a new node, in which case
# options are passed directly to the constructor of the node label, which
# is a Tk label.
#
# Any other value of _type_ is assumed to be the type of the widget to
# create. The optional arguments comprise an option-value list which can
# contain any valid options for _type_. The return value is the tag.
# ------------------------------------------------------------------    
body iwidgets::Widgettree::add {type tag args} {
    if [::info exists _type($tag)] {
	error "Item $tag already exists"
    }
    # Decompose the tag
    regexp {^((([^\.]+)?.*)?\.)?[^\.]+$} $tag _ _ parent

    # If this is a hierarchical tag, check that the parent is a
    # node. If the containing frame does not exist, create it.
    if { $parent != "" } {
	if ![::info exists _type($parent)] {
	    error "Unknown parent item: $parent"
	}
	if { $_type($parent) != "node" } {
	    error "Item $parent is not a node"
	}
	if ![::info exists itk_component($parent)] {
	    _mkNodeFrame $parent
	}
    }
    # Process according to type
    if { $type == "node" } {
	# Create the open/close button. Let it take the focus.
	itk_component add ${tag}button {
	    button $itk_interior.${tag}button \
		    -command "$this open $tag; $this traverse to $tag" \
		    -borderwidth 1 \
		    -bitmap $closedbitmap
	} {
            rename -takefocus -traversal traversal Traversal
        }
	grid $itk_component(${tag}button) \
		-row $_nextrow($parent) \
		-column 0 \
		-sticky nw

        # Create bindings for traversal and open-close
        bind $itk_component(${tag}button) <Key> "$this traverse %K %W"

	# Create the accompanying label
	itk_component add ${tag}label {
	    eval label $itk_interior.${tag}label -takefocus 0 $args
	}
	grid $itk_component(${tag}label) \
		-row $_nextrow($parent) \
		-column 1 \
		-sticky nw
	
	# Remember the parameters of this node
	set _tag($itk_component(${tag}label)) $tag
        set _children($tag) {}
	set _nextrow($tag) 0
	set _row($tag) $_nextrow($parent)
	set _state($tag) closed
	set _type($tag) node

        lappend _children($parent) $tag

	# Update the row counter. Increment it by two so that when the
	# button is opened, the new widget can be placed in the intervening row
	incr _nextrow($parent) 2

    } else {
	# Extract options
        if [::info exists _options($type)] {
            set options $_options($type)
        } else {
            set options "\nusual\n"
        }
	# Create the widget
	itk_component add $tag {
	    eval $type $itk_interior.$tag $args
	} $options    ;# indenting \}

	# Grid it
	grid $itk_component($tag) \
		-row $_nextrow($parent) \
		-column 1 \
		-padx $itk_option(-padx) \
		-pady $itk_option(-pady) \
		-sticky nw
	    
	# Remember the parameters of this item
	set _tag($itk_component($tag)) $tag
	set _row($tag) $_nextrow($parent)
	set _type($tag) $type
	
	# Update the row counter
	incr _nextrow($parent)
    }
    return $tag
}

# ------------------------------------------------------------------
## METHOD: close tag
#
# Close a node of the tree. If the node is already closed, this
# method does nothing. If the <b>-closecommand</b> option is
# not null, append the tag and evaluate the command in the global
# scope. In this case, the node is not closed -- the close command must
# explicitly close it with the <b>hide</b> method. If the
# <b>-closecommand</b> option is null, the node is just closed. 
# Raise an error if the node does not exist or if _tag_ is a leaf.
# ------------------------------------------------------------------
body iwidgets::Widgettree::close {tag} {
    if ![::info exists _type($tag)] {
	error "Unknown item: $tag"
    }
    if { $_type($tag) != "node" } {
	error "Item $tag is not a node"
    }
    if { $_state($tag) == "closed" } {
	return
    }

    set _state($tag) closed
    if { $closecommand != "" } {
	# If there's a command, execute it
	uplevel #0 $closecommand $tag
    } else {
	# Otherwise just close the node
	hide $tag
    }
}

# ------------------------------------------------------------------
## METHOD: delete tag
#
# Delete an item from the tree. If the item is a node, then all
# descendents are deleted too. Raise an error if the item
# does not exist. Note that the grid rows occupied by the item
# are not reclaimed, but this should not be visible.
# ------------------------------------------------------------------
body iwidgets::Widgettree::delete {tag} {
    if ![::info exists _type($tag)] {
	error "Unknown item: $tag"
    }
    # Decompose the tag
    regexp {^((([^\.]+)?.*)?\.)?[^\.]+$} $tag _ _ parent

    # Get the items to delete. If a node, get all descendents in
    # bottom-up order, otherwise just the tag.
    if { $_type($tag) == "node" } {
	set items [lsort -decreasing [array names _type $tag.]]
	lappend items $tag
    } else {
	set items $tag
    }
    # Delete each item
    foreach tag $items {
	if { $_type($tag) == "node" } {
	    destroy $itk_component(${tag}button)   ;# button
	    destroy $itk_component(${tag}label)    ;# label
	    destroy $itk_component($tag)           ;# frame

	    unset _tag($itk_component(${tag}label))
	    unset _tag($itk_component($tag))

	    unset itk_component(${tag}button)
	    unset itk_component(${tag}label)
	    unset itk_component($tag)

	    unset _type($tag)
	    unset _state($tag)
	    unset _row($tag)
	    unset _children($tag)

	} else {
	    # Bogosity needed because we can't tell if this is
	    # a Tk widget or a mega-widget... I think...
	    if [catch {destroy $itk_component($tag)}] {
		delete object $itk_component($tag)
	    }
	    unset _tag($itk_component($tag))
	    unset itk_component($tag)
	    unset _type($tag)
	    unset _row($tag)
	}
    }
    # Remove from parent list
    set t [lsearch -exact $_children($parent) $tag]
    set _children($parent) [lreplace $_children($parent) $t $t]
}

# ------------------------------------------------------------------
## METHOD: hide tag
#
# Unconditionally close a node of the tree, without checking
# the <b>-closecommand</b> option. If the node is already closed,
# this method does nothing. Raise an error if the node does
# not exist or if _tag_ is a leaf.
# ------------------------------------------------------------------
body iwidgets::Widgettree::hide {tag} {
    if ![::info exists _type($tag)] {
	error "Unknown item: $tag"
    }
    if { $_type($tag) != "node" } {
	error "Item $tag is not a node"
    } 
    if { $_state($tag) != "closed" } {
	return
    } 
    # Hide the widget, making sure it exists first
    if [::info exists itk_component($tag)] {
	grid remove $itk_component($tag)
    }
    # Change the button
    $itk_component(${tag}button) configure \
	    -bitmap $closedbitmap \
	    -command "$this open $tag; $this traverse to $tag"

    # Update state
    set _state($tag) closed
}

# ------------------------------------------------------------------
## METHOD: itemcget tag option
#
# Return a configuration option of an item. Raise an error if
# the item does not exist or if the option is invalid. Legal
# options are exactly those described for the <b>add</b> method.
# ------------------------------------------------------------------
body iwidgets::Widgettree::itemcget {tag option} {
    if ![::info exists _type($tag)] {
	error "Unknown item: $tag"
    }
    if { $_type($tag) == "node" } {
	$itk_component(${tag}label) cget $option
    } else {
	$itk_component($tag) cget $option
    }
}

# ------------------------------------------------------------------
## METHOD: itemconfigure tag ?option value ...? 
#
# Configure options of an item. If only _tag_ is supplied, return
# the list of options of that item. If _option_ is supplied,
# return that option. If additional arguments are supplied,
# configure each option with the given value. Raise an error
# if the item does not exist or an invalid option is supplied. Legal
# options are exactly those described for the <b>add</b> method.
# ------------------------------------------------------------------
body iwidgets::Widgettree::itemconfigure {tag {option {}} args} {
    if ![::info exists _type($tag)] {
	error "Unknown item: $tag"
    }
    if { $_type($tag) == "node" } {
	eval $itk_component(${tag}label) $option $args
    } else {
	eval $itk_component($tag) $option $args
    }
}

# ------------------------------------------------------------------
## METHOD: locate x y ?tag?
#
# Return the tag of the item at the given _x_ and _y_ coordinates.
# If the _tag_ argument is given, it must be a node, and the _x_ and
# _y_ coordinates are relative to the interior of that node. If _x_
# is negative, then the _x_ coordinate is ignored in figuring out
# which item is under the mouse. If _x_ is non-negative, then a tag
# is returned only if the mouse is actually over an item.
# ------------------------------------------------------------------
body iwidgets::Widgettree::locate {x y {tag {}}} {
    if { $tag == "" } {
	set master $itk_interior
    } else {
	if ![::info exists itk_component($tag)] {
	    error "Unknown item: $tag"
	}
	set master $itk_component($tag)
    }
    if { $x < 0 } {
	# Get the row in this widget
	foreach {_ row} [grid location $master 0 $y] {}
    } else {
	# Get the column and row in this widget
	foreach {col row} [grid location $master $x $y] {}
	
	# If in column zero, we didn't hit anything
	if { $col == 0 } {
	    return ""
	}
    }
    # Scan the slave widgets in column 1. If a widget is found
    # in this row, return it. If a child widget is found instead,
    # do a recursive call to find the tag in the child.
    foreach slave [grid slave $master -column 1] {
	set tag $_tag($slave)
	if { $_row($tag) == $row } {
	    return $tag
	} elseif { $_row($tag) + 1 == $row } {
	    return [locate \
		    [expr $x - [winfo x $slave]] \
		    [expr $y - [winfo y $slave]] \
		    $tag]
	} else {
	    error "Uh-oh: something's gone wrong..."
	}
    }
}

# ------------------------------------------------------------------
## METHOD: names ?tag?
#
# Return the tags of items at a given level of the tree. If the
# _tag_ argument is not supplied, return the list of items at
# the top level of the tree. If _tag_ is supplied, it must be a node
# or an error is raised. The result in this case will be a list
# of children of that item.
# ------------------------------------------------------------------
body iwidgets::Widgettree::names {{tag {}}} {
    if { $tag != "" } {
        if ![::info exists _type($tag)] {
            error "Unknown item: \"$tag\""
        } elseif ![::info exists _children($tag)] {
            error "Item \"$tag\" is not a node"
        }
    }
    return $_children($tag)
}

# ------------------------------------------------------------------
## METHOD: open tag
#
# Open a node of the tree. If the node is already open, do nothing. If the
# node has no children and <b>-createcommand</b> is not null,
# append the tag and evaluate at the global scope. If the node has
# children and <b>-opencommand</b> is not null, append the tag and
# evaluate at the global scope. Raise an error if the node does not exist
# or if _tag_ is not a node.
# ------------------------------------------------------------------
body iwidgets::Widgettree::open {tag} {
    if ![::info exists _type($tag)] {
	error "Unknown item: $tag"
    }
    if { $_type($tag) != "node" } {
	error "Item $tag is not a node"
    }
    if { $_state($tag) == "open" } {
	return
    }

    # Set the state so that callbacks make new items display
    set _state($tag) open

    # If the containing frame doesn't exist, execute -createcommand.
    if ![::info exists itk_component($tag)] {
	if { $createcommand != "" } {
	    uplevel #0 $createcommand $tag
	}
    } else {
	# If it does exist, call -opencommand and then grid it
	if { $opencommand != "" } {
	    uplevel #0 $opencommand $tag
	}
	grid $itk_component($tag)
    }
    # Configure the button
    $itk_component(${tag}button) configure \
	    -bitmap $openedbitmap \
	    -command "$this close $tag; $this traverse to $tag"
}

# ------------------------------------------------------------------
## METHOD: options type optioncmds
#
# Query or specify option commands for a type that can be passed to
# <b>add</b>. By default, an added widget's options are integrated
# into the option list with the <b>usual</b> option handling
# mechanism. This method can be used to override the default behavior.
# The _type_ is a widget type, and _optioncmds_ is a list of option
# commands in the same format as the second argument to the 
# *itk_component add*. If _optioncmds_ is not
# supplied, return the option commands for the specified _type_.
# ------------------------------------------------------------------
body iwidgets::Widgettree::options {type {optioncmds _}} {
    if { $optioncmds == "_" } {
        if [::info exists _options($type)] {
            return $_options($type)
        } else {
            return {
                usual
            }
        }
    } else {
        set _options($type) $optioncmds
    }
}

# ------------------------------------------------------------------
## METHOD: traverse mode ?tag?
#
# Traverse the tree. This method is provided because Tk's default
# Tab traversal doesn't give the user enough control over where
# the traversal goes. The _mode_ controls the traversal operation,
# while the _tag_ is the tag of the button that currently has the
# focus. If _tag_ is null or not supplied, then no button has the
# focus. To aid construction of call-backs, the _tag_ can either be
# a tag or a widget path. _mode_ is case-insensitive, and can be one
# of <b>down</b>, <b>return</b>, <b>up</b>, <b>left</b>, or <b>right</b>,
# with the effect described for the default bindings. It can also
# be <b>to</b>, which moves the focus to the given node.
# If the <b>-traversal</b> option is false, the method returns
# without doing anything.
# ------------------------------------------------------------------
body iwidgets::Widgettree::traverse {mode {tag {}}} {
    if !$itk_option(-traversal) {
        return
    }
    set mode [string tolower $mode]
    set new {}
    # If no button has the focus, give it somewhere
    if { $tag == "" } {
        if { $mode == "up" } {
            set new [lindex [names] end]
        } elseif [regexp {^(down|left|right)$} $mode] {
            set new [lindex [names] 0]
        }
    } else {
        if { [regexp {(.+)button$} $tag _ t] \
                && [::info exists _tag(${t}label)] } {
            # Got a widget path, so convert to tag
            set tag $_tag(${t}label)
        } elseif ![::info exists _type($tag)] {
            error "Unknown item: $tag"
        }
        # Decompose the tag
        regexp {^((([^\.]+)?.*)?\.)?[^\.]+$} $tag _ _ parent

        # A button currently has the focus, so move the focus
        switch -exact $mode {
            "down" {
                set t [lsearch -exact $_children($parent) $tag]
                while { [incr t] < [llength $_children($parent)] } {
                    if { $_type([lindex $_children($parent) $t]) == "node" } {
                        set new [lindex $_children($parent) $t]
                        break
                    }
                }
            }
            "up" {
                set t [lsearch -exact $_children($parent) $tag]
                while { [incr t -1] >= 0 } {
                    if { $_type([lindex $_children($parent) $t]) == "node" } {
                        set new [lindex $_children($parent) $t]
                        break
                    }
                }
            }
            "left" {
                if { $parent != "" } {
                    set new $parent
                }
            }
            "to" {
                set new $tag
            }
            "right" {
                if { $_state($tag) == "closed" } {
                    open $tag
                }
                if { $_children($tag) != "" } {
                    set new [lindex $_children($tag) 0]
                }
            }
            "return" {
                # Toggle the node
                if { $_state($tag) == "open" } {
                    close $tag
                } else {
                    open $tag
                }
                return
            }
        }
    }
    if { $new != "" } {
        focus $itk_component(${new}button)
    }
}

# ------------------------------------------------------------------
## METHOD: type tag
#
# Return the type of _tag_. The type will be value of the _type_
# argument passed to the <b>add</b> method when the item was created.
# Raise an error if the item does not exist.
# ------------------------------------------------------------------
body iwidgets::Widgettree::type {tag} {
    if ![::info exists _type($tag)] {
	error "Unknown item: $tag"
    }
    return $_type($tag)
}

