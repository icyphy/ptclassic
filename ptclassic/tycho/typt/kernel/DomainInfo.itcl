# Ptolemy Retargetting mechanism: Gather information about domains
#
# @Author: Christopher Hylands
#
# @Version: $Id$
#
# @Copyright (c) 1996 The Regents of the University of California.
# All rights reserved.
#
# Permission is hereby granted, without written agreement and without
# license or royalty fees, to use, copy, modify, and distribute this
# software and its documentation for any purpose, provided that the above
# copyright notice and the following two paragraphs appear in all copies
# of this software.
#
# IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY
# FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
# ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF
# THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.
#
# THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE
# PROVIDED HEREUNDER IS ON AN "AS IS" BASIS, AND THE UNIVERSITY OF
# CALIFORNIA HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,
# ENHANCEMENTS, OR MODIFICATIONS.
# 
#                                        PT_COPYRIGHT_VERSION_2
#                                        COPYRIGHTENDKEY
#######################################################################

catch {delete class DomainInfo}

#######################################################################
#### DomainInfo
# One DomainInfo object contains information about all the stars
# in that domain
# <p>
# Here is an example of how to use the DomainInfo:
# <tcl><pre>
#     ::tycho::DomainInfo .sdf SDF
#     ::tycho::DomainInfo .cgc CGC
#     ::tycho::DiffStars .sdf .cgc
# </pre></tcl>
#
class ::tycho::DomainInfo {

    constructor {args} {}
    destructor {}
    
    ###################################################################
    ####                            options                        ####

    # One line description of xxxx option; listed in alphabetical order
    itk_option define -xxxx xxxx Xxxx ""

    ###################################################################
    ####                         public methods                    ####

    # Return a list of all the stars
    method stars {} {}

    # Return the descriptor for starName
    method descriptor {starName} {}

    # Return the ports for starName
    method ports {starName} {}

    # Return the multiports for starName
    method multiports {starName} {}

    # Return the states for starName
    method states {starName} {}

    # Print the contents of the current DomainInfo object
    method print {}
    
    # Print one star in the current DomainInfo object
    method printStar {id}

    ###################################################################
    ####                      public procs                         ####

    # Compare two domainInfo objects
    public proc diffDomains {domainA domainB}

    ###################################################################
    ####                   protected methods                       ####


    ###################################################################
    ####                   protected variables                     ####


    ###################################################################
    ####                   protected procs                         ####

    # Compare two domainInfo objects
    protected proc diffStars {domainA domainB}

    ###################################################################
    ####                   private methods                         ####

    # Return the star information as a list of keyword value pairs
    private method starInfo {starName}

    ###################################################################
    ####                   private variables                       ####

    # This object contains information about the domainName domain.
    public variable domainName

    # Keywords that the ptcl print command returns 
    private common starKeywords { Descriptor: MultiPorts: States:}

    public variable stars
}


#######################################################################
#### constructor
#
body ::tycho::DomainInfo::constructor {args} {
    set domainName [lindex $args 0]
    domain $domainName
    #set stars(Gain) [starInfo Gain]
    foreach star [knownlist] {
        set stars($star) [starInfo $star]
    }
}


#######################################################################
#### destructor
#
body ::tycho::DomainInfo::destructor {} {
}


    ###################################################################
    ###################################################################
    ####                      public methods                       ####



# Return all of the stars
body ::tycho::DomainInfo::stars {} {
    return [array names stars]
}

# Return the descriptor for starName
body ::tycho::DomainInfo::descriptor {starName} {
    set starList $stars($starName)
    return [lindex $starList [lsearch $starList {Descriptor*}]]
}

# Return the descriptor for starName
body ::tycho::DomainInfo::ports {starName} {
    set starList $stars($starName)
    return [lindex $starList [lsearch $starList {Ports*}]]
}
# Return the descriptor for starName
body ::tycho::DomainInfo::multiports {starName} {
    set starList $stars($starName)
    return [lindex $starList [lsearch $starList {MultiPorts*}]]
}

# Return the descriptor for starName
body ::tycho::DomainInfo::states {starName} {
    set starList $stars($starName)
    return [lindex $starList [lsearch $starList {States*}]]
}

#######################################################################
#### print
# Return the contents of this domain as a list
#
body ::tycho::DomainInfo::print {} {
    foreach id [array names stars] {
        lappend results [printStar $id ]
    }
    return [list $domainName $results] 
}

body ::tycho::DomainInfo::printStar {id} {
    set stateList [lindex [states $id] 1]
    set stateResults {}
    foreach state $stateList {
        lappend stateResults [format "\t%s\n" [join $state ]]
    }
    return [format "%s\n\t%s\n\t%s\n\t%s\n\tState\n\t%s\n" \
            $id [descriptor $id] \
            [ports $id] \
            [multiports $id] \
            $stateResults]
}

    ###################################################################
    ###################################################################
    ####                      public procedures                    ####

#######################################################################
#### diffDomains
# Compare two domains, passed in as strings
# Return three lists:
# stars that are common to both
# stars only in domainA
# stars only in domainB
body ::tycho::DomainInfo::diffDomains {domainA domainB} {
    ::tycho::DomainInfo .domainA $domainA
    ::tycho::DomainInfo .domainB $domainB
    set retVal [::tycho::DomainInfo::diffStars .domainA .domainB]
    delete object .domainA .domainB
    return $retVal
}


    ###################################################################
    ###################################################################
    ####                      protected methods                    ####


    ###################################################################
    ###################################################################
    ####                      protected procedures                 ####


#######################################################################
#### diffStars
# Compare two domainInfo objects
# Return three lists:
# stars that are common to both
# stars only in domainA
# stars only in domainB
body ::tycho::DomainInfo::diffStars {domainA domainB} {
    set starsA [$domainA stars]
    set starsB [$domainB stars]
    set commonButPortsMismatch {}
    set commonButMultiPortsMismatch {}
    set commonButStatesMismatch {}
    set commonStars {}
    set domainAOnly {}
    set domainBOnly {}
    foreach starA $starsA {
        if { [lsearch -exact $starsB $starA] != -1 } {
            if { [$domainA ports $starA] != [$domainB ports $starA] } { 
                lappend commonButPortsMismatch $starA
            } else {
                if { [$domainA multiports $starA] != \
                        [$domainB multiports $starA] } { 
                    lappend commonButMultiPortsMismatch $starA
                } else {
                    if { [$domainA states $starA] != \
                            [$domainB states $starA] } { 
                        lappend commonButStatesMismatch $starA
                    } else {
                        lappend commonStars $starA
                    }
                } 
            }
        } else {
            lappend domainAOnly $starA
        }
    }

    foreach starB $starsB {
        if { [lsearch -exact $starsA $starB] == -1 } {
            lappend domainBOnly $starB
        }
    }
    return [list $commonStars $commonButPortsMismatch \
            $commonButMultiPortsMismatch $commonButStatesMismatch \
            $domainAOnly $domainBOnly]
}


    ###################################################################
    ###################################################################
    ####                      private methods                      ####

#######################################################################
#### starInfo
# Return the star information as a list of keyword value pairs
#
body ::tycho::DomainInfo::starInfo {starName} {
    domain $domainName
    set printResults [::print $starName]
    # Search printResults for keywords
    set descriptor {}
    set ports {}
    set multiports {}
    set tmpStates {}
    set states {}

    # Look for the star name and the descriptor.  All objects must
    # have these.
    if {![regexp {^Star: (.*)
Descriptor:(.*)} $printResults dummy star rest]} {
        error "Error while parsing Descriptor: $printResults"
    }
    
    set status [regexp {(.*)
Ports:(.*)
MultiPorts:(.*)
States:(.*)
(__+)
} $rest dummy descriptor ports multiports tmpStates trash]

    if {!$status} {
        set status [regexp {(.*)
MultiPorts:(.*)
States:(.*)
(__+)
} $rest dummy descriptor multiports tmpStates trash]
    }

    if {!$status} {
        set status [regexp {(.*)
Ports:(.*)
States:(.*)
(__+)
} $rest dummy descriptor ports tmpStates trash]
    }

   if {!$status} {
        set status [regexp {(.*)
Ports:(.*)
MultiPorts:(.*)
(__+)
} $rest dummy descriptor ports multiports trash]
    }

    if {!$status} {
        set status [regexp {(.*)
Ports:(.*)
(__+)
} $rest dummy descriptor ports trash]
    }

    if {!$status} {
        set status [regexp {(.*)
MultiPorts:(.*)
(__+)
} $rest dummy descriptor multiports trash]
    }

    if {!$status} {
        set status [regexp {(.*)
States:(.*)
(__+)
} $rest dummy descriptor tmpStates trash]
    }


    if {!$status} {
        set descriptor $rest
        # The object did not have a multiport, it could be a base?
        puts "No multiport: $star, $rest"
    }


    # Process the states into sublist
    set stateList {}
    if {$tmpStates != {} } {
        set tmpStateList [split $tmpStates {
}]
        foreach state $tmpStateList {
            if { $state != {}} {
                if {[scan [string trimleft $state] \
                        "%s type: %s" stateName type] \
                        == 2} {
                    lappend stateList [list $stateName $type]
                }
            }
        }
    }
    
    return [list [list Star $star] \
            [list Descriptor $descriptor] \
            [list Ports $ports] \
            [list MultiPorts $multiports] \
            [list States $stateList]]
}



