# Generate an IDoc file (a representation of a ::tycho::Class) from source.
#
# @Author: Cliff Cordeiro
#
# @Contributor: Christopher Hylands
#
# @Version: $Id$
#
# @Copyright (c) 1996-%Q% The Regents of the University of California.
# All rights reserved.
#
# Permission is hereby granted, without written agreement and without
# license or royalty fees, to use, copy, modify, and distribute this
# software and its documentation for any purpose, provided that the above
# copyright notice and the following two paragraphs appear in all copies
# of this software.
#
# IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY
# FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
# ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF
# THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.
#
# THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE
# PROVIDED HEREUNDER IS ON AN "AS IS" BASIS, AND THE UNIVERSITY OF
# CALIFORNIA HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,
# ENHANCEMENTS, OR MODIFICATIONS.
# 
#                                        PT_COPYRIGHT_VERSION_2
#                                        COPYRIGHTENDKEY
#######################################################################

#######################################################################
#### IDocSys
# 
#
#
class ::tycho::IDocSys {
    inherit ::tycho::TyDoc

    constructor {args} {}
    destructor {}
    
    ###################################################################
    ####                         public methods                    ####

    # Generate the IDocumentation for a single Itcl file.
    method generateSingleFileIDoc {filename}

    # Generate an index of the IDocumentation (in HTML)
    method generateIDocIndex { {title {"Index of classes"}}}

    # Check if the given file is newer than its related documentation.
    method modCheck {filename}

    ###################################################################
    ####                      public procs                         ####

    # Generate the IDocumentation for the files in $filelist
    public proc generateIDoc {debug generateIndex title filelist}

    # Return a list of all the classes defined in the given source file.
    public proc getClassesInSource {filename}

    ###################################################################
    ####                   protected variables                     ####

    # The author of the current source file
    protected variable author ""

    # The contributor(s) to the current source file
    protected variable contributor ""

    # The version of the current source file
    protected variable version ""

    # The first line of the copyright information from the current source file
    protected variable copyright ""

    # language for the current file
    protected variable language

    # an array of ::tycho::Class objects for this file
    protected variable myClass

    # true if there is outside class information
    protected variable relatedModified

    # The current source file name
    protected variable sourceFile


    ###################################################################
    ####                   private methods                         ####

    # Read the current file, call parseData
    private method readFile {filename}

    # Parse the data for a single file, creating and modifying classes as needed
    private method parseData {data}

    # Parse the data within a class definition
    private method parseClass {class body}

    # Add the class comment by formatting it into HTML.
    private method addClassComment {class expl}

    # Uncapitalize and unpluralize a docTag (Authors -> author)
    private method formatTag {docTag}

    # Format and add the arguments in a form the class model understands
    private method addArgs {class entityName arguments}

    # Add the constructor to the class model
    private method addConstructor {class arguments desc}

    # Add the destructor to the class model
    private method addDestructor {class desc}

    # Add an itk_option to the class model
    private method addItk_Option {class switchName desc {default {}}}
    
    # Add a common proc to the class model
    private method addCommon {class commonName protection desc {default {}}}
    
    # Add a variable to the class model
    private method addVariable {class varName protection desc {default {}}}

    # Add a proc to the class model
    private method addInsideProc {class procName arguments protection desc}
    
    # Add a method to the class model
    private method addMethod {class methodName protection arguments desc} 


    # Attach body information to the appropriate entity in the class model
    private method addBody {bodyName arguments expl}

    # Attach configbody information to the appropriate entity in the class model
    private method addConfigBody {configName expl}

    # Add a non-class procedure to the related class model
    private method addOutsideProc {procName arguments expl}

    
    # Format a description properly
    private method formatDesc {comment}

    # Format an explanation properly (in HTML)
    private method formatExpl {comment}

    ###################################################################
    ####                   private variables                       ####

    # Keywords that can appear in a class definition
    private common keywords "# variable common itk_option method proc constructor destructor public private protected inherit set array"

}

#######################################################################
#### constructor
#
body ::tycho::IDocSys::constructor {args} {
}

    ###################################################################
    ###################################################################
    ####                      public methods                       ####

#####################################################################
#### generateIDoc
# Output an IDoc (::tycho::Class) representation of the given Itcl 
# file (which must have been already read). 
#
body ::tycho::IDocSys::generateSingleFileIDoc {filename} {
    # output class model data
    foreach class [array names myClass] {
        # puts $class
        # puts [$myClass($class) describe
        if {$class != "related"} {
            set docFile [info namespace tail $class].idoc
            ::tycho::rmIfNotWritable $docFile
            set fd [open $docFile "w"]
            $myClass($class) write $fd
            close $fd
            delete object $myClass($class)
        } else {
            if {$relatedModified} {
                # NOTE: goes by the filename, not the class name, for
                # related documentation
                if {[array size myClass] == 1} {
                    # Not related, ONLY docs
                    set relFile [file root $filename].idoc
                } else {
                    # Related file
                    set relFile [file root $filename]_rel.idoc
                }
                ::tycho::rmIfNotWritable $relFile
                set fd [open $relFile "w"]
                $myClass(related) write $fd
                close $fd
            }
            delete object $myClass(related)
        }
    }
}

#####################################################################
#### generateIDocIndex
# Fixme!
#
body ::tycho::IDocSys::generateIDocIndex { {title {"Index of classes"}}} {
# FIXME: FIXME: FIXME!
}

#####################################################################
#### modCheck
# Checks if the current file is newer than it's associated documentation.
# And returns 1 if so.
#
# This requires searching for all classes defined within the file and
# checking if those class's documents are older. Takes about 5% of 
# the time to create the docs.
#
# A more ideal system would check which classes need to be redocumented.
# However, there are few sources with more than one class so this is a
# decent compromise.
#
# For non-itcl/itk/tcl/tk files, it silently returns 1 because it can't tell.
#
body ::tycho::IDocSys::modCheck {filename} {
    set sourceTime [file mtime $filename]
    set extension [file extension $filename]

    if {$extension == ".tcl" || $extension == ".tk" || $extension == ""} {
        set docFile [file join doc codeDoc [file root $filename].idoc]
        if ![file exists $docFile] {
            # No tcl-only documentation
            return 1
        }
        if {$sourceTime > [file mtime $docFile]} {
            # The source is newer than the tcl-only docs
            return 1
        }
        # It's okay
        return 0
    }
    
    if {$extension != ".itcl" && $extension != ".itk"} {
        # Can't check other types of files
        return 1
    }

    set classes [getClassesInSource $filename]
    foreach class $classes {
        if {$class == "related"} {
            set relFile [file join doc codeDoc [file root $filename]_rel.idoc]
            if ![file exists $relFile] {
                # No class-related documentation
                return 1
            }
            if {$sourceTime > [file mtime $relFile]} {
                # The source is newer than the related docs
                return 1
            }
            continue
        }
        set docFile [file join doc codeDoc [info namespace tail $class].idoc]
        if ![file exists $docFile] {
            # There is no documentation.
            return 1
        }
        if {$sourceTime > [file mtime $docFile]} {
            # The source is newer.
            return 1
        }
    }
    # not modified
    return 0
}

    ###################################################################
    ###################################################################
    ####                      public procedures                    ####

#####################################################################
#### generateIDoc
# Generate IDoc files for all the files named in filelist, placing the
# output in the doc/codeDoc subdirectory.
#
# If there are many files, catch errors and return all of the messages.
# If there is only one file, don't catch it so the user can trace the
# stack.
#
body ::tycho::IDocSys::generateIDoc {debug generateIndex title filelist} {
    set IDocSys [::tycho::IDocSys [::tycho::autoName .IDocSys]]
    set oneFileOnly [expr [llength $filelist] == 1] 

    if ![file isdirectory doc/codeDoc] {
        exec mkdir -p doc/codeDoc
    }
    set retval ""
    foreach filename $filelist {

        if ![$IDocSys modCheck $filename] {
            # file does not need to be redocumented if batch and not modified
            if $debug {
              #  puts "$filename <not modified>"
            }
            continue
        }

        if $debug {
            puts "$filename"
        }
        if ![file readable $filename] {
            set retval "$retval\nWarning: generateIDoc: $filename is not readable"
        } else {
            if {$oneFileOnly} {
                # Don't catch errors
                $IDocSys readFile $filename
                cd doc/codeDoc
                $IDocSys generateSingleFileIDoc $filename
                cd ../..
            } else {
                # Catch and accumulate errors for multiple files.
                if [catch {$IDocSys readFile $filename} errMsg] {
                    set retval "$retval\nWarning: $errMsg"
                } else {
                    cd doc/codeDoc
                    if [catch {$IDocSys generateSingleFileIDoc $filename} \
                            errMsg] {
                        set retval "$retval\nWarning: $errMsg"
                    }
                    cd ../..
                }
            }
        }
    }
    if {$generateIndex == 1} {
        cd doc/codeDoc
        if [catch {$IDocSys generateIDocIndex $title} errMsg] {
            set retval "$retval\nWarning: $errMsg"
        }
        cd ../..
    }
    delete object $IDocSys
    return $retval
}

#####################################################################
#### getClassesInSource
# Quickly scan the source file for the classes which are defined within.
# Requires around 5% of the time it takes to make the docs. Returns 
# "related" if there are non-class structures (such as ensembles and 
# procs) in the file.
#
# This is approximate, they must be declared before the first class 
# in a file or after a body within a file. Which is only decent coding
# style.
#
body ::tycho::IDocSys::getClassesInSource {filename} {
    set inClass 0
    set related 0
    set retval {}
    
    set fd [open $filename]
    while {![eof $fd]} {
        gets $fd lineIn
        if [regexp {^[	 ]*(class)[ 	]+([^ ]+)[ 	]+\{} \
                $lineIn dummy dummy2 classname] {
            lappend retval $classname
            set inClass 1
        }
        if {$related} {
            # don't bother checking
            continue
        }
        # If no related information found yet, keep looking
        if {$inClass} {
            # if we see a body, we're out of the class declaration
            if [regexp {^[	 ]*(body)[ 	]+[^ ]+[ 	]+[^ ]+} \
                    $lineIn] {
                set inClass 0
            }
        } else {
            # check for outside procs or ensembles when not in the class
            if [regexp {^[	 ]*((proc)|(ensemble))[ 	]+[^ ]+[ 	]+[^ ]+} \
                    $lineIn] {
                set retval [linsert $retval 0 "related"]
                set related 1
            }
        }
    }
    close $fd
    return $retval
}

    ###################################################################
    ###################################################################
    ####                      private methods                      ####

#####################################################################
#### readFile 
# Read in a file line by line, identify comments, merge multi-line comments
# into one line, bracket protect the comment contents, and append to a 
# variable. Then parse that variable to distill class information.
#
body ::tycho::IDocSys::readFile {filename} {
    # Initialize single file data
    set author ""
    set contributor ""
    set version ""
    set copyright ""

    catch {unset myClass}

    # check extension (only tcl/tk, itk, itcl supported as yet)
    set ext [file extension $filename]
    switch $ext {
        .tk {
            set language Itcl
        }
        .tcl {
            set language Itcl
        }
        .itcl {
            set language Itcl
        }
        .itk {
            set language Itcl
        }
        "" {
            # Fix for files such as tycho-mac, tydoc, idoc
            set language Itcl
        }
        default {
            error "::tycho::IDocSys does not support $ext files"
        }
    }

    # setup related model for outside class information
    set myClass(related) [::tycho::Class [::tycho::autoName class]]
    set relatedModified 0

    set sourceFile $filename
    set inEscapedComments ""
    set currentComment {}
    set currentLongLine {}
    set fd [open $filename]
    while {![eof $fd]} {
        gets $fd lineIn
     
        if {[regexp {^[	 ]*$} $lineIn]} {
            # Remove blank lines
            continue
        }

        if {[regexp {\\$} $lineIn]} {
            # Concatenate lines ending with a \.
        }
         
        if [ regexp {^[	 ]*#(.*)$} $lineIn dummy commentText ] {
            # It's some sort of comment
            if {[regexp {^# --+[ 	]*$} $lineIn ]} {
                # Filter out comment lines like the ones in iwidgets:
                # -----------------------------------
                continue
            }
            if {[regexp {^[	 ]*#[	 ]*#+.*$} $lineIn]} {
                # Filter out comment lines with multiple #'s
                continue
            }
            # Store adjacent comments
            append currentComment $commentText "\n"
        } else {
            # The text is not a comment line
            if {$currentComment != {}} {
                append inEscapedComments "# " [list $currentComment] "\n"
                set currentComment {}
            }
            if {$currentLongLine != {}} {
                # Currently have a long line
                if {[regexp {\\$} $lineIn]} {
                    # Another follows
                    append currentLongLine " " [string trimleft \
                            [string trimright $lineIn \\]]
                } else {
                    # This is the last
                    append currentLongLine " " [string trimleft $lineIn]
                    append inEscapedComments $currentLongLine "\n"
                    set currentLongLine {}
                }
                continue
            }
            if {[regexp {\\$} $lineIn]} {
                # Begin a new long line (ending in "\")
                append currentLongLine [string trimright $lineIn \\]
                continue
            }
            append inEscapedComments $lineIn "\n"
        } 
    }
    # Make sure all comments are saved
    if {$currentComment != {}} {
        append inEscapedComments "# " $currentComment "\n"
    }
    close $fd

    parseData $inEscapedComments
}

#####################################################################
#### parseData
# Expects a modified source file, with adjacent comments all on one line,
# useless comments removed. This data is then gone through as a list,
# looking for toplevel keywords, such as "class" "proc" "configbody" and 
# "body". These are parsed according to Itcl's syntax and information
# of note is added to the class model.
#
# Comments are saved until the next keyword and are assumed to belong to
# that entity. The class comment, then, must be the comment directly
# preceding the class definition, ignoring initialization code that 
# IDocSys does not recognize.
#
# NOTE: @ tags are only recognized in the class comment, the comment 
# that appears before the class definition.
#
body ::tycho::IDocSys::parseData {data} {
    set inComment 0
    set inOutsideProc 0
    set inBody 0
    set inConfigBody 0
    set inEnsemble 0
    set inClass 0
    set lastComment {}
    foreach construct $data {
        if {$construct == "\n"} {
            # Ignore empty lines 
            continue
        }
        if {$inComment} {
            # This is a comment. Save it.
            set lastComment "$construct"
            set inComment 0
            continue
        }
        if {$inOutsideProc} {
            # This is an outside proc. proc name args body
            if {$inOutsideProc == 1} {
                set procName $construct
                set inOutsideProc 2
            } elseif {$inOutsideProc == 2} {
                set args $construct
                set inOutsideProc 3
            } else {
                # puts "PROC: $procName ARGS: $args BODY: $construct"
                addOutsideProc $procName $args $lastComment
                set inOutsideProc 0
                set lastComment {}
                set procName {}
                set args {}
            }
            continue
        }
        if {$inBody} {
            # This is part of a body statement. body class::func arglist body
            if {$inBody == 1} {
                set bodyName $construct
                set inBody 2
            } elseif {$inBody == 2} {
                set args $construct
                set inBody 3
            } else {
                # puts "BODY: $bodyName ARGS: $args BODY: $construct"
                addBody $bodyName $args $lastComment
                set inBody 0
                set lastComment {}
                set bodyName {}
                set args {}
            }
            continue
        }
        if {$inConfigBody} {
            # This is part of a configbody statement. 
            # configbody class::option body
            if {$inConfigBody == 1} {
                set optionName $construct
                set inConfigBody 2
            } else {
                # puts "CONFIG: $optionName BODY: $construct"
                addConfigBody $optionName $lastComment
                set inConfigBody 0
                set lastComment {}
                set optionName {}
            }
            continue
        }
        if {$inEnsemble} {
            # This is part of an ensemble statement. ensemble name { commands }
            if {$inEnsemble == 1} {
                set ensembleName $construct
                set inEnsemble 2
            } else {
                #puts "ENS: $ensembleName BODY: $construct"
                set inEnsemble 0
                # FIXME: ensembles are unsupported
                # Keep lastComment: probably relates to Class
                set ensembleName {}
            }
            continue
        }
        if {$inClass} {
            # This is part of a class statement. class name { definition }
            if {$inClass == 1} {
                set className $construct
                set inClass 2
            } else {
                # puts "CLASS: $className BODY: $construct"
                parseClass $className $construct
                addClassComment $className $lastComment
                set inClass 0
                set lastComment {}
                set className {}
            }
            continue
        }
        if {[string index $construct 0] == "#"} {
            # A comment follows.
            set inComment 1
            continue
        }
        if {$construct == "proc"} {
            # A proc follows.
            set inOutsideProc 1
            continue
        }
        if {$construct == "body"} {
            # A body follows.
            set inBody 1
            continue
        }
        if {$construct == "configbody"} {
            # A configbody follows.
            set inConfigBody 1
            continue
        }
        if {$construct == "ensemble"} {
            # An ensemble follows.
            set inEnsemble 1
            continue
        }
        if {$construct == "class"} {
            # A class follows.
            set inClass 1
            continue
        } 
        # puts "UNCLASSIFIED: $construct"
    }
}


#####################################################################
#### parseClass
# This method works in much the same way as parseBody. It takes the 
# contents of the class definition and looks for keywords (see 
# $keywords). These are then parsed according to Itcl syntax, relevant
# information added to the class model for this class. 
#
# Because there may be multiple classes in one itcl file, each class
# model is stored in an array which is indexed by the name of the class
# the class models are created in this procedure while parsing the class
# definition.
#
body ::tycho::IDocSys::parseClass {class body} {
    set myClass($class) [::tycho::Class [::tycho::autoName class]]
    $myClass($class) modelconfigure -language $language
    $myClass($class) modelconfigure -name $class
    $myClass($class) modelconfigure -source $sourceFile

    set lastComment {}
    set lastProtection {}
    set default {}
    set inComment 0
    set inVariable 0
    set inCommon 0
    set inItk_Option 0
    set inMethod 0
    set inProc 0
    set inConstructor 0
    set inDestructor 0
    set inInherit 0

    # To assure every item is seen
    lappend body # #

    # Parse each item
    foreach construct $body {
        # Ignore empty lines (is necessary?)
        if {$construct == "\n"} {
            continue
        }

        # First, check if last word was a keyword
        if {$inComment} {
            # This is a comment. Save it.
            set lastComment "$construct"
            set inComment 0
            continue
        }
        if {$inVariable} {
            if {$inVariable == 1} {
                set name $construct
                # Default protection is protected
                if {$lastProtection == {}} {
                    set lastProtection protected
                }
                set inVariable 2
                continue
            }
            # Check for initial value
            if {[lsearch -exact $keywords $construct] == -1} {
                # Must be an initial value, save it.
                # FIXME: can be broken by having an initial value
                # that is a keyword, as newlines are not considered
                # NOTE: variables can have an initialization code
                # field. This is ignored by the parser and is not
                # specifically checked.
                addVariable $class $name $lastProtection \
                        $lastComment $construct
                set inVariable 0
                set lastComment {}
                set lastProtection {}
                continue 
            }
            # No initial value, parse construct.
            addVariable $class $name $lastProtection $lastComment
            set inVariable 0
            set lastComment {}
            set lastProtection {}
        }
        if {$inCommon} {
            if {$inCommon == 1} {
                set name $construct
                # Default protection is protected
                if {$lastProtection == {}} {
                    set lastProtection protected
                }
                set inCommon 2
                continue
            }
            # Check for initial value
            if {[lsearch -exact $keywords $construct] == -1} {
                # Must be an initial value, save it.
                # FIXME: can be broken by having an intial value
                # that is a keyword, as newlines are not considered
                addCommon $class $name $lastProtection \
                        $lastComment $construct
                set inCommon 0
                set lastComment {}
                set lastProtection {}
                continue
            }
            # Continue parsing this, there is no initial value
            addCommon $class $name $lastProtection $lastComment
            set inCommon 0
            set lastComment {}
            set lastProtection {}
        }
        if {$inItk_Option} {
            if {$inItk_Option == 1} {
                if {$construct != "define"} {
                    # NOTE: must be itk_option define ...
                    set inItk_Option 0
                    continue
                }
                set inItk_Option 2
                continue
            }
            if {$inItk_Option == 2} {
                # save switchname
                set name $construct
                set inItk_Option 3
                continue
            }
            if {$inItk_Option != 5} {
                incr inItk_Option
                continue
            }
            # At init value
            addItk_Option $class $name $lastComment $construct
            set inItk_Option 0
            set lastComment {}
            continue
        }
        if {$inMethod} {
            if {$inMethod == 1} {
                set name $construct
                # Default protection is public
                if {$lastProtection == {}} {
                    set lastProtection public
                }
                set inMethod 2
                continue
            }
            # Getting args
            addMethod $class $name $lastProtection $construct $lastComment
            set inMethod 0
            set lastComment {}
            set lastProtection {}
            continue
        } 
        if {$inProc} {
            if {$inProc == 1} {
                set name $construct
                # Default protection is public
                if {$lastProtection == {}} {
                    set lastProtection public
                }
                set inProc 2
                continue
            }
            # Getting args
            addInsideProc $class $name $lastProtection $construct $lastComment
            set inProc 0
            set lastComment {}
            set lastProtection {}
            continue
        } 
        if {$inConstructor} {
            # $construct is args, init and body will be ignored by parser
            addConstructor $class $construct $lastComment
            set inConstructor 0
            set lastComment {}
            continue
        }
        if {$inDestructor} {
            # No args. $construct is destructor body. Ignore.
            addDestructor $class $lastComment
            set inDestructor 0
            set lastComment {}
            continue
        }
        if {$inInherit} {
            if {[string range $construct 0 1] == "::"} {
                $myClass($class) parent $construct
                continue
            }
            # No more parents, parse this.
            set inInherit 0
        }

        # Below, parse keywords
        # NOTE: does not support private {method {}{} variable {} ...}
        # Check if it has a - NOTE: switch can't handle -something's
        if {[string index $construct 0] == "-"} {
            # puts "#UNABLE: $construct"
            continue
        }
        switch $construct {
            "#" {
                set inComment 1
            }
            "private" {
                set lastProtection private
            }
            "protected" {
                set lastProtection protected
            }
            "public" {
                set lastProtection public
            }
            "variable" {
                set inVariable 1
            }
            "common" {
                set inCommon 1
            }
            "itk_option" {
                set inItk_Option 1
            }
            "method" {
                set inMethod 1
            }
            "proc" {
                set inProc 1
            }
            "constructor" {
                set inConstructor 1
            }
            "destructor" {
                set inDestructor 1
            }
            "inherit" {
                set inInherit 1
            }
            default {
                # puts "#UNCLASSIFIED: $construct"
            }
        }
    }
}

#####################################################################
#### addClassComment
# Add a class comment to the class model. This method parses the 
# comment preceding the class definition, formatting it into HTML,
# removing the copyright, and creating the footer with tagged 
# information, including the first line of the copyright, the author,
# the contributors, and the version of the source file.
#
# If more than one class occupies a file, this information is
# saved. That is, if the tags are not redefined for a new class,
# the old information is used.
#
body ::tycho::IDocSys::addClassComment {class expl} {
    set classModel $myClass($class)
 
    # Parse line by line
    set explList [split $expl "\n"]
    set docTag desc
    foreach explLine $explList {
        if [regexp {^ @([A-Za-z]+):*[ 	]+(.*)} \
		$explLine dummy docTag docValue] {
	    set explLine $docValue
            set docTag [formatTag $docTag]
	    # puts "ct: $docTag, cl: $docValue"
	}
	if {$docTag == "copyright"} {
	    if {[set $docTag] == "" } {
		# We save only the first line of the copyright
		append $docTag $explLine "\n"
            } else {
                if {[regexp {COPYRIGHTENDKEY} $explLine]} {
                    # ignore until the key
                    set docTag desc
                }
            }
        } else {
	    append $docTag $explLine "\n"
        }
    }
    
    set expl [formatExpl $desc]
    
    # Append the footer
    append expl <hr>
    if {$author != ""} {
        if {[llength $author] == 1} {
            append expl "<br>Author: $author"
        } {
            append expl "<br>Authors: $author"
        }
    }
    if {$contributor != ""} {
        if {[llength $contributor] == 1} {
            append expl "<br>Contributor: $contributor"
        } {
            append expl "<br>Contributors: $contributor"
        }
    }
    if {$version != ""} {
        append expl "<br>Version: $version"
    }
    if {$copyright != ""} {
        append expl "<br>Copyright: $copyright"
    }
    $classModel annotation explanation "$expl"
}

#####################################################################
#### formatTag
# Uncapitalize and singularize a docTag so that it can be added to the
# standard protected variables: copyright, author, contributor, version
# Do the same to strange ones (lowercase and remove trailing s's). 
# The error is encountered in the caller if it is an error.
#
body ::tycho::IDocSys::formatTag {docTag} {
    set docTag [string tolower $docTag]
    set docTag [string trimright $docTag "s"]
    return $docTag
}

#####################################################################
#### addArgs
# Add the arguments to a proc or method to its associated entity in
# the class model. This involves reformatting from Itcl:
# <code>add {num1 {num2 0}}</code> to the class model's preferred
# format: <code>parameter num1; parameter num2 -optional 1 -default 0</code>
#
body ::tycho::IDocSys::addArgs {class entityName arguments} {
    set classModel $myClass($class)
    foreach arg $arguments {
        set default [lindex $arg 1]
        # check the length in case the default is {}
        if {[llength $arg] == 2} {
            $classModel parameter $entityName [lindex $arg 0] \
                    -optional 1 -default $default
        } else {
            $classModel parameter $entityName $arg
        }
    }
}

#####################################################################
#### addConstructor
# Add the constructor, its arguments, and associated description to
# the class model for $class.
#
body ::tycho::IDocSys::addConstructor {class arguments desc} {
    set classModel $myClass($class)
    $classModel Constructor constructor
    set desc [formatDesc $desc]
    $classModel annotation constructor.description $desc Constructor
    addArgs $class constructor $arguments    
}

#####################################################################
#### addDestructor
# Add the destructor, its arguments, and associated description to
# the class model for $class.
#
body ::tycho::IDocSys::addDestructor {class desc} {
    set classModel $myClass($class)
    $classModel Destructor destructor
    set desc [formatDesc $desc]
    $classModel annotation destructor.description $desc Destructor
}

#####################################################################
#### addItk_Option
# Add the itk_option, its associated description, and its default (if 
# any) to the class model for $class.
#
body ::tycho::IDocSys::addItk_Option {class switchName desc {default {}}} {
    # Itk_options have the modifier flag set to itk_option in Itcl
    set classModel $myClass($class)
    $classModel variable $switchName \
            -protection public -modifiers itk_option -default $default
    set desc [formatDesc $desc]
    $classModel annotation $switchName.description $desc variable
}

#####################################################################
#### addCommon 
# Add a common proc at the given protection, its associated description,
# and its default (if any) to the class model for $class.
#
body ::tycho::IDocSys::addCommon {class commonName protection \
        desc {default {}}} {
    # Commons are variables of classwide scope in Itcl
    set classModel $myClass($class)
    $classModel variable $commonName \
            -protection $protection -scope class -default $default
    set desc [formatDesc $desc]
    $classModel annotation $commonName.description $desc variable
}

#####################################################################
#### addVariable 
# Add a variable at the given protection, its associated description,
# and its default (if any) to the class model for $class.
body ::tycho::IDocSys::addVariable {class varName protection \
        desc {default {}}} {
    # Variables are variables of instance scope in Itcl
    set classModel $myClass($class)
    $classModel variable $varName \
            -protection $protection -scope instance -default $default
    set desc [formatDesc $desc]
    $classModel annotation $varName.description $desc variable
}

#####################################################################
#### addInsideProc
# Add a proc which is part of a class at the given protection, its
# associated description, and arguments to the class model for $class.
#
body ::tycho::IDocSys::addInsideProc {class procName protection \
        arguments desc} {
    # Procs are methods of classwide scope in Itcl
    set classModel $myClass($class)
    $classModel method $procName -protection $protection -scope class
    set desc [formatDesc $desc]
    $classModel annotation $procName.description $desc method
    addArgs $class $procName $arguments
}    

#####################################################################
#### addMethod 
# Add a method at the given protection, its arguments, and associated
# description to the class model for $class.
#
body ::tycho::IDocSys::addMethod {class methodName protection arguments desc} {
    # Methods are methods of instance scope in Itcl
    set classModel $myClass($class)
    $classModel method $methodName -protection $protection -scope instance
    set desc [formatDesc $desc]
    $classModel annotation $methodName.description $desc method
    addArgs $class $methodName $arguments
}

#####################################################################
#### addBody 
# Add the information from a body structure to the class model. The body
# name contains the information necessary to decide which class it 
# belongs to and which entity its information is applicable to. At 
# present, it just ignores the $arguments argument because those are
# added when the entity is first parsed. It adds the explanation to
# the given entity in the proper class.
#
body ::tycho::IDocSys::addBody {bodyName arguments expl} {
    # assumes the method or proc already exists
    set class [info namespace qualifiers $bodyName]
    set bodyName [info namespace tail $bodyName]

    # Tcl allows either tycho::crap or ::tycho::crap
    if ![info exists myClass($class)] {
        set class "::$class"
    }

    if [info exists myClass($class)] {
        set classModel $myClass($class)
        # Insert the explanation
        set expl [formatExpl "$expl"]
        if {$expl != {}} {
            $classModel annotation $bodyName.explanation $expl method
        }
    }
}

#####################################################################
#### addConfigBody 
# Add the information from a configbody structure to the class model.
# the config name contains the information necessary to decide which
# class it belongs to and which entity its information is applicable
# to. It adds the explanation to the proper entity in the proper
# class model.
#
body ::tycho::IDocSys::addConfigBody {configName expl} {
    # assumes the itk_option already exists
    set class [info namespace qualifiers $configName]
    set configName [info namespace tail $configName]
 
    # Tcl allows either tycho::crap or ::tycho::crap
    if ![info exists myClass($class)] {
        set class "::$class"
    }

    if [info exists myClass($class)] {
        set classModel $myClass($class) 
        set expl [formatExpl "$expl"]
        if {$expl != {}} {
            $classModel annotation $configName.explanation $expl variable
        } 
    }
}

#####################################################################
#### addOutsideProc
# Add the proc given to the related class model. This model contains
# all procs which are not defined within a specific class namespace
# yet are found in the current file.
#
body ::tycho::IDocSys::addOutsideProc {procName arguments expl} {
    # add to $myClass(related)
    set classModel $myClass(related)
    $classModel method $procName -protection public -scope class
    set expl [formatExpl "$expl"]
    if {$expl != {}} {
        $classModel annotation $procName.explanation $expl method
    }
    set relatedModified 1
}

#####################################################################
#### formatDesc 
# Format the description appropriately by removing carriage returns
# and returning a filler value if no description is found. (The IDoc
# viewer requires a description.)
#
body ::tycho::IDocSys::formatDesc {comment} {
    # remove carriage returns
    set commentList [split $comment "\n"]
    set comment [join $commentList " "]
    set comment [string trim $comment " "]

    if {$comment == {}} {
        # IDoc assumes all entities have a description
        set comment "No description given."
    }

    # Catch comments that don't have a terminating period (or other
    # suitable mark)
    regsub "\(\[^\.?!>\]\)\[ \t\]*\$" $comment {\1.} comment

    return $comment
}

#####################################################################
#### formatExpl
# Format the explanation appropriately by substituting HTML tags for
# comment conventions such as _underlines_ and *asterisks*. Include a
# &lt;p&gt; tag for every empty line in a comment. Surround proc and
# method names with &lt;code&gt; tags.
#
body ::tycho::IDocSys::formatExpl {comment} {
    if {"$comment" == "\n"} {
        return {}
    }
    
    # Blank lines are a new paragraph
    # FIXME: we don't want this inside <pre> ... </pre>!
    regsub -all "\n\[ \t\]*\n" $comment "\n<p>" comment

    # Underscores delimit italicized text. Because of the way regsub
    # works, we have to do it twice to catch eg "_x_ _y_." We also
    # need to be careful to catch the start and end of the string.
    regsub -all {([^a-zA-Z0-9])_([^_]*)_([^a-zA-Z0-9])} $comment \
	    {\1<i>\2</i>\3} comment
    regsub -all {([^a-zA-Z0-9])_([^_]*)_([^a-zA-Z0-9])} $comment \
	    {\1<i>\2</i>\3} comment
    regsub {^_([^_]*)_([^a-zA-Z0-9])} $comment \
	    {<i>\1</i>\2} comment
    regsub {([^a-zA-Z0-9])_([^_]*)_$} $comment \
	    {\1<i>\2</i>} comment

    # Asterisks delimit _single_ program code words
    regsub -all {([^a-zA-Z0-9])\*([^\* ]*)\*([^a-zA-Z0-9])} $comment \
	    {\1<code>\2</code>\3} comment

    # A single word followed by {} is a method or proc name
    regsub -all {([a-zA-Z0-9_-]+)\{\}} $comment \
           {<code>\1</code>} comment


    return "$comment"
}
