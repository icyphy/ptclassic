# Generate an IDoc file (a representation of a ::tycho::Class) from source.
#
# @Author: Cliff Cordeiro
#
# @Contributor: Christopher Hylands
#
# @Version: $Id$
#
# @Copyright (c) 1996-%Q% The Regents of the University of California.
# All rights reserved.
#
# Permission is hereby granted, without written agreement and without
# license or royalty fees, to use, copy, modify, and distribute this
# software and its documentation for any purpose, provided that the above
# copyright notice and the following two paragraphs appear in all copies
# of this software.
#
# IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY
# FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
# ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF
# THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.
#
# THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE
# PROVIDED HEREUNDER IS ON AN "AS IS" BASIS, AND THE UNIVERSITY OF
# CALIFORNIA HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,
# ENHANCEMENTS, OR MODIFICATIONS.
# 
#                                        PT_COPYRIGHT_VERSION_2
#                                        COPYRIGHTENDKEY
#######################################################################

#######################################################################
#### IDocSys
# 
#
#
class ::tycho::IDocSys {
    inherit ::tycho::TyDoc

    constructor {args} {}
    destructor {}
    
    ###################################################################
    ####                         public methods                    ####

    # Generate an index of the IDocumentation (in HTML) FIXME
    method generateIDocIndex { {title {"Index of classes"}}}

    ###################################################################
    ####                      public procs                         ####

    # Generate the IDocumentation for the files in $filelist
    public proc generateIDoc {debug generateIndex title filelist}

    # Return a list of all the classes defined in the given source file.
    public proc getClassesInSource {filename}

    # Return the DocSys type that generates IDocs for the given file.
    public proc generator {filename}

    # Check if the given file is newer than its related documentation.
    public proc modCheck {filename}

    ###################################################################
    ####                   protected methods                       ####
    
    # Format the class comment, removing tags and things.
    protected method formatClassComment {comment}

    # Format a description properly
    protected method formatDesc {comment}

    # Format an explanation properly (in HTML)
    protected method formatExpl {comment}

    # Uncapitalize and unpluralize a docTag (Authors -> author)
    protected method formatTag {docTag}

    # Format a description in a short form (when only an explanation is found).
    protected method shortDesc {comment}

    ###################################################################
    ####                   protected procs                         ####

    # ::tycho::safeUpdate copied here
    protected proc tydocUpdate {obj}

    ###################################################################
    ####                   protected variables                     ####

    # The author of the current source file
    protected variable author ""

    # The contributor(s) to the current source file
    protected variable contributor ""

    # The package the current source file belongs to
    protected variable package ""
    
    # The version of the current source file
    protected variable version ""

    # The first line of the copyright information from the current source file
    protected variable copyright ""

    # language for the current file
    protected variable language

    # an array of ::tycho::Class objects for this file
    protected variable myClass

    # true if there is outside class information
    protected variable relatedModified

    # The current source file name
    protected variable sourceFile
}

#######################################################################
#### constructor
#
body ::tycho::IDocSys::constructor {args} {
}

    ###################################################################
    ###################################################################
    ####                      public methods                       ####

#####################################################################
#### generateIDocIndex
# Fixme!
#
body ::tycho::IDocSys::generateIDocIndex { {title {"Index of classes"}}} {
# FIXME: FIXME: FIXME!
}


    ###################################################################
    ###################################################################
    ####                      public procedures                    ####

#####################################################################
#### generateIDoc
# Generate IDoc files for all the files named in filelist, placing the
# output in the doc/codeDoc subdirectory.
#
# If there are many files, catch errors and return all of the messages.
# If there is only one file, don't catch it so the user can trace the
# stack.
#
body ::tycho::IDocSys::generateIDoc {debug generateIndex title filelist} {
    set IDocSys ""

    set oneFileOnly [expr [llength $filelist] == 1] 

    if ![file isdirectory doc/codeDoc] {
        exec mkdir -p doc/codeDoc
    }
    set retval ""
    foreach filename $filelist {
        set generator [generator $filename]
        if {[info command $IDocSys] != {}} {
            if ![$IDocSys isa $generator] {
                delete object $IDocSys
                set IDocSys [$generator [::tycho::autoName IDocSys]]
            }
        } {
            # First file
            set IDocSys [$generator [::tycho::autoName IDocSys]]
        }

        if ![$generator::modCheck $filename] {
            # file does not need to be redocumented if not modified
            if $debug {
              #  puts "$filename <not modified>"
            }
            continue
        }

        if $debug {
            puts "$filename"
        }

        if ![file readable $filename] {
            set retval "$retval\nWarning: generateIDoc: $filename is not readable"
        } else {
            if {$oneFileOnly} {
                # Don't catch errors
                $IDocSys readFile $filename
                cd doc/codeDoc
                $IDocSys generateSingleFileIDoc $filename
                cd ../..
            } else {
                # Catch and accumulate errors for multiple files.
                if [catch {$IDocSys readFile $filename} errMsg] {
                    set retval "$retval\nWarning: $errMsg"
                } else {
                    cd doc/codeDoc
                    if [catch {$IDocSys generateSingleFileIDoc $filename} \
                            errMsg] {
                        set retval "$retval\nWarning: $errMsg"
                    }
                    cd ../..
                }
            }
        }
    }
    if {$generateIndex == 1} {
        cd doc/codeDoc
        # Uses the last IDocSys object...not implemented anyway. :)
        if [catch {$IDocSys generateIDocIndex $title} errMsg] {
            set retval "$retval\nWarning: $errMsg"
        }
        cd ../..
    }
    delete object $IDocSys
    return $retval
}

#####################################################################
#### generator
# Return the class name which generates ::tycho::Class models of the
# given file. Returns {} if none exists.
#
# NOTE: This should not be redefined in it's children, rather when 
# a new child is written, this method should be updated.
#
body ::tycho::IDocSys::generator {filename} {
    set extension [file extension $filename]

    # Note files with no extension are assumed to be Itcl or tcl scripts
    switch $extension {
        ".itcl" {return "::tycho::ItclDocSys"}
        ".itk"  {return "::tycho::ItclDocSys"}
        ".tcl"  {return "::tycho::ItclDocSys"}
        ".tk"   {return "::tycho::ItclDocSys"}
        ".java" {return "::tycho::JavaDocSys"}
        ""      {return "::tycho::ItclDocSys"}
    }
    return {}
}

#####################################################################
#### getClassesInSource
# Quickly scan the source file for the classes which are defined within.
#
# Calls the procedure in the appropriate child class for the given file
# extension.
#
body ::tycho::IDocSys::getClassesInSource {filename} {
    set generator [generator $filename]

    if {$generator != {}} {
        return [$generator::getClassesInSource]
    }

    error "Unsupported extension."
}

#####################################################################
#### modCheck
# Checks if the current file is newer than it's associated documentation.
# And returns 1 if so.
#
# This requires searching for all classes defined within the file and
# checking if those class's documents are older. In Itcl, this takes about 
# 5 percent of the time to create the docs.
#
# A more ideal system would check which classes need to be redocumented.
# However, there are few sources with more than one class so this is a
# decent compromise.
#
# Works by calling the appropriate subclass proc for the file extension.
#
# For unsupported files, it silently returns 1 because it can't tell.
#
body ::tycho::IDocSys::modCheck {filename} {
    set generator [generator $filename]

    if {$generator != {}} {
        return [$generator::modCheck $filename]
    }

    return 1
}

    ###################################################################
    ###################################################################
    ####                      protected procs                      ####

#######################################################################
#### tydocUpdate
# Safe update, local copy so we can run this in a script w/o Tycho.
# This is a copy of ::tycho::safeUpdate, see kernel/TopLevel.itcl.
#
body ::tycho::IDocSys::tydocUpdate {obj} {
    update
    if {$obj == {}} {return}
    # NOTE: Formerly used
    #   if {[uplevel #0 info objects $obj] == {} && ![winfo exists $obj]}
    if {[info which -command $obj] == {}} {
        # If you are having trouble with safeUpdate, uncomment the line below
        # error "::tycho::safeUpdate: command aborted: $obj does not exist"
        
        #::tycho::silentError
        set savetkerror [info body ::tkerror]
        proc ::tkerror {msg} "proc ::tkerror {msg} [list $savetkerror]"
        error silent   
    }
    return 0
}

    ###################################################################
    ###################################################################
    ####                     protected methods                     ####

#####################################################################
#### formatClassComment
# This method parses the 
# comment preceding the class definition, formatting it into HTML,
# removing the copyright, and creating the footer with tagged 
# information, including the first line of the copyright, the author,
# the contributors, and the version of the source file.
#
# If more than one class occupies a file, this information is
# saved. That is, if the tags are not redefined for a new class,
# some of the old information (author, contributors, copyright, and 
# version) is used.
#
body ::tycho::IDocSys::formatClassComment {expl} {
    # Parse line by line
    set explList [split $expl "\n"]
    set docTag desc
    foreach explLine $explList {
        if [regexp {^[ 	]*@([A-Za-z]+):*[ 	]+(.*)} \
		$explLine dummy docTag docValue] {
	    set explLine $docValue
            set docTag [formatTag $docTag]
	    # puts "ct: $docTag, cl: $docValue"
	}
	if {$docTag == "copyright"} {
	    if {[set $docTag] == "" } {
		# We save only the first line of the copyright
		append $docTag $explLine "\n"
            } else {
                if {[regexp {COPYRIGHTENDKEY} $explLine]} {
                    # ignore until the key
                    set docTag desc
                }
            }
        } else {
	    append $docTag $explLine "\n"
        }
    }
    
    set expl [formatExpl $desc]
    
    # Append the footer
    append expl <hr>
    if {$author != ""} {
        if {[llength $author] <= 2} {
            append expl "<br>Author: $author"
        } {
            append expl "<br>Authors: $author"
        }
    }
    if {$contributor != ""} {
        if {[llength $contributor] == 1} {
            append expl "<br>Contributor: $contributor"
        } {
            append expl "<br>Contributors: $contributor"
        }
    }
    if {$version != ""} {
        append expl "<br>Version: $version"
    }
    if {$copyright != ""} {
        append expl "<br>Copyright: $copyright"
    }

    return $expl
}

#####################################################################
#### formatTag
# Uncapitalize and singularize a docTag so that it can be added to the
# standard protected variables: copyright, author, contributor, version
# Do the same to strange ones (lowercase and remove trailing s's). 
# The error is encountered in the caller if it is an error.
#
body ::tycho::IDocSys::formatTag {docTag} {
    set docTag [string tolower $docTag]
    set docTag [string trimright $docTag "s"]
    return $docTag
}

#####################################################################
#### formatDesc 
# Format the description appropriately by removing carriage returns
# and returning a filler value if no description is found. (The IDoc
# viewer requires a description.)
#
body ::tycho::IDocSys::formatDesc {comment} {
    # remove carriage returns
    set commentList [split $comment "\n"]
    set comment [join $commentList " "]
    set comment [string trim $comment " "]

    if {$comment == {}} {
        # IDoc assumes all entities have a description
        return " "
    }

    # Catch comments that don't have a terminating period (or other
    # suitable mark)
    regsub "\(\[^\.?!>\]\)\[ \t\]*\$" $comment {\1.} comment

    # Remove HTML tags. 
    while "\[regexp \{^(.*)\[ 	\]*<\[^>\]*>\[ 	\]*(.*)\$\} \
            \$comment dmy first last\]" {
        set comment "$first $last"
    }

    return $comment
}

#####################################################################
#### formatExpl
# Format the explanation appropriately by substituting HTML tags for
# comment conventions such as _underlines_ and *asterisks*. Include a
# &lt;p&gt; tag for every empty line in a comment. Surround proc and
# method names with &lt;code&gt; tags.
#
body ::tycho::IDocSys::formatExpl {comment} {
    if {"$comment" == "\n"} {
        return {}
    }
    
    # Blank lines are a new paragraph
    # FIXME: we don't want this inside <pre> ... </pre>!
    regsub -all "\n\[ \t\]*\n" $comment "\n<p>" comment

    # Underscores delimit italicized text. Because of the way regsub
    # works, we have to do it twice to catch eg "_x_ _y_." We also
    # need to be careful to catch the start and end of the string.
    regsub -all {([^a-zA-Z0-9])_([^_]*)_([^a-zA-Z0-9])} $comment \
	    {\1<i>\2</i>\3} comment
    regsub -all {([^a-zA-Z0-9])_([^_]*)_([^a-zA-Z0-9])} $comment \
	    {\1<i>\2</i>\3} comment
    regsub {^_([^_]*)_([^a-zA-Z0-9])} $comment \
	    {<i>\1</i>\2} comment
    regsub {([^a-zA-Z0-9])_([^_]*)_$} $comment \
	    {\1<i>\2</i>} comment

    # Asterisks delimit _single_ program code words
    regsub -all {([^a-zA-Z0-9])\*([^\* ]*)\*([^a-zA-Z0-9])} $comment \
	    {\1<code>\2</code>\3} comment

    # A single word followed by {} is a method or proc name
    regsub -all {([a-zA-Z0-9_-]+)\{\}} $comment \
           {<code>\1</code>} comment


    return "$comment"
}

#####################################################################
#### shortDesc
# Format a description into a short form. Used when only an explanation
# is provided (like in outside/related procs).
#
# Only one of formatDesc and shortDesc need be called (short calls format)
#
body ::tycho::IDocSys::shortDesc {comment} {
    set comment [formatDesc $comment]

    # Return the first sentence.
    regexp {^([^.!?]*[.!?]+)[ 	]+} $comment dmy comment
    regexp {^(.*)@} $comment dmy comment

    return $comment
}
