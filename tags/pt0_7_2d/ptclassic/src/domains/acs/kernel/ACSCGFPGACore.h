/**********************************************************************
Copyright (c) 1999-2001 Sanders, a Lockheed Martin Company
All rights reserved.
 
Permission is hereby granted, without written agreement and without
license or royalty fees, to use, copy, modify, and distribute this
software and its documentation for any purpose, provided that the above
copyright notice and the following two paragraphs appear in all copies
of this software.
 
IN NO EVENT SHALL THE SANDERS, A LOCKHEED MARTIN COMPANY BE LIABLE TO ANY 
PARTY FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES 
ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF 
SANDERS, A LOCKHEED MARTIN COMPANY HAS BEEN ADVISED OF THE POSSIBILITY OF 
SUCH DAMAGE.
 
SANDERS, A LOCKHEED MARTIN COMPANY SPECIFICALLY DISCLAIMS ANY WARRANTIES,
INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE
PROVIDED HEREUNDER IS ON AN "AS IS" BASIS, AND SANDERS, A LOCKHEED MARTIN
COMPANY HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,
ENHANCEMENTS, OR MODIFICATIONS.
                                                        COPYRIGHTENDKEY
 
 
 Programmers:  Ken Smith
 Date of creation: 3/23/98
 Version: @(#)ACSCGFPGACore.h	1.2 09/08/99
***********************************************************************/
#ifndef _ACSCGFPGACore_h
#define _ACSCGFPGACore_h

#ifdef __GNUG__
#pragma interface
#endif

// JMS
#include <sys/types.h>
#include <unistd.h>
#include "StringArray.h"
#include "CoreList.h"
#include "Pipealign.h"
#include "ACSIntArray.h"
#include "Connection_List.h"
#include "Pin.h"
#include "Capability.h"
#include "Constants.h"
#include "Resource.h"
#include "Sg_Constructs.h"
#include "acs_vhdl_lang.h"
#include "acs_starconsts.h"

class VHDL_LANG;
class Capability;

#include "ACSCGCore.h"
#include "ACSWormhole.h"


// Global category string
extern const char ACSCGFPGACategory[];

class ACSCGFPGACore : public ACSCGCore {
public:
  // Debug switches
  static const int DEBUG_STARIO=0;

  /*virtual*/ int isA(const char*) const;
  
  // This is the default constructor for the FPGA core category.
  ACSCGFPGACore::ACSCGFPGACore(void);
  ACSCGFPGACore::ACSCGFPGACore(const char* category);

  // This is the flavor of constructor used by ACSCore* makeNew( ACSCorona & ).
  ACSCGFPGACore::ACSCGFPGACore(ACSCorona& corona_);

  ACSCGFPGACore::~ACSCGFPGACore();

  //
  // A set of unique identifier to this core smart generator
  //
  int acs_id;
  int comment_flag;
  ostrstream comment;
  int acs_origin;

  //
  // Determines if the component definition should be unique
  //   
  int unique_component;
  int declaration_flag;
  ostrstream unique_name;

  // Most of these attributes are intermediary between the Ptolemy
  // IO windows and the smart generators.  Refer to the Pins.
  int acs_type;     // SOURCE/SINK/BOTH, BOTHs are used for algorithms!!
  int acs_domain;
  int acs_state;    // For scheduling, does this core have a memory if so, then SAVE, else NO
  int acs_device;   // A numeric identifier specifying where the sg will reside
  int target_type;  // depicts particular type of fpga or memory
  int memory_device; // If this is a SOURCE/SINK, which memory it is associated with
  int acs_existence;
  int acs_speed;
  int sg_language;

  // Hierarchy related
  CoreList* child_sgs;

  // Implementation related
  int target_implementation;
  int implementation_lock;

  // Compilation related
  char* dest_dir;
  StringArray* child_filenames;
  int black_box;
  int bitslice_strategy;

  // Scheduler-related
  int act_input;    // Input activation time as dictated by the scheduler
  int act_output;   // Output activation time as dicated by the scheduler
  int act_launch;   // Launch rate, how often it will be activated
  int act_complete; // Marks the time when it no longer needs activation
  int acs_delay;    // Delay amount as determined by the smart generator
  int alg_delay;    // Delay amount that is dictated by the algorithm
  int pipe_delay;   // Delay amount that is dictated by the scheduler
  int phase_dependent; // Determines which phase in a given sequence it should activate
  int delay_offset; // If phase dependent, the output may be produced at input time
  Pipealign* pipe_alignment;

  // Partitioning-related

  // Delay class - handles intermediate delays assigned by the scheduler
  //               NOT the delays generated by the smart generator!
  //               ASSUMPTION:delays are contiguous
  int acsdelay_count;
  ACSIntArray* acsdelay_ids;
 
  // Data class - handles I/O information concerning values
  int address_start;
  int address_step;
  int word_count;
 
  // Setup related
  int initialized;
  int lib_queried;
  int macro_queried;

  // Mechanical growth related
  int bw_dirty;
  int bw_exempt;
  int bw_loop;
 
  // Resolver related

  // Smart generator working variables
  int sign_convention;          //FIX:Pin specific?
  int total_count;
  int input_count;              // Requests for parameterized port sizes
  int output_count;
  int control_count;
  int bidir_count;
  StringArray* libs;
  StringArray* incs;
  ostrstream sg_declarative;
  ostrstream sg_body;
  Pin* pins;
  Pin* ext_signals;
  Pin* data_signals;
  Pin* ctrl_signals;
  Pin* constant_signals;
  Resource* resources;
  Capability* sg_capability;   // Store language capability information
  Constants* sg_constants;     // Constant information
  VHDL_LANG* lang;             //FIX: For now default to VHDL


  // Smart generator working variables for cost
  char* root_filename;
  char* cost_filename;
  char* numsim_filename;
  char* rangecalc_filename;
  char* natcon_filename;
  char* schedule_filename;

  // Core-based methods
  char* ACSCGFPGACore::comment_name(void);
  char* ACSCGFPGACore::name(void);
  char* ACSCGFPGACore::lc_name(void);
  char* ACSCGFPGACore::make_name(const char*,const int);
  int ACSCGFPGACore::vector_length(double);
  int ACSCGFPGACore::intparam_query(const char*);
  void ACSCGFPGACore::intparam_set(const char*,int);

  // Smart generator-based methods:
  int ACSCGFPGACore::sg_param_query(void);
  int ACSCGFPGACore::add_comment(const char*);
  int ACSCGFPGACore::add_comment(const char*,const int);
  int ACSCGFPGACore::add_comment(const char*,const char*);
  int ACSCGFPGACore::add_comment(const char*,const char*,const int);
  int ACSCGFPGACore::update_sg(const int, const int);
  int ACSCGFPGACore::sg_delay(void);
  int ACSCGFPGACore::sg_delay_query(void);
  int ACSCGFPGACore::sg_io_query(void);
  int ACSCGFPGACore::sg_initialize(void);
  int ACSCGFPGACore::sg_initialize(char*,
				   int*);
  int ACSCGFPGACore::sg_costfunc(int);
  int ACSCGFPGACore::bits_overlap(const int, const int,
		   const int, const int);
  char* ACSCGFPGACore::tolowercase(char*);
  int ACSCGFPGACore::fpga_type(void);

  // Pin accessor/modifier methods
  Pin* ACSCGFPGACore::get_pin_handle(void);
  Pin* ACSCGFPGACore::dup_pins(void);
  int ACSCGFPGACore::replace_pintype(const int, const int);
  int ACSCGFPGACore::replace_pintypes(ACSIntArray*);
  int ACSCGFPGACore::alter_pintype(const int, const int);
  int ACSCGFPGACore::find_hardpin(const int);
  int ACSCGFPGACore::find_hardpin(const int, const int);
  int ACSCGFPGACore::set_precision(const int, const int, const int, const int);
  int ACSCGFPGACore::set_pinpriority(const int, const int);

  virtual ACSIntArray* ACSCGFPGACore::sg_get_privaledge(void)
    {
      printf("WARNING:sg_get_privaledge not implemented for core %s\n",comment_name());
      return(0);
    }
  virtual ACSIntArray* ACSCGFPGACore::sg_get_privaledge(const int)
    {
      printf("WARNING:sg_get_privaledge not implemented for core %s\n",comment_name());
      return(0);
    }
  virtual int ACSCGFPGACore::sg_set_privaledge(const int, const int)
    {
      printf("WARNING:sg_set_privaledge not implemented for core %s\n",comment_name());
      return(0);
    }
  virtual int ACSCGFPGACore::sg_set_privaledge(const int, const int, const int)
    {
      printf("WARNING:sg_set_privaledge not implemented for core %s\n",comment_name());
      return(0);
    }
  virtual int ACSCGFPGACore::sg_add_privaledge(const int)
    {
      printf("WARNING:sg_add_privaledge not implemented for core %s\n",comment_name());
      return(0);
    }
  virtual int ACSCGFPGACore::sg_add_privaledge(const int, const int)
    {
      printf("WARNING:sg_add_privaledge not implemented for core %s\n",comment_name());
      return(0);
    }
  virtual int ACSCGFPGACore::sg_cost(ofstream&,
				     ofstream&,
				     ofstream&,
				     ofstream&,
				     ofstream&) 
    { 
      printf("WARNING:sg_cost not implemented for core %s\n",comment_name());
      return(0);
    };
  virtual int ACSCGFPGACore::sg_bitwidths(int) 
    { 
      return(0);
    };
  virtual int ACSCGFPGACore::sg_designs(int)
    { 
      return(0);
    };
  virtual int ACSCGFPGACore::sg_delays(void)
    { 
      return(0);
    };
  virtual int ACSCGFPGACore::sg_setup(void) 
    {
      return(0);
    };
  virtual int ACSCGFPGACore::sg_param_query(StringArray*,StringArray*) 
    {
      return(0);
    };
  virtual int ACSCGFPGACore::macro_query(void) 
    {
      return(NORMAL_STAR);
    };
  virtual CoreList* ACSCGFPGACore::macro_build(int*) 
    {
      return(NULL);
    };
  virtual CoreList* ACSCGFPGACore::macro_build(int*, int*) 
    {
      return(NULL);
    };
  virtual Connection_List* ACSCGFPGACore::macro_connections(void)
    {
      return(NULL);
    };
  virtual int ACSCGFPGACore::revisit_pins(void)
    {
      return(1);
    };
  virtual int ACSCGFPGACore::acs_build(void) 
    {
      return(0);
    };

//JR
//add definitions for virtuals declared in ACSCGCore	
	/* virtual */ StringList setargStates(Attribute a=ANY);

protected:
	// Generate declarations for PortHoles and States.
        /* virtual */ StringList declareBuffer(const ACSPortHole*) ;
        /* virtual */ StringList declareOffset(const ACSPortHole*) ;
        /* virtual */ StringList declareState(const State*) ;
 
        // Generate declaration, initilization and function
        // codes for command-line settable states.
        /* virtual */ StringList cmdargState(const State*) ;
        /* virtual */ StringList cmdargStatesInit(const State*) ;
        /* virtual */ StringList setargState(const State*) ;
        /* virtual */ StringList setargStatesHelp(const State*) ;
 
        // Generate initialization code for PortHoles and States.
        /* virtual */ StringList initCodeBuffer(ACSPortHole*) ;
        /* virtual */ StringList initCodeOffset(const ACSPortHole*) ;
        /* virtual */ StringList initCodeState(const State*) ;
 
        /* virtual */ StringList portBufferIndex(const ACSPortHole*) ;
        /* virtual */ StringList portBufferIndex(const ACSPortHole*, const State
*, const char*) ;
 
        /* virtual */ StringList arrayStateIndexRef(const State*, const char*) ;
};


// JMS-added
// class CGStarMPHIter : public BlockMPHIter {
// public:
//         CGStarMPHIter(CGStar& s) : BlockMPHIter(s) {}
//         CGPortHole* next() { return (CGPortHole*)BlockMPHIter::next();}
//         CGPortHole* operator++(POSTFIX_OP) { return next();}
//};

#endif
