\input texinfo.tex      @c -*-texinfo-*-
@c %**start of header
@setfilename mcg.info
@settitle Multiprocessor Code Generation in Ptolemy
@setchapternewpage off
@c version: $Id$
@c %**end of header

@iftex
@finalout
@titlepage
@title Multiprocessor Code Generation in Ptolemy
@subtitle A programmer's companion for Ptolemy 0.5 development
@subtitle May, 1993
@author by Soonhoi Ha
@end iftex

@node Top, Overview, (dir), (dir)

This document describes the routines for multiprocessor, homogeneous or
heterogeneous, code generation in Ptolemy. As an illustration, C-code
generation domains are explained. The principal audience for
this document is programmers who maintain or 
seek to extend Ptolemy in major ways
(e.g. write a new domain or a new parallel scheduler), or who seek a
deeper understanding of how the code generation kernel works.  
A detailed knowledge of C++, the Ptolemy kernel, and the SDF domain
is assumed. As of this writing, a code-generation domain can not
have wormholes of other domains but CGDDF domain. So, when a wormhole
of a code generation is mentioned in the documentation, it should be
understood as a wormhole of CGDDF domain.

@iftex
@vskip 0pt plus 1filll
@end iftex

Copyright @copyright{} 1990, 1991, 1992 The Regents of the University of
California.  All rights reserved.

Permission is hereby granted, without written agreement and without
license or royalty fees, to use, copy, modify, and distribute this
software and its documentation for any purpose, provided that the above
copyright notice and the following two paragraphs appear in all copies of
this software.

IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY FOR
DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING
OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF THE
UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
DAMAGE.

THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANT ABILITY
AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE PROVIDED HEREUNDER IS
ON AN ``AS IS'' BASIS, AND THE UNIVERSITY OF CALIFORNIA HAS NO OBLIGATION
TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.

@iftex
@end titlepage
@end iftex

@menu
* Overview::              	Overview of parallel code generation
* APEG generation::		Generation of an APEG graph from an SDF graph
* Parallel Schedulers::         Parallel Scheduling Procedure
* Base Classes for Code Generation:: 
* Target ::          		Target Definition
* Heterogeneous Support::	Focus on heterogeneous code generation.
* CGC Domain::			C-code generation domain for example
* CGDDF Domain::		CGDDF domain in Ptolemy
* CGdsp3 Domain::		CGdsp3 domain in Ptolemy
* Status::			Comments on the current status
* References::			references
@end menu

@node Overview, APEG generation, Top, Top
@chapter Overview of Parallel Code Generation

This chapter describes the overall procedure of parallel code generation
in Ptolemy. We start with an SDF program graph and a multiprocessor
target description. In the target definition, we specify the number of
processors and some information about the processors with target parameters.
If the number of processor is given 1, it is classified as a sequential
code generation problem: a chosen
SDF scheduler schedules the graph and code is generated based on the
scheduling result. Parallel code generation is a bit more complicated.

If the number of processor is greater than 1, we create an APEG (acyclic
precedence expanded graph) associated with the SDF program graph. The APEG
graph displays all precedence relations between invocations of the SDF
stars. All parallel schedulers take this APEG graph as an input graph
and generate the schedule. In Ptolemy, we can have many scheduling
algorithms (currently 3), and choose one by setting the appropriate
target parameters. There is a common framework all parallel scheduling
algorithm should be fit into (@pxref{Parallel Schedulers}). The scheduling
result indicates the assignment and the ordering of star invocations
in the processors. The next step is to generate code for each processor
based on the scheduling result.

We create an SDF @emph{sub-universe} for each processor. The sub-universe
consists of stars assigned to the processor and some other automatically
inserted stars, for example send and receive stars for interprocessor
communication. We apply the sequential code generation routine for
each processor with the associated sub-universe.

We may generate parallel codes inside a wormhole so that the main
workstation can communicate with the target multiprocessor system. 
Then, the wormhole interface code should be added to the generated code.
Another possibility of using the wormhole mechanism was to generate code
for dynamic constructs with CGDDF domain. Ptolemy supports 4 dynamic 
constructs in CGDDF domain: @emph{case, for, do-while, recur}.

The following chapter will explain each steps in significant detail with
code segments.
 
@node APEG generation, Parallel Schedulers, Overview, Top
@chapter APEG generation

Since all code generation domains depends on the SDF domain, and 
the same routine is needed by a specialized loop scheduler in the SDF
domain ($(PTOLEMY)/src/domains/sdf/loopScheduler), the source of APEG 
generation is placed in $(PTOLEMY)/src/domains/sdf/expgraph.

An APEG graph (an ExpandedGraph class) consists of EGNodes and 
EGGates. Class EGNode represents
an object corresponding to an invocation of a DataFlowStar (DataFlowStar
is a base class of SDFStar class). An EGNode has a list of EGGates.
EGGate class is similar to PortHole class in the respect that it
is an object for connection between EGNodes. Between two EGGates,
there exists an EGArc object. All connections in an APEG
graph is homogeneous. If there is a sample rate change on an arc in the
SDF program graph, the arc is mapped to several homogeneous arcs.
APEG generation routines are defined as member methods of the ExpandedGraph
class.

Refer to @ref{class ExpandedGraph}, to see the main discussion of APEG
generation.

@menu
* class EGArc::			class EGArc
* class EGGate::		class EGGate
* class EGNode::		class EGNode
* class ExpandedGraph::		class ExpandedGraph
@end menu

@node class EGArc, class EGGate, APEG generation, APEG generation
@section Class EGArc

Class EGArc contains the information of (1) sample rate
of the arc and (2) the initial delay on the arc.

@example
EGArc(int @var{arc_samples}, int @var{arc_delay});
@end example

The constructor requires two arguments for sample rate and the
number of initial delays on the arc.

@example
int samples();
int delay();
@end example

These functions return the sample rate of the arc, and the
initial delay on the arc. We can increase the sample rate of the
arc using the following method

@example
void addSamples(int @var{increments});
@end example

There is no protected members in Class EGArc.

@node class EGGate, class EGNode, class EGArc, APEG generation
@section Class EGGate

Class EGGate is a terminal in an EGNode for connection with other
EGNodes. A list of EGGates will become a member of EGNode, called
@code{ancestors} or @code{descendants} based on the direction of connection.

@menu
* EGGate public members::	EGGate public members
* class EGGateList::		a list of EGGates
@end menu

@node EGGate public members, class EGGateList, class EGGate, class EGGate
@subsection EGGate public members

@example
EGGate(EGNode* @var{parent}, PortHole* @var{pPort});
@end example

Is a constructor. The first argument is the EGNode that this EGGate
belongs to, and the second argument is the corresponding porthole of
the original SDF graph.

@example
const PortHole* aliasedPort();
const char* name() const;
@end example

The above methods returns the corresponding porthole of the original
SDF graph, the name of the porthole.

@example
int isItInput();
@end example

Returns TRUR or FALSE based on the corresponding porthole is an
input or not.

@example
void allocateArc(EGGate* @var{dest}, int @var{no_samples}, int @var{no_delay});
@end example

The method creates a connection between this EGGate and the first
argument by allocating an arc with information from the second and 
the third arguments. It should be called once per connection.

@example
int samples();
int delay();
void addSamples(int @var{increments});
@end example

These methods call the corresponding methods of the EGArc class if
an arc was already allocated by @code{allocateArc}.

@example
EGGate* farGate();
EGNode* farEndNode();
DataFlowStar* farEndMaster();
int farEndInvocation();
@end example

The above methods querry information about the other side of the connection:
EGGate, EGNode, the original DataFlowStar that the EGNode points to, and
the invocation number of the EGNode. 

@example
StringList printMe();
@end example

It prints the information of the arc allocated: the sample rate and
the initial delay.

@example
void setProperty(PortHole* @var{pPort}, int @var{index});
@end example

This method sets the pointer to the corresponding porthole of the original
SDF graph and the index of the EGGate. Since multiple EGGates in an
EGNode may be mapped to the same porthole in the original SDF graph,
we order the EGGates by indices.

@example
void setLink(EGGateLink* @var{p});
EGGateLink* getLink();
@end example

Since the list of EGGates is maintained as a derived class of DoubleLinkList,
an EGGate is assigned an EGGateLink that is derived from the DoubleLink class.
These methods set and get the assigned EGGateLink.

@example
void hideMe(int @var{flag});
@end example

If the initial delay is greater than or equal to the sample rate in an EGArc,
the precedence relationship between the source and the destination of
the arc disappears while not removing the arc from the APEG. This method
removes this EGGate from the access list of EGGates (@code{ancestors} or
@code{descendants}), and stores it in
the list of hidden EGGates (@code{hiddenGates}) of the parent 
EGNode (@pxref{class EGNode}). 
If the argument flag is NULL,
it calls the same method for the EGGate of the other side of connection.
By default, the flag is NULL.

@example
virtual ~EGGate();
@end example

Is a virtual destructor that deletes the allocated arc, removes itself
from the list of EGGates.

@node class EGGateList, , EGGate public members, class EGGate
@subsection Class EGGateList

This class, derived from DoubleLinkList, contains a list of EGGates.
An EGGate is assigned to an EGGateLink and the EGGateList class
accesses an EGGate through the assigned EGGateLink. 

The following ordering is maintained in the precedence list:
entries for the same far-end
EGNode occur together (one after another), and they occur in order of
increasing invocation number. Entries for the same invocation occur in
increasing order of the number of delays on the arc.

@menu
* class EGGateLink::		class EGGateLink
* EGGateList public members::	EGGateList public members
* Iterator for EGGateList::	iterator for EGGateList
@end menu

@node class EGGateLink, EGGateList public members, class EGGateList, class EGGateList
@subsubsection class EGGateLink

@example
EGGateLink(EGGate* @var{e});
@end example

The constructor has an argument for an EGGate. 

@example
EGGate* gate();
EGGateLink* nextLink();
@end example

These methods return the corresponding EGGate and the next link in the parent
list.

@example
void removeMeFromList();
@end example

Removes this link from the parent list.

@node EGGateList public members, Iterator for EGGateList, class EGGateLink, class EGGateList
@subsubsection EGGateList public members

Class EGGateList has a default constructor. 

@example
void initialize();
@end example

This method deletes all EGGates in the list and initialize the list.
It is called inside the destructor.

@example
DoubleLink* createLink(EGGate* @var{e});
@end example

Creates an EGGateLink for the argument EGGate.

@example
void insertGate(EGGate* @var{e}, int @var{update});
@end example

This method insert a new EGGate into the proper position in the precedence
list. The update parameter indicates whether or not to update the arc
data if an EGGate with the same far-end EGNode and delay, already exists.
If @var{update} is 0, the argument EGGate will be deleted if redundant.
If 1, the arc information of the existing EGGate will be updated (sample
rate will be increased). When we insert an EGGate to the
@code{descendants} list of the parent EGNode, we set @var{update} to be 1.
If the EGGate will be added to the @code{ancestors}, the variable is set 0.

@example
StringList printMe();
@end example

Prints the list of EGGates.

@node Iterator for EGGateList, , EGGateList public members, class EGGateList
@subsubsection Iterator for EGGateList

Class EGGateLinkIter is derived from class DoubleLinkIter. The constructor
has an argument of the reference to a constant EGGateList object. It returns
EGGates. This class has a special method to return the next EGGate connected
to a new @code{farEndMaster} that is different from the argument DataFlowStar.

@example
EGGate* nextMaster(DataFlowStar* @var{master});
@end example

@node class EGNode, class ExpandedGraph, class EGGate, APEG generation
@section Class EGNode

Class EGNode is a node in an APEG, corresponding to an invocation of a
DataFlowStar in the original SDF graph. The constructor has two arguments:
the first argument is the pointer to the original Star of which it is an
invocation, and the second argument represents the invocation number.
The default value for the invocation number is 1. It has a virtual
destructor that does nothing in this class.

An EGNode maintains three public lists of EGGates: @code{ancestors},
@code{descendants}, and @code{hiddenGates} (@pxref{class EGGate}).

@menu
* other EGNode public members::		other EGNode public members
* class EGNodeList::			class EGNodeList
@end menu

@node other EGNode public members, class EGNodeList, class EGNode, class EGNode
@subsection Other EGNode public members

Invocations of the same DataFlowStar are linked together.

@example
void setNextInvoc(EGNode* @var{next});
EGNode* getNextInvoc();
EGNode* getInvocation(int @var{i});
void setInvocationNumber(int @var{i});
int invocationNumber();
@end example

The first two methods sets and gets the next invocation EGNode. The third
method searches through the linked list starting from the current EGNode
to return the invocation with the argument invocation number. If the
argument is less than the invocation number of the current EGNode, returns 0.
The other methods sets and gets the invocation number of the current EGNode.

@example
void deleteInvocChain();
@end example

Deletes all EGNodes linked together starting from the current EGNode.
This method is usually called at the EGNode of the first invocation. 

@example
StringList printMe();
StringList printShort();
@end example

These methods print the name and the invocation number. In the first method,
the @code{ancestors} and @code{descendants} lists are also printed.

@example
DataFlowStar* myMaster();
@end example

Returns the original DataFlowStar of which the current EGNode is an
invocation.

@example 
int root();
@end example

This method returns TRUE or FALSE, based on this node is a root of the
APEG. A node is a root if it either has no ancestors, or if each arc
in the ancestor list has enough delay on it.

@example
EGGate* makeArc(EGNode* @var{dest}, int @var{samples}, int @var{delay});
@end example

Create a connection from this node to the first argument node. A pair of
EGGates and an EGArc are allocated in this method. This EGNode
is assumed to be the source of the connection. 

@example
void resetVisit();
void beingVisited();
int alreadyVisited();
@end example

The above methods manipulates a flag for traversal algorithms: resets to 0,
sets to 1, or querries the flag.

@example
void claimSticky();
int sticky();
@end example

These methods manipulates another flag to indicate that the invocations
of the same DataFlowStar may not be scheduled into different processors
since there is a strong interdependency between them. The first method
sets the flag and the second querries the flag.

@node class EGNodeList, , other EGNode public members, class EGNode
@subsection EGNodeList

Class EGNodeList is derived from class DoubleLinkList. 

@example
void append(EGNode* @var{node});
void insert(EGNode* @var{node});
@end example

These methods appends or inserts the argument EGNode to the list.

@example
EGNode* takeFromFront();
EGNode* headNode();
@end example

The above methods both returns the first EGNode in the list. The first method
removes the node from the list while the second method does not.

There is a iterator class for the EGNodeList class, called EGNodeListIter.
It returns the EGNodes.

@node class ExpandedGraph, , class EGNode, APEG generation
@section class ExpandedGraph

Class ExpandedGraph has a constructor with no argument and a virtual
destructor that deletes all EGNodes in the graph. 

The major method to generate an APEG is 

@example
virtual int createMe(Galaxy& @var{galaxy}, int @var{selfLoopFlag});
@end example

The first argument is the original SDF galaxy of which the pointer will
be stored in a protected member @code{myGal}. The second argument
enforces to make arcs between invocations of the same star regardless
of the dependency. The procedure of APEG generation is as follows.
(1) initialize the APEG graph.

@example
virtual void initialize();
@end example

Does nothing here, but will be redefined in the derived class if necessary.

(2) Allocate all invocations (EGNodes) of the blocks in the original SDF
graph. Keep the list of the first invocations of all blocks in the protected
member @code{masters}. 

@example
virtual EGNode *newNode(DataFlowStar* @var{star}, int @var{invoc_index});
@end example

Is used to create an invocation of a DataFlowStar given as the first
argument. The second argument is the invocation number of the node.
This method is virtual since the derived ExpandedGraph class may have
derived classes from the EGNode class.

(3) For each star in the original SDF graph, 
    (3-1) Make connections between invocations of the star if any one of the
          conditions is met: @var{selfLoopFlag} is set in the second argument,
          the star has internal states, the star accesses past values on its
          portholes, or the star is a wormhole. The connection made in this
          stage does not indicate the flow path of samples, but the
          precedence relation of two EGNodes. Therefore, EGGates associated
          with this connection are not associated with portholes in the
          original SDF graph. If the connections are made, 
          the @code{claimSticky} method of EGNode class is called for each
          invocation EGNode. If any such connection is made, the APEG
          is said not-parallelizable as a whole: A protected member,
          @code{parallelizable}, is set FALSE.

    (3-2) For each input porthole, get the far-side output porthole and make
          connections between invocations of two DataFlowStars. A connection
          in the original SDF graph may be mapped to several connections
          in the APEG since the APEG is homogeneous. 

(4) Find the root nodes in the APEG and stored in its protected member
    @code{sources}.

@example
void insertSource(EGNode* @var{node});
@end example

Inserts the argument EGNode into the source list, @code{sources}, of 
the graph.
 
All protected members are explained above.

@menu
* other ExpandedGraph public members::	other ExpandedGraph public members
* Iterators for ExpandedGraph::		Iterators for ExpandedGraph
@end menu

@node other ExpandedGraph public members, Iterators for ExpandedGraph, class ExpandedGraph, class ExpandedGraph
@subsection Other ExpandedGraph public members

@example
int numNodes();
@end example

This method returns the number of total nodes in the APEG.

@example
virtual StringList display();
@end example

Displays all EGNodes by calling @code{printMe} method of EGNode class.

@example
virtual void removeArcsWithDelay();
@end example

This method hide all connections that have delays on them. When an APEG
is created, the number of initial delays on an arc, if exists, is 
always greater than or equal to the sample rate of the arc. Therefore,
this method is used to make the APEG actually acyclic.

@node Iterators for ExpandedGraph, , other ExpandedGraph public members, class ExpandedGraph
@subsection Iterators for ExpandedGraph

There are three types of iterators associated with an ExpandedGraph:
EGMasterIter, EGSourceIter, and EGIter. As its name suggests, 
EGMasterIter returns  the EGNodes in @code{masters} list of the
graph. EGSourceIter returns the EGNodes in @code{sources} list of the 
graph. Finally, EGIter returns all EGNodes of the ExpandedGraph.

EGMasterIter and EGSourceIter are derived from EGNodeListIter. EGIter,
however, is not derived from any class. Instead, EGIter uses
EGMasterIter to get the first invocation of each DataFlowStar in the
original SDF graph and traverse the linked list of invocations. Thus
invocations are traversed master by master.

@node Parallel Schedulers, Base Classes for Code Generation, APEG generation, Top
@chapter Parallel Schedulers

Base classes for parallel schedulers can be found in $(PTOLEMY)/src/domains/
cg/parScheduler. All parallel schedulers use an APEG as the input. The
APEG for parallel schedulers is called ParGraph, which is derived from
class ExpandedGraph. Class ParNode, derived from class EGNode, is a node
in a ParGraph.

The base scheduler object is ParScheduler. Since it is derived from class
SDFScheduler, it inherits many methods and members from the SDFScheduler
class. The ParScheduler class has a ParProcessors class that has
member methods to implement the main scheduling algorithm. The ParProcessors
class has an array of UniProcessor class. The UniProcessor class,
privately derived from class DoubleLinkList, is mapped to a
processing element in the target architecture.

Note that all parallel scheduling algorithms are retargettable:
they do not assume any specific topology while they take the effect
of topology into account to estimate the interprocessor communication
overhead. 

Refer to @ref{class ParScheduler}, to see the overall procedure of parallel
scheduling. Refer to @ref{class UniProcessor}, to see the procedure of
sub-universe generations.

@menu
* class ParNode::		class ParNode
* class ParGraph::		class ParGraph
* class ParScheduler::		class ParScheduler, overall procedure
* class ParProcessors::		class ParProcessors, scheduling algorithm
* class UniProcessor::		class UniProcessor
* Dynamic Level Scheduler::	Sih's dynamic level scheduling algorithm
* Hu's Level Scheduler::	Hu's static level scheduling algorithm
* Declustering Scheduler::	Sih's declustering algorithm
@end menu

@node class ParNode, class ParGraph, Parallel Schedulers, Parallel Schedulers
@section ParNode

This class represents a node in the APEG for parallel schedulers, thus 
contains additional members for parallel scheduling besides what are
inherited from class EGNode. It has the same two-argument 
constructor as class EGNode.

@example
ParNode(DataFlowStar* @var{master}, int @var{invoc});
@end example

Initializes data members. If the argument star is at the wormhole
boundary, we do not parallelize the invocations. Therefore, we create
precedence relations between invocations by calling @code{claimSticky}
of EGNode class in the constructor. If this constructor is called,
the @code{type} protected member is set 0.

The ParNode class has another constructor with one argument.

@example
ParNode(int @var{t});
@end example

The scheduling result is stored in UniProcessor class as a list of
ParNodes. This constructor is to model idle time (@var{t} = 1), or
communication time(@var{t} = -1 for sending time, @var{t} = -2
for receiving time) as a ParNode. The @code{type} protected member
is set to @var{t}. It initializes data members.

@menu
* ParNode protected members::		ParNode protected members
* other ParNode public members::	other ParNode public members
* Iterators for ParNode::		Iterators for ParNode
@end menu

@node ParNode protected members, other ParNode public members, class ParNode, class ParNode
@subsection ParNode protected members

@example
int StaticLevel;
@end example

Is set to the longest execution path to a termination node in the APEG.
It defines the static level (or priority) of the node in the 
Hu's scheduling algorithm. Initially it is set 0.

@example
int procId
@end example

Is the processor index on which this ParNode is scheduled. Initially it
is set 0.

@example
int scheduledTime;
int finishTime;
@end example

Indicates when the node is scheduled and finished. 

@example
int exTime;
@end example

Is the execution time of the node. If it is a regular node (@code{type} = 0),
it is set to the execution time of the original DataFlowStar. Otherwise,
it is set 0.

@example
int waitNum;
@end example

Indicates the number of ancestors to be scheduled before scheduling this node.
during the scheduling procedure. Initially it is set 0. 
At a certain point of scheduling procedure,
we can schedule a ParNode only when all ancestors are already assigned, or
@code{waitNum} is 0.

@example
EGNodeList tempAncs;
EGNodeList tempDescs;
@end example

These list members are copies of the ancestors and descendants of the node.
While EGGateLists, @code{ancestors} and @code{descendants}, may not
be modified during scheduling procedure, these lists can be modified.

@node other ParNode public members, Iterators for ParNode, ParNode protected members, class ParNode
@subsection Other ParNode public members

There are a group method to manipulate the member variables.

@example
void assignSL(int @var{sl});
int getSL();
virtual int getLevel();
@end example

The first two methods set and get the @code{StaticLevel} member.
The last one returns the priority of the node, which is just
@code{StaticLevel} by default. In the derived classes, this method
can be redefined, for example in Dynamic Level Scheduling
(@pxref{Dynamic Level Scheduler}) to return the dynamic level of the node.

@example
int getType();
@end example

Returns the type of the node.

@example
void setProcId(int @var{id});
int getProcId();
virtual int whichProc();
virtual void assignProc(int @var{id});
@end example

The first two methods set and get the @code{procId} member. The last
two methods are virtual methods to do the same thing as the first two
methods. In the Declustering algorithm (@pxref{Declustering Scheduler}),
they are redefined to store the temporary information of the processor
assignment.

@example
void setScheduledTime(int @var{t});
int getScheduledTime();
void setFinishTime(int @var{t});
int getFinishTime();
@end example

These methods are used to set or get the time when the node is
scheduled first and finished.

@example
void setExTime(int @var{t});
int getExTime();
@end example

These methods are used to set and get the execution time of the node.

@example
void resetWaitNum();
void incWaitNum();
@end example

Resets the @code{waitNum} variable to the number of ancestors, and
increases it by 1.

@example
int fireable();
@end example

This method decreases @code{waitNum} by one, and return TRUE or FALSE,
based on whether @code{waitNum} reaches zero or not. If it reaches 0,
the node is declared "fireable".

@example
void copyAncDesc(ParGraph* @var{g}, int @var{flag});
void removeDescs(ParNode* @var{n});
void removeAncs(ParNode* @var{n});
void connectedTo(ParNode* @var{n});
@end example

The first method initializes the lists of temporary ancestors and
descendants, @code{tempAncs} and @code{tempDescs}, from 
@code{ancestors} and @code{descendants} that are inherited members from
EGNode class. List @code{tempAncs} is sorted smallest @code{StaticLevel}
first while list @code{tempDescs} is sorted largest @code{StaticLevel}
first. The first argument is necessary to call the sorting routine which
is defined in the ParGraph class (@pxref{class ParGraph}). By virtue of
sorting, we can traverse descendant with larger @code{StaticLevel} first.
If the second argument is not 0, we switch the lists: copy 
@code{ancestors} to @code{tempDecsc} and @code{descendants} to
@code{tempAncs}.

The second and the third methods remove the argument node from the
temporary descendant list or from the temporary ancestor list. In the latter
case, we decrease @code{waitNum} by one.

The last method above is to make a temporary connection between the 
node as the source and the argument node as the destination. The temporary
descendant list of the current node is added the argument node while the
temporary ancestor list of the argument node is added the current node (also
increase @code{waitNum} of the argument node by 1).

@example
CGStar* myStar();
@end example

Returns the original DataFlowStar after casting the type to CGStar, star
class type of the CG domain.

@example
int atBoundary();
@end example

Returns TRUE or FALSE, based on whether @code{myStar} is at the wormhole
boundary or not.

@example
int amIBig();
Profile* profile();
void withProfile(Profile* @var{p});
@end example

The first method returns TRUE or FALSE, based on whether @code{myStar} is
a wormhole or not. If the original graph contains a dynamic construct
(@pxref{CGDDF Domain}), the dynamic construct resides in a wormhole.
Before the scheduling is performed in the top-level graph, the wormhole
executes scheduling the inside galaxy and stores the scheduling results
in the Profile object (@pxref{class Profile}). The ParNode keeps the pointer
to the Profile object if it is an invocation of the wormhole. The second
and the third methods gets and sets the pointer to the Profile. In the
general context, the node will be considered "Big" if the master star
can be scheduled onto more than one processors. Then, the star
is supposed to keep the Profile object to store the schedules on the
processors. A wormhole is a special case of those masters.

@example
void setOSOPflag(int @var{i});
int isOSOP();
@end example

After scheduling is performed, we set a flag to indicate whether all
invocations of a star are assigned to the same processor or not, using the
first method. The second method querries the flag. Note that only the
@emph{first} invocation has the valid information.

@example
void setCopyStar(DataFlowStar* @var{s}, ParNode* @var{prevNode});
DataFlowStar* getCopyStar();
ParNode* getNextNode();
ParNode* getFirstNode();
int numAssigned();
@end example

The above methods are used to create sub-universes 
(@pxref{Sub-Universe creation}). When we create a sub-universe, we make a
copy of the master star if some invocations are assigned to the processor.
Then, these invocations keep the pointer to the cloned star. Since
all invocations may not be assigned to the same processor, we maintain
the list of invocations assigned to the given processor. The first and
second methods set and get the pointer to the cloned star. The first method
also make a chain of the invocations assigned to the same processor.
The third method returns the next invocation chained from the current node,
while the fourth method returns the starting invocation of the chain. The
last method returns the total number of invocations in the chain. It should
be called at the starting invocation of the chain.

@example
void setOrigin(EGGate* @var{g});
EGGate* getOrigin();
void setPartner(ParNode* @var{n});
ParNode* getPartner();
@end example

These methods manipulate the connection information of communication nodes.
If two adjacent nodes in an APEG are assigned to two different processors,
we insert communication nodes between them: Send and Receive nodes. As
explained earlier, a communication node is created by one-argument
constructor. The
first two methods are related to which EGGate the communication node is
connected. The last two methods concerns the other communication node
inserted.

@node Iterators for ParNode, , other ParNode public members, class ParNode
@subsection Iterators for ParNode

There are two types of iterators associated with ParNode class: 
ParAncestorIter, ParDescendantIter. As their names suggest, ParAncestorIter
class returns the ParNodes in the temporary ancestor list (@code{tempAncs}),
and ParDescendantIter class returns the ParNodes in the temporary
descendant list (@code{tempDescs}). 

@node class ParGraph, class ParScheduler, class ParNode, Parallel Schedulers
@section Class ParGraph

Class ParGraph, derived from class ExpandedGraph, is an APEG graph for
parallel schedulers. It has a constructor with no argument. 

@example
int createMe(Galaxy& @var{g}, int @var{selfLoopFlag});
@end example

Is the main routine to create and initialize the APEG of the
argument Galaxy. Using @code{createMe} method of the ExpandedGraph
class, it creates an APEG. After that, it resets the busy flags of
the ParNodes, and call

@example
virtual int initializeGraph();
@end example

This is a protected method. It performs 4 main tasks as follows.
(1) Call a protected method @code{removeArcsWithDelay} to remove 
the arcs with delays, and to store the source and the
destination nodes of each removed arc into the list of NodePairs
(@pxref{class NodePair}). The list is a protected member, named
@code{nodePairs} of SequentialList class.

@example
void removeArcsWithDelay();
SequentialList nodePairs;
@end example

(2) For each node, compute the static level (@code{StaticLevel}) by calling
a protected method @code{SetNodeSL}. 

@example
int SetNodeSL(ParNode* @var{n});
@end example

(3) Sum the execution times of all nodes and save the total execution time
to a protected member @code{ExecTotal}.

@example
int ExecTotal;
@end example

(4) Assign the larger static level than any other nodes to the nodes at
the wormhole boundary. This let the parallel scheduler schedules the
nodes at the wormhole boundary first.

@menu
* other ParGraph protected members::	other ParGraph protected members
* other ParGraph public members::	other ParGraph public members
* class NodePair::			class NodePair
@end menu

@node other ParGraph protected members, other ParGraph public members, class ParGraph, class ParGraph
@subsection Other ParGraph protected members

@example
EGNode* newNode(DataFlowStar* @var{s}, int @var{invoc});
@end example

Redefines the virtual method to create a ParNode associated with the
given invocation of the argument star.

@example
ostream* logstrm;
@end example

This is a stream object for logging information.

@node other ParGraph public members, class NodePair, other ParGraph protected members, class ParGraph
@subsection Other ParGraph public members

@example
EGNodeList runnableNodes;
void findRunnableNodes();
@end example

The list of runnable (or fireable) nodes are stored in @code{runnableNodes}.
The above method is to initialize the list with all root ParNodes.

@example
int getExecTotal();
Galaxy* myGalaxy();
@end example

Returns the total execution time of the graph and the original graph.

@example
void setLog(ostream* @var{str});
@end example

Sets the stream object @code{logstrm}.

@example
void replenish(int @var{flag});
@end example

This method initialize the temporary ancestor list and descendant list
of all ParNodes in the graph.

@example
void sortedInsert(EGNodeList& @var{l}, ParNode* @var{n}, int @var{flag});
@end example

Insert a ParNode, @var{n}, into the EGNodeList, @var{l}, in sorted order.
It sorts nodes of highest @code{StaticLevel} first if @var{flag} = 1,
or lowest @code{StaticLevel} first if @var{flag} = 0.

@example
void restoreHiddenGates();
@end example

This method restores the hidden EGGates from @code{removeArcsWithDelay} 
method to the initial list, either @code{ancestors} or @code{descendants}
of the parent node.

@example
int pairDistance();
@end example

After scheduling is completed, it is supposed to return the
maximum scheduling distance between node pairs in @code{nodePairs} list.
Currently, however, it just returns -1, indicating the information
is not available.

@example
~ParGraph();
@end example

The destructor initializes the @code{nodePairs} list.

@node class NodePair, , other ParGraph public members, class ParGraph
@subsection Class NodePair

Class NodePair saves the source and the destination ParNodes of an arc.

@example
NodePair(ParNode* @var{src}, ParNode* @var{dest});
ParNode* getStart();
ParNode* getDest();
@end example

The constructor requires two arguments of the source and the destination
nodes, while the next two methods return the node.

@node class ParScheduler, class ParProcessors, class ParGraph, Parallel Schedulers
@section Class ParScheduler

Class ParScheduler is derived from class SDFScheduler, thus inherits the most
parts of @code{setup} method. They include initialization of galaxy and
computation of the repetition counters of all stars in the SDF graph.
It redefines the scheduling part of the set-up stage (@code{computeSchedule}).

@example
int computeSchedule(Galaxy& @var{g});
@end example

Is a protected method to schedule the graph with given number of processors.
The procedure is

(1) Let the target class do preparation steps if necessary before scheduling
begins.

(2) Check whether the number of processors is 1 or not. If it is 1, we use
the single processor scheduling (@code{SDFScheduler :: computeSchedule}).
After we set the target pointer of each star, return.

(3) Form the APEG of the argument galaxy, and set the total execution time
of the graph to a protected member @code{totalWork}.

(4) Set the target pointer of each UniProcessor class
(@pxref{class UniProcessor}).

@example
void mapTargets(IntArray* @var{array} = 0);
@end example

If no argument is given, assign the child targets to the UniProcessors
sequentially. If the IntArray argument maps the child targets to the
UniProcessors. If array[1] = 2, UniProcessor 1 is assigned Target 2.

(5) Before the main scheduling begins, complete the profile information of
wormholes. Since we may want to perform more tasks before scheduling, make
this protected method virtual. Be default, return TRUE to indicate no error
occurs.

@example
virtual int preSchedule();
@end example

(6) Perform scheduling by calling @code{mainSchedule}.

@example 
int mainSchedule();
@end example

This public method first checks whether manual assignment is requested or not.
If it is, do manual assignment. Otherwise, call an automatic scheduling 
routine which will be redefined in each derived class, actual scheduling
class. After scheduling is performed, set the @code{procId} parameter of
the stars in the original galaxy if all invocations are enforced to be
assigned to the same processor (@pxref{Target}).

@example
int assignManually();
@end example

Is a protected method to return TRUE if manual assignment is requested, or
return FALSE otherwise.

@example
virtual int scheduleManually();
@end example

Is a public virtual method. This method first checks whether all stars
are assigned to processors (@code{procId} parameter of a star should be
non-negative and smaller than the number of processors). If there is any
star unassigned, return FALSE. All invocations of a star is set the same
@code{procId} parameter. Based on that assignment, perform the
list scheduling (@pxref{class ParProcessors}). The @code{procId} of a Fork
star is determined by its ancestor. If the ancestor is a wormhole, the
@code{procId} of the Fork should be given explicitly as other stars.

@example
virtual int scheduleIt();
@end example

Is a public virtual method for automatic scheduling. Refer to the derived
schedulers. By default, it does nothing and return FALSE to indicate that
the actual scheduling is not done in this class.

@example
int OSOPreq();
@end example

Is a protected method to return TRUE or FALSE, based on whether all
invocations are enforced to be scheduled on the same processor.

Now, all methods necessary for step (5) are explained. Go back to the next
step.

(7) As the final step, we schedule the inside of wormholes based on the
main scheduling result if automatic scheduling option is taken. 
In the main scheduling routine, we will determine
how many processors will be assigned to a wormhole.

@example
int finalSchedule();
@end example

If scheduling of wormholes succeeds, return TRUE. Otherwise, return FALSE.

@menu
* compileRun::				  overall procedure of code generation
* other ParScheduler protected members::  other ParScheduler protected members
* other ParScheduler public members::	  other ParScheduler public members
@end menu

@node compileRun, other ParScheduler protected members, class ParScheduler, class ParScheduler
@subsection compileRun method

@example
void compileRun();
@end example

Is a redefined public method of SDFScheduler class. It first checks the number
of processors. 
If the number is 0, it just calls @code{SDFScheduler :: compileRun}. This
case occurs inside a wormhole (@pxref{CGDDF Domain}). Otherwise, 

(1) Set the target pointer of UniProcessors.

(2) Create sub-universes for each processors.

@example
int createSubGals(Galaxy& @var{g});
@end example

Is a public method. It first checks whether all invocations of stars are
scheduled on the same processor, and set the flag if it is the case.
After restoring all hidden EGGates of the APEG, create sub-universes.

(3) Prepare each processor (or UniProcessor class) for code generation.
It includes sub-universe initialization, and simulation of the schedule on
the processor obtained from the parallel scheduling.

(4) Let the target do something necessary, if any, before generating codes.

(5) Generate codes for all processors.

@node other ParScheduler protected members, other ParScheduler public members, CompileRun, class ParScheduler
@subsection Other ParScheduler protected members

@example
const char* logFile;
pt_ofstream logstrm_real;
ostream* logstrm;
@end example

These are for logging information. @code{logFile} indicates where to store
the logging information.

@example
MultiTarget* mtarget;
@end example

Is the pointer to the target object, which is MultiTarget type.

@example
int numProcs;
@end example

Is the total number of processors.

@example
ParGraph *exGraph
@end example

Is the pointer to the APEG used as the input graph to the scheduler.

@example
ParProcessors* parProcs;
@end example

This member points the actual scheduler object. It will be set up in the
@code{setUpProcs} method of the derived class.

@example
IntArray avail;
@end example

This array is to monitor the pattern of processor availability 
during scheduling.

@example
int inUniv;
@end example

This flag is set TRUE when it is the scheduler of a universe, not a wormhole.
In the latter case, it is set FALSE. By default, it is set TRUE.

@example 
int withParallelStar();
@end example

This method returns TRUE or FALSE, based on whether the galaxy contains 
any wormhole or data-parallel star, or not.

@example
int overrideSchedule();
@end example

If the user wants to override the scheduling result after automatic
scheduling, he can set the @code{adjustSchedule} parameter of the target
object. This method pokes the value of that parameter. This is one of
the future feature, not implemented yet in Ptolemy due to limitation of
the graphical interface, pigi.

@node other ParScheduler public members, , other ParScheduler protected members, class ParScheduler
@subsection Other ParScheduler public members

@example
ParScheduler(MultiTarget* @var{t}, const char* @var{log} = 0);
virtual ~ParScheduler();
@end example

The constructor has two arguments: the target pointer and the name of log
file name. The virtual destructor does nothing.

@example
virtual void setUpProcs(int @var{num});
@end example

The number of processors is given as an argument to this method. It
will initialize the @code{avail} array. In the derived class, this
method will create a ParProcessors class (set @code{parProcs} member).

@example
ParProcessors* myProcs();
UniProcessor* getProc(int @var{ix});
@end example

These methods will return the pointer to the ParProcessors object associated
with this scheduler and the UniProcessor object indexed by the argument.
The range of the index is 0 to @code{numProcs}-1.

@example
void ofWorm();
@end example

Resets @code{inUniv} flag to FALSE.

@example
int getTotalWork();
@end example

Returns the total execution time of the graph.

@example
void setProfile(Profile* @var{profile});
@end example

Copy the scheduling results to the argument Profile (@pxref{class Profile}).
If the scheduling is inside a wormhole, the scheduling results should be
passed to the outside of the wormhole by a Profile object.

@example
StringList displaySchedule();
@end example

This method displays the schedule of wormholes. Display of the
overall schedule is defined in the derived classes.

@node class ParProcessors, class UniProcessor, class ParScheduler, Parallel Schedulers
@section class ParProcessors

Class ParProcessors is the base class for all actual scheduler object.
Refer to derived classes to see how scheduling is performed. This class
just provide the set of common members and methods. Among them, there is
a list scheduling routine.

@example
int listSchedule(ParGraph* @var{graph});
@end example

This method performs the list scheduling with the input argument APEG.
It should be called after all nodes are assigned to the processors. It
is the last routine to be called for all parallel schedulers. It adds
communication nodes to the APEG (@code{findCommNodes}) and schedule 
them with the regular ParNodes. It returns the makespan of the schedule.

@example
void findCommNodes(ParGraph* @var{graph});
@end example

This method puts a pair of communication ParNodes, a send node and a
receive node, on the arc between two nodes assigned to the different 
processors. Note that we use @code{tempAncs} and @code{tempDescs}
list of ParNode class to insert these nodes instead of modifying the APEG. 
We store the newly created communication ParNodes
in @code{SCommNodes}. The procedure consists of
two stages. In the first stage, all regular arcs in the APEG are considered.
The @code{StaticLevel} of the send node is assigned to that of the source node
plus one to ensure that the send node is scheduled right after the source
node. The static level of the receive node is assigned to the same value
as the destination node.
In the second stage, all hidden arcs are considered. In this case, the
@code{StaticLevel} of communication nodes are assigned to 1, the minimum
value since they may be scheduled at the end of the schedule.
The number of interprocessor requirements are saved in a protected member,
@code{commCount}.

@example
int getMakespan();
@end example

Returns the longest scheduled time among all UniProcessors.

@menu
* other ParProcessors protected members::	ParProcessors protected members
* other ParProcessors public members::	ParProcessors public members
@end menu

@node other ParProcessors protected members, other ParProcessors public members, class ParProcessors, class ParProcessors
@subsection Other ParProcessors protected members

@example
int numProcs;
MultiTarget* mtarget;
EGNodeList SCommNodes;
@end example

These members specify the number of processors, the pointer to the
multiprocessor target class, and the list of communication nodes added
during @code{listSchedule}.

@example
IntArray pIndex;
@end example

Is used to access the processors in the order of available time. 

@example
void scheduleParNode(ParNode* @var{node});
@end example

This method schedules a parallel node (a wormhole or a data-parallel star)
inside the @code{listSchedule} method. Note that the processors are
already assigned for the node.

@example
virtual ParNode* createCommNode(int @var{i});
@end example

Is a virtual method to create a ParNode with type given as an argument.
It is virtual since the derived scheduler may want to create a node of 
derived class of ParNode.

@example
void removeCommNodes();
@end example

Clears the @code{SCommNodes} list.

@example
void sortWithAvailTime(int @var{guard});
@end example

Sort the processors with their available times unless no node is assigned to
the processor. All idle processors are appended after the processors
that are available at @var{guard} time and before the processor busy at
@var{guard} time. Store the results to @code{pIndex} array.

@example
int OSOPreq();
@end example

Returns TRUE or FALSE, based on whether all invocations of a star are
enforced to be scheduled on the same processor or not.

@node other ParProcessors public members, , other ParProcessors protected members, class ParProcessors 
@subsection Other ParProcessors public members

@example
ParProcessors(int @var{pnum}, MultiTarget* @var{t});
virtual ~ParProcessors();
@end example

The constructor has two arguments: the number of processors and the target
pointer. It creates @code{pIndex} array and initialize other data structures.
The destructor clears @code{SCommNodes}.

@example
void mapTargets(IntArray* @var{array});
void prepareCodeGen();
void createSubGals();
void generateCode();
@end example

The above methods perform the actual action defined in the ParScheduler class.
For description, refer to @ref{class ParScheduler}. The last method
deliver the generate code from each processor to the target class.

@example
int size();
@end example

returns the number of processors.

@example
virtual UniProcessor* getProc(int @var{id});
@end example

This method returns the UniProcessor with a given index. It is virtual since
the derived class wants to return it own specific class derived from
UniProcessor class.

@example
void initialize();
@end example

Initializes @code{pIndex}, @code{SCommNodes}, and processors.

@example
StringList display(NamedObj* @var{gal});
StringList displaySubUnivs();
@end example

These methods return the StringList contains the scheduling result and
the sub-universe description.

@example
ParNode* matchCommNodes(DataFlowStar* @var{s}, EGGate* @var{g}, PortHole* @var{p};
@end example

This method is used in sub-universe generation. The first argument is a
communication star, either a send star or a receive star, that the
system automatically inserts for interprocessor communication.
The second argument is the EGGate that the interprocessor communication (IPC)
occurs. If the second argument is NULL, the third argument indicates
the porthole that the IPC occurs. In case all invocations of any star
are assigned to the same processor, the sub-universe creation procedure
is greatly simplified: we do not need to look at the APEG, rather look at
the original SDF graph to create the sub-universe. It is the case when
the second argument becomes NULL. This method sets the pointer of the
communication star to the corresponding ParNode that are inserted during
@code{listSchedule} method.

@node class UniProcessor, Dynamic Level Scheduler, class ParProcessors, Parallel Schedulers
@section UniProcessor

Class UniProcessor simulates a single processing element (shortly processor).
It is derived from class DoubleLinkList to hold the list of ParNodes
from parallel scheduling. Class NodeSchedule is derived from class
DoubleLink to register a ParNode into the DoubleLinkList.

A UniProcessor keeps two target pointers: one for multiprocessor target
(@code{mtarget}), and the other for the processor
(@code{targetPtr}). They are both protected members.

@example
MultiTarget* mtarget;
CGTarget* targetPtr;
@end example

The pointer to the processor can be obtained by a public method:

@example
CGTarget* target();
@end example

The pointers to the multiprocessor target and to the ParProcessors class
that this UniProcessor belongs to, are set by the following method:

@example
void setTarget(MultiTarget* @var{t}, ParProcessors* @var{parent});
@end example

@menu
* class NodeSchedule::				class NodeSchedule
* members for scheduling::			members for scheduling
* Sub-Universe creation::			sub-universe creation
* members for code generation::			members for code generation
* other UniProcessor protected members::	other protected members
* other UniProcessor public members::		other public members
* Iterator for UniProcessor::			iterator class for UniProcessor
@end menu

@node class NodeSchedule, members for scheduling, class UniProcessor, class UniProcessor
@subsection Class NodeSchedule

A NodeSchedule is an object to link a ParNode to a linked list.
It indicates whether the node represents an idle time slot or not.
It also contains the duration of the node. There is no protected member
in this class.

@example
void resetMembers();
void setMembers(ParNode* @var{n}, int @var{dur});
@end example

These methods set the information for the associated node: the pointer to
the node, duration, and a flag to tell whether it is an idle node or not. 
In the first method, the idle flag is set FALSE. The constructor also 
resets all internal information of the class.

@example
ParNode getNode();
int getDuration();
int isIdleTime();
@end example

The above methods return the pointer to the node associated with this class,
its duration, and the flag to say TRUE if it represents an idle time slot.

@example
NodeSchedule* nextLink();
NodeSchedule* previousLink();
@end example

These methods return the next and the previous link in the linked list.

@node members for scheduling, Sub-Universe creation, class NodeSchedule, class UniProcessor
@subsection Members for scheduling

Since a list scheduling (with fixed assignment) will be performed as the 
last stage of all scheduling algorithms in Ptolemy 
(@pxref{class ParProcessors}), basic methods for list scheduling are
defined in the UniProcessor class. In list scheduling, we need the
available time of the processor.

@example
int availTime;
@end example

Is a protected member to indicate the time when the processor available.
There are public methods to access this member:

@example
void setAvailTime(int @var{t});
int getAvailTime();
@end example

@example
NodeSchedule* curSchedule;
@end example

This protected member points to the NodeSchedule appended last to the
linked list. There are two public methods to access a NodeSchedule:

@example
NodeSchedule* getCurSchedule();
NodeSchedule* getNodeSchedule(ParNode* @var{n});
@end example

The first method just returns @code{curSchedule} member while the second one
returns the NodeSchedule associated with the argument ParNode.

When a ParNode is runnable earlier than the available time of the processor,
we want to check whether there is an idle slot before @code{availTime} to
fit the ParNode in the middle of the schedule:

@example
int filledInIdleSlot(ParNode* @var{n}, int @var{start}, int @var{limit} = 0);
@end example

The first two arguments are the pointer to the ParNode to be scheduled and
the earliest time when the node can be scheduled. Without the third argument
given explicitly, this method returns the earliest time that the processor
is available to schedule the node. If the third argument is given,
the available time of the processor should be less than @var{limit}.
If this method could not find an idle slot to schedule the node, it returns
-1. Otherwise, it returns the possible scheduling time of the node.

@example
int schedInMiddle(ParNode* @var{n}, int @var{when}, int @var{leng});
@end example

Schedule the node, @var{n}, at @var{when} inside an idle-time slot of the
processor. The third argument indicates the duration of the node.
This method returns the completion time of the schedule if scheduling
is succeeded. If it fails to find an idle-time slot at @var{when} to
accommodate the node, it returns -1.

If a node is to be appended at the end of the schedule in a processor,

@example
void appendNode(ParNode* @var{n}, int @var{leng});
@end example

Does that blindly. To schedule a non-idle node, we have to use

@example
int schedAtEnd(ParNode* @var{n}, int @var{start}, int @var{leng});
@end example

In case @var{start} is larger than the processor available time, this
method put an idle time slot in the processor and calls @code{appendNode}.
And, it sets the schedule information of the node, and increases
@code{availTime} of the processor.

@example
void addNode(ParNode* @var{n}, int @var{start});
@end example

This method is given a ParNode and its runnable time, and schedule the node
either inside an idle time slot if possible, or at the end of the schedule
list. The methods described above are used in this method.

@example
void scheduleCommNode(ParNode* @var{n}, int @var{start});
@end example

When we schedule the given communication node, @var{n}, available at
@var{start}, we also have to check the communication resource whether
the resources are available or not. For that purpose, we detect the time
slot in this processor to schedule the node, and check whether the
same time slot is available in the communication resources: we use
@code{scheduleComm} of the multiprocessor target to check it. If we find
a time slot available for this processor and the communication resources,
we schedule the communication node.

@example
int getStartTime();
@end example

Returns the earliest time when the processor is busy.

All methods described in this sub-section are public.

@node Sub-Universe creation, members for code generation, members for scheduling, class UniProcessor
@subsection Sub-Universe creation

After scheduling is performed, a processor is given a set of assigned 
ParNodes. According to the scheduling result, we will generate a code
to the target processor. To generate code for the assigned nodes, we need
to allocate the resources for the nodes, and examine the connectivity of
the nodes in the original graph. These steps are common to the generic
routine for single processor code generation, in which a processor target
is given a galaxy. Therefore, we wants to create a sub-galaxy
that consists of stars of which any invocation is assigned to the processor.
Note that a sub-galaxy is NOT a subgraph of the original SDF graph.
Besides the stars in the original program graph, we include other
stars such as communication stars and spread/collect stars. This subsection
will explain some details of sub-universe creation.

@example
void createSubGal();
@end example

Is the main public method for sub-universe creation. It first creates
a galaxy data structure, @code{subGal} a private member. Then, it clones
stars at least one of whose invocations is assigned to the processor.
Make a linked list for all assigned invocations (nodes) of each star 
in order of increasing invocation number, and set the pointer of cloned
star. As for a wormhole, we create a CGWormStar (@pxref{class CGWormStar})
instead of cloning the wormhole. A CGWormStar class will replace a
wormhole in the sub-universe. If an original star is not supported by the
processor target (for example, heterogeneous scheduling case
(@pxref{Heterogeneous Support})), we create
a star with the same name as the original star in the target domain.

At next step, we connect the cloned stars by referring to the original
galaxy. If a star is at the wormhole boundary in the original graph,
we connect the cloned star to the same event horizon; by doing that
the wormhole in the original graph is connected to the sub-universe.
If the star at the wormhole boundary is scheduled on more than one
processors (or not all invocations are assigned to the same processor),
the wormhole in the original graph will be connected to the last
created sub-universe. 

If an arc connects two stars whose invocations are assigned to the same
processor respectively, we examine whether two stars are assigned to
the same processor or not. If they are, we just connect the cloned
stars in the sub-universe. If they aren't, we have a cloned star of
either one star whose invocations are assigned to the current sub-universe.
In this case, we create a send star (@code{createSend} method of
the multiprocessor target) or a receive star (@code{createReceive} of the
target), based on whether the cloned star is a source or destination of
the connection (@pxref{class CGMultiTarget}). We we create a
communication star, we set the communication star pointer of
the communication nodes in the APEG (@pxref{class ParProcessors}), 
by @code{matchCommNodes} method of ParProcessors class.
If the partner communication star was already created in another
sub-universe, we pair the send and the receive stars by
@code{pairSendReceive} method of the multiprocessor target
(@pxref{class CGMultiTarget}).

The last case is when an arc connects two stars whose invocations are
distributed over more than one processors. If no invocation of
the destination star is assigned to this processor, we call
@code{makeBoundary} method. Otherwise, we call @code{makeConnection} method.

@example
void makeBoundary(ParNode* @var{src}, PortHole* @var{orgP});
@end example

The first argument is the pointer to the earliest invocation of 
the star assigned to this processor and the second one is the pointer to
the output porthole in the original SDF graph as the source of the
connection. We examines all assigned invocations to check whether
the destination invocations are assigned to the same processor or not.
If they are, we create one send star and connect it to the cloned star.
Otherwise, we create a Spread star (@pxref{Spread and Collect stars})
to distribute the output samples
to more than one processors. We connect the cloned star and the Spread star, 
and the Spread star to multiple send stars.

@example
void makeConnection(ParNode* @var{dest}, ParNode* @var{src}, PortHole* @var{ref}, ParNode* @var{firstS});
@end example

The first argument is the pointer to the first assigned invocation 
of the destination star while the second one is the source node connected
to the first argument. The third argument is the pointer to the destination
porthole of the connection in the original graph. The last argument is
the pointer to the first invocation of the source star. Note that the last
argument node may not be assigned to the current processor.
This method examines all assigned invocations of the destination star 
to identify the sources of the samples to be consumed by the cloned star
in this processor. If the number of sources are more than one, we
create a Collect star (@pxref{Spread and  Collect stars}) and connect the
Collect star to the cloned destination star in the sub-universe. For
each source in the other processors, we create a receive star and 
connect it to the Collect star. Similarly, we examines all assigned
invocations of the source star to identify the destinations of the samples
to be produced by the source star in this processor. If the number of
destinations are more than one, we create a Spread star and connect it
to the source star. For each destination in the other processors, we create
a send star and connect it to the Spread star. As a result, it may occur
that to connect two stars in the sub-universe, we need to splice a Spread 
and a Collect star on that connection. 

@menu
* Spread and Collect stars::		Spread and Collect stars
* class CGWormStar::			class CGWormStar
@end menu

@node Spread and Collect stars, class CGWormStar, Sub-Universe creation, Sub-Universe creation
@subsubsection Spread and Collect stars

A Spread or a Collect star is created by @code{createSpread} or
@code{createCollect} method of the multiprocessor target. The following
illustration will show when we need to create a Spread or a Collect star
in a sub-universe.

Suppose we have star A connected to star B in original graph. Star A
produces two samples and star B consumes one. Then, one invocation
of star A is connected to two invocations of star B. If one invocation of
star A and only one of invocation of star B are assigned to the
current processor. Then, we need to connect the cloned stars of A and B
in the sub-universe. We can not connect stars A and B in the sub-universe
directly since among two samples generated by star A, one sample should be
transferred to another processor through a send star. In this case, we
connect a Spread star to star A, and one send star and star B to the
Spread star in the sub-universe. Then, star A produces two samples to
the Spread star while the Spread star @emph{spread} the incoming two samples
to the send star and star B one sample each. The number of output portholes
and the sample rate of each porthole are determined during the
sub-universe creation. If there is no initial delay on the connection and
neither star A nor B needs to access the past samples, the Spread star
does not imply additional copying of data in the generated code.

Similarly, we need to put a Collect star to the destination star if
samples to that star come from more than one sources.

@node class CGWormStar, , Spread and Collect stars, Sub-Universe creation
@subsection class CGWormStar

If the original galaxy has a wormhole (recall that this documentation
restricts the domain of the wormhole should be CGDDF), it is very 
costly to clone a wormhole in the sub-universe. Instead, we create
a CGWormStar as the image of the wormhole. CGWormStar class, derived from
CGStar class, has
a four-argument constructor:

@example
CGWormStar(CGStar* @var{worm}, int @var{pix}, int @var{invoc}, int @var{flag});
@end example

The first argument is the pointer to the wormhole. The second argument
specify the index of the inside processors. The inside of the wormhole
is scheduled possibly onto more than one processors. This index indicates
the mapping which inside processor is associated with this processor.
The third argument indicates which invocation of a wormhole this star
simulates. If the last argument @var{flag} is non-zero, we create
the portholes of the CGWormStar to insert it to the sub-universe.
If it is set zero, we do not create the portholes, instead we just map
one CGWormStar to one invocation of the wormhole. 

When we schedule a wormhole or a data-parallel star, we assume that
the communication to the inside of the wormhole occurs through one
processor. For example, we schedule a wormhole with three processors,
only one processor is involved in communication with the other
stars outside the wormhole. Even though the other two processors are assigned
the ParNodes associated with the wormhole, the sub-universe will not
contain any CGWormStar in the connection. When generating code for the
wormhole, however, we need to access the wormhole associated with the
ParNodes. Therefore, we create a CGWormStar for each ParNode associated with
the wormhole, but do not insert the star into the sub-universe.

The @code{go} method generate a code for the wormhole, by calling
@code{downLoadCode} of the wormhole class (@pxref{class CGWormBase}).

There are other three public methods.

@example
int isItWormhole() const;
@end example

Just returns TRUE.

@example
void initialize();
@end example

Does nothing. It is redefined to nullify what the base CGStar does.
 
@example
int run();
@end example

This method calls @code{Star::run} and advances the offset pointer of
CGPortHoles.

@node members for code generation, other UniProcessor protected members, Sub-Universe creation, class UniProcessor
@subsection Members for code generation

@example
void prepareCodeGen();
@end example

This method performs the following tasks before generating code.

(1) Initialize the sub-universe, which also initialize the cloned stars.

(2) Replace CGWormStars in the sub-universe with the original wormholes.
And set the galaxy pointer of the processor target to the sub-universe.
Note that the wormholes are now detached from the original SDF graph.
They will be restored after code generation to be discussed below.

(3) Convert a schedule (or a linked list of ParNodes) obtained from the
parallel scheduler to a SDFSchedule class format (list of stars). The
code generation routine of the processor target assumes the SDFSchedule
class as the schedule output.

(4) Simulate the schedule to compute the maximum number of samples
to be collected at runtime if we follow the schedule. This information
is used to determine the buffer size to be allocated to the arcs.

@example
void simRunSchedule();
@end example

Performs the step (4). It is a protected member.

@example
StringList& generateCode();
@end example

This method generate code for the processor target by calling
@code{targetPtr->generateCode()} (@pxref{class CGTarget}).
After generating code, it
restores the wormholes into the original graph.

@example
int genCodeTo(Target* @var{t});
@end example

This method is used to insert the code of the sub-universe to the
argument target class. It performs the almost same steps as
@code{prepareCodeGen} and then calls @code{insertGalaxyCode}
of the processor target class instead of @code{generateCode} method.

@node other UniProcessor protected members, other UniProcessor public members, members for code generation, class UniProcessor
@subsection Other UniProcessor protected members

There are a set of methods to manage NodeSchedule objects to minimize
the runtime memory usage as well as execution time.

@example
void putFree(NodeSchedule* @var{n});
NodeSchedule* getFree();
void clearFree();
@end example

If a NodeSchedule is removed from the list, it is put into a pool of
NodeSchedule objects. When we need a NodeSchedule object, a NodeSchedule
in the pool is extracted and initialized. We deallocate all NodeSchedules in
the pool by the third method.

@example
void removeLink(NodeSchedule* @var{n});
@end example

Removes the argument NodeSchedule from the scheduled list.

@example
int sumIdle
@end example

Indicates the sum of the idle time slots after scheduling is completed.
The valid value is available only after @code{display} method is called.

@node other UniProcessor public members, Iterator for UniProcessor, other UniProcessor protected members, class UniProcessor
@subsection Other UniProcessor public members

There are a constructor with no argument to initialize all data members and
a destructor to delete @code{subGal} and CGWormStars and to delete all
NodeSchedule objects associated with this processor.

@example
Galaxy* myGalaxy();
int myId();
DoubleLinkList :: size;
int getSumIdle();
@end example

The above methods return the pointer to the sub-universe, the index of
the current processor, the number of scheduled nodes, and the sum of idle
time after scheduling is completed (or @code{sumIdle}).

@example
void initialize();
@end example

This method puts all NodeSchedules in the list to the pool of free
NodeSchedules and initialize protected members.

@example
void copy(UniProcessor* @var{org});
@end example

Copies the schedule from the argument UniProcessor to the current processor.

@example
StringList displaySubUniv();
StringList display(int @var{makespan});
int writeGantt(ostream& @var{os});
@end example

The first method display the sub-universe. The second method displays the
schedule in the textual form while the third one forms a string to
be used by Gantt-chart display program.

@node Iterator for UniProcessor, , other UniProcessor public members, class UniProcessor
@subsection Iterator for UniProcessor

Class ProcessorIter is the iterator for UniProcessor class.
A NodeSchedule object is returned by @code{next} and @code{++} operator.

@example
ParNode* nextNode();
@end example

Returns the ParNode in the list.

@node Dynamic Level Scheduler, Hu's Level Scheduler, class UniProcessor, Parallel Schedulers
@section Dynamic Level Scheduler

Dynamic Level Scheduling is one of the list scheduling algorithm where
the priority of a node is not fixed during scheduling proceeds
(@pxref{References}). The scheduling algorithm is implemented in
$(PTOLEMY)/src/domains/cg/dlScheduler. All classes in that directory
are derived from the base parallel scheduling classes described 
above in this chapter.
For example, DLNode class is derived from class ParNode, and redefines
@code{getLevel} method to compute the @emph{dynamic} level of the node.

@example
int getLevel();
@end example

This method returns the sum of the static node and the worst case
communication cost between its ancestors and this DLNode. 

Class DLNode has the same constructors as class ParNode.

The dynamic level scheduler maintains a list of runnable nodes sorted
by @code{getLevel} value of the DLNodes. It fetches a node of highest
priority and choose the best processor that can schedule the node earliest
taking interprocessor communication into account.

@menu
* class DLGraph::			class DLGraph
* class DLScheduler::			class DLScheduler
* class DLParProcs::			class DLParProcs
@end menu

@node class DLGraph, class DLScheduler, Dynamic Level Scheduler, Dynamic Level Scheduler
@section Class DLGraph

Class DLGraph, derived from class ParGraph, is the input APEG graph to the
dynamic level scheduler. It consists of DLNode objects created by
redefining the following method:

@example
EGNode* newNode(DataFlowStar* @var{s}, int @var{invoc});
@end example

This method creates a node in the APEG graph. Here, it creates a DLNode.

The DLGraph has two protected members to maintain the number of
unscheduled nodes and the sum of unscheduled work.

@example
int unschedNodes;
int unschedWork;
@end example

We may check whether the scheduler is deadlocked or not by examining these
variables when the scheduler halts. We provide public methods to
manipulate them.

@example
void decreaseNodes();
void decreaseWork(int @var{val});
int numUnSchedNodes();
int sizeUnSchedWork();
@end example

The first two methods decrease the values of the variables by one and
@var{val}. The next two methods return the values of the variables.

The DLGraph class redefines @code{resetGraph} method.

@example
void resetGraph();
@end example

It makes the initial list of runnable nodes and set the variables described
above. This method internally calls the following protected method:

@example
virtual void resetNodes();
@end example

This method resets the busy flag and the @code{waitNum}
member of DLNodes.

There are three other public members.

@example
DLNode* fetchNode();
@end example

Fetches a DLNode from the head of the list of the runnable node.

@example
int workAfterMe(ParNode* @var{pd});
@end example

This method returns the total execution time of the descendants of
the argument node. 

@example
StringList display();
@end example

Displays the APEG graph and the list of source nodes.

@node class DLScheduler, class DLParProcs, class DLGraph, Dynamic Level Scheduler
@section class DLScheduler

Class DLScheduler is derived from class ParScheduler. It has a constructor
with three arguments.

@example
DLScheduler(MultiTarget* @var{t}, const char* @var{logFile}, int @var{flag});
@end example

The arguments are the pointer to the multiprocessor target, the name of the
logging file, and a flag to indicate whether the communication overhead
can be ignored or not. If the processor target has a special hardware for
communication separately from the CPU, most part of communication load
could be executed simultaneously with other computation load. In this case,
we do not reserve the communication time slot in the processor schedule
but in the access schedule of the communication resources only. This mode
of operation is select if @var{flag} is set TRUE. But, it is not
implemented yet since we haven't had that kind of architecture while
developing the code.

It has a protected member to point to a ParProcessors class.

@example
DLParProcs* parSched;
@end example

This pointer is set in the following redefined method:

@example
void setUpProcs(int @var{num});
@end example

This method first performs @code{ParScheduler::setUpProcs}, and then
create a DLParProcs object. While this class defines the overall
procedure of the dynamic level scheduling algorithm, the DLParProcs class
provides the details of the algorithm (@pxref{class DLParProcs}). 

@example
~DLScheduler();
@end example

Deallocate the DLParProcs object.

The main procedure of the dynamic level schedule is defined in

@example
int scheduleIt();
@end example

This method does the following:

(1) Initializes the DLParProcs and resets the DLGraph and
the communication resources of the multiprocessor target.

(2) Fetch a node from the list of runnable nodes until there is no more nodes
in the list.

(2-1) If the node is not a wormhole node, call @code{scheduleSmall} method
of the DLParProcs class to schedule the node.

(2-2) If the node is the first invocation of a wormhole or a parallel-star
node, we first determine the pattern of processor availability, and computes
the amount of work that can be done simultaneously with this node. With
this information and the number of processors, we determine how many
processors to be assigned the the node. Once we decide the number of the
processors, we get the profile of the wormhole (or the parallel star)
associated with that number, and schedule the node by @code{scheduleBig}
method of the DLParProcs class. Currently, we do not support parallel-stars
since we haven't had any example of parallel-stars.

(2-3) If the node is an invocation of a wormhole, but not the first invocation,
we use the same number of processors and the same profile as the first
invocation to schedule this node. We use @code{copyBigSchedule} method of
the DLParProcs class. 

(3) When there is no more runnable node, we check whether the graph is
deadlocked or normally completed. In case of normal completion, we
performs an additional list scheduling (@code{listSchedule} of 
the ParProcessors class), based on the processor assignment determined
by the above procedure.

@example
StringList displaySchedule();
@end example

Displays the final schedule results.

@node class DLParProcs, , class DLScheduler, Dynamic Level Scheduler
@section Class DLParProcs

Class DLParProcs, derived from the ParProcessors class,
defines a main object to perform the dynamic level scheduling algorithm. 
It has a constructor with two arguments:

@example
DLParProcs(int @var{num}, MultiTarget* @var{t});
@end example

The arguments are the number of processors and the pointer to the
multiprocessor target. This method creates @var{num} UniProcessors for
processing elements. These UniProcessors are deallocated in the destructor:

@example
~DLParProcs();
@end example

@example
UniProcessor* schedules;
UniProcessor* getProc(int @var{ix});
@end example

The first member is a protected member for the array of UniProcessors, while
the second is a public method to access the UniProcessor with a given index
as an argument.

Based on the type of node described in @code{scheduleIt} method of the
DLScheduler class, we call one of the following methods to schedule the node.
@code{scheduleSmall}, @code{scheduleBig}, @code{copyBigSchedule}.

@example
virtual void scheduleSmall(DLNode* @var{n});
@end example

This method is a public method to schedule an atomic node that will be
schedule on one processor. It is virtual since the HuParProcs class
(@pxref{class HuParProcs}) redefines this method.
The scheduling procedure is as follows:

(1) Obtain the list of processors that can schedule this node. Refer to
@code{candidateProcs} method of the CGMultiTarget
class (@pxref{class CGMultiTarget}).  Here, we
examine the resource restriction of the processor, as well as the type of
stars that a processor supports in case of heterogeneous target. If
all invocations of a star should be scheduled to the same processor and
another invocation of the star is already scheduled, we put that processor only
into the list of candidate processors to schedule this node.

(2) Among all candidate processors, we select the processor that can schedule
the node earliest. In this stage, we consider all communication overhead
if ancestors would be assigned to the different processors.

(3) Assign the node to that processor:

@example
void assignNode(DLNode* @var{n}, int @var{destP}, int @var{time});
@end example

Is a protected method to assign an atomic node (@var{n}) to the processor
of index @var{destP} at @var{time}. This method also schedules the
communication requirements in the communication resources.

(4) Indicate that the node was fired:

@example
virtual void fireNode(DLNode* @var{node});
@end example

It is a virtual and protected method. It fires the argument node and insert
its descendants into the list of runnable nodes if they become runnable 
after this node is fired.

(5) Finally, we decrease the number of unscheduled nodes and the total
remaining work of the DLGraph class.

@example
void scheduleBig(DLNode* @var{n}, int @var{when}, IntArray& @var{avail});
@end example

Schedules a non-atomic node, @var{n}, that may be scheduled on more than one
processors. The second argument and the third argument indicate when the
node will be scheduled and what is the pattern of processor availability at
that time. They are determined by @code{determinePPA} method before this
method is called from @code{scheduleIt} method of the DLScheduler class.

The DLNode class has the pointer to the Profile class that determines the
inside schedule of the node. We insert idle time slots to the
processors to match the pattern of processor availability with the starting
pattern of the profile and append the node at the end of the processors. 
We record the assignment of the profile to
the processors in @code{assignedId} array of the Profile class
(@pxref{class Profile}). We also save the scheduling information in the
DLNode: when the node is scheduled and completed, and on which processor
it is scheduled. To determine the latter, we select the processor that
the inside scheduler assumes the first processor it is assigned.

After appending the profile at the end of the available processors, we
fire the node and updates the variables of the DLGraph.

@example
virtual int determinePPA(DLNode* @var{n}, IntArray @var{array});
@end example

It is a public method to record the pattern of processor availability to
@var{array} to schedule a non-atomic node @var{n}.
This method first obtains the list of candidate processors and chooses
a processor that can execute the node earliest taking into account
all communication requirement. Next, it schedules the communication 
load in the communication resources. Finally, it sorts the processors
in order of available times (@code{ParProcessors :: sortWithAvailTime}), and
fill the @var{array} structure.

@example
void copyBigSchedule(DLNode* @var{n}, IntArray& @var{avail});
@end example

This method is called to schedule a wormhole node and the node does not
corresponds to the first invocation. When we schedule the first invocation,
we determine the assignment of the wormhole. For other invocations,
we use the same assignment. In this method, we prepare @code{pIndex} and
@code{avail} arrays, and call the @code{scheduleBig} method.

@example
void initialize(DLGraph* @var{graph});
@end example

This method calls @code{ParProcessors :: initialize} and resets the
@code{candidate} member to the index of the first UniProcessor, and
@code{myGraph} member to @var{graph} argument.

@example
IntArray* candidate;
DLGraph* myGraph;
@end example

These are protected members to store the array of candidate processors and
the pointer to the input APEG.

@example
int costAssignedTo(DLNode* @var{n}, int @var{destP}, int @var{start});
@end example

This method is a protected method to compute the earliest time when
the processor of index @var{destP} could schedule the node @var{n} that
is runnable at time @var{start}.

@node Hu's Level Scheduler, Declustering Scheduler, Dynamic Level Scheduler, Parallel Schedulers
@section Hu's Level Scheduler

Hu's level scheduling algorithm is a simple list scheduling algorithm, in
which a node is assigned a fixed priority. No communication overhead is
considered in the scheduling procedure. 
The code lies in $(PTOLEMY)/src/domains/cg/HuScheduler. 
All classes except HuScheduler class in this directory 
are derived from the classes for the dynamic level schedulers.

@menu
* class HuNode::		a node in the APEG for Hu's level scheduler
* class HuGraph::		an APEG for Hu's level scheduler
* class HuScheduler::		a ParScheduler for Hu's level scheduler
* class HuParProcs::		a ParProcessors for Hu's level scheduler
@end menu

@node class HuNode, class HuGraph, Hu's Level Scheduler, Hu's Level Scheduler
@subsection Class HuNode

Class HuNode represents a node in the APEG for Hu's level scheduling algorithm.
It is derived from the DLNode class so that it has the same constructors.
The level (or priority) of a node is not dependent on the communication 
overhead.

@example
int getLevel();
@end example

Just returns @code{StaticLevel} of the node.

A HuNode has two private variables to indicate the available time of the node
(or the time the node becomes runnable)
and the index of the processor on which the node wants to be assigned. 
The latter is usually set to the index of the processor that its immediate
ancestor is assigned. There are five public methods to manipulate these
private variables.

@example
int availTime();
void setAvailTime(int @var{t});
void setAvailTime();
int getPreferredProc();
void setPreferredProc(int @var{i});
@end example

The first three methods get and set the available time of the node. If no
argument is given in @code{setAvailTime}, the available time is set to
the earliest time when all ancestors are completed. The last two methods
get and set the index of the processor on which
the node is preferred to be scheduled.

@node class HuGraph, class HuScheduler, class HuNode, Hu's Level Scheduler
@subsection Class HuGraph

Class HuGraph is the input APEG for Hu's level scheduler. It redefines
three virtual methods of its parent classes.

@example
EGNode* newNode(DataFlowStar* @var{s}, int @var{invoc});
@end example

Creates a HuNode as a node in the APEG.

@example
void resetNodes();
@end example

This method resets the variables of the HuNodes: visit flag, @code{waitNum},
the available time, and the index of the preferred processor.

@example
void sortedInsert(EGNodeList& @var{nlist}, ParNode* @var{n}, int @var{flag});
@end example

In the ParGraph class, this method sorts the nodes in order of decreasing
@code{StaticLevel} of nodes. Now, we redefine it to sort the nodes in order
of increasing available time first, and decreasing the static level next.

@node class HuScheduler, class HuParProcs, class HuGraph, Hu's Level Scheduler
@subsection Class HuScheduler

Class HuScheduler, derived from the ParScheduler class, is parallel to the
DLScheduler class in its definition.

@example
HuScheduler(MultiTarget* @var{t}, const char* @var{log});
@end example

The constructor has two arguments: one for the multiprocessor target and the
other for the log file name.

The HuScheduler class has a pointer to the HuParProcs object that will
provide the details of the Hu's level scheduling algorithm.

@example
HuParProcs* parSched;
@end example

Is the protected member to point to the HuParProcs object.
That object is created in the following method:

@example
void setUpProcs(int @var{num});
@end example

This method first calls @code{ParScheduler::setUpProcs} and next creates
a HuParProcs object. The HuParProcs is deallocated in the destructor.

@example
int scheduleIt();
@end example

The scheduling procedure is exactly same as that of the Dynamic Level 
Scheduler except that the actual scheduling routines are provided
by the HuParProcs object rather than a DLParProcs object. 
Refer to @code{scheduleIt} method of class DLScheduler
(@pxref{class DLScheduler}). Also note that the runnable nodes in
this scheduling algorithm are sorted by their available time first.

@example
StringList displaySchedule();
@end example

Displays the scheduling result textually.

@node class HuParProcs, , class HuScheduler, Hu's Level Scheduler
@subsection Class HuParProcs

Class HuParProcs is derived from class DLParProcs so that it has the
same constructor. While many scheduling methods defined in the
DLParProcs class are inherited, some virtual methods are redefined to
realize different scheduling decision. For example, it does not
consider the communication overhead to determine the processor that can
schedule a node earliest. And it does not schedule communication resources.
Another big difference is that the Hu's level scheduling algorithm has
a notion of global time clock. No node can be scheduled ahead of the global
time. At each scheduling step, the global time is the same as the
available time of the node at the head of the list of runnable nodes.

@example
void fireNode(DLNode* @var{n});
@end example

This protected method is redefined to set the available time and the index
of the preferred processor of the descendants if they are runnable after node
@var{n} is completed, before putting them into the list of runnable nodes
(@code{sortedInsert}) of the HuGraph method.

@example
void scheduleSmall(DLNode* @var{n});
@end example

When this method is called, the node @var{n} is one of the earliest
runnable nodes. We examine a processor that could schedule the node
at the same time as the available time of the node. If the node
is at the wormhole boundary, we examine the first processor only. If
the node should be assigned to the same processor on which any earlier
invocations were already assigned, we examine that processor whether
it can schedule the node at that time or not. If no processor is found,
we increase the available time of the node to the earliest time when
any processor can schedule it, and put the node back to the list of
runnable nodes. If we find a processor to schedule the node at
the available time of the node, we assign, and fire the node and
update the variables of the HuGraph. Recall that no communication
overhead is considered.

@example
int determinePPA(DLNode* @var{n}, IntArray& @var{avail});
@end example

Before computing the pattern of processor availability, we first check
whether any processor is available to schedule the node @var{n} at its
available time. If no processor is found, we increase the available time
of the node to the earliest time when a processor is able to schedule it,
and put the node back to the list of runnable nodes.
If we find a processor to schedule the node, we set the @var{avail} and
@var{pIndex} arrays with information of the pattern of processor availability.

@node Declustering Scheduler, , Hu's Level Scheduler, Parallel Schedulers
@section Declustering Scheduler

Declustering scheduler is the most elaborate scheduler developed by Sih
(@pxref{References}). This algorithm only applies to the homogeneous
multiprocessor targets. And, it does not support wormholes (so CGDDF domain)
nor parallel stars. Since it takes into account the global information
of the graph, it may overcome the weaknesses of list schedulers which
consider only local informations at each scheduling step. It turns out
that this scheduling algorithm is very costly since it involves
recursive executions of the list scheduling with various assignment
and choose the best scheduling result. The scheduling routine was
originally written in LISP in Gabriel system, and translated into
C++. Since the algorithm itself is very complicated, the reader of the code
is highly encouraged to read the Sih's paper on the scheduling algorithm.

Class DeclustScheduler is derived from class ParScheduler. It has a
constructor with two arguments as the ParScheduler class.
The type of the ParProcessors used for DeclustScheduler is the DCParProcs
class. The DeclustScheduler maintains two instances of DCParProcs classes:
one is to save the best scheduling result so far, and the other is to
try another list scheduling whose scheduling results will be compared with
the current best scheduling result. These two DCParProcs are created in

@example
void setUpProcs(int @var{num});
@end example

They are deleted in the destructor.

@example
StringList displaySchedule();
@end example

Displays the best scheduling result obtained so far.

The overall procedure of the declustering algorithm is following:

(1) Make elementary clusters of nodes. To make elementary clusters, we examine
the output arcs of all branch nodes (a branch node is a node with more than
one output arcs) and the input arcs of all merge nodes (a merge node is a
node with more than one input arcs). Those arcs or arcs connected to them
are candidates to be cut to make clusters. An arc is cut if the
introduced communication overhead can be compensated by exploiting
parallelism.

(2) We make a hierarchy of clusters starting from elementary clusters up
to one cluster which includes all nodes in the APEG. Clusters with
smallest work-load will be placed at the bottom level of the hierarchy.

The above two steps are performed in the following protected method:

@example
int preSchedule();
@end example

Before making clusters, it first checks whether the APEG has wormholes or
parallel stars. If it finds any, it returns FALSE.

(3) Now, we decompose the cluster hierarchy. We examine the hierarchy from
the top. We assign two processors to each branch (son cluster) of the top node 
at the next level. Then, we execute a list scheduling to save 
the scheduling result. Choose a son cluster with more work-load. 
Then, introduce another processor to schedule two branches of the son cluster.
Execute another list scheduling to compare the previously best scheduling
result to save the better result. Repeat this procedure until all processors
are consumed. It is likely to stop traversing the cluster hierarchy since
all processors are consumed. At this stage, we compare the loads of
processors and try to balance the loads within a certain
ratio by shifting some elementary clusters
from the most heavily loaded processor to a lightly loaded processor.

(4) In some cases, we can not achieve our goals by shifting clusters to
balance the loads of processors. We try to breakdown some elementary
clusters in heavily loaded processors to lightly loaded clusters. It is
called to "breakdown" the clusters.

(5) In each step of (3) and (4), we execute a list scheduling to compare the
previously best scheduling result. This is the reason why the declustering
algorithm is that computationally intensive. Finally, we get the
best scheduling result. Based on that scheduling results, we make
a final version of the APEG  including all communication nodes 
(@code{finalizeGalaxy} method of DCParProcs class). Note that we do not
call the list scheduling algorithm in the ParProcessors class after we find
out the best scheduling result since we already executed that routine for
that result.

Steps (3), (4), and (5) are performed in the following public method:

@example
int scheduleIt();
@end example

Many details of the scheduling procedure are hidden with private methods.
The remaining section will describe the classes used for Declustering
scheduling one by one.

@menu
* class DCNode::			an APEG node for Declustering
* class DCArcList::			class DCArcList
* class DCGraph::			an APEG for Declustering
* class DCCluster::			class DCCluster
* class DCClusterList::			class DCClusterList
* class DCClustArcList::		class DCClustArcList
* class DCUniProc::			class DCUniProc
* class DCParProcs::			class DCParProcs
@end menu

@node class DCNode, class DCArcList, Declustering Scheduler, Declustering Scheduler
@subsection Class DCNode

Class DCNode, derived from class ParNode, is an APEG node for declustering
scheduler. It has the same constructors with the ParNode class.
This class does not have any protected member.

@example
int amIMerge();
int amIBranch();
@end example

These methods return TRUE if this node is a merge node or a branch node.

@example
DCCluster* cluster;
DCCluster* elemDCCluster;
@end example

These pointers point to the highest-level cluster and the elementary
cluster this node currently belongs to.

@example
void assignProc(int @var{n});
int whichProc();
@end example

We redefine these methods to set and get the temporary processor index on
which this node is scheduled. Since we execute the list scheduling
multiple times, we need to distinguish the final assignment and the
temporary assignment.

@example
void saveInfo();
int getBestStart();
int getBestFinish();
@end example

The first method saves the scheduling information of this node in
the best scheduling result, which includes the processor assignment, the
scheduled time, and the completion time. The next two methods return
those scheduled time and the completion time of the current node.

@example
int getSamples(DCNode* @var{destN});
@end example

Returns the number of samples transferred from the current node to the
destination node @var{destN}. If no sample is passed, it returns 0 with
an error message.

@example 
DCNode* adjacentNode(DCNodeList& @var{nlist}, int @var{direction});
@end example

DCNodeList is derived from class EGNodeList just to perform the type
casting. This method returns an adjacent node of the current node
in the given node list. If @var{direction} is 1, look at the ancestors,
if -1, descendants.

@example
StringList print();
@end example

Prints the master star name and the invocation number of the node.

There are three iterators defined for DCNode class: @code{DCNodeListIter},
@code{DCAncestorIter}, and @code{DCDescendantIter}. As names suggest,
they return the DCNode in the list, in the ancestors of a node, and in
the descendants of a node.

@node class DCArcList, class DCGraph, class DCNode, Declustering Scheduler
@subsection Class DCArc and DCArcList

Class DCArc represents an candidate arc in the APEG to be cut to make
elementary clusters. It has a constructor with five arguments.

@example
DCArc(DCNode* @var{src}, DCNode* @var{sink}, int @var{first}, int @var{second},int @var{third});
@end example

The first two arguments indicate the source and destination nodes of the arc.
The remaining three arguments define a triplet of information used to help
find arcs to be cut. We call these arcs ''cut-arcs''. 
We consider a pair
of a branch node and a merge node and two paths between them to find out
a pair of cut-arcs to parallelize these two paths if beneficial.
The @var{first} argument is the sum of execution times of
nodes preceding this arc starting from the branch node.
The @var{second} argument is the communication overhead for this arc.
The @var{third} argument is the sum of execution times of nodes following this
arc to the merge node.

The five arguments given to the constructor can be retrieved by the following
methods:

@example
DCNode* getSrc();
DCNode* getSink();
int getF();
int getS();
int getT();
@end example

They can be printed by

@example
StringList print();
@end example

The sink and the source nodes can be reversed, and can be copied from
an argument DCArc by the following methods:

@example
void reverse();
int operator==(DCArc& @var{a});
@end example

There are other public methods as follow:

@example
DCArcList* parentList();
@end example

A DCArc will be inserted to a list of DCArcs (class DCArcList to be discussed
below). This method return the pointer to the list structure.

@example
int betweenSameStarInvoc();
@end example

Returns TRUE or FALSE, based on whether this arc is between invocations of
the same star.

Class DCArcList is derived from class SequentialList to make a list of
DCArcs. It has a constructor with no argument and a copy constructor.
The destructor deletes all DCArcs in the list.

@example
void insert(DCArc* @var{arc});
void append(DCArc* @var{arc});
@end example

These methods to put the argument DCArc at the front and the back of the list.

@example
DCArc* head();
@end example

Returns the DCArc at the front of the list.

@example
int remove(DCArc* @var{arc});
@end example

Removes a DCArc from the list.

@example
int member(DCArc* @var{arc});
@end example

Returns TRUE if the given DCArc is a member of the list.

@example
int mySize();
@end example

Returns the number of DCArcs in the list.

@example
StringList print();
@end example

It prints a list of DCArcs in the list.

There is a iterator for DCArcList: DCArcIter. It returns a DCArc.

@node class DCGraph, class DCCluster, class DCArcList, Declustering Scheduler
@subsection Class DCGraph

Class DCGraph, derived from class ParGraph, is an input APEG for
DeclustScheduler. It has no explicit constructor.

@example
EGNode* newNode(DataFlowStar* @var{s}, int @var{invoc});
@end example

Creates a DCNode as an APEG node for DCGraph.

@example
DCNodeList BranchNodes;
DCNodeList MergeNodes;
@end example

These lists store the branch nodes and merge nodes.

@example
int initializeGraph();
@end example

This protected method initializes the DCGraph: set up the list of branch 
nodes and
the merge nodes (@code{BranchNodes}, @code{MergeNodes}), and the list of
initially runnable nodes. We sort these lists with static levels of nodes:
the branch nodes are sorted smallest static level first while the merge
nodes are sorted largest static level first. In this method, we also
initialize the DCNodes, which include the detection of the merge nodes
reachable from the node and the branch nodes reachable to the node.

The remaining methods are all public.

@example
const char* genDCClustName(int @var{type});
@end example

Generate a name of the cluster. If @var{type} = 0, we prefix ''ElemDCClust''
to represent an elementary cluster. Otherwise, we prefix ''MacroDCClust''.

@example
StringList display();
@end example

Displays the APEG with the lists of initially runnable nodes, the branch
nodes, and the merge nodes.

@example
DCNode* intersectNode(DCNode* @var{d1}, DCNode* @var{d2}, int @var{direction});
@end example

This method returns a merge nodes with smallest static level, reachable from
both @var{d1} and @var{d2} nodes if @var{direction} = 1. 
If @var{direction} = 0, it returns a branch nodes with smallest static level,
reachable to both @var{d1} and @var{d2} nodes.

@example
DCArcList* traceArcPath(DCNode* @var{branch}, DCNode* @var{src}, DCNode* @var{dest}, int @var{direction});
@end example

This method makes a list of candidate cut-arcs between @var{branch} and
@var{dest} nodes, and returns the pointer to the list. 
The second argument, @var{src}, is a immediate
descendant of the @var{branch} node on the path to the @var{dest} node.
If @var{direction} = 1, we reverse all arcs and find a cut-arcs from 
@var{dest} to @var{branch} nodes.

@example
void addCutArc(DCArc* @var{arc});
@end example

The DCGraph keeps a list of all cut-arcs. This method adds
a DCArc to that list.

@example
void formElemDCClusters(DCClusterList& @var{EClusts});
@end example

In this method, we remove all cut-arcs in the APEG, and make each
connected component as an elementary cluster. The argument @var{EClusts}
is the list of those elementary clusters. We connect these clusters at
the end.

@example
void computeScore();
@end example

In scheduling stage (3) of the DeclustScheduler, we may want to shift
clusters from heavily loaded processors to lightly loaded processors. To
prepare this step, we compute the ''score'' of top-level clusters at that
scheduling phase. The score of a cluster is the number of samples passed
to other processors minus the number of samples passed inside the same
processor along the cur-arcs that the cluster contains.
The information indicates the cost of shifting a cluster due to
communication.

@example
void commProcs(DCCluster* @var{clust}, int* @var{procs});
@end example

This method finds processors that the argument cluster communicates with.
We set the component of the second argument array to 1 if that processor
communicates with the cluster.

@example
void copyInfo();
@end example

Saves the scheduling information of the nodes in case the recentest
scheduling result is better than the previous best.

@node class DCCluster, class DCClusterList, class DCGraph, Declustering Scheduler
@subsection Class DCCluster

Class DCCluster represents a cluster of nodes in Declustering algorithm.
There is no protected member in this class.
It consists of two DCClusters, called component clusters, to make 
a hierarchy of clusters. An elementary cluster has NULL component clusters.
It is constructed with the constructor with one argument.

@example
DCCluster(DCNodeList* @var{node-list});
@end example

The cluster contains all nodes from the list, and set the @code{elemDCCluster}
member of the nodes.

To make a macro cluster, we use the following constructor:

@example
DCCluster(DCCluster* @var{clust1}, DCCluster* @var{clust2});
@end example

The arguments clusters become the component clusters of this higher level
cluster. The cluster-arcs are established from the cluster-arcs of
two component clusters by calling the following method:

@example
void fixArcs(DCCluster* @var{clust1}, DCCluster* @var{clust2});
@end example

In this method, arcs put inside the same cluster are removed among the arcs
of two argument clusters.

In both constructors, we compute the sum of execution times of all nodes in
the cluster, which can be obtained by

@example
int getExecTime();
@end example

@example
DCCluster* getComp1();
DCCluster* getComp2();
@end example

These methods return two component clusters.

@example
void setName(const char* @var{name});
const char* readName();
@end example

The above methods set and get the name of the cluster.

@example
void addArc(DCCluster* @var{adj}, int @var{numSample});
@end example

This method adds a cluster-arc that is adjacent to the first argument cluster
with sample rate @var{numSample}.

@example
void setDCCluster(DCCluster* @var{clust});
@end example

Sets @code{cluster} pointer of the nodes in the cluster to the argument
cluster.

@example
void assignP(int @var{procNum});
int getProc();
@end example

These methods assign all nodes in the cluster to a processor, and returns
the processor that this cluster is assigned to.

@example
void switchWith(DCCluster* @var{clust});
@end example

Switchs the processor assignment of this cluster with the argument cluster.

@example
DCCluster* pullWhich();
@end example

Returns the cluster between two component clusters to be pulled out. Currently,
return the component cluster with smaller execution time.

@example
DCCluster* findCombiner();
@end example

This method returns the best cluster to be combined with by looking at
communication cost of cluster-arcs. We break ties by returning the 
cluster with smallest execution time.

@example
void broken();
int getIntact();
@end example

These methods indicate whether the cluster, or its subclusters, was broken
into its components in the scheduling stage (3) of DeclustScheduler.
The first method indicates that it happens while the second method
querries whether it happens or not.

@example
int getScore();
int setScore(int @var{score});
void resetMember();
@end example

These methods get and set the score of the cluster. Refer to
@code{computeScore} method of the DCGraph class to see what the score of
a cluster is. The last method resets the score to 0.

@example
StringList print();
@end example

Prints the name of this cluster and the names of component clusters.

@example
~DCCluster();
@end example

The destructor deletes the nodes in the cluster and cluster-arcs
if it is an elementary cluster.

@node class DCClusterList, class DCClustArcList, class DCCluster, Declustering Scheduler
@subsection Class DCClusterList

Class DCClusterList, derived from class DoubleLinkList, keeps a list of
clusters. It has no protected members. 
It has a default constructor and a copy constructor.

@example
void insert(DCCluster* @var{clust});
void append(DCCluster* @var{clust});
void insertSorted(DCCluster* @var{clust});
@end example

These methods put the argument cluster at the head and the back of the list.
The last method inserts the cluster in order of increasing execution time.

@example
DCClusterLink* firstLink();
DCCluster* firstDCClust();
DCCluster* popHead();
@end example

The above methods return the DCClusterLink and DCCluster at the head of the
list. The last method extracts the cluster from the list.
Class DCClusterLink is derived from class DoubleLink as a
container of DCCluster in the DCClusterList. It has a public method to
access the cluster:

@example
DCCluster* getDCClustp();
@end example

A DCClusterLink is created by

@example
DCClusterLink* createLink(DCCluster* @var{clust});
@end example

@example
void removeDCClusters();
@end example

Removes all clusters in the list.

@example
void resetList();
void resetScore();
void setDCClusters();
@end example

The first two methods reset the score of all clusters to 0. The first method
also declares that each cluster is not broken. The third method resets the
cluster pointer of the nodes of the clusters in the list.

@example
int member(DCCluster* @var{clust});
@end example

Returns TRUE or FALSE, based on whether the argument cluster is in the list or
not.

@example
void findDCClusts(DCNodeList& @var{nlist});
@end example

Add clusters that the nodes of the argument list belongs to, to the list.
If the number of clusters is 1, we break the cluster into two
component clusters and put them into the list.

@example
int listSize();
@end example

Returns the number of clusters in the list.

@example
StringList print();
@end example

Prints the list of clusters.

There is an iterator associated with the DCClusterList: DCClusterListIter.
It returns a DCCluster, while it can return a DCClusterLink by
@code{nextLink} method.

@node class DCClustArcList, class DCUniProc, class DCClusterList, Declustering Scheduler
@subsection Class DCClustArc and class DCClustArcList

Class DCClustArc represents a cluster-arc. It has a constructor with two
arguments:

@example
DCClustArc(DCCluster* @var{neighbor}, int @var{nsamples});
@end example

The first argument is the pointer to the neighbor cluster while the second
argument indicates the sample rate of the connection.

@example
DCCluster* getNeighbor();
void changeNeighbor(DCCluster* @var{clust});
@end example

These methods return the neighbor cluster and change it.

@example
void changeSamples(int @var{newsamps});
void addSamples(int @var{delta});
int getSamples();
@end example

The above methods modify, increment, and return the sample rate of the current
arc.

@example
StringList print();
@end example

Prints the name of the neighbor cluster and the sample rate.

Class DCClustArcList is derived from class SequentialList to make a list
of cluster-arcs. It has four public methods.

@example
DCClustArc* contain(DCCluster* @var{clust});
@end example

Returns the DCClustArc that is adjacent to the argument cluster. If no
cluster-arc is found in the list, return 0.

@example
void changeArc(DCCluster* @var{oldC}, DCCluster* @var{newC});
@end example

This method changes the pointer of neighbor cluster, @var{oldC},
in all cluster-arcs in the list to @var{newC}.

@example
void removeArcs();
@end example

Deletes all cluster-arcs in the list.

@example
StringList print();
@end example

Prints the list of DCClustArcs.

There is an iterator associated with the DCClustArcList: DCClustArcListIter.
It returns a DCClustArc.

@node class DCUniProc, class DCParProcs, class DCClustArcList, Declustering Scheduler
@subsection Class DCUniProc

Class DCUniProc is derived from class UniProcessor to maintain a new
variable for the processor: the sum of the computation and the communication
load, called @emph{load} shortly. This variable can be set and got by 
the following methods:

@example
int computeLoad();
int getLoad();
@end example

Both methods return the load of the processor.

@node class DCParProcs, , class DCUniProc, Declustering Scheduler
@subsection Class DCParProcs

Class DCParProcs is derived from class ParProcessors. It has the same
constructor and destructor with the ParProcessors class.

@example
UniProcessor* getProc(int @var{index});
DCUniProc* getSchedule(int @var{index});
@end example

The above methods return pointer to the component DCUniProc with given index.
The second method is a type-casted version of the first method.

There is one protected method:

@example
ParNode* createCommNode(int @var{i});
@end example

Creates a DCNode to represent a communication code. The argument indicates
the type of the node.

The other methods are all public, and support the main scheduling procedure
described in the DeclustScheduler class (@pxref{Declustering Scheduler}).

@example
int commAmount();
@end example

Returns the communication overhead of the current schedule.

@example
void saveBestResult(DCGraph* @var{graph});
@end example

This method saves the current scheduling information of the nodes as the best
scheduling result.

@example
void finalizeGalaxy(DCGraph* @var{graph});
@end example

After all scheduling is completed, we make a final version of the APEG
including all communication loads based on the best scheduling result
obtained.

@example
void categorizeLoads(int @var{procs});
@end example

This method categorizes each processor as being heavily or lightly loaded.
It sets an integer array, @var{nprocs}, 1 for heavy and -1 for light
processors. Initial threshold is 50% of the maximum load. We consider all
processors are heavily loaded if all processors are loaded beyond 75% of the
maximum load. We regard at most one idle processor as lightly loaded. 

@example
int findSLP(DCNodeList* @var{nlist});
@end example

This method finds the progression of nodes (regular or communication)
in the schedule which prevents the makespan from being any shorter. We call
this set of nodes and @emph{schedule limiting progression: SLP} (refer to
the Sih's paper). The SLP can span several processors and can not contain
idle time. If there are several schedule limiting progression, it will
return just one of them.

@node Base Classes for Code Generation, Target, Parallel Schedulers, Top
@chapter Base Classes for Code Generation

This chapter explains the basic classes for code generation in
$(PTOLEMY)/src/domains/cg/kernel directory. We do not cover all classes
in that directory. We will concentrate on how to organize the code by
which methods.

A segment of codes is formed in a CodeStream class. Each target will have
a list of CodeStreams, and arrange them to generate the final code.
A star uses CodeBlock classes to form a code segment, which will be
copied to a CodeStream of the target class after some processing.

We define a set of macros that a star programmer may use to refer
variables without worrying about resource allocation. For example, we refer
the portholes of a star, not knowing which physical resource is allocated
to them. 

@menu
* CodeStream::				class CodeStream and its role
* CodeBlock and Macros::		Write a code in CodeBlock
* Unique Symbol Generation::		Generation of unique symbols
* Resource Management::			Resource for portholes and states
* Utility Functions::			utility functions for code generation
* class CGStar::			other members of CGStar
* class CGPortHole::			other members of CGPortHole
@end menu

@node CodeStream, CodeBlock and Macros, Base Classes for Code Generation, Base Classes for Code Generation
@section CodeStream

Class CodeStream is derived from class StringList to make a stream of code.
In class CGTarget, a base target class for code generation, we have
two CodeStreams: @code{myCode} and @code{procedures}.

@example
CodeStream myCode;
CodeStream procedures;
@end example

These are protected members of class CGTarget. They are the default members
of the list of code streams that a CGTarget maintains.

@example
CodeStreamList codeStringLists;
@end example

It is a protected member of the CGTarget class.
We can add a CodeStream to @code{codeStringLists} by the following protected
method of the CGTarget class.

@example
void addStream(const char* @var{name}, CodeStream* @var{slist});
@end example

The first argument is the name of the CodeStream which is the second argument.
This method will be called in the constructor of the target class. If a target
tries to add a CodeStream with existing name, error will be signaled.

@example
CodeStream* getStream(const char* @var{name});
@end example

This method returns the pointer of the CodeStream with the given name. If
a stream is not found, it returns NULL. It is a public method of the 
CGTarget class. The CGStar class has the same method to get the
CodeStream with the given name from the target class it belongs to.

Now we will explain the public members of class CodeStream.

@example
int put(const char* @var{code}, const char* @var{name} = NULL);
@end example

This method puts a segment of code, @var{code}, to the list. We can give
the name of the code segment. If @var{name} is absent, we append the code
unconditionally. Otherwise, we check whether a code with the same name
already exists or not, by examining the @code{sharedNames} list. If no
code segment with the same name is found, append the code segment. This
method returns TRUE if code was successfully added to the stream, FALSE
otherwise.

@example
UniStringList sharedNames;
@end example

Is a protected member to store the names of code segments in the list.
Class UniqueStringList is privately derived from class StringList. It has
two public methods as follows:

@example
StringList :: initialize;
int isUnique(const char* @var{name});
@end example

The first method initialize the list. The second method returns FALSE or TRUE,
based on whether the argument string already exists in the StringList or not.

The CodeStream class has a method to initialize the string list and
@code{sharedNames}:

@example
void initialize();
@end example

Class CodeStreamList contains a list of CodeStreams. It is privately
derived from class NamedList since each CodeStream is assigned a name. 
There are four public methods in the CodeStreamList class:

@example
int append(CodeStream* @var{stream}, const char* @var{name});
int add(const char* @var{name}, CodeStream* @var{stream});
CodeStream* get(const char* @var{name}) const;
int remove(const char* @var{name});
@end example

The first two methods append a CodeStream to the list. They differ from
each other in the order of arguments. The third method returns a CodeStream
with the given name while the last method remove a CodeStream with the
given name from the list.

@menu
* class NamedList::			class NamedList
@end menu

@node class NamedList, , CodeStream, CodeStream
@subsection Class NamedList

Class NamedList is privately derived from class SequentialList to make
a list of objects with name. It has a default constructor. The destructor
deletes all objects in the list. There is no protected member in this class.

@example
int append(Pointer @var{object}, const char* @var{name});
void prepend(Pointer @var{object}, const char* @var{name});
@end example

Put an object, @var{object}, with name @var{name} at the end and the
beginning of the list. In the first method, we may not put multiple
objects with the same name. If an object with the same name exists, return
FALSE. On the other hand, the second method allows multiple objects with
the same name. Only the most recently prepended object will be visible.

@example
Pointer get(const char* @var{name} = NULL);
@end example

Returns the object with the given name. If no name is given, returns the
object at the head of the list. If no object is found, return NULL.

@example
int remove(const char* @var{name} = NULL);
@end example

Removes the object with the given name. If no name is given, remove the first
object at the head of the list. If no object is found return FALSE, else TRUE.

There is an iterator associated with the NamedList class: NamedListIter.
It returns a pointer to an object.

@node CodeBlock and Macros, Unique Symbol Generation, CodeStream, Base Classes for Code Generation
@section CodeBlock and Macros

Class CodeBlock stores a pointer to a text in its constructor.

@example
CodeBlock(const char* @var{text});
@end example

We have to make sure that the argument text lives as long as the codeblock is
used. There are four public methods defined to access the text.

@example
void setText(char* @var{line});
const char* getText();
operator const char*();
void printCode();
@end example

The first method sets the text pointer in the class. The next two methods
return the text this class points to. The last method prints to the code to
the standard output.

A star programmer uses ''codeblock'' directive in the preprocessor language
file to put a text. In a CodeBlock, the programmer uses the following macros
to access the star variables without worrying about resource managements or
name conflicts:

$val(@var{name})			Value of a state
$size(@var{name})			Buffer size of a state or a porthole
$ref(@var{name})			Reference to a state or a porthole
$ref(@var{name},@var{offset})		Reference with offset
$label(@var{name})			Unique label inside a codeblock
$codeblockSymbol(@var{name})		Another name for $label
$starSymbol(@var{name})			Unique label inside a star
$sharedSymbol(@var{list},@var{name})	Unique label for set list, name pair

These macros are resolved after resources are allocated or unique symbols are
generated. A CodeBlock defined in a CGStar is put to a CodeStream of
the target by the following methods of the CGStar class:

@example
int addCode(const char* @var{code}, const char* @var{stream} = NULL, const char* @var{name} = NULL);
int addProcedure(const char* @var{code}, const char* @var{name});
@end example

These methods are protected.
The first method puts a code, @var{code}, to the CodeStream with 
name @var{stream}
of the target. If the name of the CodeStream is not given, it uses
@code{myCode} stream of the target. The second method uses @code{procedure}
CodeStream of the target. The argument @var{name} of both methods is 
optional to
specify the name of the code. If the code is successfully added, they return
TRUE, and FALSE otherwise. Before putting the code into the CodeStream,
we process the code to resolve the macros by @code{processCode} method.

@example
StringList processCode(CodeBlock& @var{cb});
StringList processCode(const char* @var{code});
@end example

These methods are all protected and basically equal since the first method
calls the second method. They scans the code word by word copy to a
StringList. If a macro is found, the macro is expanded (@code{expandMacro})
before copying to the StringList. We can check whether a word is a macro
or not by comparing the first character with

@example
virtual char substChar() const;
@end example

This method is a virtual protected method of the CGStar class to return the
special character that introduces a macro in a code block. In the CGStar
class, it returns ''$''. 

@example
virtual StringList expandMacro(const char* @var{func}, const StringList& @var{argList});
@end example

This is a virtual protected method to expand a macro named @var{func}. The
argument list must be passed by reference so that the StringList is not
consolidated. It is virtual since the derived classes can define more macros.
A macro is identified by

@example
int matchMacro(const char* @var{func}, const StringList& @var{argList}, const char* @var{name}, int @var{argc});
@end example

This protected method returns TRUE when the first argument matches with the
third argument and the number of argument in the second argument is the same
as the fourth argument.

Based on the type macro, we may use one of the following protected methods to 
expand the macro:

@example
virtual StringList expandVal(const char* @var{name});
StringList expandSize(const char* @var{name});
virtual StringList expandRef(const char* @var{name});
virtual StringList expandRef(const char* @var{name}, const char* @var{offset});
@end example

These methods expands $val, $size, $ref, and $ref2 macros. We will redefine
the virtual methods in the derived classes. Particularly, we have to redefine
the last two methods in the derived classes because in the CGStar class they
generate error messages. The other macros deal with unique symbols in a
code block, in a star, and in a set of symbols. Refer to the next subsection
(@pxref{Unique Symbol Generation}).

When we find an error when expanding macros or processing code blocks, we
call the following methods to generate error message:

@example
void macroError(const char* @var{func}, const StringList& @var{argList});
void codeblockError(const char* @var{p1},  const char* @var{p2} = "");
@end example

The arguments of the second method provide the text of error message.

@node Unique Symbol Generation, Resource Management, CodeBlock and Macros, Base Classes for Code Generation
@section Unique Symbol Generation

To generate a unique symbol in a scope, we make a list of symbols in that
scope. For example, the CGStar class has two SymbolLists (protected
members): @code{starSymbol} and @code{codeblockSymbol}. 

@example
SymbolList starSymbol;
SymbolList codeblockSymbol;
@end example

Class SymbolList is derived from class BaseSymbolList. Class BaseSymbolList
is privately derived from class NamedList.
A BaseSymbolList keeps two private  members to give a unique name for 
each symbol in the list: a separator and a counter.

@example
BaseSymbolList(char @var{sep} = '_', int* @var{count} = NULL);
@end example

The first argument of the constructor sets the separator and the second 
argument sets the pointer of the count variable. These two variables can be
set by the following methods:

@example
void setSeparator(char @var{sep});
void setCounter(int* @var{count});
@end example

When we append or insert a symbol to the list, we give a unique 
name to that symbol by appending a separator followed by the counter value
to the argument symbol, and returns the unique name:

@example
const char* append(const char* @var{name});
const char* prepend(const char& @var{name});
@end example

@example
const char* get(const char* @var{name} = NULL);
@end example

Returns the unique symbol with the given name. If no name is given, return the
first symbol in the list.

@example
int remove(const char* @var{name} = NULL);
@end example

This method removes the unique symbol with the given name. If no name is given,
remove the first symbol in the list. It returns FALSE, if error occurs.

Symbols in the list are deletes in the destructor or in the following method:

@example
void initialize();
@end example

Now, class SymbolList is privately derived from class BaseSymbolList with
the same constructor and a default destructor.
This class uncovers only three methods of the base class.

@example
BaseSymbolList::setSeparator;
BaseSymbolList::setCounter;
BaseSymbolList::initialize;
@end example

It has one additional method:

@example
const char* lookup(const char* @var{name});
@end example

If a unique symbol with the given name exists, this method returns that
unique symbol. Otherwise, it creates a unique symbol with that name and 
puts it into the list.

Recall that the CGStar class has two SymbolLists. The macros,
$codeblockSymbol, $label, and $starSymbol, are resolved by @code{lookUp}
method of the @code{codeblockSymbol} and @code{starSymbol}, based on
the scope of the symbol. If the symbol already exists in the SymbolList,
it returns that unique symbol. Otherwise, it creates a unique symbol
in the scope of interest.

If we want to generate a unique symbol in the file scope, we use a symbol
list defined in the target class.

@example
ScopedSymbolList sharedSymbol;
@end example

It is a protected member of the CGTarget class. ScopedSymbolList class is
privately derived from class NamedList to store a list of SymbolLists, 
It has the same constructor as the base class. 

@example
void setSeparator(char @var{set});
void setCounter(int* @var{count});
@end example

These methods in the ScopedSymbolList class set the separator and the counter
pointer of all SymbolLists in the list.

@example
const char* lookup(const char* @var{scope}, const char* @var{name});
@end example

In this method, the first argument determines the SymbolList in the list named
@var{scope}, and the second argument determines the unique symbol in the
SymbolList. If no SymbolList is found with that name, we creats a new
SymbolList and insert it in the list.

The SymbolLists in the list are deleted in the destructor and in the following
method:

@example
void initialize();
@end example

Now, we can explain how to expand the last macro defined in the CGStar class:
$sharedSymbol. The first argument of the macro determines the StringList
and the second argument accesses the unique string in that StringList. It is
done by calling the following protected method in the CGStar class.

@example
const char* lookupSharedSymbol(const char* @var{scope}, const char* @var{name});
@end example

This method calls the same method defined the CGTarget class.

The CGTarget class has another symbol list:

@example
SymbolStack targetNestedSymbol;
@end example

It is a protected method to generate a unique nested symbol.
Class SymbolStack is privately derived from class BaseSymbolList. It has the
same constructor as the base class and has a default destructor.

For stack operation, it defines the following two methods:

@example
const char* push(const char* @var{tag} = "L");
StringList pop();
@end example

These methods put the symbol with given name to the top of the list and
pop the symbol at the top of the list.

This class also exposes four methods of the base class:

@example
BaseSymbolList::get;
BaseSymbolList::setSeparator;
BaseSymbolList::setCounter;
BaseSymbolList::initialize;
@end example

In this section, we explain various symbol lists. The separator and the
counter are usually defined in the CGTarget class.

@example
char separator;
int symbolCounter;
@end example

These are public members in the CGTarget class. They are set in the
constructor.

@node Resource Management, Utility Functions, Unique Symbol Generation, Base Classes for Code Generation
@section Resource Management

When we generate an assembly code, we have to allocate memory for portholes
and states of each star. For a high level language generation, we assign
unique definitions to them. It is rather easy to allocate resources for states
since its requirements are visible from the star definition: size and
name. In this section, we will focus on how to determine the buffer 
size of the portholes.

We allocate a buffer for each connection. We do not assume in the base class,
however, the buffer is owned by the source or by the destination porthole.
Instead, we use methods of the CGGeodesic class. Before determining the buffer
size, we obtain the information how many samples are accumulated on each
CGGeodesic by simulating the schedule. 

@example
int getMaxNum();
@end example

This public method of the CGGeodesic class returns the maximum number of

samples accumulated during one iteration of the schedule.

@example
incCount(int @var{delta});
@end example

Increases the number of samples on the Geodesic by @var{delta}.

The minimum buffer requirement of a connection is the sum of 
@code{getMaxNum} and the number of old samples required
by the destination star.

@example
int minNeeded() const;
@end example

Returns that minimum buffer size. It is a protected member of the CGGeodesic
class. 

We do not want to allocate buffers for portholes if unnecessary. For example,
the output portholes of a Fork star can share the same resource with its
input. A Gain star with unity gain is another example. Therefore, we pay
special attention to stars of Fork type. Without confusion, we refer
a star a @emph{Fork} star if its outputs can share the same resource as
the input. In the CGStar class, we provide the following methods.

@example
void isaFork();
int isItFork();
virtual void forkInit(CGPortHole& input, MultiCGPortHole& output);
virtual void forkInit(CGPortHole& input, CGPortHole& output);
@end example

Only the second method is public while others are protected. The first two
methods declare and querry that the star is a Fork star. If it is,
we call either one of the last two methods, based on whether the output
is a MultiPortHole or not. In those methods, we shift delays from a Fork's
input port to the output ports, and set the @code{forkSrc} pointer of
the output ports to the Fork's input port. The Fork's input port
keeps a list of the output ports in @code{forkDests} member. We apply
this procedure recursively in case of cascaded Forks.

@example
CGPortHole* forkSrc;
SequentialList forkDests;
@end example

These members are protected members of the CGPortHole class. They are set
by the following public method:

@example
void setForkSource(CGPortHole* @var{p});
@end example

The argument is the input porthole of the Fork star and this port is
an output porthole when we call this method. 

@example
int fork() const;
@end example

Is a public method of the CGPortHole class to return TRUE if it is an
input porthole of a Fork star.

Class CGGeodesic provides two methods to return the Fork input port
if it is at a Fork output port. Otherwise these methods return NULL.

@example
CGPortHole* src();
const CGPortHole* src() const;
@end example

These two methods are protected and differ from each other with the return
type. 

Now we will explain more methods of the CGGeodesic class.

@example
int forkType() const;
@end example

This public method indicates the type of the current CGGeodesic. If it
is at a Fork input, it is @code{F_SRC}. If it is at a Fork output, it is
@code{F_DEST}.

@example
int forkDelay() const;
@end example

This method returns the amount of delay from the current Geodesic up to
the fork buffer that this Geodesic refers to. If it is not associated
with a fork buffer, it returns 0.

We do not allocate a buffer to a CGGeodesic if it is @code{F_DEST}.

@example
int localBufSize() const;
int bufSize() const;
@end example

The above methods return the buffer size associated with this Geodesic.
While the first method returns 0 if the Geodesic is at a Fork output, the
second method returns the size of the fork buffer. The actual computation of
the buffer size is done by the following protected member.

@example
virtual int internalBufSize() const;
@end example

This method returns 0 with an error message if the schedule has not
yet been run. If this Geodesic is a @code{F_SRC}, the minimum size
is set to the maximum buffer requirements over all fork destinations.
If there are delays or old values are used, we may want to use a
larger size so that compile-time indexing is supportable. The buffer size
must divide the total number of tokens produced in one execution.
To avoid modulo addressing, we prefer to use the @emph{lcm} value of
the number of sample consumed and produced during one iteration of the
schedule. Since it may be wasteful, we check the extra buffer size required
for linear addressing with the @code{wasteFactor}. If the waste ratio is
larger then @code{wasteFactor}, we give up the linear addressing.

@example
virtual double wasteFactor();
@end example

In the CGGeodesic class, it is set to 2.0. If a derived class wants to
enforce linear addressing as much as possible, it should set the value
large.

@example
void initialize();
@end example

It initialize the Geodesic.

Refer to class CGPortHole (@pxref{class CGPortHole}) for more information
on resource managements.

@node Utility Functions, class CGStar, Resource Management, Base Classes for Code Generation
@section Utility Functions

There are three utility functions defined in the CG domain for code generation.

@example
char* makeLower(const char* @var{name});
int rshSystem(const char* @var{hostname}, const char* @var{command}, const char* @var{directory} = NULL);
@end example

The above functions are defined in file CGUtility.h.
The first method creates a new string, copies the argument
string changing all upper characters to lower characters, and returns the
string. The second method is used to execute a remote shell command,
@var{command}, at the @var{directory} in the machine @var{hostname}. We use
@code{xon} command instead of @code{rsh} to keep the X window environment
variables.

@example
int display(const StringList& @var{stuff}, const char* @var{filename} = NULL);
@end example

This method is defined in file CGDisplay.h. It displays a given string list
(usually a code), @var{stuff}, using an editor, which is determined by
an environment variable @code{PT_DISPLAY}. Two examples are @code{vi} and
@code{xedit}. The the file name is given, the code is written to that file.
If error occurs, return FALSE.

@node class CGStar, class CGPortHole, Utility Functions, Base Classes for Code Generation
@section Class CGStar

In this section, we will explain other CGStar members not described above in
this chapter. Class CGStar has a constructor with no argument. It is derived
from class DataFlowStar, not SDFStar, to support BDF in the future.

There is an iterator to access a PortHole of a CGStar: CGStarPortIter. It
returns a CGPortHole.

@menu
* CGStar protected members::		protected members of CGStar
* CGStar public members::		public members of CGStar
@end menu

@node CGStar protected members, CGStar public members, class CGStar, class CGStar
@section CGStar protected members

Protected members related to CodeStream, SymbolList, and resource
managements can be found in earlier sections of this chapter.

@example
virtual void outputComment(const char* @var{msg}, const char* @var{stream} = NULL);
@end example

Adds a comment @var{msg} to the target @var{stream}. If no target stream is
specified, use @code{myCode} stream.

@example
StringList expandPortName(const char* @var{name});
@end example

If the argument specifies a name of a MultiPortHole, the index may be
indicated by a State. In this case, this method gets the value of the
State as the index to the MultiPortHole and return a valid MultiPortHole name.
This method is used in @code{expandSize} method.

@example
void advance();
@end example

This method updates or increases the offset variable of all PortHoles by
the number of samples consumed or produced. It calls @code{advance} method
of each porthole.

@example
IntState procId;
@end example

This is a integer state to indicate the processor assignment. By default,
the value is -1 to indicate the star is not assigned yet. If we assign
stars manually, we give a valid processor id to this state.

@example
int dataParallel
@end example

Is a flag to be set if this star is a wormhole or a parallel star.

@example
Profile* profile;
@end example

This is a pointer to a Profile object (or a Profile array). If it is not
a parallel star, this pointer is set NULL.

@example
int deferrable();
@end example

When constructing a schedule for a single processor, we defer a star
as late as possible to reduce the buffer requirement on every arc.
In this method, we never defer a Fork star, and always defer a non-Fork
star that feeds into a Fork. This prevents the resulting fork buffer
from being larger than necessary; new samples are not added until they must be.

@node CGstar public members, , CGstar protected members, class CGStar
@subsection CGstar public members

@example
const char* domain() const;
int isA(const char* @var{class});
@end example

The first method returns ''CG''. The second method returns TRUE if
based on the argument class is CGStar or a base class of CGStar.

@example
int isSDF() const;
@end example

Returns TRUE if it is a SDF type star (default). For BDF stars, 
it will return FALSE.

@example
virtual void initCode();
@end example

This method allows a star to generate code outside the main loop.
This method will be called after scheduling is performed and before
scheduling is executed. On the other hand, @code{go} method is called
during scheduling is executed, to form a main loop body.

@example
int run();
@end example

This method in CG domain does not perform any data movement, but
execute @code{go} method followed by @code{advance} method (look at
protected members).

@example
CGTarget* myTarget();
void setTarget(Target* @var{t});
@end example

These methods get and set the target pointer this star is assigned to.
When we set the target pointer, we also initialize the SymbolLists and
the CodeStream pointers.

@example
virtual CGWormBase* myWormhole();
@end example

This method returns the pointer to itself if this star is a wormhole. 
It returns NULL if it is not a wormhole (default).

@example
int isParallel() const;
virtual Profile* getProfile(int @var{ix} = 0);
@end example

The first method returns TRUE if this star is a wormhole or a parallel 
star which needs more than one processor to generate code. If it is
@emph{parallel}, the second method returns the pointer to a Profile
indexed by the second argument. A parallel star stores the scheduling
results of the inside in Profile objects (@pxref{class Profile}).

@example
int maxComm();
@end example

Returns the communication overhead with its ancestors. It calls
@code{commTime} method of the target class to obtain the communication
cost.

@example
void setProcId(int @var{i});
int getProcId();
@end example

These methods set and get the processor id this star is assigned to.

@node class CGPortHole, , class CGStar, Base Classes for Code Generation
@section Class CGPortHole

Class CGPortHole is derived from class DFPortHole to support non-SDF type
DataFlow stars as well as SDF stars. Methods related to a Fork star
are already described in a previous section, Resource Management
(@pxref{Resource Management}).

In this section, we will categorize the members of CGPortHole into 4
roles.

@menu
* buffer management::			members for buffer management
* embedding::				members for buffer embedding
* switch Geodesic::			members to switch geodesic
* other members::			other members
* derived classes::			derived classes
@end menu

@node buffer management, embedding, class CGPortHole, class CGPortHole
@subsection buffer management

A CGPortHole is connected a buffer after resource allocation. A CGPortHole
maintains an offset index to the buffer to identify the current position
in the buffer which this porthole will put or get a new sample.

@example
int offset;
@end example

It is a protected member for indexing the buffer connected to this port.

Methods described in this subsection are all public.

@example
unsigned bufPos() const;
@end example

Returns @code{offset}, the offset position in the buffer.

@example
virtual int bufSize() const;
virtual int localBufSize() const;
@end example

Both methods returns the size of buffer connected to this porthole.
In this base class, they call the same methods of CGGeodesic
(@pxref{Resource Management}). Recall that the second method returns 0
when it is a Fork output. If a porthole is at the wormhole boundary,
both return the multiple of the sample rate and the repetition count of its
parent star. They are virtual so that the derived classes can redefine them.

@example
virtual void advance();
@end example

After its parent star is executed, we advance the offset by the number of
samples produced or consumed. The offset is wrapped around if it reaches
the boundary of the buffer.

@node embedding, switch Geodesic, buffer management, class CGPortHole
@subsection Embedding

Let's consider a DownSample star. If we allocate separate buffers to
its input and output ports, the buffer size of input port will be
larger than the output port. Also, we perform unnecessary sample copy.
We can improve this situation by allocating one buffer at the input site
and indicating a special section of that buffer as the image of the output
buffer. We call this relationship @emph{embedding}: the input buffer
embeds the output buffer. Unlike the fork buffer, the size of input and
output buffers are different. Therefore, we have to specify which position
the embedded buffer starts in the embedding buffer. We use this embedding
relationship to implement Spread and Collect stars in the CGC domain, without
increasing the buffer requirements. For example, the output ports of
a Spread star are embedded in the input buffer of the star, starting from
the different offsets.

@example
CGPortHole* embeddedPort;
int embeddedLoc;
int embeddingFlag;
@end example

These are protected members to specify embedding relations. The first one
points to the embedding port which this PortHole is embedded in. The second
member indicates the starting offset of embedding. The last member indicates
whether this porthole is an embedding port or not.

The following are public methods related to embedding.

@example
CGPortHole* embedded();
int whereEmbedded();
int embedding();
@end example

These methods return the protected members described in the previous
paragraph in the same order.

@example
void embed(CGPortHole& @var{p}, int @var{i} = -1);
@end example

This method establishes an embedding relationship between this port and
the argument port @var{p}. This porthole becomes an embedding port.
The second argument specifies the starting offset.

@example
void embedHere(int @var{offset});
@end example

This method changes the starting offset of embedded buffer in the embedding
buffer.

@node switch Geodesic, other members, embedding, class CGPortHole
@subsection Switch Geodesic

In the original graph, a PortHole is connected to a Geodesic. In code
generation domains, we usually allocate a resource to the Geodesic so that
the source and the destination port can share the same resource (Note that
it is not a must). After resource allocation, we may want to alias
a porthole to another porthole, that means another resource rather than
the allocated resource (@pxref{CGDDF Domain}). To do that, we switch
the pointer to the Geodesic to another Geodesic.

@example
virtual void switchGeo(Geodesic* @var{g});
virtual void revertGeo(Geodesic* @var{g});
@end example

Both methods set the Geodesic pointer to the argument @var{g}. There is a flag
to indicate that this port switched Geodesic or not. The first method
sets the flag while the second method resets the flag. Both are virtual since
in the derived classes we may need to save the original Geodesic.
The flag is querried by

@example
int switched() const;
@end example

If Geodesic is switched in this port, we have to reset the geodesic
pointer of this port to 0 in the destructor to prevent deleting the
same Geodesic multiple times. Also, we have to make sure that
both ends of a Geodesic do not switch Geodesic to prevent memory leaking.

@node other members, derived classes, switch Geodesic, class CGPortHole
@subsection Other members

Class CGPortHole has a constructor with no argument to reset the variables.
In the destructor, we clear @code{forkDests} list and remove the pointer
to this porthole from the @code{forkDests} list of @code{forkSrc} port.
All members described in the subsection are public.

@example
virtual Geodesic* allocateGeodesic();
CGGeodesic& cgGeo() const;
@end example

The first method allocates a CGGeodesic and give it a name.
The second method returns the reference of the Geodesic after type casting.

@example
void forceSendData();
void forceGrabData();
@end example

These methods put and get samples from the Geodesic at the wormhole
boundary. They are used when the inside code generation domain
communicate with the base workstation by wormhole mechanism.

@node derived classes, , other members, class CGPortHole
@subsection Derived classes

Class InCGPort and class OutCGPort are derived from CGPortHole to indicate
whether it is an input port or an output port.

Class MultiCGPort is derived from class MultiSDFPort. It has a protected
member @code{forkSrc} to point to the Fork input if its parent star
is a Fork star. It has a default destructor.

@example
CGPortHole* forkSrc;
@end example

There are two public methods related to this protected member.

@example
void setForkBuf(CGPortHole& @var{p});
void forkProcessing(CGPortHole& @var{p});
@end example

The first method sets @code{forkSrc} with the pointer to the argument port.
The second method sets @code{forkSrc} pointer of the argument port with
the @code{forkSrc} of this MultiPortHole.

Two methods are derived from MultiCGPort: MultiInCGPort and MultiOutCGPort.
They both have the following method:

@example
PortHole& newPort();
@end example

This method creates an InCGPort or an OutCGPort whether it is an input or an
output.

@node Target, Heterogeneous Support, Base Classes for Code Generation, Top
@chapter Target

Target has a clear meaning in code generation domains, a model of
the target machine for which code will be generated. Class CGTarget is the
base class for all code generation targets whether it is a single
processor target or a multiprocessor target. Class MultiTarget,
derived from class CGTarget, serves as the base target for all
multiprocessor targets. If we do not support CGDDF domain, class
CGMultiTarget becomes the base multiprocessor target. For
single processor targets, we have AsmTarget and HLLTarget to distinguish
assembly code generation targets and high level language generation targets.
If we generate assembly code for a target, the target will be derived from
class AsmTarget. If we generate a high level language code, the target
will be derived from HLLTarget. For detailed discussion for Target
hierarchy, refer [4] in References (@pxref{References}).

In this chapter, we will describe class CGTarget and some base multiprocessor
targets since we focus on multiprocessor code generation. Refer to
other sources for AsmTarget and other high level language targets.
 
@menu
* class CGTarget::			base target class for code generation
* multiprocessor targets::		base multiprocessor targets
@end menu

@node class CGTarget, multiprocessor targets, Target, Target
@section Class CGTarget

Class CGTarget is derived from class Target. It has a four-argument
constructor.

@example
CGTarget(const char* @var{name}, const char* @var{starclass}, const char* @var{desc}, char @var{sep});
@end example

The first argument is the name of the target and the second argument is the
star class that this target can support. The third argument is the description
of this target. The last one is a separator character for unique symbol
generation.

There are two protected states in the CGTarget:

@example
StringState destDirectory;
IntState loopingLevel;
@end example

The first state indicates where to put the code file. The second state
determines which scheduler is used in case this target is a single
processor target. By default, @var{loopingLevel} = 0 and we do not
try looping. If @var{loopingLevel} = 1, we select Joe's loop scheduler.
Otherwise, we use the most complicated loop scheduler.

At the top level, three methods of the Target class are called in sequence:
@code{setup}, @code{run}, and @code{wrapup}. 

@example
void setup();
@end example

In this method, we do the following tasks:

(1) Initialize @code{myCode} and @code{procedure} code stream.

(2) Select a scheduler if no scheduler is selected yet.

At this stage, we check whether the galaxy is assigned or not. In
multiprocessor targets, a child target is not assigned a galaxy until
a sub-univers is created. If the galaxy is not assigned, return.

(3) Reset the symbol lists.

(4) Modify the galaxy if necessary by calling @code{modifyGalaxy}. In this
base class it does nothing. But, in AsmTarget, we insert some stars
(CircToLin, LinToCirc) at loop boundary to change the type of buffer
addressing in case a loop scheduling is performed. In this method,
the galaxy can not be initialized particularly if it is a child target.

@example
virtual int modifyGalaxy();
@end example

Is a protected method.

(5) If it is a child target, the schedule was already made at this stage
from a parallel scheduler of the parent multiprocessor target. Otherwise,
we initialize and schedule the graph.

(6) If it is a child target or it is not inside a wormhole, return.
Otherwise, we first adjust the sample rate of the wormhole portholes
(@code{adjustSampleRates}). Then, we generate and download code:
@code{generateCode} and @code{wormLoadCode}.

@example
void adjustSampleRates();
@end example

This method is a protected method to be called when this target is
inside a wormhole. After scheduling is performed, we need to multiply
the sample rate of wormhole portholes by the repetition
count of the stars inside the wormhole connected to the porthole.

@example
virtual void generateCode();
@end example

This method guides the overall procedure to generate code for single
processor targets. The procedure is as follows:

(1) If this target is a child target, call @code{setup} to initialize the
variables. Copy the symbol counter (@code{symbolCounter}) of the parent
target to the symbol counter of this target to achieve a unique symbol
in the system scope.

(2) Write initial code.

@example
virtual void headerCode();
@end example

In this base class, this protected method writes the  header comment 
to @code{myCode} CodeStream.

@example
virtual StringList headerComment(const char* @var{begin} = NULL, const char* @var{end} = "", const char* @var{cont} = NULL);
@end example

This method is a public virtual method to generate the header comment in
the code. In this base class, the head comments include the user id,
code creation date, target name, and the galaxy name. The arguments are
passed to @code{comment} method.

@example
virtual StringList comment(const char* @var{cmt}, const char* @var{begin} = NULL, const char* @var{end} = "", const char* @var{cont} = NULL);
@end example

This public method generates a comment from a specified string @var{cmt}.
We prepend @var{begin} and append @var{end} to the string. If @var{begin}
is NULL, we prepend '#' as a shell-stype comment. If @var{cont} is
specified, multi-line comments are supported.

(3) We compute buffer sizes, allocate memory, etc: @code{allocateMemory}.

@example
virtual int allocateMemory();
@end example

This method is protected. It does nothing and returns TRUE in this base class.

(4) We do initialization for code generation: for example, compute offsets
of portholes and call @code{initCode} methods of stars: @code{codeGenInit}.

@example
virtual int codeGenInit();
@end example

Is a protected method. It does nothing and returns TRUE in this base class.

(5) Generate the code for the main loop: @code{mainLoopCode}.

@example
virtual void mainLoopCode();
@end example

In this method we first compute the number of iterations. If this target
is inside a wormhole, the number is -1 indicating an infinite loop. Otherwise,
the @code{stopTime} of the scheduler determines the number of iteration.
In this base class, we call the following five methods sequentially:
@code{beginIteration}, @code{wormInputCode} if inside a wormhole,
@code{compileRun}, @code{wormOutputCode} if inside a wormhole, and
@code{endIteration}. In the derived class, this sequence may be changed
(@pxref{class CGMultiTarget}).

@example
void beginIteration(int @var{numIter}, int @var{depth});
void endIteration(int @var{numIter}, int @var{depth});
@end example

These public methods form the head or ending of the main loop. The arguments of
both methods are the number of iteration and the depth of the loop. In the
main loop, the depth is set 0.

@example
virtual void wormInputCode();
virtual void wormOutputCode();
virtual void wormInputCode(PortHole& @var{p});
virtual void wormOutputCode(PortHole& @var{p});
@end example

The above methods are all public. They generate code at the wormhole 
boundary if
the target resides in a wormhole. The last two methods generate code
for the argument porthole that is at the wormhole boundary. In this
base class, put comments in @code{myCode} CodeStream indicating that
the methods are successfully executed. They should be redefined in the
derived classes to be useful. The first two methods traverse all
portholes at the wormhole boundary to use the last two methods.

@example
virtual void compileRun(SDFScheduler* @var{sched});
@end example

This protected method calls @code{compileRun} of the argument scheduler.
By default, this method calls @code{go} methods of all stars in the scheduled
order to generate code in @code{myCode} CodeStream.

(6) Call @code{wrapup} methods of stars to generate code after the main loop,
but still inside the main function.

(7) Add more code if necessary: @code{trailerCode}

@example
virtual void trailerCode();
@end example

This protected method does nothing in this base class.

(8) Organize the CodeStreams into a single code and save the result to
@code{myCode} stream: @code{frameCode}.

@example
virtual void frameCode();
@end example

This method is a protected method. It does nothing in this base class.

(9) If this target is not a child target, write the generated code to a file:
@code{writeCode}.

@example
virtual void writeCode(const char* @var{name} = NULL);
@end example

This is a public method to write the @code{myCode} stream to the argument
file. If no argument is given, use ''code.output'' as the default file name.

(10) If it is a child target, copy the symbol counter to that of the parent
target.

The methods described above for code generation are all virtual methods.
They will be redefined in the derived targets. 

@example
virtual int wormLoadCode();
@end example

This method is protected. It downloads code to the target machine and starts
it executing if the target resides in a wormhole. In this base class, we
just display the code.

Now, we discuss the @code{run} method.

@example
int run();
@end example

If the target is not inside a wormhole, it generates code by calling
@code{generateCode} as explained above. Otherwise, we do the transfer of
data to and from the target since this method will be called when the
wormhole is executed: @code{sendWormData} and @code{receiveWormData}
in sequence.

@example
virtual int sendWormData();
virtual int receiveWormData();
virtual int sendWormData(PortHole& @var{p});
virtual int receiveWormData(PortHole& @var{p});
@end example

The above methods are all protected. They send and receive samples to this
target when run inside a wormhole. The argument is the porthole of the
interior star at the wormhole boundary. If no argument is given, send and
receive for all the appropriate portholes. In this base class, we generate
comments to indicate that these methods are successfully called.

@example
void wrapup();
@end example

In derived classes, wrapup will generate wrapup code to finalize the code,
download, and run the code. This CGTarget class just displays the code.

So far, we explain the three top level methods of the CGTarget class.
Methods related to the CodeStream and unique symbol generations can
be found in the previous chapter. We will describe the remaining members.

@menu
* other CGTarget protected members::	other CGTarget protected members
* other CGTarget public members::	other CGTarget public members
* class HLLTarget::			HLLTarget, derived class
@end menu

@node other CGTarget protected members, other CGTarget public members, class CGTarget, class CGTarget
@subsection Other CGTarget protected members

@example
char* schedFileName;
@end example

The name of log file in case a loop scheduling is taken. By default, the name
is set ''schedule.log''.

@example
int noSchedule;
@end example

This is a flag to be set TRUE if scheduling is not needed in the setup stage.
This flag will be set when the schedule is copied from @code{copySchedule}
method in parallel code generation. By default, this flag is set FALSE.

@example
StringList indent(int @var{depth});
@end example

This method returns a list of spaces for indenting. The number of spaces
is 4 per each @var{depth}.

@example
void switchCodeStream(Block* @var{b}, CodeStream* @var{s});
@end example

This method is set the current @code{myCode} pointer of the argument block
@var{b} to @var{s} CodeStream. If @var{b} is a galaxy, perform this for
all component stars.

@node other CGTarget public members, class HLLTarget, other CGTarget protected members, class CGTarget
@subsection Other CGTarget public members

@example
static int haltRequested();
@end example

Returns TRUE if error is signaled while Ptolemy is running.

@example
int inWormhole();
@end example

@example
int isA(const char* @var{class});
@end example

Is a standard @code{isA} method for type identification.

Returns TRUE or FALSE, based on whether the target is inside a wormhole or not.

@example
Block* makeNew() const;
@end example

Create a new, identical CGTarget. Internal variables are not copied.

@example
virtual int incrementalAdd(CGStar* @var{s}, int @var{flag} = 1);
@end example

This method is called when we add code for the argument star @var{s}
incrementally. If @var{flag} is 1 (default), we allocate memory for the star, 
and call @code{setup}, @code{initCode}, @code{go}, and @code{wrapup} of
the star. If @var{flag} is 0, we just call @code{go} method of that star.
This method is used in CGDDF domain to insert communication stars for
control and data synchronization. In this base class, generate an error
message.

@example
virtual int insertGalaxyCode(galaxy* @var{g}, SDFScheduler* @var{sched});
@end example

This method inserts the code for the argument galaxy @var{g} incrementally.
We have to allocate resources and generate initialization, main loop, and
wrapup codes. It is used to generate code for galaxy inside a dynamic
construct. A dynamic construct is a wormhole in the code generation domain.
When we call @code{go} method of the wormhole, we generate code
for the inside galaxy (@pxref{CGDDF Domain}).

@example
virtual int compileCode();
virtual int loadCode();
virtual int runCode();
@end example

These methods compile and load the code, and run the target. In this base
class, generate error messages.

@example
void writeFiring(Star& @var{s}, int @var{depth});
@end example

This method generate code for a firing of the argument star. In this base
class, simply execute @code{run} of the star.

@example
void genLoopInit(Star& @var{s}, int @var{reps});
void genLoopEnd(Star& @var{s});
@end example

In case a loop scheduling is taken, we may want to perform loop
initialization routines for stars inside each loop. There methods
call @code{beginLoop} and @code{endLoop} methods of the argument
star.

@example
void copySchedule(SDFSchedule& @var{sched});
@end example

If this is a child target, the schedule is inherited from the parallel
scheduling of the parent target. This method copies the argument
schedule to the schedule of this target and set @code{noSchedule} flag.

@example
virtual int systemCall(const char* @var{cmd}, const char* @var{error} = NULL, const char* @var{host} = ''localhost'');
@end example

This method makes a system call using @code{rshSystem} utility function.
If @var{error} is specified and the system call is unsuccessful, display the
error message.

@example
void amInherited();
@end example

This method declares that this target is inherited from other target.
In CGDDF domain, we have a wormhole of code generation domain. The
target inside the wormhole should be same as the target outside the
CGDDF domain. Then, we just inherit the outside target to the inside target.

@example
virtual int support(Star* @var{s});
@end example

Returns TRUE if this target allows the argument star, FALSE otherwise.

@example
virtual int execTime(DataFlowStar* @var{s}, CGTarget* @var{t} = 0);
@end example

We return the execution time of the argument star @var{s} in the argument
target @var{t}. In a heterogeneous system, execution time of a given
star may vary depending on which target execute the star. In this base
class, we just call @code{myExecTime} method of the star.

@node class HLLTarget, , other CGTarget public members, class CGTarget
@subsection Class HLLTarget

Class HLLTarget, derived from CGTarget class, is a base class of
all high level language code generation targets. There is
AsmTarget class for the base target of all assembly code generation
targets. Since we will illustrate C code generation target, we will
explain the HLLTarget class only in this subsection.

HLLTarget class has a constructor with three arguments as CGTarget class.
In this base class, we provide some methods to generate C++ code.
The following three protected methods are defined to create a
C++ identifier, derived from the actual name.

@example
StringList sanitize(const char* @var{s}) const;
StringList sanitizedName(const NamedObj& @var{b}) const;
virtual StringList sanitizedFullName(const NamedObj& @var{b}) const;
@end example

The first method takes a string argument and modifies it with a valid
C++ identifier. If the string contains a non-alphanumeric character, it
will replace it with '_'. If the string stars with a numeral, it
prepends 'x' at the beginning. The second method calls the first method
with the name of the argument object. The third method generates
an identifier for the argument object that will be placed in @code{struct}
data structure. Therefore, we puts '.' between the object name and its
parent name.

Some public methods are defined.

@example
void beginIteration(int @var{repetitions}, int @var{depth});
void endIteration(int @var{repetitions}, int @var{depth});
@end example

If the @var{repetitions} is negative, we print a @code{while} loop
with infinite repetition. Otherwise, we generate a @code{for}
loop. The second argument @var{depth} determines the amount of indent
we put in front of the code.

@example
void wrapup();
@end example

Saves the generated code to "code.output" file name.

Since this target is not an actual target, it has a pure virtual method:
@code{makeNew}.

@node multiprocessor targets, , class CGTarget, Target
@section Multiprocessor Targets

There are two base multiprocessor targets: MultiTarget and CGMultiTarget.
Class MultiTarget, derived from class CGTarget, serves a base multiprocessor
target for CG domain and CGDDF domain. On the other hand, CGMultiTarget
class is the base multiprocessor target for CG domain, thus derived from
MultiTarget class. Since the MultiTarget class is a pure virtual class,
the derived classes should redefine the pure virtual methods of the class.

Some members only meaningful for CG domain are split to MultiTarget
class and the CGMultiTarget class. If they are accessed from the parallel
scheduler, some members are placed in MultiTarget class. Otherwise, they
are placed in CGMultiTarget class (Note that this is the organization issue).
Refer to the CGMultiTarget class for detailed descriptions.

@menu
* class MultiTarget::		class MultiTarget
* class CGMultiTarget::		class CGMultiTarget
* class CGSharedBus::		class CGSharedBus
@end menu

@node class MultiTarget, class CGMultiTarget, multiprocessor targets, multiprocessor targets
@subsection Class MultiTarget

Class MultiTarget, derived from CGTarget, has a constructor with three
arguments.

@example
MultiTarget(const char* @var{name}, const char* @var{starclass}, const char* @var{desc});
@end example

The arguments are the name of the target, the star class it supports, and the
description text. The constructor hides @code{loopingLevel} parameter
inherited from the CGTarget class since the parallel scheduler does not
looping as of now.

@example
IntState nprocs;
@end example

This state, as a protected member, represents the number of processors.
We can set this state, and also change the initial value, by the following 
public method:

@example
void setTargets(int @var{num});
@end example

After child targets are created, the number of child target is stored in
the following protected member:

@example
int nChildrenAlloc;
@end example

There are three states, which are all protected, to choose a scheduling option.

@example
IntState manualAssignment;
IntState oneStarOneProc;
IntState adjustSchedule;
@end example

If the first state is set YES, we assign stars manually by setting
@code{procId} state of all stars. If @code{oneStarOneProc} is set YES,
the parallel scheduler puts all invocations of a star into the same
processor. Note that if manual scheduling is chosen, @code{oneStarOneProc}
is automatically set YES. The last state, @code{adjustSchedule}, will be
used to override the scheduling result manually. This feature has not been
implemented yet. There are some public methods related to these states:

@example
int assignManually();
int getOSOPreq();
int overrideSchedule();
void setOSOPreq(int @var{i});
@end example

The first three methods querry the current value of the states. The last
method sets the current value of @code{oneStarOneProc} state to the
argument value.

There are other two states that are protected:

@example
IntState sendTime;
IntState inheritProcessors;
@end example

The first state indicates the communication cost to send a unit sample
between nearest neighbor processors. If @code{inheritProcessors} is set YES,
we inherit the child targets from somewhere else by the following method.

@example
int inheritChildTargets(Target* @var{mtarget});
@end example

This is a public method to inherit child targets from the argument target.
If the number of processors is greater than the number of child targets
of @var{mtarget}, this method returns FALSE with error message. Otherwise,
it copies the pointer to the child targets of @var{mtarget} as its child
targets. If the number of processors is 1, we can use a single processor
target as the argument. In this case, the argument target becomes the child
target of this target.

@example
void enforceInheritance();
int inherited();
@end example

The first method sets the initial value of @code{inheritProcessors} state
while the second method gets the current value of the state.

@example
void initState();
@end example

Is a redefined public method to initialize the state and implements
the precedence relation between states.

@menu
* other MultiTarget public members::	other MultiTarget public members
@end menu

@node other MultiTarget public members, , class MultiTarget, class MultiTarget
@subsubsection Other MultiTarget public members

@example
virtual DataFlowStar* createSpread() = 0;
virtual DataFlowStar* createCollect() = 0;
virtual DataFlowStar* createReceive(int @var{from}, int @var{to}, int @var{num}) = 0;
virtual DataFlowStar* createSend(int @var{from}, int @var{to}, int @var{num}) = 0;
@end example

These methods are pure virtual methods to create Spread, Collect, Receive, and
Send stars that are required for sub-universe generation. The last two method
need three arguments to tell the source and the destination processors as well
as the sample rate.

@example
virtual void pairSendReceive(DataFlowStar* @var{snd}, DataFlowStar* @var{rcv});
@end example

This method pairs a Send, @var{snd}, and a Receive, @var{rcv}, stars. In this
base class, it does nothing.

@example
virtual void addProcessorCode(int @var{pid}, const char* @var{code});
@end example

The arguments of this method are the processor id and the generated code for
that processor. In this base class, we append the argument code into the
@code{myCode} stream so that codes for all child targets are placed
sequentially in one code.

@example
virtual IntArray* candidateProcs(ParProcessors* @var{procs}, DataFlowStar* @var{s});
@end example

This method returns the array of candidate processors which can schedule
the star @var{s}. The first argument is the current ParProcessors that tries to
schedule the star (@pxref{class CGMultiTarget}). In this class, do
nothing and returns NULL.

@example
virtual Profile* manualSchedule(int @var{count});
@end example

This method is used when this target is inside a wormhole. This method
determines the processor assignments of the Profile manually. The argument
indicates the number of invocation of the wormhole.

@example
virtual void saveCommPattern();
virtual void restoreCommPattern();
virtual void clearCommPattern();
@end example

These methods are used to manage the communication resources. In this base
class, do nothing. The first method saves the current resource schedule,
while the second method restores the saved schedule. The last method clears
the resource schedule.

@example
virtual int scheduleComm(ParNode* @var{node}, int @var{when}, int @var{limit} = 0);
@end example

This method schedules the argument communication node, @var{node}, available
at @var{when}. If the target can not schedule the node until @var{limit},
return -1. If it can, return the schedule time. In this base class, just return
the second argument, @var{when}, indicating that the node is scheduled
immediately after it is available to model a fully-connected interconnection of
processors.

@example
virtual ParNode* backComm(ParNode* @var{node});
@end example

For a given communication node, find a communication node scheduled just before
the argument node on the same communication resource. In this base class,
return NULL.

@example
virtual void prepareSchedule();
virtual void prepareCodeGen();
@end example

These two methods are called just before scheduling starts, and just
before code generation starts, to do necessary tasks in the target class.
They do nothing in this base class.

The following methods are defined to support CGDDF domain 
(@pxref{CGDDF Domain}).

@example
virtual void setProfile(Profile* @var{prof});
@end example

This method sets the pointer to the Profile of this target with the argument
Profile pointer. The scheduling result of this target will be copied to the
Profile object. Do nothing in this base class.

@example
virtual int totalWorkLoad();
@end example

Returns the total work-load under this target.

@example
virtual int computeProfile(int @var{numP}, int @var{resWork}, IntArray* @var{array});
@end example

This method computes the best Profile in the CGDDF Domain: how many 
processors to assign and the corresponding Profile with that number 
of processors. The first argument is the maximum number of available 
processors, the second the work-load that can be executed simultaneously 
with this CGDDF Domain, and the third is the pattern of processor availability.
Return the number of assigned processors.
In CG domain, the role of this method is different. Refer to class
CGMultiTarget (@pxref{class CGMultiTarget}). In this base class, do nothing 
and return the first argument. 

@example
virtual int insideSchedule(Profile* @var{profile});
@end example

This method finalizes the schedules of all code generation wormholes in the
CGDDF galaxy to which this target belongs. Return FALSE if any error occurs.
In this base class, do nothing and return TRUE.

@example
virtual int downLoadCode(int @var{invoc}, int @var{pix}, Profile* @var{pf});
@end example

This method downloads code of the CGDDF galaxy assigned to processor of
index @var{pix}. The first argument is the invocation numbe, and the
third argument represents the Profile of the galaxy. It returns FALSE if
any error occurs. In this base class, do nothing and return TRUE.

@node class CGMultiTarget, class CGSharedBus, class MultiTarget, multiprocessor targets
@subsection Class CGMultiTarget

While class CGMultiTarget is the base multiprocessor target for all 
code generation domains, either homogeneous or heterogeneous, it
models a fully-connected multiprocessor target. In the target list
in pigi, "FullyConnected" target refers to this target. It is defined in
$(PTOLEMY)/src/domains/cg/targets directory. It has a constructor with three
argument like its base class, MultiTarget. 

To specify child targets, this class has the following three states.

@example
StringArrayState childType;
StringArrayState resources;
IntArrayState relTimeScales;
@end example

The above states are all protected.
The first state, @code{childType}, specifies the names of the child
targets as a list of strings separated by a space. If the number of strings
is fewer than the number of processors specified by @code{nproc} parameter,
the last entry of @code{childType} is extended to the remaining processors.
For example, if we set @code{nproc} equal to 4 and @code{childType} to
be "default-CG56[2] default-CG96", then the first two child targets become
"default-CG56" and the next two child targets become "default-CG96".

The second state, @code{resources}, specifies special resources for child
targets. If we say "0 XXX ; 3 YYY", the first child target (index 0) has
XXX resource and the fourth child (index 3) has YYY resource. Here ';' is
a delimeter. If a child target (index 0) has @code{resources} state already,
XXX resource is appended to the state at the end. Note that we can not edit
the states of child targets in the current pigi. If a star needs a special
resource, the star designer should define @code{resources} StringArrayState
in the definition of the star. For example, a star S is created with
@code{resources} = YYY. Then, the star will be scheduled to the fourth child.
One special resource is the target index. If @code{resources} state of a
star is set to "2", the star is scheduled to the third target (index 2).

The third state indicates the relative computing speed of the processors.
The number of entries in this state should be equal to the number of
entries in @code{childType}. Since we specify the execution of a star
with the number of cycles in the target for which the star is defined,
we have to compensate the relative cycle time of processors in case of
heterogeneous target environment.

Once we specify the child targets, we select a scheduler with appropriate
options. States inherited from class MultiTarget are used to select
the appropriate scheduling options. In the CGMultiTarget class, we have
the following three states, all protected, to choose a scheduler unless
the manual scheduling option is taken.

@example
IntState ignoreIPC;
IntState overlapComm;
IntState useCluster;
@end example

The first state indicates whether we want to ignore communication overhead
in scheduling or not. If it says YES, we select the Hu's level scheduler
(@pxref{Hu's Level Scheduler}). If it says NO, we use the next state,
@code{overlapComm}. If this state says YES, we use the dynamic level scheduler
(@pxref{Dynamic Level Scheduler}). If it says No, we use the last state.
@code{useCluster}. If it says YES, we use the declustering algorithm
(@pxref{Declustering Scheduler}). If it says NO, we again use the dynamic
level scheduler. By default, we use the dynamic level scheduler by setting
all states NO. Currently, we do not allow communication to be overlapped
with computation. If more scheduling algorithms are implemented, we may need
to introduce more parameters to choose those algorithms. 

There are other states that are also protected.

@example
StringState filePrefix;
@end example

Indicates the prefix of the file name generated for each processor.
By default, it is set "code_proc", thus creating code_proc0, code_proc1, etc
for code files of child targets.

@example
IntState ganttChart;
@end example

If this state says YES (default), we display the Gantt chart of the 
scheduling result. 

@example
StringState logFile;
@end example

Specifies the log file.

@example
IntState amortizedComm;
@end example

If this state is set YES, we provide the necessary facilities to packetize
samples for communication to reduce the communication overhead. These
has not been used nor tested yet.

Now, we discuss the three basic methods: @code{setup, run, wrapup}.

@example
void setup();
@end example

(1) Based on the states, we create child targets and set up them:
@code{prepareChildren}.

@example
virtual void prepareChildren();
@end example

This method is protected. If the children are inherited, it does nothing.
Otherwise, It clears the list of current child targets if exists. Then,
it creates new child targets by @code{createChild} method and give them
a unique name using @code{filePrefix} followed by the target index.
This method also adjusts the @code{resources} parameter of child targets
with the @code{resources} specified in this target: @code{resourceInfo}.
Finally. it initializes all child targets.

@example
virtual Target* createChild(int @var{index});
@end example

This protected method creates a child target, determined by
@code{childTypes}, of given @var{index}.

@example
virtual void resourceInfo();
@end example

This method parses the @code{resources} state of this class and adjust the
@code{resources} parameter of child targets. If no @code{resources} parameter
exists in a child target, it creates one.

(2) Choose a scheduler based on the states: @code{chooseScheduler}.

@example
virtual void chooseScheduler();
@end example

This is a protected method to choose a scheduler based on the states
related to scheduling algorithms.

(3) If it is a heterogeneous target, we flatten the wormholes:
@code{flattenWorm}. To represent a universe for heterogeneous targets,
we manually partition the stars using wormholes: which stars are assigned
to which target. 

@example
void flattenWorm();
@end example

This method flattens wormholes recursively if the wormholes have
a code generation domain inside (not CGDDF nor simulation domains).

(4) Set up the scheduler object. Clear @code{myCode} stream.

(5) Initialize the flattened galaxy, and perform the parallel scheduling:
@code{Target::setup}.

(6) If the child targets are not inherited, display the Gantt chart if
requested: @code{writeSchedule}.

@example
void writeSchedule();
@end example

This public method displays a Gantt chart.

(7) If this target is inside a wormhole, it adjusts the sample rate of the
wormhole ports (@code{CGTarget::adjustSampleRates}), generates code
(@code{generateCode}), and download and run code in the target
(@code{CGTarget::wormLoadCode}).

@example
void generateCode();
@end example

This is a redefined public method.  If the number or processors is 1,
just call @code{generateCode} of the child target and return. 
Otherwise, we first
set the stop time, or the number of iteration, for child targets
(@code{beginIteration}). If the target is inside a wormhole,
the stop time becomes -1 indicating it is an infinite loop.
The next step is to generate wormhole interface code
(@code{wormInputCode, wormOutCode} if the target is inside a wormhole.
Finally, we generate code for all child targets 
(@code{ParScheduler::compileRun}).
Note that we generate wormhole interface code before generating code
for child targets since  we can not intervene the code generation procedure of
each child target once started.

@example
void beginIteration(int @var{repetitions}, int @var{depth});
void endIteration(int @var{repetitions}, int @var{depth});
@end example

These are redefined protected methods. In the first method, we call
@code{setStopTime} to set up the stop time of child targets.
We do nothing in the second method.

@example
void setStopTime(double @var{val});
@end example

This method sets the stop time of the current target. If the child
targets are not inherited, it also sets the stop time of the
child targets.

@example
void wormInputCode();
void wormOutputCode();
void wormInputCode(PortHole& @var{p});
void wormOutputCode(PortHole& @var{p});
@end example

They are all redefined public methods. The first two methods traverse
the portholes of wormholes in the original graph, find out all
portholes in sub-universes matched to each wormhole porthole, and generate
wormhole interface code for the portholes.
The complicated thing is that
more than one ParNodes are associated with a star and these ParNodes
may be assigned to several processors.
The last two methods are used when the number of processors is 1 since we
then use @code{CGTarget::wormInputCode,wormOutputCode} instead of the first
two methods.
 
@example
int run();
@end example

If this target does not lie in a wormhole or it has only one processor,
we just use @code{CGTarget::run} to generate code.
Otherwise, we transfer data samples to and from the target:
@code{sendWormData} and @code{receiveWormData}.

@example
int sendWormData();
int receiveWormData();
@end example

These are redefined protected methods. They send data samples to the current
target and receive data samples from the current target. We traverse the
wormhole portholes to identify all portholes in the sub-universes 
corresponding to them, and call @code{sendWormData, receiveWormData} for them.

@example
void wrapup();
@end example

In this base class, we write code for each processor to a file.
 
@menu
* other CGMultiTarget protected members:: other CGMultiTarget protected members
* other CGMultiTarget public members::	  other CGMultiTarget public members
@end menu

@node other CGMultiTarget protected members, other CGMultiTarget public members, class CGMultiTarget, class CGMultiTarget
@subsubsection Other CGMultiTarget protected members

@example
ParProcessors* parProcs;
@end example

Is a pointer to the actual scheduling object associated with the current
parallel scheduler.

@example
IntArray canProcs;
@end example

This is an integer array to be used in @code{candidateProcs} to contain
the list of processor indices.

@example
virtual void resetResources();
@end example

This method clears the resources this target maintains such as communication
resources.

@example
void updataRM(int @var{from}, int @var{to});
@end example

This method updates a reachability matrix for communication amortization.
A reachability matrix is created if @code{amortizedComm} is set YES.
We can packetize communication samples only when packetizing does not
introduce deadlock of the graph. To detect the deadlock condition, we
conceptually cluster the nodes assigned to the same processors. If the
resulting graph is acyclic, we can packetize communication samples.
Instead of clustering the graph, we set up the reachability matrix and
update it in all send nodes. If there is a cycle of send nodes, we can
see the deadlock possibility.

@node other CGMultiTarget public members, , other CGMultiTarget protected members, class CGMultiTarget
@subsubsection Other CGMultiTarget public members

The destructor deletes all child targets, scheduler, and reachability matrix
if exists. There is a @code{isA} method defined for type identification.

@example
Block* makeNew() const;
@end example

Creates am object of CGMultiTarget class.

@example
int execTime(DataFlowStar* @var{s}, CGTarget* @var{t});
@end example

This method returns the execution time of a star @var{s} if scheduled on
the given target @var{t}. If the target does not support the star, return -1.
If it is a heterogeneous target, we consider the relative time scale of
processors. If the second argument is NULL or it is a homogeneous 
multiprocessor target, just return the execution time of the star in its
definition.

@example
IntArray* candidateProcs(ParProcessors* @var{par}, DataFlowStar* @var{s});
@end example

This method returns a pointer to an integer array of processor indices.
We search the processors that can schedule the argument star @var{s}
by checking the star type and the resource requirements. We include at most
one idle processor.

@example
int commTime(int @var{from}, int @var{to}, int @var{nSamples}, int @var{type});
@end example

This method returns the expected communication overhead when transferring
@var{nSamples} data from @var{from} processor to @var{to} processor. If
@var{type} = 2, this method returns the sum of receiving and sending
overhead.

@example
int scheduleComm(ParNode* @var{comm}, int @var{when}, int @var{limit} = 0);
@end example

Since it models a fully-connected multiprocessors, we can schedule
a communication star anytime without resource conflict, thus return the
second argument @var{when}.

@example
ParNode* backComm(ParNode* @var{rcv});
@end example

This method returns the corresponding send node paired with the argument
receive node, @var{rcv}. If the argument node is not a receive node, return
NULL.

@example
int amortize(int @var{from}, int @var{to});
@end example

This method returns TRUE or FALSE, based on whether communication can be
amortized between two argument processors.

The following methods to support CGDDF Domain (@pxref{CGDDF Domain}).

@example
int totalWorkLoad();
@end example

Returns the total work-load of this target.

@example
int computeProfile(int @var{nP}, int @var{flag}, IntArray* @var{procMap});
@end example

This method schedules the galaxy inside the wormhole. If @var{flag} = 1,
it schedules with @var{nP} processors. If @var{flag} = -1, we schedule
the graph with @var{nP} processors, create sub-galaxies, and schedule the
wormholes in the galaxy. The third argument @var{procMap} indicates the 
mapping of the child targets and the processors inside the wormhole.
If @var{flag} = -2, we create sub-galaxies. Return TRUE if no error occurs.

@example
void setProfile(Profile* @var{pf});
@end example

Passes the argument Profile pointer to the parallel scheduler.

@example
int downLoadCode(int @var{index}, int @var{pId}, Profile* @var{pf});
@end example

This method inserts the code of the galaxy in this wormhole to the
target code. This method is called in @code{go} method of the wormhole.
If the number of processors is 1, we use @code{CGTarget::insertGalaxyCode}.
Otherwise, we use @code{UniProcessor::genCodeTo}. The first argument
indicates the processor index while the second argument indicates the
target index.

@node class CGSharedBus, , class CGMultiTarget, multiprocessor targets
@subsection Class CGSharedBus

Class CGSharedBus, derived from class CGMultiTarget, is a base class for
shared bus multiprocessor targets. It has the same kind of constructor as
its base class.

This class has an object to model the shared bus.

@example
UniProcessor bus;
UniProcessor bestBus;
@end example

These are two protected members to save the current bus schedule and the
best bus schedule obtained so far. The @code{bus} and @code{bestBus}
are copied to each other by the following public methods.

@example
void saveCommPattern();
void restoreCommPattern();
@end example

@example
clearCommPattern();
void resetResources()
@end example

The first method is a public method to clear @code{bus} schedule, while the
second is a protected method to clear both @code{bus} and @code{bestBus}.

This classes redefines the following two public methods.

@example
int scheduleComm(ParNode* @var{node}, int @var{when}, int @var{limit} = 0);
@end example

This method schedules the argument node available at @var{when} on @code{bus}.
If we can schedule the node before @var{limit}, we schedule the node and
return the schedule time. Otherwise, we return -1. If @var{limit} = 0,
there is no limit when to schedule the node.

@example
ParNode* backComm(ParNode* @var{node});
@end example

For a given communication node, find a communication node scheduled just
before the argument node on @code{bus}.

@node Heterogeneous Support, CGC Domain, Target, Top
@chapter Heterogeneous Support

In this chapter, we summarize the special routines to support
heterogeneous targets. They are already explained in earlier chapters.

(1) To specify the component targets (@pxref{class CGMultiTarget}), 
we first set @code{childTypes} state of
the target class that must be derived from class CGMultiTarget.
We may add special resources to the processors by setting @code{resources}
state, a list of items separated by ';'. An item starts with the target index
followed by a list of strings identifying resources. The relative computing
speed of processors are specified by @code{relTimeScales} state.

(2) An application program for a heterogeneous target uses wormholes. In
pigi, all stars in a universe should be in the same domain. To overcomm this
restriction, we use wormhole representation to distinguish stars for
different targets, or domains, but still in the same universe.
Once the graph is read into the Ptolemy kernel, all wormholes of code
generation domain are flattened to make a single universe:
@code{flattenWorm} method of CGMultiTarget class. Currently, we
manually partition the stars to different kinds of processors. For
example, if we have three "default-CG96" targets and one "default-CG56"
target, we partition the stars to two kinds: CG96 or CG56. This
partitioning is based on the original wormhole representation. 
If we ignore this partitioning, we can apply an automatic scheduling with
the flattened graph. This feature has not been tested yet even though
no significant change is required in the current code. 

(3) When we schedule a star in the scheduling phase, we first obtain the
list of processors that can schedule the star: @code{candidateProcs} method
of CGMultiTarget class. The execution time of the star to a processor is
computed in @code{execTime} method of CGMultiTarget class considering the
relative speed of processors. 

(4) After scheduling is performed, we create sub-universes for child targets.
In case manual partitioning is performed, we just clone the stars from the
original graph in the sub-universes. In case we use automatic partitioning,
we need to create a star in the current target with the same name as the
corresponding star in the original graph: @code{cloneStar} private method
of UniProcessor class. We assume that we use the same name for a star
in all domains.

@node CGC Domain, CGDDF Domain, Heterogeneous support, Top
@chapter CGC Domain

In this chapter, we will explain the current implementation of C code
generation domain. The source code can be found 
$(PTOLEMY)/src/domains/cgc/kernel
directory. We follow the general framework for code generation defined in
CG kernel directory. 

In the CGC domain, the resource we have is the name space. We have to avoid
name conflicts by guaranteeing unique names for different variables.
The most complicated task is to determine the dimension, or buffer size,
of each variable, and the method how to access them; static buffering,
linear indexing, or modulo addressing.

We use the CGC domain to test new functionalities in code generation:
buffer embedding and CGDDF support for example. We have tested some
simple demos to verify the design.

@menu
* buffer allocation::		buffer allocation
* data structure::		data structure of galaxy and stars
* code streams::		code streams in the CGC domain
* other CGCPortHole members::	class CGCPortHole
* other CGCStar members::	class CGCStar
* other CGCTarget members::	class CGCTarget
* class CGCMultiTarget:: 	multiprocessor target 
@end menu

@node buffer allocation, data structure, CGC Domain, CGC Domain
@section Buffer Allocation

In the CGC domain, we allocate one buffer for each connection in principle.
We have to determine the required size of buffers first.
If a porthole is @emph{embedded} (@pxref{embedding}), and the buffer
size requirement is equal to the sample rate of the embedded port, we
do NOT allocate a buffer on that connection.
We will use static buffering for all @emph{embedded} and @emph{embedding}
portholes. If the buffer requirement of an embedded(or embedding) porthole
is not equal to the sample rate of the porthole, we actually need to have
two buffers on that connection and copy data between these buffers.
In this case, we splice a Copy star on the arc and schedule the Copy star
appropriately to generate code for copying data. After inserting the Copy
star, we will end up with one buffer per connection.
Another cause of copy requirement is type conversion from complex to
float/int or from float/int to complex. Then, we splice a type-conversion
star on the arc.
  
Class CGCTarget redefines the
following protected method for buffer allocation (@pxref{class CGTarget}).

@example
int allocateMemory();
@end example

In this method, we first merge cascaded forks into a single fork whose
input keeps the list of all fork destinations. We will allocate only one
buffer for each fork. All fork destinations will refer to the same
fork input buffer. Then. this method do the following tasks:

(1) Determine the buffer requirements for all portholes.

(2) Splice Copy stars or type conversion stars if necessary.

(3) Set the buffer type for each output porthole: either OWNER or EMBEDDED.
If the output porthole is embedded, or the corresponding input porthole is
embedded, it is called EMBEDDED. Otherwise, it is OWNER.

@example
void setBufferType();
@end example

This is a public method of CGCPortHole class to determine the buffer type of
an output.

(4) We assign unique names for buffers.

(5) We initialize the offset pointer for each porthole which is associated
with a buffer of size greater than 0 (@code{initOffset} method of CGCPortHole
method). This offset pointer indicates from which offset of the buffer the
porthole starts reading or writing samples.

@example
int initOffset();
@end example

This is a public method of CGCPortHole class to initialize the offset pointer.
If there are delays, or initial samples, on the arc, these samples are placed
at the end of the buffer. The offset pointer of a
porthole indicates the location of the last sample the next firing of its
parent star will produce or consume. It is compatible with the SDF simulation
domain: @code{$ref(porthole,num)} in CGC stars is now
equivalent to @code{porthole%num} in SDF stars. 
We can set the offset pointer of an output porthole manually by the following
public method of CGCPortHole class. 

@example
void setOffset(int @var{v});
@end example
 
Now, we will explain steps (1), (2), and (4) in more details.

@menu
* buffer requirement::			determine the buffer requirement
* splice stars::			when to splice stars and why
* buffer naming::			give a unique name to a variable
@end menu

@node buffer requirement, splice stars, buffer allocation, buffer allocation
@subsection Buffer requirement

To determine the buffer requirements of portholes, we traverse portholes 
of all stars, and call @code{finalBufSize} method of CGCPortHole class.

@example
void finalBufSize(int @var{statBuf});
@end example

This is a public method of CGCPortHole class to determine the buffer
size for this porthole. The argument indicates whether
we try to use static buffering or not. We allocate one buffer for each
connection. Therefore, we do nothing if this porthole is an input porthole.
If this porthole is disconnected, we set the buffer size equal to the
number of samples produced for each firing. If it lies at wormhole
boundary, we use @code{localBufSize} method of CGPortHole class to determine
the size of buffer and return. Otherwise, we do the following:

(1) We can manually assign the buffer size by calling @code{requestBufSize}
for an output porthole of interest in the setup stage of a star:

@example
void requestBufSize(int @var{sz});
@end example

This method sets the buffer size manually. The argument size should not be
smaller than the minimum size determined by the scheduler. The minimum size
determined by the scheduler is the sum of maximum number of samples
accumulated on the arc during the schedule and the number of old samples
to be access from the destination port. If @var{sz} is smaller than this
minimum value, we generate a warning message and give up manual allocation.

(2) We set the initial buffer size by calling @code{localBufSize} method
of CGPortHole class. If argument @var{statBuf} = 1, we set the buffer
size as a smallest multiple of the sample rate of this porthole, which is
not less than the initial buffer size. By doing this, we increase the chance
of using linear buffering. We also set the waste factor 
(@pxref{Resource Management}) in CGCGeodesic
class to a huge number by calling the following public method in CGCGeodesic
class:

@example
void preferLinearBuf(int @var{i})
@end example

The waste factor set by the above method can be obtained by the following
redefined protected method of the CGCGeodesic class.

@example
double wasteFactor() const;
@end example

(3) We set two flags for this porthole to indicate we can use static buffering
and/or linear buffering: @code{hasStaticBuf} and @code{asLinearBuf}. These two
flags are all private. If static buffering flag is set, we use direct
addressing in the generated code to access the buffer. If linear
buffering flag is set, we will use indirect addressing and no modulo addressing
will be required. Otherwise, we will use indirect addressing and modulo
addressing in the generated code to access the allocated buffer.
Initially both flags are set TRUE. If this porthole needs to access past
samples, we reset both flags to FALSE. When the argument @var{statBuf} is
given 0, we give up static buffering in case the buffer size determined
in (2) is greater than the sample rate of this porthole. Note that
if a loop scheduler is used, @var{statBuf} becomes 0 and some
possibilities of static buffering are sacrificed as the cost of
code compaction. The following method is called to adjust the flags further.

@example
void setFlags();
@end example

Is a protected member of CGCPortHole class. If the final buffer size is
not a multiple of the sample rate, we reset @code{asLinearBuf} flag to 0.
We have to use modulo addressing in the generated code. If the
product of the sample rate and the repetition count of its parent star is
not a multiple of the final buffer size, we give up static buffering, setting
@code{hasStaticBuf} to 0. If an output porthole is embedded or embedding,
we set both flags TRUE since we enforce static buffering.

(4) As the final step, we set the flags for destination portholes. If this
porthole is connected to a fork input, all fork destinations will be
the destination portholes of this porthole. We first check whether
@var{statBuf} argument is 0 and the buffer size is greater than the sample
rate of the porthole. And, we call @code{setFlags} method for that porthole.
If the porthole needs to access past samples, or the number of initial
samples on the connection is not a multiple of the sample rate, we give up
linear buffering.

The final buffer size can be obtained by the following two public methods
of CGCPortHole class.

@example
int maxBufReq() const;
int bufSize() const @{ return maxBufReq(); @}
@end example

The above methods return the final buffer size associated with this porthole.
If it is a fork destination, it returns the size of the fork input buffer.
If the porthole is switched its Geodesic (@pxref{switch Geodesic}), it returns
the size of buffer associated with the switched Geodesic.

The flags for static buffering and linear buffering can be obtained by
the following public methods of CGCPortHole class:

@example
int linearBuf() const;
int staticBuf() const;
@end example

We give up static buffering for a CGPortHole by calling the following public
method of CGCPortHole class.

@example
void giveUpStatic();
@end example

@node splice stars, buffer naming, buffer requirement, buffer allocation
@subsection Splice stars

After buffer requirements for all portholes are determined, we can detect
the arcs which can not have only one buffer. For instance, if we need
to convert data types from complex to float/int or vice versa automatically,
we need two buffers on the arc: one for complex variables and the other
for float/int variables. This copying operation is required since C language
does not provide built-in "complex" type variable. Therefore, we define
"complex" type data in the generated code as follows;

@example
static char* complexDecl =
"\n#if !defined(COMPLEX_DATA)\n#define COMPLEX_DATA 1"
"\n typedef struct complex_data @{ double real; double imag; @} complex; \n"
"#endif\n";
@end example

Another case is when an embedded or embedding porthole requires a buffer
whose size is greater than the sample rate of the porthole. Recall that
an embedded or embedding porthole will assume static buffering for
each execution when we generate code for that porthole. If the buffer 
size is larger than the sample rate, we may not use static buffering. 
We need two buffers for the embedded or embedding porthole.

Rather than assigning two buffers on an arc and letting the target
generating code to copy data between these two buffers, we splice
a star on the arc. The spliced star will separate two buffers on one arc
into one buffer on its input and the other buffer on its output arc.
When this spliced star is scheduled before the destination star of after
the source star,
it will generate code to copy data from the input buffer to the output buffer.

Stars are spliced in the following protected method of CGCTarget class.

@example
void addSpliceStars();
@end example

This method traverses all portholes of stars in the galaxy. For an input
porthole, it first checks whether type conversion is necessary or not:
@code{isConverted} method of CGCPortHole class.

@example
int isConverted();
@end example

This is a public method of CGCPortHole class. If no type conversion between
complex and float/int data is required, it returns 0. If we need to convert
from complex to float/int (or vice versa), it returns 1 (or -1). This 
method should be called for an output porthole (or source porthole of a
connection).

If type conversion is required, we splice a CxToFloat star or a FloatToCx
star at the input porthole of the arc. If the input porthole is embedded or
embedding and the buffer requirement is larger than the sample rate, 
we need to splice a Copy star. If we already spliced a type conversion
star, we do not splice a Copy star since the spliced type conversion star
performs the task of copying already. Otherwise, we splice a Copy star at
the input porthole.

When we splice a star at an input porthole (destination porthole), we
initialize the spliced star and set the target pointer. A spliced star should
have one "input" and one "output". We set the sample rate of these portholes
equal to the sample rate of the input porthole. The buffer size of the input
porthole of the spliced star is determined by the original source porthole.
The buffer size of the output porthole is set the sample rate of the
input porthole. And, we check whether static or linear buffering can be used
for the portholes. The input porthole of a spliced Copy star gives up
static buffering while the output porthole of the spliced Copy star and
the original destination porthole can use static and linear buffering.
In case we spliced a type conversion star, we need to change the type of the
original source porthole.

We splice a Copy star at the output (source porthole) when the output 
is an embedded or
embedding porthole and the buffer size is larger than the sample rate of
the output porthole. We initialize the spliced star and set the target
pointer. The sample rate of the input and output porthole of
the spliced Copy star is equal to the sample rate of the output porthole.
The buffer size of the output porthole of the spliced star is set to the
buffer size of the arc. We give up static buffering for this output
porthole. On the other hand, we change the buffer size of
the source porthole to the sample rate of the porthole. 

We need to pay special attention to Collect (or Spread) stars. A Collect
(or Spread) star is not a regular SDF star so that it is not 
scheduled when all input data are available. Actually, we do not execute 
the spliced Collect (or Spread) stars.
But, the output porthole of a Collect (or Spread) star is an embedding
(or embedded) porthole. And
its buffer size can be larger than the sample rate of the porthole.
In this case, we splice a Copy star at the destination porthole, not
at the source porthole. We schedule this Copy star before the destination
star. The sample rate of portholes of the spliced Copy star is equal to
the sample rate of the destination porthole. The output buffer size
of the spliced star is set the the buffer size of the arc while the input
buffer size now becomes the sample rate of the source porthole. The
trickest part here is to determine the offset pointers. We copy data 
when the destination porthole requires it. Therefore, the offset pointers of
the input porthole and the output porthole of the spliced Copy star
depends on the initial delay on the arc. We manually set the offset by
@code{setOffset} method of CGCPortHole class.

There is another case we need data copying between two buffers: when
two embedded portholes are connected together. Suppose, an output porthole
of a Spread star is connected to an input porthole of a Collect star.
Since the output porthole of a Spread star is embedded to the input buffer
and the input porthole of a Collect star is embedded to the output buffer,
we need to copy data from the input buffer of the Spread star to the output
buffer of the Collect star. Since we do not schedule neither Spread nor
Collect star, we may not splice a Copy star either at the source porthole
not at the destination porthole. Therefore, we leave it as a special case
so that we generate code to copy data between two buffers in
@code{moveDataBetweenShared} method of CGCStar class after executing the
star connected to the input porthole of the Spread star. So, we do not
splice star when two embedded portholes are connected together.

@example
void moveDataBetweenShared();
@end example

This is a protected method of CGCStar class. This method is called inside
@code{runIt} method after generating code for a star. If the star is
connected to an embedding porthole of a star of which an embedded output 
porthole is connected to an embedded porthole. Since we meet the case
when two embedded portholes are connected, we generate code for copying
data between two embedding buffers.

@menu
* scheduling spliced stars::		scheduling spliced stars
@end menu

@node scheduling spliced stars, , splice stars, splice stars
@subsubsection Scheduling spliced stars

When we splice a star at the input port of a star, we want to
schedule the spliced star before the star. On the other hand, we want
to schedule the spliced star after a star if we splice a star at the
output porthole of the star. When we splice stars, we are already given
the schedule. Therefore, we need to insert spliced stars into the
schedule. An intuitive approach is to insert them into the schedule list.

Currently, we use a simpler method. We use the fact that the spliced
star and the star connected to the spliced star can be regarded as a
cluster and schedule of that cluster is well known. Our idea is to
actually execute the cluster when we execute a star if the star is connected
to spliced stars. CGCStar class has a private member to keep the
list of stars: @code{spliceClust}. Initially, the star itself is
inserted to the list. If we splice a star at the input porthole, we
prepend the spliced star to the list. If we splice a star at the output
porthole, we append the spliced star to the list. And, we redefine
@code{run} method.

@example
int run();
@end example

If there are spliced stars, or the list size is greater than 1, we
traverse the list and execute @code{runIt} method for each star. Otherwise,
we execute @code{runIt} method.

@example
int runIt();
@end example

It is a protected method of CGCStar class to generate main code for this
star. If generates a comment regarding this star and main code. It updates
offset pointers of the star. Finally, it calls @code{moveDataBetweenShared}
method to generate code to copy data between two embedding portholes if
necessary.

@node buffer naming, , splice stars, buffer allocation
@subsection Buffer naming

One major task for resource assignment in the CGC domain is to give
a unique name for each variable. In the setup stage of the CGCTarget,
we assign an unique index value to each star starting from 1 to the number
of stars in the galaxy. The CGCTarget has two protected members to
give a unique index for galaxy. If a CGC galaxy has a wormhole of
CGDDF domain, we have to generate the code for galaxy inside the CGDDF
domain. In this case, we want to assign a different index to the galaxy
inside the CGDDF domain from the index assigned to the outside galaxy.

@example
int galId;
int curId;
@end example

The second member is used to give unique indices for galaxies while the
first member indicates the index of the current galaxy.

Now, the CGCTarget can generate a unique name for each variable,
portholes and states, by the following protected method.

@example
StringList sanitizedFullName(const NamedObj& @var{b}) const;
@end example

In this method, the argument object is a porthole or a state of a star.
We prefix 'g' followed by the galaxy index, followed by "_", followed
by the name of the star, followed by another '_', followed by the star
index, followed by yet another '_' to the name of the object. For example,
if star A has a state xx and the star index is 2 and the galaxy index is 1,
the name of the state becomes "g1_A_2_xx".

@example
StringList correctName(const NamedObj& @var{b});
@end example

Is a public version of @code{sanitizedFullName} method.

Now, we are ready to generate unique names for portholes.

@example
void setGeoName(char* @var{name});
@end example

Is a public method of CGCPortHole class. If this porthole is disconnected
and no Geodesic is assigned, we store the name in the porthole. Otherwise,
we store the name in the Geodesic by calling the following public method
of CGCGeodesic class.

@example
void setBufName(char* @var{name});
@end example

The buffer name of a porthole can be obtained by the following public
method of CGCPortHole class.

@example
const char* getGeoName() const;
@end example

This method returns the buffer name stored in this object if it is
disconnected, or call @code{getBufName} method of CGCGeodesic class.
If it is a fork destination, it returns the name of the fork input buffer.

@node data structure, code streams, buffer allocation, CGC Domain
@section Data structure for galaxy and stars

In the global declaration section of the generated code, we declare
data structures for stars. At early design stage of CGC domain, we use
@code{struct} construct of C language to declare the data structure of
the program. This way, we could assign unique memory locations to variables
very easily. But, the length of a variable gets large as the hierarchy of
the graph grows. Furthermore, we reduce significant amount of
compiler optimization possibility. Therefore, we invented a scheme to generate
unique symbols for variables (@code{sanitizedFullName} of CGCTarget class)
without using "struct" construct.

@example
virtual void galDataStruct(Galaxy& @var{galaxy}, int @var{level} = 0);
virtual void starDataStruct(CGCStar* @var{block}, int @var{level} = 0);
@end example

The above methods are protected methods of CGCTarget class to be called
in @code{frameCode} method to declare data structures of galaxy and stars.
The second argument of both methods indicates the depth of hierarchy which
the first argument block resides in, thus advising the amount of indents
in the generated code. By default, it is set 0. The first method calls
the second method for each component star if it is not a Fork star. We do
not generate code nor declare data structure for Fork stars.

The data structure for a star consists of four fields:

(1) Comments to indicate that the following declarations corresponds to what
star: @code{sectionComment} method.

@example
StringList sectionComment(const char* @var{string});
@end example

This is a protected method of CGCTarget class to generate a comment line,
@var{string} in the generated code.

(2) Declare buffers associated with portholes. We do not declare input
portholes. If an output porthole is EMBEDDED, we declare a pointer to 
the embedding buffer, by prepending '*' in front of the buffer name. 
Otherwise, it declare a regular buffer. 

(3) Declare index pointers to the buffer if static buffering
is not used and the size of buffer is greater than 1 . Portholes
will use these index pointers to locate the buffer position. For a regular
buffer, we declare an index pointer, named after the buffer name appended by
"_ix". The name of index porthole is given by @code{offsetName} method 
of CGCTarget class.

@example
StringList offsetName(const CGCPortHole* @var{p});
@end example

This is a public method to assign an index pointer to the argument porthole.
It appends '_' followed by "ix" at the end of the porthole name, by calling
the following public method of CGCTarget class:

@example
StringList appendedName(const NamedObj& @var{p}, const char* @var{add});
@end example

This  method is used to append '_' followed by
@var{add} to the name of the object @var{p}.

(4) Finally, we declare referenced states. A State is called @emph{referenced}
only when we use $ref macro for the state at most once. CGCStar class
has the following members for referenced states:

@example
StateList referencedStates;
void registerState(const char* @var{name});
@end example

The first is a public member to store the list of referenced states in this
Star. The second is a protected method to add the state with given name to
the list of referenced states if not inserted.

We traverse the list of referenced states to declare variables. Unlike
portholes, the size of a state variable is given. If the size of state is 1,
we both declare and initialize the state. If the state is an array state,
we both declare and initialize the state using array initialization unless
the state is declared inside a function. If we are declare an array state
inside a function, we have to write explicit initialization code.
Class CGCTarget has the following public method to tell whether we are
working inside a function or not.

@example
int makingFunc();
@end example

Returns TRUE if we are defining a function.

@menu
* buffer initialization::		initialize buffers and offset pointers
@end menu

@node buffer initialization, , data structure, data structure
@subsection buffer initialization

We initialize buffers and index pointers as follows.

(1) If the buffer is EMBEDDED, we assign a pointer to the embedded 
buffer and set the pointer
to the starting address of the embedding buffer, from which the buffer
is embedded. If the size of the embedding
buffer is 1, we assign the pointer of the embedding buffer.

(2) For the regular buffer, we initialize with 0s in case the buffer size is
greater than 1.

(3) We initialize an index pointer of a buffer to the offset pointer of
the porthole associated with that index pointer.

@node code streams, other CGCPortHole members, data structure, CGC Domain
@section CGC code streams

Besides two code streams inherited from CGTarget class, @code{myCode} and
@code{procedures}, CGCTarget class maintains 9 more code streams (all
protected). These
code streams will be stitched together to make the final code in
@code{frameCode} method. There are two schemes to organize a code in general.
One scheme would be to put code strings to a single CodeStream in order.
For example, we put global declarations, main function declaration, 
initialization, and main loop into a single @code{myCode} stream in order.
For single processor code generation, it would be feasible. For
multiprocessor case, however, the parent target may add some extra code
strings. Therefore, we assign different code streams to different
section of codes. On the other hand, if we have too many code streams,
it would be arduous to remember all. 

@example
CodeStream globalDecls;
CodeStream galStruct;
CodeStream include;
@end example

These three code streams will be placed in the global scope of the final code.
The galaxy declaration (@code{galStruct}) is separated from @code{globalDecls}
because we need to put galaxy declaration inside a function if we want to
define a function from a galaxy (for example, recursion construct).
A programmer can provide strings to @code{globalDecls} and @code{include}
by using the following protected CGCStar methods in a star definition:

@example
int addGlobal(const char* @var{decl}, const char* @var{name} = NULL);
int addInclude(const char* @var{decl});
@end example

In the first method, we use @var{decl} strings as the name if the second
argument is given NULL, to make a global declaration unique.
The argument of the second method is the name of a file to be included, for
example <stream.h> or "DataStruct.h".

@example
CodeStream mainDecls;
CodeStream mainInit;
CodeStream commInit;
@end example

These three code streams will be placed in the main function before the
main loop: declaration in the main function, initialization code, and
initialization code for communication stars. We separated @code{commInit}
from @code{mainInit} since communication stars are inserted by the parent
multiprocessor target, and we need to be able to copy this code to
support CGDDF Domain. A programmer can provide strings to the first
two code streams by using the following protected CGCStar methods.

@example
int addDeclaration(const char* @var{decl}, const char* @var{name} = NULL);
int addMainInit(const char* @var{decl}, const char* @var{name} = NULL);
@end example

The first method uses @var{decl} string as the name of the string if
@var{name} is given NULL.

@example
CodeStream wormIn;
CodeStream wormOut;
CodeStream mainClose;
@end example

The first two streams contain code sections to support wormhole interface
to the host machine. They will be placed at the beginning of the main loop and
at the end of the main loop. The last code stream will be placed after the
main loop in the main function.

Recall that using @code{addCode} method defined in CGStar class, we can
put code strings to any code stream (@pxref{CodeBlock and Macros}).

These nine code streams are initialize by the following protected method
of CGCTarget class.

@example
virtual void initCodeStrings();
@end example

Note that code streams are not initialized in @code{setup} method of 
the target since the parent target may put some code before calling
the @code{setup} method of the target. We initialize code streams after
we stitch them together and copy the final code in @code{myCode} stream
in @code{frameCode} method. We do not initialize @code{myCode} stream in
the above method.

@example
void frameCode();
@end example

This method put all code streams together and copy the resulting code to
@code{myCode} stream. 

@node other CGCPortHole members, other CGCStar members, code streams, CGC Domain
@section Other CGCPortHole members

CGCPortHole is derived from CGPortHole class. It has a constructor with no
argument. In the constructor, we initialize the default properties of a
CGCPortHole: static buffering and linear buffering flags are set TRUE, buffer
size is set 1. These properties are also initialized in @code{initialize}
method. In the destructor, it deallocates the name of the buffer if stored
in this class (when this porthole is disconnected). All members described in
this section are public.

@example
CGCPortHole* getForkSrc();
const CGCPortHole* getForkSrc() const;
@end example

These methods return the fork input porthole (@code{forkSrc}) if this porthole
is a fork destination. The second method is the @emph{const} version of the 
first method.

@example
CGCPortHole* realFarPort();
const CGCPortHole* realFarPort() const;
@end example

These method return the far side porthole. If the far side porthole is a fork
destination, they return the far side porthole of the fork input, thus
bypassing fork stars. The second is the @emph{const} version of the 
first method.

@example
CGCGeodesic& geo();
const CGCGeodesic& geo() const;
@end example

Return the geodesic connected to this PortHole, type casted. The second 
is the @code{const} version of the first method.

@example
Geodesic* allocateGeodesic();
@end example

Allocates a CGCGeodesic.

@example
void setupForkDests();
@end example

If this method is called for a fork input porthole, make a complete list of
@code{forkDests} considering all cascaded forks.

@example
int inBufSize() const;
@end example

This method returns the @code{bufferSize} of this porthole.

CGCPortHole has an iterator called @code{ForkDestIter}. It returns 
fork destinations one at a time. The return type is CGCPortHole.

The derived classes of CGCPortHole in the CGC domain are @code{InCGCPort},
@code{OutCGCPort}, @code{MultiCGCPort}, @code{MultiInCGCPort}, and
@code{MultiOutCGCPort}.

@node other CGCStar members, other CGCTarget members, other CGCPortHole members, CGC Domain
@section Other CGCStar members

Class CGCStar is derived from CGStar class. It has a constructor with no
argument. CGCTarget class is a friend class. It has a method to return
the domain it lies in (@code{domain}) and a method for class identification
(@code{isA}). In @code{initialize} method, we initialize 
@code{referencedStates} list. All other members described in this section
are all protected.

@example
CGCTarget* targ();
@end example

Returns the target pointer, type casted to CGCTarget.

@example
StringList expandRef(const char* @var{name});
StringList expandRef(const char* @var{name}, const char* @var{offset});
@end example

The above methods resolve macro $ref. The @var{name} argument is a
state name or a porthole name. If it is a state name, we put the state
in the @code{referencedStates} list. In the second method, the second 
argument is the offset of the first argument (state or porthole). It can
be a numeral, an IntState name, or a string. If it is an IntState, the
current value of the state is taken. 

There are various ways to referring to a porthole. If the buffer size is
1, we use the buffer name or the pointer version depending on the type,
EMBEDDED or OWNER. If the buffer size is larger than 1, we use direct
addressing if static buffering is used. If static buffering can not
be used, we use indirect addressing. The following method generates
indirect addressing:

@example
virtual StringList getActualRef(CGCPortHole* @var{p}, const char* @var{ix});
@end example

This method generates an indirect addressing for the argument porthole @var{p}
with offset @var{ix}. If we may not use linear addressing, we generate
modulo addressing, in which the index is modulo the buffer size.

@example
virtual int amISpreadCollect();
@end example

Returns TRUE or FALSE, based on whether this star is a Spread or a Collect
star or not. We need to take special care for Spread and Collect stars.

@node other CGCTarget members, class CGCMultiTarget, other CGCStar members, CGC Domain
@section Other CGCTarget members

CGCTarget is derived from HLLTarget class (@pxref{class HLLTarget})
that is the base target class for high level language code generation. 
It has a constructor with three argument like its base target classes.
In the constructor, we initialize code streams and put them into the
@code{codeStringLists} by @code{addStream} method.
It has @code{makeNew} method defined.

@menu
* other CGCTarget protected members::	other CGCTarget protected members
* other CGCTarget public members::	other CGCTarget public members
@end menu

@node other CGCTarget protected members, other CGCTarget public members, other CGCTarget members, other CGCTarget members
@subsection Other CGCTarget protected members

CGCTarget class has many states guiding the compilation procedure.

@example
IntState doCompile;
@end example

If this state is set NO, we only generate code, not compiling the code.

@example
StringState hostMachine;
StringState funcName;
StringState compileCommand;
StringState compileOptions;
StringState linkOptions;
@end example

The @code{hostMachine} state indicates where the generated code is compiled
and run. If this state does not indicate the current host,, we will use
remove shell command for compilation and execution. The @code{funcName}
state is by default set "main". For multiprocessor code generation case,
we may want to give different function name for the generated code.
The next three states determines the compilation command:

@code{compileCommand} @code{compileOptions} fileName @code{linkOptions}

There are some other states defined in this class.

@example
IntState staticBuffering;
@end example

If this state is set YES, we increase the @code{wasteFactor} of geodesics
to use static buffering as much as possible, which is default.

@example
StringState saveFileName;
@end example

We save the generated code in this file if the file name is given.

@example
StringArrayState resources;
@end example

This state displays which resources this target has. By default, the
CGCTarget has the standard I/O (@var{STDIO}) resource. If a derived
target does not support the standard I/O, it should clear this state.

@example
int codeGenInit();
@end example

This method generate initialization code: buffer initialization, and
@code{initCode} method of all stars. Before generating initialization code,
we switch the @code{myCode} pointer of stars to the @code{mainInit} code
stream so that @code{addCode} method called inside the @code{initCode}
method puts the string into the @code{mainInit} code stream.

@example
void compileRun(SDFScheduler* @var{s});
@end example

Before calling @code{compileRun} method of the SDFScheduler, which will
call @code{run} method of stars in the scheduled order, we switch the
@code{myCode} pointer of stars back to the @code{myCode} code stream
of the target. After code generation, we switch the pointer of stars to
the @code{mainClose} code stream for wrapup stage.

@example
int wormLoadCode();
@end example

If the @code{doCompile} state is set NO, we just return TRUE, doing nothing.
Otherwise, we compile and run the generated code. Return FALSE if any
error occurs.

@example
StringList sectionComment(const char* @var{s});
@end example

This method makes a comment statement with the given string in C code.

@example
void wormInputCode(PortHole& @var{p});
void wormOutputCode(PortHole& @var{p});
@end example

The above methods just print out comments. We haven't supported
wormhole interface for CGC domain yet (Sorry!).

@node other CGCTarget public members, , other CGCTarget protected members, other CGCTarget members
@subsection Other CGCTarget public members

@example
void setup();
@end example

This method initialize @code{galId, curId} indices for unique symbol
generation. It also generate indices for stars and portholes.
Then, it calls @code{CGTarget :: setup} for normal setup procedure.

@example
void wrapup();
@end example

This method displays the generated code stored in @code{myCode} stream.
If the galaxy is not inside a wormhole, it calls @code{wormLoadCode}
method to compile and run the code.

@example
int compileCode();
@end example

This method compiles the generated code. The compile command is generated
by the following method:

@example
virtual StringList compileLine(const char* @var{fName});
@end example

The argument for this method is the file name to be compiled. If the
@code{hostMachine} does not indicate the local-host, we use remote
shell.

@example
int runCode();
@end example

This method runs the code. If the @code{hostMachine} is not the
local-host, we use @code{rshSystem} function.

@example
void headerCode();
@end example

Is redefined to generate a valid C comment with the target name.

@example
void beginIteration(int @var{repetitions}, int @var{depth});
void endIteration(int @var{repetitions}, int @var{depth});
@end example

The first method generates the starting line of @code{while} loop
(if @var{repetitions} is negative) or @code{for} loop (otherwise).
After that it appends the @code{wormIn} code stream to the @code{myCode}
stream before stars fill the loop body. The @code{wormIn} code stream
is already filled. The second method close the loop. Just before closing
the loop, it appends the @code{wormOut} code stream to the @code{myCode}
at the end of the loop body.

@example
void setHostName(const char* @var{s});
const char* hostName();
@end example

The above methods set and get the @code{hostName} state.

@example
void writeCode(const char* @var{name} = NULL);
@end example

If the argument is NULL, we use the galaxy name as the file name.
This method saves the code to the file.

@example
void wantStaticBuffering();
int useStaticBuffering();
@end example

These methods set and get the @code{statisBuffering} state.

@example
int incrementalAdd(CGStar* @var{s}, int @var{flag} = 1);
@end example

We add the code for the argument star, @var{s},  during code generation step.
If @var{flag} is 0,
we add the main body of the star (@code{go} method only). Otherwise,
we initialize the star, allocate memory, and generate initialization code,
main body, and wrapup code.

@example
int insertGalaxyCode(Galaxy* @var{g}, SDFScheduler* @var{s});
@end example

We insert the code for the argument galaxy during code generation procedure.
We give the unique index for the galaxy and set the indices of stars inside
the galaxy. Then, it calls @code{CGTarget :: insertGalaxyCode} to generate
code. After all, we declare the galaxy.

@example
void putStream(const char* @var{n}, CodeStream* @code{cs});
CodeStream* removeStream(const char* @var{n});
@end example

The above methods put and remove a code stream named @var{n}.

@node class CGCMultiTarget, , other CGCTarget members, CGC Domain
@section Class CGCMultiTarget

Class CGCMultiTarget, derived from CGSharedBus class, models multiple
Unix machines connected together via Ethernet. We use socket mechanism
for interprocessor communication. Since the communication overhead is
huge, we do not gain any speed up for small examples. Nonetheless, we
can test and verify the procedure of multiprocessor code generation.

This class has five private states as follows.

@example
IntState doCompile;
IntState doRun;
@end example

If these states are set YES, we compile and run the generated code.

@example
StringState machineNames;
StringState nameSuffix;
@end example

We list the machine names separated by commas. If all machines names listed
have the same suffix, we separate that suffix in the second state. For
example, if @code{machineName} is "ohm" and @code{nameSuffix} 
is ".berkeley.edu", we mean machine named "ohm.berkeley.edu".

@example
IntState portNumber;
@end example

To make socket connections, we assign port numbers that are available.
For now, we set the starting port number with this state. We will
increase this number by one every time we add a new connection. Therefore,
it should be confirmed that these assigned port numbers should be available.
If the Ptolemy program is assigned a port number in the future, then we will
be able to let the system choose the available port number for each
connection.

With the given list of machine names, we prepare a data structure called
@code{MachineInfo} that pairs the machine name and internet address.

@example
class MachineInfo @{
friend class CGCMultiTarget;
	const char* inetAdddrr;		// internet address
	const char* nm;			// machine name
public:
	MachineInfo: inetAddr(0), nm(0) @{ @}
@}
@end example

This class has a constructor with three argument like its base classes. The
destructor deallocates @code{MachineInfo} arrays if allocated. It has
@code{makeNew} method and @code{isA} method redefined.

@menu
* CGCMultiTarget protected members::		protected members
* CGCMultiTarget public members::		public members
@end menu

@node CGCMultiTarget protected members, CGCMultiTarget public members, class CGCMultiTarget, class CGCMultiTarget
@subsection CGCMultiTarget protected members

@example
void setup();
@end example

If the child targets are inherited, we also inherit the machine information.
Otherwise, we set up the machine information. The number of processors and
the number of machines names should be equal. Then, we call
@code{CGMultiTarget::setup} for normal setup operation 
(@pxref{class CGMultiTarget}). At last, we set the @code{hostName} state
of child targets with the machine names.

@example
int wormLoadCode();
@end example

This method do nothing if @code{doCompile} state is NO. Otherwise, it
compile the code for all child targets (@code{compileCode}). Then, it
checks whether @code{doRun} state is YES or NO. If it is YES, we execute
the code.

@example
int sendWormData(PortHole& @var{p});
int receiveWormData(PortHole& @var{p});
int sendWormData();
int receiveWormData();
@end example

These method should be redefined in the future to support
wormhole interface. Currently, they do same tasks with the base Target
classes.

@node CGCMultiTarget public members, , CGCMultiTarget protected members, class CGCMultiTarget
@subsection CGCMultiTarget public members

@example
MachineInfo* getMachineInfo();
int* getPortNumber();
@end example

These methods return the current machine information and the next port number
to be assigned.

@example
DataFlowStar* createSend(int @var{from}, int @var{to}, int @var{num});
DataFlowStar* createReceive(int @var{from}, int @var{to}, int @var{num});
@end example

The above methods create CGCUnixSend and CGCUnixReceive stars for
communication stars with TCP protocol.

@example
void pairSendReceive(DataFlowStar* @var{snd}, DataFlowStar* @var{rcv});
@end example

This method pairs a UnixSend star and a UnixReceive star to make a
connection. We assign a port number to the connection. More important
task is to generate function calls in the initialization code (@code{commInit}
stream) of two child targets which these communication stars belong to.
These functions will make a TCP connection between two child targets with
the assigned port number. The UnixSend star will call @code{connect}
function while the UnixReceive star will call @code{listen} function.

@example
void setMachineAddr(CGStar* @var{snd}, CGStar* @var{rcv});
@end example

This method informs the @var{snd} star about the internet address of 
the machine that the @var{rcv} star is scheduled on. The address is needed in
@code{connect} function. When we generate code for "for" or "recursion"
construct in CGDDF domain, we realize intercycle parallelism by
duplicating the same galaxy in different set of processors. We schedule
the same communication stars but with different machine information.
This method sets the correct machine information in this case.

@example
void signalCopy(int @var{flag});
@end example

By giving a non-zero value as the argument, we indicate that the code
will be duplicated in different set of processors so that we need to
adjust the machine information of communication stars.

@example
void prepCode(Profile* @var{pf}, int @var{nP}, int @var{numChunk});
@end example

This method is also used to allow code replication into different set of
targets. For details, refer the the next chapter (@pxref{CGDDF Domain}).

@example
DataFlowStar* createCollect();
DataFlowStar* createSpread();
@end example

These methods create CGCCollect and CGCSpread stars.

@example
void addProcessorCode(int @var{procId}, const char* @var{s});
@end example

The first argument of this method is the processor index, and the second
argument is the final code for that processor. This method stores the
code to a file named after the child target name. If there is only one
child target, the file is named after the galaxy name.
We also display the code.

@node CGDDF Domain, CGdsp3 Domain, CGC Domain, Top
@chapter CGDDF Domain

CGDDF domain is created to overcome the limitation of the SDF semantics
that the sample rate of portholes can not be changed at run time. The
DDF domain is a super set of the SDF domain in the sense that the DDF
domain support all SDF stars and some special stars that does not
follow SDF semantics: Case, EndCase, UpSample, DownSample, etc. In the
DDF simulation domain, we make clusters of SDF stars inside DDF wormholes.
Then, we resort to a run time scheduler or a quasi-static scheduler to
execute the graph: we construct a static schedule for each DDF wormhole,
and we dynamically schedule the DDF wormholes based on the run time behavior
of DDF stars.

The CGDDF Domain is the version of the DDF domain that generates code 
for dynamic constructs. Since it is not simple to generate code for 
general DDF galaxies,
we restrict the topology of galaxies in the CGDDF Domain. Currently,
we support @code{case}, @code{for}, @code{do-while}, and @code{recursion}
construct in the CGDDF Domain. The topology of each construct consists of
(CG)DDF stars and (CG)DDF wormholes of CG domain. For example,
a @code{case} construct consists of one Case star, one EndCase star,
one Fork star, and CGDDF wormholes one per each case branch. We can do
without either one of Case and EndCase stars and Fork star. The Fork star
provide the control input to the Case and the EndCase stars. Note that
a CGDDF domain can not be a Universe. It should be encapsulated inside
a wormhole of outer CG domain. In the current implementation, wormholes in
CG domains are all assumed to be of CGDDF domain.

CGDDFTarget class has a state specifying the type of the dynamic construct.

@example
StringState constructType;
@end example

We can specify "case", "for", "dowhile", or "recur" for this protected state.
It is case-insensitive.

We create a Scheduler object for each construct. The base Scheduler object
in the CGDDF domain is CGConScheduler. The construct specific scheduler
is doubly derived from class CGConScheduler and a construct specific 
topology class such as Case, For, DoWhile, or Recur, based on the
type of dynamic construct. The topology classes are derived from
 DyConstruct class. The topology classes can be found in
$(PTOLEMY)/src/domains/ddf/kernel since they are also used in the 
simulation DDF domain.

@menu
* topology classes::		Case, For, DoWhile, Recur classes
* CGDDF scheduling procedure::	scheduling procedure for CGDDF domain.
* class Profile::		Profile class stores the scheduling results.
* CGDDF code generation ::	code generation procedure for CGDDF Domain
* scheduler classes::		scheduler classes in the CGDDF domain
* CGDDF targets::		targets for CGDDF
* wormhole classes::		wormholes to support CGDDF domain
@end menu

@node topology classes, CGDDF scheduling procedure, CGDDF Domain, CGDDF Domain
@section Topology classes

The base topology class is class DyConstruct.
It has two protected members:

@example
SequentialList* schedules;
PortHole* testPort;
@end example

The @code{schedules} array stores lists of stars. In a quasi-static scheduling
scheme, we choose an element list of the array and execute the stars in
the list at runtime. Which lists to be chosen can be data dependent.
The @code{schedules} array is created either in the constructor of
construct specific scheduler or in @code{clearSchedules} method.
The @code{testPort} is the porthole which will receive the control data.

DyConstruct class has a constructor with no argument that reset the
@code{schedules} pointer. In the destructor, we deallocate the
@code{schedules} array.
It has two virtual public methods to be redefined in the derived classes.

@example
virtual void clearSchedules();
virtual int checkTopology(Galaxy& @var{g});
@end example

In this base class, these methods do nothing. In the derived classes, however,
the first method initialize the @code{schedules} array. The Case method
creates @code{schedules} array in this method since the number of 
branches should be known to determine the size of array.
In the second method, we check the topology of the argument galaxy whether
it conforms to the predefined topology of the construct. The current
scheme of topology checking is ad hoc: examining which DDF stars or
wormholes are connected to where. During this topology checking procedure,
we set up the @code{schedules} array.

Class Case, derived from DyConstruct class, has the following protected
members to detect the number of branches in the construct:

@example
void checkNumArcs(Galaxy& @var{g});
int numArc;
@end example

The first method detects the number of branches and save that number into
the second member.

The other three derived classes of DyConstruct class, For, DoWhile, and Recur,
define the following public method to create @code{schedules} array.

@example
void createSchedule();
@end example

Besides, For class has a protected member, @code{noUp}, to be set when
no UpSample star exists. Recur class has a protected member, @code{selfArc},
to indicate whether Self stars lie in the TRUE branch or the FALSE branch.

Topology checking is performed in @code{CGConScheduler::setup} method.

@example
void setup();
@end example

After initializing the galaxy, this method calls the following methods
in order:

@example
virtual int examine(Galaxy& @var{g});
virtual int closerExamine();
@end example

These are virtual protected methods of CGConScheduler class.
In this base class, we do nothing. In the derived classes (CGCaseScheduler,
CGForScheduler, CGDoWhileScheduler, and CGRecurScheduler), we clear the
@code{schedules} array and call @code{checkTopology} method in the first
method. CGCaseScheduler also creates @code{schedules} array in this method.
In the second method, we examine the validity of the
@code{schedules} array that are filled in the first method.

At last, @code{setup} method calls @code{initMembers} method.

@example
virtual void initMembers();
@end example

Is a protected method. In this base class, it does nothing. In the
derived classes, this method initialize private members of construct-specific
scheduler object, for example pointers to the CGDDFWormholes and their
Profile arrays. In CGDoWhileScheduler and CGRecurScheduler classes,
this initialization steps are merged with @code{closerExamine} method
described above.

@node CGDDF scheduling procedure, class Profile, topology classes, CGDDF Domain
@section CGDDF scheduling procedure

The scheduling technique for dynamic constructs is based on Ha's Ph.D.
Thesis work (@pxref{References}). The scheduling technique consists of
two stages: @emph{top-down} and @emph{bottom-up}. When we initialize 
the galaxy,
the top-down stage is performed. In the @code{setup} method of CGDDFWormholes,
we schedule the inside SDF galaxy with various number of processors
(ranging 1 to the total number of processors) and store the scheduling
result to Profile arrays of the wormholes. 

The bottom-up stage is performed in the @code{computeSchedule} method of
the outer CG domain scheduler. Based on the pattern of processor
availability and the parallelizable work-load, we choose the
optimal profile for each wormhole and schedule the wormhole
(@pxref{Dynamic Level Scheduler}). 

The optimal profile depends on
the statistics of the run time behavior of the dynamic construct.
In case of if-then-else construct, which is realized by a Case construct with
two branches, the probability of TRUE branch being taken is assumed to be
known. In case of data dependent iteration such as For and DoWhile constructs,
we assume that the statistical distribution of the number of
iteration cycles is known or is approximated. The event of TRUE branch
being taken and the number of iteration cycles described above are
called @emph{run-time parameter} of the construct. The run-time
parameter of a Recur construct is the number of recursion depth in which
we assume that the recursion branches are independent each other.

@menu
* run-time distribution::	statistics of run-time parameter
* top-down stage::		top-down stage
* bottom-up stage::		bottom-up stage
* manual scheduling::		manual scheduling case
@end menu

@node run-time distribution, top-down stage, CGDDF scheduling procedure, CGDDF scheduling procedure
@subsection Run-time distribution

CGConScheduler class has a member for the distribution information 
of the run-time parameter.

@example
DistBase dist;
@end example

Currently, we support three forms of distributions: uniform, geometric, and
general tabular form of distribution. Class DistBase is the base
class of these actual distributions: DistUniform, DistGeometric, and
DistGeneral. We define an @code{enum} structure called
@code{distType} as follows:

@example
enum distType @{GEOMETRIC, UNIFORM, GENERAL, NONE@};
@end example

Class DistBase has a pointer to a derived DistBase object to point to the
actual distribution: @code{params}. This pointer is cleared in
the constructor. The destructor deallocate the actual DistBase object.
Class DistBase has the following public members.

@example
int setType(Target& @var{tg});
@end example

This method reads the @code{paramType} state of the argument CGDDFTarget
object and set up the @code{params} pointer to the actual distribution
object.

@example
StringState paramType;
@end example

Is a protected state of CGDDFTarget class. This state should be set
one of the actual distribution models: "uniform", "geometric", or
"general".

Now back to the definition of DistBase class.

@example
int readType();
virtual const char* myType() const;
DistBase* myParam();
@end example

These methods return the  enum type of the distribution, the name
of the distribution, and the pointer to the actual distribution object. If
the second method is called in this base class, we return "unspecified".

@example
virtual int setParams(Target& @var{tg});
@end example

The argument is the CGDDF Target. In this base class, we do nothing.
In the derived classes, we read the parameters of a distribution from
the states of CGDDFTarget class. DistUniform class has the minimum
value (@code{min}) and the maximum value (@code{max}) as parameters.
DistGeometric class has the minimum value (@code{min}) and the geometric
constant (@code{p}) while DistGeneral has a pointer to a table (@code{table})
and the file name that gives the table information. There are four states
in CGDDFTarget class to specify the distribution parameters:

@example
FloatState paramGeo;
IntState paramMin;
IntState paramMax;
StringState paramFile;
@end example

@example
virtual StringList printParams();
@end example

This method prints which distribution this class is and what are the
distribution parameters.

@example
virtual DistBase* copy();
@end example

This method creates a new object of the same distribution class.

@example
virtual void paramInfo();
@end example

This method uses @code{message} method of Error class to explain
the distribution parameters.

@example
virtual double assumedValue();
@end example

When we assign the static level of nodes in the APEG, we use the
execution time of the nodes. To assign an execution time for
a dynamic construct, we call this method to obtain a fixed
value for distribution parameter.

The derived classes of DistBase class defines some additional
methods to get the distribution parameters. DistGeometric class
has the following methods:

@example
int getMin();
double getP();
@end example

DistUniform class has the following:

@example
int getMin();
int getMax();
@end example

DistGeneral has the following methods:

@example
DistTable& getTable(int @var{index});
int tableSize();
@end example

The first method returns the probability that the run-time parameter
becomes @var{index}. Class DistTable stores a pair of numbers:
@code{index} and @code{value}. The second number represents the
probability of the run-time parameter becoming the first number.

@node top-down stage, bottom-up stage, run-time distribution, CGDDF scheduling procedure
@subsection Top-down stage

The top-down stage is performed when the galaxy is initialized.
A CGDDF domain is inside a CGWormBase object. All wormhole objects of
code generation domains will be derived from CGWormBase class, which
is derived from class Wormhole. In the @code{setup} method of
CGWormBase class, we do the following.

(1) First check whether the inside domain is CGDDF or not.

(2) Get the number of processors from the outside domain and save the number.
Create a Profile array and initialize them. The size of the array is the
number of processors. This step is done in @code{assignProcs} method.

@example
void assignProcs(int @var{numP});
@end example

Is a public method of CGWormBase class.

(3) Inform the inner target about the number of processors, and inherit
the child targets from the outside target to the inside CGDDFTarget.

(4) Set up the inside domain by calling @code{Wormhole::setup} method.
Here, we initialize the inner galaxy, which includes CGDDFWormholes of
code generation domain: @code{CGDDFWormhole::setup}.

@example
void setup();
@end example
 
(4-1) Check whether the inside target is a code generation target or not.

(4-2) Get the number of processors from the outside target. If @code{fixedNum}
state of the CGDDFTarget is set, we use this state value as the number of
available processors. We create a Profile array (@code{profile}, private
member). A Profile component, @code{profile[i]} will contain the scheduling
results of the inside galaxy with i+1 processors. We also ensure that
the inside target inherits child targets from the outside if the inside
target is a multiprocessor target. This step is performed in
the following public method of CGDDFWormhole class.

@example
assignProcs(int @var{numP});
@end example

(4-3) Inform the inside code generation target about the number of
processors, and inherit the child targets if the target is a multiprocessor
target. If it is a single processor target, call @code{amInherited} method
of the target (@pxref{class CGTarget}).

(4-4) Set up the inner target by @code{Wormhole::setup} method. Here, we
initialize the inside galaxy and schedule the inside galaxy with
the number of processor given by (4-2). The scheduling result is stored
in the @code{profile} array by @code{setProfile} method of CGMultiTarget
class (@pxref{class CGMultiTarget}). Now, we decrease the number of
processors by one and schedule the inside galaxy to save the scheduling
result to the @code{profile} array. We repeat this procedure until the number
of processors become 1. At the end of this stage, the @code{profile}
array stores the scheduling results of the inside galaxy with
varying number of assigned processors from 1 to the number of available
processors. If the inside galaxy contains dynamic
constructs, we schedule the nested dynamic constructs.

Now, we go back the @code{setup} method of CGWormBase class.

(5) At last, we pass the Profile array of CGWormBase class to the
inside scheduler that will store the scheduling result to the array:
@code{setProfile} method of CGDDFTarget class.
Set the execution time of the wormhole with the average execution time of
the dynamic construct.
 
@node bottom-up stage, manual scheduling, top-down stage, CGDDF scheduling procedure
@subsection Bottom-up stage

The bottom-up stage is performed in @code{computeSchedule} method of
the outermost scheduler (@pxref{Parallel Schedulers}) unless
manual scheduling option is taken. A parallel scheduler
creates an APEG if the number of processors is greater than 1. A dynamic
construct lies inside a wormhole and a wormhole is associated with a
ParNode that requires more than one processors to be scheduled. Before
scheduling the ParNode associated with the wormhole, we compute the
pattern of processor availability and the work-load (called
@emph{residual} work-load) that can be
executed independently of the dynamic construct. Now, we call
@code{computeProfile} method of CGWormBase class to schedule the wormhole.

@example
void computeProfile(int @var{num}, int @var{resWork}, IntArray* @var{avail});
@end example

This is a public method of CGWormBase class. The arguments represent the
number of processors, the residual work-load, and the pattern of processor
availability. It just calls @code{computeProfile} method of CGDDFTarget class.

@example
int computeProfile(int @var{numP}, int @var{resWork}, IntArray* @var{avail});
@end example

This is a redefined public method of CGDDFTarget class. 

(1) First, it informs the
scheduler object (a derived class from CGConScheduler) how many processors
are assigned and which Profile object the scheduler uses to store the
scheduling results.

@example
void setProcs(int @var{n});
void copyProfile(Profile* @var{pf});
@end example

These two methods are public methods of CGConScheduler class to store the
number of assigned processors and the pointer to the current Profile object
in the protected members:

@example
int numProcs;
Profile* profile;
@end example

(2) If the number of assigned processors is given by @code{fixedNum} state
of the CGDDF target, we call the following public method of
CGConScheduler class to schedule the dynamic construct.

@example
void CGConScheduler :: fixProfile(int @var{nP}, int @var{resWork}, IntArray* @var{array});
@end example

(3) Otherwise, we call the following protected method of CGConScheduler class.

@example
int CGConScheduler :: calcProfile(int @var{resWork}, IntArray* @var{avail});
@end example

This method varies the number of assigned processors to the dynamic
construct from 1 to the number of available processors in step (1).
For each assigned number of processors, we compute the best Profile
of the dynamic construct based on the statistical distribution of run-time
parameter, the pattern of processor availability, and the residual work:
@code{setProfile} method of CGConScheduler class.
We also compute the cost of the dynamic construct with each assigned
number of processors. The cost include the expected execution time of the
dynamic construct and the introduced idle time. For detailed discussion,
refer to reference [3] (@pxref{References}). We store the best Profile
in the profile pointer set in step (1), and the optimal number of
assigned processors to the following protected member of CGConScheduler class:

@example
int optNum;
@end example

(4) It returns the optimal number of assigned processors.

Now, let's discuss @code{setProfile} method of scheduler objects, which is
the main routine to compute the profile of the dynamic construct.

@example
virtual int setProfile(int @var{num}, int @var{resWork}, Profile* @var{prof});
@end example

This is a protected method of CGConScheduler class. In this base class, it
does nothing and returns FALSE. The first argument is the number of assigned 
processor. If all CGDDFWormholes inside the dynamic construct can be
optimally scheduled with fewer processors than @var{num}, this method
returns FALSE. If the number of assigned processor is given by the
programmer by @code{fixedNum}, we generate an error message indicating that
the assigned number is too large. 
Otherwise, we compute the optimal profile of the dynamic construct and
save the result to the argument @var{prof}.

After the main scheduling of the outside scheduler is completes, we do a
port processor for wormholes. In the bottom-up stage, we determines the
number of assigned processors for each wormhole of code generation domain.
With that number of processors, we schedule the inside galaxy of each wormhole
once more to prepare code generation procedure. This final step is
initiated by @code{finalSchedule} method of ParScheduler class. It
calls the following public method of CGWormBase class:

@example
int insideSchedule();
@end example

This method calls the @code{insideSchedule} method of the inside CGDDF target.

@example
int insideSchedule(Profile* @var{prof});
@end example

This method is a redefined public method of CGDDFTarget class. The argument is
the optimal profile of the dynamic construct. This method in turns calls
@code{finalSchedule} method for all CGDDFWormholes.

@example
int finalSchedule(int @var{num}, IntArray* @var{a});
@end example

This is a public method of CGDDFWormholes class. If the inside target is
not a multiprocessor target, it does nothing. Otherwise, it calls
@code{computeProfile} method of the inside multiprocessor target to
schedule the inside galaxy. The second argument represents the
processor assignment of the inside schedule. The processor assignment
is determined in the bottom-up stage by the outside scheduler.
In case of manual assignment (when the outside scheduler uses manual
assignment and the @code{fixedNum} and @code{procIds} states of CGDDFTarget
class are specified), we directly use the second argument, @code{a}, as the
processor assignment. We also give "-2" as the second argument to 
@code{computeProfile} method of CGMultiTarget class 
(@pxref{class CGMultiTarget}). 
Otherwise, the argument @code{a} indicates the mapping from
the indices of the profile after sorted with longest finish time, to the
processor indices. Therefore, we make a new assignment array which maps
the indices of the profile without sorting to the processor indices.
We give "-1" as the second argument to @code{computeProfile} method.
Recall that the @code{computeProfile} method also creates sub-galaxies
for the inside wormhole galaxy. 

@node manual scheduling, , bottom-up stage, CGDDF scheduling procedure
@subsection Manual scheduling

When we choose manual assignment option for the outside scheduler,
a dynamic construct is also manually scheduled. The top-down stage is
again performed when the galaxy is initialized (@code{CGWormBase::setup}).
The profile of the dynamic construct is also computed in this stage
unlike automatic scheduling case. Recall the last step of
the @code{setup} method of CGWormBase class is to set up the profile
pointer of the inside scheduler. In this step, we compute the profile
if manual assignment options is chosen.

@example
void setProfile(Profile* @var{p});
@end example

This is a redefined public method of CGDDFMultiTarget class. It sets the
profile pointer of this target to the argument Profile pointer.
If we select manual assignment, we call the @code{fixProfile} method to
compute the profile of the dynamic construct.

In the @code{computeSchedule} method of the outside scheduler, we call
the following method of CGWormBase objects associated with dynamic
constructs.

@example
Profile* manualSchedule(int @var{count});
@end example

This is a public method of CGWormBase class. The argument is the repetition
count of the wormhole. This method schedule the inside dynamic construct
manually (by @code{manualSchedule} method of CGDDFTarget class) and return
the pointer to the resulting Profile.

@example
Profile* manualSchedule(int @var{count});
@end example

This is a redefined public method of CGDDFTarget class. In case of
manual scheduling, the number of processors is given by @code{fixedNum}
state and the processor assignment is specified by @code{procIds}
IntArrayState of the CGDDF target. Then, we call the @code{insideSchedule}
method to finalize the schedule of the CGDDFWormholes.

@node class Profile, CGDDF code generation, CGDDF scheduling procedure, CGDDF Domain
@section Class Profile

A Profile object keeps the scheduling results of a wormhole or a parallel star.
It has two IntArrays to record the scheduling start time and the finish
time on the processors. These two arrays can be set and get the following
public methods:

@example
void setStartTime(int @var{index}, int @var{time});
void setFinishTime(int @var{index}, int @var{time});
int getStartTime(int @var{index});
int getFinishTime(int @var{index});
@end example

These arrays are initialized in the @code{initialize} method.

@example
void initialize();
@end example

The number of non-zero entries in the finish time array is the
actual number of assigned processors. This value can be set and get by
the following public methods.

@example
void setEffp(int @var{i});
int getEffp();
@end example

It has another array to record a map from the profile index and the 
processor index of the inside schedule. Initially, these two indices are
same. However, if we sort the profile with finish time or with start time,
the profile indices may differ from the processor indices.

@example
void sortWithFinishTime(int @var{start} = 0);
void sortWithStartTime(int @var{start} = 0);
@end example

These public methods sort the profile with finish time and with start time.
The argument indicates from which index we allow sorting. For example,
if @var{start} = 1, we do not sort the first entry of arrays of finish time
and start time. 

Mapping from the profile index and the processor can be set and get the
following methods:

@example
void setProcId(int @var{profile_index}, int @var{proc_index});
int getProcId(int @var{profile_index});
@end example

Class Profile has two constructors: one with no argument, and the other
with one argument. The constructor with one argument and the following method
initialize three arrays mentioned above.

@example
void create(int @var{n});
@end example

The arrays of finish time and start time are initialized with 0s. But,
the mapping array of profile index and processor index is initialized with
an integer sequence from 0 to @var{n}-1.

After the profile is completed, we compute the makespan of the local schedule
and the schedule period in the following method.

@example
void summary();
@end example

The makespan is obtained by the maximum finish time of processors.
The schedule period is the maximum value of the finish time minus start time
on processors. These two values can be obtained:

@example
int getMakespan();
int getPeriod();
@end example

We can copy this profile to another profile.

@example
void copyIt(Profile* @var{dest}, int @var{offsetIndex} = 0, int @var{offsetTime} = 0);
@end example

The second argument is the offset of profile indices and the third argument
indicates the time shift of start times and finish times.

When we schedule this profile, the start times may not match the pattern
of processor availability. In this case, we compute the length of idle
time on the processor where the first profile index will be scheduled.

@example
int frontIdleLength(IntArray& @var{avail});
@end example

The argument is the pattern of processor availability. This method
compares the processor available time and the start time on each
processor and return the maximum difference.

To compute the overhead this profile introduced to the overall schedule,
we compute the idle time due to mismatch of the pattern of
processor availability and the profile start times.

@example
int totalIdleTime(IntArray& @var{avail}, int @var{numProcs});
@end example

The first argument is the pattern of processor availability. If the
second argument @var{numProcs} is larger than the assigned number
of processors, we introduce extra idle time on the unassigned processors
by the makespan of this profile.

The total cost of the profile can be set and get the following methods:

@example
void setTotalCost(double @var{d});
int getTotalCost();
@end example

If we can parallelize this profile into different sets of processors,
we have to determine the minimum time shift by which successive instances of
this profile should be separated. This minimum time shift can be
set and get the following methods.

@example
void setMinDisplacement(int @var{i});
int getMinDisplacement();
@end example

When we compute the optimal profile of a "for" construct and 
the profile can be parallelized, we need to 
compute the ratio of makespan over the minimum time shift.

@example
int ToverK();
@end example

Class Profile has another important member: an array of arrays to
record the processor assignment onto the targets. A processor
assignment can be represented by an IntArray object. Since a
parallel star, or a wormhole, may have multiple invocations and
these invocations may be scheduled onto different sets of processors,
we have an array of IntArray objects. The size of this array is equal to
the number of invocations. There are six methods related to this array of
IntArray objects.

@example
void createAssignArray(int @var{num});
@end example

Creates @var{num} IntArrays and the size of each IntArray is the
number of actually assigned processors. This method initializes these
IntArray objects.

@example
int numInstance();
@end example

Returns the number of invocations, or the size of the array of IntArrays.

@example
void assign(int @var{invoc}, int @var{index}, int @var{value});
@end example

This method fills an entry (of @var{index}) of the @var{invoc}-th
IntArray with @var{value}.

@example
IntArray* assignArray(int @var{invoc});
@end example

Returns the IntArray associated with the argument invocation.

@example
int assignedTo(int @var{invoc}, in @var{index});
@end example

Returns the processor to which the profile index, @var{index}, of the
@var{invoc}-th invocation is assigned.

@example
int profileIx(int @var{invoc}, int @var{value});
@end example

This method returns the index of the profile of the @var{invoc}-th
invocation assigned to the processor of index @var{value}.

The destructor deletes the array of IntArrays.

@node CGDDF code generation, scheduler classes, class Profile, CGDDF domain
@section CGDDF code generation

After the parallel scheduling is completed, we generate code for each
processor. A dynamic construct is represented by CGWormStars in the
processor schedule. Since a dynamic construct may be scheduled on
more than one processors, several CGWormStars will be associated with
a dynamic construct. Different invocations of a dynamic construct
will make different CGWormStars. Now, the UniProcessor class
(@pxref{class UniProcessor}) execute the @code{go} method of the stars
in the scheduled lists. When a CGWormStar is executed, code for
the dynamic construct associated with that CGWormStar is generated.
The @code{go} method of a CGWormStar is defined as

@example
void CGWormStar :: go() @{
	myWorm->downLoadCode(invocNum, profileIndex);
@}
@end example

If the outside target is not a multiprocessor target, the outside
scheduler schedules the wormhole itself in the scheduled list. The @code{go}
method of a code generation method also calls the @code{downLoadCode}
method of CGWormBase class with two zero arguments.

@example
void downLoadCode(int @var{invoc}, int @var{pix});
@end example

This is a public method of CGWormBase class. The arguments are the
invocation number of the wormhole and the profile index that is assigned
to the current target for which we generate code.
This method calls the @code{downLoadCode} method of the inside CGDDF target.

@example
int downLoadCode(int @var{invoc}, int @var{pix},  Profile* @var{prof});
@end example

This is a redefined public method of CGDDFTarget class.
If the first argument is non-zero, we use @code{assignedTo} method of the
given profile object, @var{prof}, to get the processor index on 
which the given profile index, @var{pix}, is scheduled. This method in turns
calls the @code{downLoadCode} method of CGConScheduler class.

@example
virtual int downLoadCode(int @var{invoc}, int @var{pipx}, int @var{procIx});
@end example

This is a virtual public method of CGConScheduler class. In this base class,
it does nothing and returns 0 to indicate an error occurs. The derived
scheduler classes will redefine this method to generate actual code onto
the processor of index @var{procIx}.

In the @code{downLoadCode} method of the actual scheduler object, we will
call @code{downLoadCode} method of CGDDFWormhole class to generate code
in the current target of interest.

@example
void downLoadCode(int @var{index}, int @var{pId}, CGTarget* @var{t});
@end example

This is a public method of CGDDFWormhole class. We first set the
@code{repetitions} count of this wormhole to 1. This is necessary
since inside portholes at the wormhole boundary inquire the repetition
counter value of the far side block to calculate the resource requirement.
If the code generation target is not a multiprocessor target, 
we generate code for the
whole inside galaxy in the given target, @var{t}, by calling
@code{insideGalaxyCode} method. Otherwise, we call @code{downLoadCode}
of the CGMultiTarget object to generate code for the given target.

It is worth noting that we create communication stars between processors
for synchronization before code generation procedure starts. These
communication stars are created in the @code{insideSchedule} method
of CGDDFTarget class in the scheduling phase. Actually, we call
the following two public methods of CGConScheduler class in sequence.

@example
virtual void buildSyncLinks(MultiTarget* @var{mtarget}, Profile* @var{prof});
virtual void buildDataSyncs(MultiTarget* @var{mtarget}, Profile* @var{prof});
@end example

The first method creates communication stars for control synchronization
between processors. Recall that a data parallel star or the wormhole
can communicate with the outside galaxy via the first profile index.
Therefore, if a dynamic construct is scheduled on N processors, we
need to create (N-1) send stars for the processor on which the first
profile index is scheduled, and (N-1) receive stars for the other
processors one per each. The second method is to create communication stars
for data synchronization. If different invocations of a profile are
parallelized, the first profile index of the first
invocation need to transfer the data from the
outside to the processors on which the first profile indices of other 
invocations are scheduled. In this base class, we do nothing.

@node scheduler classes, CGDDF targets, CGDDF code generation, CGDDF Domain
@section Scheduler classes

The base scheduler in the CGDDF domain is CGConScheduler. CGConScheduler is
derived from the base scheduler class, Scheduler. Many members of this class
are already explained in earlier sections. They include the following
protected members:

@example
Profile* profile;	// profile pointer
int numProcs;		// current number of the assigned processors
int optNum;		// optimal number of assigned processors
DistBase dist;		// distribution of run-time parameter
virtual int examine(Galaxy& @var{g});	// topology checking
virtual int closerExamine();		// check the scheduling lists
virtual void initMembers();		// member initialization
virtual int setProfile(int @var{numP}, int @var{resWork}, Profile* @var{pf});
@end example

and the following public members:

@example
void setup();
int calcProfile(int @var{numP}, IntArray* @var{avail});
int fixProfile(int @var{numP}, int @var{resWork}, IntArray* @var{avail});
void copyProfile(Profile* @var{obj});
void setProcs(int @var{n});
virtual void buildSyncLinks(MultiTarget* @var{t}, Profile* @var{pf});
virtual void buildDataSyncs(MultiTarget* @var{t}, Profile* @var{pf});
@end example

CGConScheduler class has two more protected members to keep the communication
stars for synchronizations, created by @code{buildSyncLinks}.

@example
BlockList syncSendStars;
BlockList syncReceiveStars;
@end example

These lists are initialized in the constructor and cleared in the destructor.
The domain of CGConScheduler is CGDDF.
We have three do-nothing public methods in CGConScheduler class to redefine
pure virtual methods of Scheduler class:

@example
int run();
void setStopTime(double @var{time});
double getStopTime();
@end example

Two more public methods are defined in CGConScheduler class.

@example
virtual int getStatistics();
@end example

This method reads the target parameters to set the private members for
distribution information. In this base class, it does nothing and returns
FALSE.

@example
int avgExecTime();
@end example

This method returns the assumed execution time of the dynamic construct:
@code{assumeExecTime}.
If the distribution information is not established, it returns 0.

The following methods are all protected.

@example
virtual int assumeExecTime();
@end example

This method returns the assumed execution time of the dynamic construct.
In this base class, it returns 0.

@example
virtual void saveOptInfo();
@end example

After the optimal profile is determined, we save the profile information
if necessary. In this base class, it does nothing.

@example
const char* nameComm(int @var{invoc}, int @var{ix}, int @var{flag});
@end example

This method gives a unique name for communication stars for a given profile.
The first argument is the invocation index, and the second argument is the
profile index. The name becomes

	(wormhole-name)_(star-type)_@var{invoc}_@var{ix}

The star-type field is determined by the third argument. If @var{flag} = 0,1,
the star-type becomes snd0, rcv0. These types are used for control
synchronization. If @var{flag} = 2,3, it becomes snd1,rcv1, to be used for
forward data synchronization. if @var{flag} = 4,5, it becomes snd2, rcv2 for
backward data synchronization. Recall that the processor on which the
first index of the profile of the first invocation is mapped becomes the
@emph{synchronization} processor between the outside galaxy and the inside
galaxy. In forward data synchronization, we send data from the outside
galaxy to the inside galaxy through the synchronization
processor. On the other hand, we send data back to
the outside galaxy from the inside galaxy through synchronization processor in
backward data synchronization.

@example
CGStar* syncCommStar(BlockList& @var{blist}, int @var{invoc}, int @var{ix}, int @var{flag});
@end example

This method returns the communication star based on the name information of
the last three arguments. 
The first argument represents the block list in which the communication star
should be found. If no star is found, generate an error message and returns 0.

@example
int addSendCodes(Geodesic* @var{geo}, int @var{invoc}, CGTarget* @var{t});
@end example

This method generates code to send control synchronization from the
synchronization processor to the other processors. The control
information is given by the first argument Geodesic. The second
argument is used to find out Send stars for control synchronization
stored in @code{syncSendStars} list. The third argument indicates the
current target for which code is generated.

@example
Geodesic* findGeo(const char* @var{nm});
@end example

This method returns the Geodesic connected to a porthole of the wormhole
that contains this dynamic construct. That Geodesic indicates the memory
location (in assembly code) or the variable (in high level code) whose
value will be transferred to or from the inside galaxy. The argument
gives the information of the porthole. If @var{nm} = 0, the Geodesic
is connected to a CGDDFWormhole inside. If @var{nm} is a star name, we
the Geodesic is connected to the non-control port of the star. It can be
a porthole name. If @var{nm} = "control", the Geodesic should be connected
to a Fork star.

@example
CGPortHole* boundaryPort(Star* @var{worm}, int @var{flag});
@end example

This method returns a boundary porthole inside a wormhole, @var{worm}.
If @var{flag} = 0, it returns the input boundary porthole. If @var{flag} = 1,
it returns an output boundary porthole which is connected to the outside
Case or EndCase star through wormhole interface. 
If @var{flag} = 2, it returns an output boundary porthole
which is connected to the outside Fork star.

@menu
* class CGCaseScheduler::		class CGCaseScheduler
* class CGForScheduler::		class CGForScheduler
* class CGDoWhileScheduler::		class CGDoWhileScheduler
* class CGRecurScheduler::		class CGRecurScheduler
@end menu

@node class CGCaseScheduler, class CGForScheduler, scheduler classes, scheduler classes
@subsection Class CGCaseScheduler

CGCaseScheduler is the scheduler object for "case" construct. This class
redefines the virtual methods of CGConScheduler class for the "case"
construct.

@example
int getStatistics();
@end example

If there are two branches, the distribution time should be GEOMETRIC and
the geometric constant becomes the probability of the TRUE branch (or
branch #1) being taken. If there are more than two branches, the distribution
type should be GENERAL and probabilities of each branch being taken should
be given by a table.

@example
int examine(Galaxy& @var{g});
@end example

We first check the number of branches. Then, we prepare the schedule lists and
check the topology. 

@example
int closerExamine();
@end example

We check whether there is only one wormhole for each branch. If not,
generate an error signal.

@example
void initMembers();
@end example

Initialize private members for scheduling.

@example
int assumeExecTime();
@end example

Returns the average work-load for each branch wormholes.

@example
int setProfile(int @var{num}, int @var{resWork}, Profile* @var{prof});
@end example

This is the main routine to compute the best schedule with given number
of processors. We sort the profile of each wormhole with the finish time
as a preprocessing step. The main algorithm can be found in reference [3]
(@pxref{References}).

@node class CGForScheduler, class CGDoWhileScheduler, class CGCaseScheduler, scheduler classes
@subsection Class CGForScheduler

CGForScheduler is the scheduler class for the "for" construct. In this
subsection, we will explain some special feature for CGForScheduler class.
Refer to earlier sections for general discussion.

@example
int closerExamine();
@end example

When we examine the schedule list, we check whether the body of the construct
is represented by a single CGDDFWormhole.

@example
void saveOptInfo();
@end example

We save the number of parallel invocations for the loop body in the optimal
profile. If iteration cycles are not independent, this number will be one.

@example
int assumeExecTime();
@end example

We return the total execution time of the loop body multiplied by the
returned value of the @code{assumedValue} method of the distribution.

@example
void buildSyncLinks(MultiTarget* @var{t}, Profile* @var{pf});
@end example

This method create communication stars for control synchronization.
Before we do this normal step, we call @code{prepCode} method of the
outside multiprocessor target if the iteration cycles are parallelized.
If we parallelize iteration cycles, we have to duplicate the galaxy code
into different sets of processors. Since code for
the interprocessor communication inside the
galaxy code depends on which processor sets we use, we need to
adjust processor-dependent part of the generated code before code
duplication. The @code{prepCode} takes care of that task.

@example
void buildDataSyncs(MultiTarget* @var{t}, Profile* @var{pf});
@end example

This method creates communication stars for data synchronization in case the
iteration cycles are parallelized.

@node class CGDoWhileScheduler, class CGRecurScheduler, class CGForScheduler, scheduler classes
@subsection Class CGDoWhileScheduler

CGDoWhileScheduler is the scheduler class for the "doWhile" construct.
In the scheduling point of view, the "doWhile" construct
is a special case of the "for" construct where no intercycle parallelism
is allowed.
In this section, we will explain some special features for the "doWhile"
construct.

@example
int closerExamine();
@end example

This checks whether the loop body is represented inside a single wormhole.

@example
int assumeExecTime();
@end example

This method returns the total execution time of the loop body multiplied by
the return value of the @code{assumedValue} method of the distribution object.

@node class CGRecurScheduler, , class CGDoWhileScheduler, scheduler classes
@subsection Class CGRecurScheduler

CGRecurScheduler is the scheduler class for the "recur" construct.
The most distinguished feature is that we generate a function call for
the recursion body: @code{downLoadCode}. We need complicated 
synchronization control between processors. 

@example
void buildSyncLinks(MultiTarget* @var{t}, Profile* @var{pf});
@end example

Since the recursion body may be duplicated in different sets of processors,
we call the @code{prepCode} method of the outside multiprocessor target
like CGForScheduler class. Unlike other scheduler classes, we do not
create communication stars for control synchronization in this method.

@example
void buildDataSyncs(MultiTarget* @var{t}, Profile* @var{pf});
@end example

The first profile index for the recursion loop body will be placed in
several processors if the number of Self stars (or recursion width) is
larger than 1 and we parallelize the recursion branches. We
need data and control synchronization between the synchronization 
processor of the whole recursion construct and those processors 
where the first profile index is mapped. Those processors perform
the control synchronization with other processors assigned to
their copy of profile. Therefore, we create all communication stars
for control and data synchronization at once.

@node CGDDF targets, wormhole classes, scheduler classes, CGDDF Domain
@section CGDDF targets

CGDDFTarget class is a base target class for CGDDF support.
There is a derived class in the CGC domain: CGCDDFTarget class.
In the CGC domain, we set the inside CGDDF target of the CGCWormhole with a
CGCDDFTarget. Then we can generate C code for dynamic constructs.

Many members are already discussed in earlier sections, including the
following protected members:

@example
StringState paramType;		// distribution type
FloatState paramGeo;		// geometric constant
IntState paramMin;		// minimum value of the run-time parameter
IntState paramMax;		// maximum value of the run-time parameter
StringState paramFile;		// file name for general distribution
IntState fixedNum;		// fixed number of assigned processors
StringState constructType;	// construct type
IntArrayState procIds;		// processor indices for manual assignment
@end example

and the following public members:

@example
void setProfile(Profile* @var{pf});
int computeProfile(int @var{nP}, int @var{resWork}, IntArray* @var{avail});
int insideSchedule(Profile* @var{pf});
Profile* manualSchedule(int @var{count});
int downLoadCode(int @var{invoc}, int @var{pix}, Profile* @var{pf});
@end example

CGDDFTarget class has two more protected members.

@example
CGConScheduler* conSched;
Profile* profile;
@end example

The first member is the pointer to the scheduler object. The second is
the pointer to the Profile array of the wormhole this target lies in.

CGDDFTarget class is derived from class MultiTarget. It has a constructor
with three argument like class MultiTarget. In the constructor, we hide
several states inherited from the base class: @code{nprocs}, @code{sendTime},
@code{oneStarOneProc}, @code{manualAssignment}, and @code{adjustSchedule}.
This class has the @code{makeNew} and @code{isA} methods. We redefine four
public methods doing nothing since they are pure virtual methods in the
base class. They are

@example
DataFlowStar* createReceive(int,int,int);
DataFlowStar* createSend(int,int,int);
DataFlowStar* createSpread();
DataFlowStar* createCollect();
@end example

Now, we explain other public members.

@example
void setup();
@end example

This method does the following tasks:

(1) Create a scheduler object based on @code{constructType} state.

(2) Obtain the statistical information of the distribution by calling
@code{getStatistics} method of the scheduler object.

(3) In case of manual scheduling, this methods checks whether all
information is consistent or not. 

(4) Call @code{Target::setup} method for normal setup procedure: scheduler
setup.

@example
int numFix();
@end example

Returns the value of the @code{fixedNum} state.

@example
MultiTarget* inheritFrom();
@end example

This method returns the multiprocessor target of the outside domain from
which the child targets are inherited.

@example
int totalWorkLoad();
@end example

It returns the value from the @code{avgExecTime} method of the scheduler
object.

@example
StringList displaySchedule();
@end example

This method displays the inside schedule of all CGDDFWormholes.

There are several virtual methods that the derived target such as CGCDDFTarget
should redefine to generate code properly. In the base CGDDFTarget class,
all the following methods do nothing. We will explain these methods in
CGCDDFTarget class.

@example
virtual void signalCopy(int @var{flag});
@end example

If @var{flag} is set TRUE, it notifies the outside multiprocessor target
that the following wormhole code is now duplicated so that we need to adjust
machine information of all communication stars in case of the "for" and
the "recur" constructs. In CGCDDFTarget class, it just calls
@code{signalCopy} method of the CGCMultiTarget object. 

@example
virtual void prepCode(MultiTarget* @var{t}, Profile* @var{pf}, int @var{numP}, int @var{numChunk});
@end example

The first argument is the multiprocessor target of the outside domain.
In this base class, it does nothing while in the CGCDDFTarget class, it
calls the @code{prepCode} method of the CGCMultiTarget object, @var{t}.

@example
virtual void startCode_Case(CGStar* @var{s}, Geodesic* @var{geo}, CGTarget* @var{t});
@end example

The control variable of the "case" construct is given by the second
argument @var{geo} or the "output" porthole of the first argument
star, @var{s} if @var{geo} is NULL. In this method, we generate
the starting line of the @code{switch} statement. The third target argument
is the child target we are currently generating code for.

@example
virtual void middleCode_Case(int @var{i}, CGTarget* @var{t});
@end example

The first argument represents the argument for @code{case} statement
inside a @code{switch} construct in CGCDDFTarget class. We will generate
@code{break} and @code{case} statement to distinguish branches.

@example
virtual void endCode_Case(CGTarget* @var{t});
@end example

This method prints a closing curly brace to finalize the @code{switch}
construct in the C code.

@example
virtual startCode_DoWhile(Geodesic* @var{dest}, Geodesic* @var{src}, CGTarget* @var{t});
@end example

The first argument is the variable that will get the final result after the
do-while statement. The second argument is the variable that will be fed into
the do-while statement initially. We generate a @code{do} statement in
the argument target. Before that we generate an assignment statement from
@var{src} to @var{dest}.

@example
virtual void endCode_DoWhile(CGStar* @var{s}, Geodesic* @var{gd}, CGTarget* @var{t});
@end example

This method prints the @code{while} statement to finish the do-while
construct in the generated code. The control value is given by the
second argument @var{gd} or the "output" porthole
of the first argument star @var{s} if @var{gd} is given 0.

@example
virtual void startCode_For(CGStar* @var{s}, Geodesic* @var{gd}, CGTarget* @var{t});
@end example

This method prints the starting line of the @code{for} statement. The
maximum index range of the @code{for} statement is given 
by the second argument
@var{gd} or the "output" porthole of the first argument star @var{s}.

@example
virtual void middleCode_For(CGStar* @var{rv}, CGStar* @var{ds}, int @var{k},
int @var{mo}, CGTarget* @var{t});
@end example

If @var{k} is larger than 1, it means that we parallelize iteration cycles.
Therefore, we have to compute the modulo value of the loop index by @var{k}.
If the argument target does not correspond to the synchronization processor
of the "for" construct, the first two arguments are given NULL. In this case,
if the loop index is not equal to @var{mo}, we just print @code{continue}
statement to skip the current loop index. If we are generating code
for the synchronization processor, we are given the first two arguments.
The first star represents the receive star for backward data synchronization.
In case the modulo of the loop index by @var{k} is equal to @var{mo},
we incrementally add the code of the receive star. The second argument star
is the down-sampler star. We generate the code of the down-sampler star with
the data received from @var{rc}.

@example
virtual void endCode_For(CGTarget* @var{t});
@end example

We print a closing curly brace to finish the @code{for} construct.

@example
virtual void startCode_Recur(Geodesic* @var{arg}, PortHole* @var{p}, const char* @var{funcName}, CGTarget* @var{t});
@end example

This method performs preparation tasks to define a recurtion function.
First of all, we replace code streams of the target @var{t} with
temporary code streams. The galaxy code will be put into this
temporary code streams. The first argument is the argument variable of the
recursion function. The second variable determines the return type of
the function. If @var{p} is NULL, the return type if "void". The third
argument is the name of the recursion function.

@example
virtual void middleCode_Recur(Geodesic* @var{dest}, Geodesic* @var{arg}, const char* @var{funcName}, CGTarget* @var{t});
@end example

This method prints a recursion function call. The return value is assigned
to @var{dest} variable if not given NULL. The second argument, @var{arg},
represents the argument to the recursion function. The third argument is
the function name.

@example
virtual void endCode_Recur(Geodesic* @var{gd}, const char* @var{funcName}, CGTarget* @var{t});
@end example

This method generates the definition of the recursion function based on
the temporary code streams defined in the @code{startCode_Recur} method.
The first argument, @var{gd}, represents the return variable. If it is given
NULL, the return type of the recursion function is "void".

@node wormhole classes, , CGDDF targets, CGDDF Domain
@section Wormhole classes

A dynamic construct inside a code generation domain resides in a
wormhole. We create a base wormhole class, called CGWormBase, of all
code generation wormholes to perform the common function of realizing a
dynamic construct. A code generation wormhole, for example CGWormhole and
CGCWormhole, is doubly derived from the CGWormBase class and the base
star class in that domain. In this section, we will explain classes
CGWormBase and CGCWormhole.

Recall that a dynamic construct has a predetermined topology. Therefore,
the galaxy inside a code generation wormhole contains CGDDFWormholes
to represent the body of the construct. If we have a nested dynamic
constructs, a CGDDFWormhole will contain other wormholes for dynamic
constructs.

@menu
* class CGWormBase::		class CGWormBase
* class CGCWormhole::		class CGCWormhole
* class CGDDFWormhole::		class CGDDFWormhole
@end menu

@node class CGWormBase, class CGCWormhole, wormhole classes, wormhole classes
@subsection Class CGWormBase

Class CGWormBase is derived from the base wormhole class, Wormhole. It has the
same constructor with the base class.
Some members are already explained in earlier sections, including

@example
void setup();
void assignProcs(int @var{num});
void computeProfile(int @var{numP}, int @var{resWork}, IntArray* @var{avail});
Profile* manualSchedule(int @var{count});
int insideSchedule();
void downLoadCode(int @var{invoc}, int @var{pix});
@end example

This class has the following four protected members.

@example
void setOuterTarget(Target* @var{tp});
@end example

This method saves the pointer to the outside multiprocessor target.

@example
Profile* myProfile;
@end example

This is the pointer to the profile array that we will create 
in the @code{assignProc} method.

@example
int execTime;
@end example

It is the total execution time of the inside galaxy. It will be set in the
@code{setup} method with the @code{totalWorkLoad} method of the CGDDF target.

@example
CGWormBase* selfWorm;
@end example

This is the pointer to itself.

There are some other public members.

@example
Profile* getProfile(int @var{pNum});
@end example

This method returns the pointer to the Profile object associated with
the number of processor, @var{pNum}.

@example
void setupProfile(int @var{n});
@end example

This method creates the assignment array of the Profiles before scheduling.

@example
int isCGinside();
@end example

Returns TRUE only if the inside domain is a code generation domain.

@example
StringList displaySchedule();
@end example

This method calls the @code{displaySchedule} of the inside target object.

@node class CGCWormhole, class CGDDFWormhole, class CGWormBase, wormhole classes
@subsection Class CGCWormhole

Class CGCWormhole is doubly derived from class CGWormBase and class CGCStar.
The outside CGC domain will regard a CGCWormhole object as a CGC star while
the CGCWormhole object will contain a CGDDF domain inside. This class has
a constructor and a destructor as wormholes of other domains. It has a clone
method.

The following methods are all public.

@example
void setup();
@end example

This method makes the Profile pointer of the CGWormBase class visible to
the outside. And it sets the outer target pointer to the CGWormBase class.
At last, it calls the @code{setup} method of the CGWormBase class for
main set-up procedure.

@example
void go();
@end example

This method just calls the @code{downLoadCode} method with arguments of 2 0s.

@example
void wrapup();
@end example

Do nothing.

@example
Scheduler* scheduler() const;
@end example

Returns the pointer to the scheduler object inside.

@example
int myExecTime();
@end example

Returns the execution time of this wormhole, @code{execTime} of the CGWormBase
class.

@example
StringList print(int @var{verbose} = 0) const;
@end example

Calls the @code{Wormhole::print} method.

@example
int isItWormhole() const;
@end example

Just returns TRUE.

@example
State* stateWithName(const char* @var{name});
void initState();
@end example

These methods should be provided for all wormhole classes.

@example
CGWormBase* myWormhole();
@end example

Returns the pointer as a CGWormBase object.

@example
Profile* getProfile(int @var{pNum});
@end example

Just calls the @code{getProfile} method of the CGWormBase class.

@node class CGDDFWormhole, , class CGCWormhole, wormhole classes
@subsection Class CGDDFWormhole

Class CGDDFWormhole is doubly derived from class Wormhole and class CGDDFStar.
It will contain a code generation domain to represent the body of the dynamic
construct. It has a constructor and a destructor as other wormhole classes. It
also has a clone method.
Some members are already explained in earlier sections:

@example
void setup();
StringList displaySchedule();
void assignProcs(int @var{num});
int finalSchedule(int @var{n}, IntArray* @var{array});
void downLoadCode(int @var{index}, int @var{pId}, CGTarget* @var{t});
@end example

Other members described in this subsection are all public.

@example
State* stateWithName(const char* @var{name});
void initState();
@end example

These methods should be redefined in all wormhole classes.

@example
Schedule* scheduler() const;
Profile* myProfile();
CGDDFWormhole* myWormhole();
@end example

The above methods return the pointer to the inside scheduler object,
the Profile array, and itself.

@example
void setNumProcs(int @var{i});
int getNumProcs();
@end example

These methods set and get the number of processors assigned to this wormhole.

@example
int getTotalWork();
@end example

Returns the total execution time of the inside code generation galaxy.

@example
StringList print(int @var{verbose} = 0) const;
@end example

Just calls the @code{Wormhole::print} method.

@example
int isItWormhole() const;
@end example

Is redefined to return TRUE.

@example
int assignManually();
@end example

This method returns TRUE only if the outside domain and the inside domain take
manual scheduling.

@node CGdsp3 Domain, Status, CGDDF domain, Top
@chapter CGdsp3 Domain

The CGdsp3 domain is a code generation domain for AT&T DSP3 machine.

The AT&T DSP3 consists of up to 128 DSP32C processors. The network
topology is a kind of mesh structure inside a board that contains 16 DSP32C
with special connections between processors on the mesh boundary so that
all DSP32C processing element has four I/O ports. Four processing elements
on the corners of the mesh has two I/O ports to the outside of the board for
connection between boards. Each processing element has a routing chip
associated. Each routing chip has one input buffer and one output buffer.
The flow of data between four I/O ports can be programmed. A routine chip
has three addresses associated, called ASIC addresses. A message has the
destination address field in the header. If the destination address
matches one of its ASIC addresses, the routing chip will accept the message.
And it may pass the message to its successors or block the message depending
on the type of the ASIC addresses. So, it natually supports broadcasting
ability.

One major difficulty of this machine comes from the fact that we have to
program the flow path in the routing chip. It may either receive the
incoming data to the input FIFO and connect its output FIFO to the
output path, or connect the input and the output I/O directly. Also,
we have to choose among 4 I/O ports which one is an input and which one is
an output at each time. That implies that we need to program all
communication patterns at compile time, meaning static schedule of 
communication resources. Due to this difficulty, we regard the DSP3 machine
as a linear array machine for now. All program graphs for DSP3 will be 
acyclic.

The DSP3 machine has a real-time host (RTH) which manage all DSP32C processing
elements. The real-time host is connected to a Ethernet and communicate with
a host workstation. The host workstation will load the code and communicate
with the processing elements via the RTH. Once code is loaded is loaded,
it acts as a standalone machine with its own operating system.
It has a debugging tool.

The details of the machine can be obtained by AT&T. All routines that require
some detained knowledge were, and will be provided by the AT&T. In the
CGdsp3 domain, we provide the efficient code generation environment for
the AT&T. We will generate C code for the DSP3. The C code will be
compiled for DSP32C processors. Therefore, we will regard the CGdsp3 domain
as a super domain of the CGC domain, in other words the CGC domain is a
sub domain of the CGdsp3 domain. All CGC stars defined in the CGC domain
can be directly used in the CGdsp3 domain. The CGdsp3 domain
can redefine some CGC stars. Since the CGdsp3 domain will need significant
number of new stars, we did not make the CGdsp3 domain as a target in the
CGC domain. Note that the CGdsp3 domain is not a domain in the strict sense
since it is just the same as the CGC domain. The only difference is the
target!

The kernel code can be found in $(PTOLEMY)/src/domains/cgdsp3/kernel.
Some files are designed by AT&T to define a message class for the DSP3
(dsp3_message.h) and to send data from the host workstation to the DSP3
(TALK2DSP3.h Internet.h). The message class for the DSP3 is
DSP3Message. 

In this chapter, we will focus on the Ptolemy code for the DSP3 machine.
Currently, we focus on the manual scheduling options even though we
designed a simple scheduler for linear array architecture: chainScheduler.

@menu
* target for DSP3::			target class for the DSP3
* communication stars for DSP3::	communication stars for the DSP3
* class CoopCode::			class CoopCode
* chainScheduler::			chainScheduler
* CGdsp3 status::			current status of CGdsp3 Domain
@end menu

@node target for DSP3, communication stars for DSP3, CGdsp3 Domain, CGdsp3 Domain
@section target for DSP3

The multiprocessor target for the DSP3 is called CGdsp3Target, which is
derived from CGMultiTarget class. The child target of a CGdsp3Target is
DSP32CTarget that is derived from CGCTarget class. 

@menu
* class CGdsp3Target::		multiprocessor target for the DSP3
* class DSP32CTarget::		DSP32C processor target
@end menu

@node class CGdsp3Target, class DSP32CTarget, target for DSP3, target for DSP3
@subsection Class CGdsp3Target

Class CGdsp3Target has a constructor with three arguments like the base class,
CGMultiTarget. In the constructor, we hide some of the inherited states.
Since the scheduler object for the DSP3 is ChainScheduler, we hide the states
used to select schedulers: @code{ignoreIPC, overlapComm, useCluster}.

@example
void chooseScheduler();
@end example

This is a redefined protected method to create a scheduler object. We create
a ChainScheduler (@pxref{chainScheduler}).

Since the DSP3 is a homogeneous multiprocessor, we have no freedom to choose
a child target. Hence, we hide @code{childType} state also.

@example
Target* createChild(int @var{i});
@end example

This is a redefined protected method to create a child target. We create a
DSP32CTarget object.

We will create a code file for each processing element. Since the file name
will be same as the child target name, we also hide @code{filePrefix} state.

@example
void addProcessorCode(int @var{index}, const char* @var{code});
@end example

This is a redefined public method to write the @var{code} to a 
file associated with the child target of the given @var{index}.

This class defines the following states.

@example
IntState ChannelID;
@end example

This is the destination identifier that will be attached in the header of
a DSP3Message. It is a temporary solution to specify this identifier as
a target parameter.

@example
IntState run_it;
@end example

If this state is set TRUE, we will execute the DSP3. Otherwise, we will not
start the DSP3.

@example
IntState timeOut;
@end example

This state defines the length of time units before we stop waiting
until the communication request is fulfilled.

@example
IntState batchFactor;
@end example

To reduce the communication overhead, we make a packet of samples
and transmit that packet. This state determines the number of samples
in a packet. The maximum value of this state if 240 that is also
a default value. We hide this state to the users.

@example
StringState internetAddr;
@end example

This is the internet address of the DSP3 machine since the host workstation
communicates with the DSP3 via Ethernet.

Finally, the constructor change the default value of the @code{oneStarOneProc}
state to YES since we will use a manual scheduling by default.

@menu
* other CGdsp3Target protected members::
* other CGdsp3Target public members::
@end menu

@node other CGdsp3Target protected members, other CGdsp3Target public members, class CGdsp3Target, class CGdsp3Target
@subsubsection Other CGdsp3Target protected members

@example
TALK2DSP3 dsp3;
@end example

This is a class to model the DSP3 machine that the Ptolemy system thinks.

@example
void resetResources();
@end example

Currently, it does nothing since we do not attempt to schedule the resources.

@example
void start_the_dsp3();
@end example

If the @code{run_it} state is FALSE, do nothing. Otherwise, we make a
socket connection to the DSP3, boot the DSP3, and configure the DSP3 as a
linear array for now.

@example
int load_the_dsp3(const char* @var{load_image}, unsigned short @var{i});
@end example

This method loads the code, @var{load_image}, to a child target of 
the given index @var{i}, and execute the code. It returns TRUE of no
error occurs.

@example
void reportError(int @var{i}, const char* @var{msg});
@end example

When we generate a command to the DSP3, the command returns a error code.
If the error code is not zero, we call this method to print out the
error message @var{msg}. The first argument is the error code to distinguish
the cause of the error.

@example
int receiveWormData();
int receiveWormData(PortHole& @var{p});
@end example

The above methods are redefined to transfer the data received from the
DSP3 to the Ptolemy simulation engine. Currently, only one connection may
exist since we do not disambiguate the destination of the messages.
To disambiguate the destination, the incoming message to the Ptolemy
should set the destination identifier to the porthole index it is connected
to via wormhole interface. This is not implemented yet. Currently, the
first method just calls the @code{CGMultiTarget :: receiveWormData} method.
The second method reads the data from the DSP3 by the @code{readDSP3} method
and send the message to the wormhole outside.

@example
CGPortHole* disambiguateMessage(DSP3Message* @var{pd});
@end example

This is the routine to examine the argument DSP3Message to disambiguate
the destination porthole. This method will be called inside the
@code{receiveWormData} method later. 

@example
int sendWormData(PortHole& @var{p});
@end example

This method receives a DSP3Message from the argument porthole and send it
to the DSP3. It sets the source identifier of the DSP3Message with the
index of @var{p}. The index of a porthole can be obtained
by the following public method of the CGdsp3Star.

@example
int getIndexOf(PortHole& @var{p});
@end example

@example
int wormLoadCode();
@end example

This method compiles the code. If the @code{run_it} state is set YES,
it runs the code.

@node other CGdsp3Target public members, , other CGdsp3Target protected members, class CGdsp3Target
@subsubsection Other CGdsp3Target public members

This class refines the @code{makeNew} and the @code{isA} methods.

@example
int prepareSchedule();
@end example

This method is called before the parallel scheduling begins but after
the galaxy is initialized (@pxref{class ParScheduler}). This method
make a information structure for all processing elements. The parallel
scheduler assumes that the processing index ranges from 0 to the number
of processors - 1. However, in the DSP3 galaxy, we want to specify the
hardwired processor number for each star for manual scheduling. For example,
if we set the @code{procId} of star A to 3, it means that star A is
assigned to processor 3 in the DSP3. Therefore, we have to map this
actual processor indices to those the parallel scheduler understands.
This task is done in this method.

@example
int writeDSP3(DSP3Message* @var{msg});
int readDSP3(DSP3Message* @var{msg});
@end example

These methods write a message to and read a message from the DSP.
These methods hang up if message transfer fails within the @code{timeOut}
duration.

@example
int compileCode();
@end example

This method compiles the generated code using a makefile defined by AT&T.

@example
int runCode();
@end example

This method downloads the code into the processors and start executing.
We have to load the code the consumer first, which means that we load the
code for the last processor first in the linear array topology.

@example
void wrapup();
@end example

If the DSP3 galaxy is not inside a wormhole, we call the @code{wormLoadCode}
method to download and execute the code. Otherwise, it terminates execution
of the DSP3. The DSP3 is also terminated in the destructor of this class.

@example
int scheduleComm(ParNode* @var{comm}, int @var{when}, int @var{limit} = 0);
@end example

Currently, it does nothing and returns @var{when}. Later, we have to schedule
the communication links.

@example
int commTime(int @var{from}, int @var{to}, int @var{nSamples}, int @var{type});
@end example

This method returns the expected communication cost. It is proportional to
the distance between @var{from} processor and @var{to} processor since the
DSP3 is assumed to be a linear array network.

@example
DataFlowStar* createSend(int @var{from}, int @var{to}, int @var{num});
DataFlowStar* createReceive(int @var{from}, int @var{to}, int @var{num});
@end example

The above methods create a send star (AutoSend) and 
a receive star (AutoReceive). The communication stars are derived from
class CGdsp3CommStar. We set some information for these stars
such as the @code{batchFactor}
and the ASIC identifiers for the @var{from} and the @var{to} processors.

@node class DSP32CTarget, , class CGdsp3Target, target for DSP3
@subsection Class DSP32CTarget

Class DSP32CTarget is a derived CGC target for DSP32C processor.
It has a constructor with a single argument.

@example
DSP32CTarget(CGdsp3Target* @var{t});
@end example

The argument is the pointer to the parent DSP3 target.

This class defines the @code{makeNew} and the @code{isA} methods.
This class has a special list of code streams, called @code{coopStreams},
that is a private member. We may want to make a procedure that more than
stars cooperate to define the body of the procedure. For example, an
interrupt handler for I/Os requires which communication star
performs which action. Then, each star writes the code into a @code{CoopCode}
code stream (@pxref{class CoopCode}). The @code{codeStreams} keeps the
list of @code{CoopCode} streams.

@example
int addCoopSection(const char* @var{string}, const char* @var{name}, int @var{id});
@end example

This is a public method to add a code into the CoopCode with the given
@var{name}. If no CoopCode with the given name exists in the
@code{coopStreams}, we create a new CoopCode with that name and append the
stream in the @code{coopStreams}. Then, we put the argument code
@var{string} into that CoopCode stream. The third argument is passed to
the @code{putCode} method of the CoopCode stream (@pxref{class CoopCode}).

@example
void initCodeStrings();
@end example

We redefine this method to clear the CoopCode streams as well as other
inherited code streams.

@example
void frameCode();
@end example

We redefine this method to put the procedures at the end of
the main function. Each CoopCode makes a new procedure.

@example
void setup();
@end example

Besides the @code{CGCTarget::setup} routine, this method sets the
@code{funcName} state to the name of this target. So, the generated
code will not have a @code{main} function, but a function of this
target name.

@node communication stars for DSP3, class CoopCode, target for DSP3, CGdsp3 Domain
@section Communication stars for DSP3

Data are transferred in a DSP3Message format between processing elements and
between the DSP3 machine and the host workstation. Depending on the type of
data, float, int, or others, we need to use different routines to form
a DSP3Message. Also, we want to support different receiving mechanism.
Hence, we create a base communication star class in the CGdsp3 domain:
CGdsp3CommStar. CGdsp3CommStar class is derived from CGdsp3Star class.

CGdsp3CommStar has the following protected members.

@example
int origPE;
int destPE;
@end example

These members represents the ASIC identifiers for the source and the
destination processors.

@example
int numTok;
@end example

This is the number of samples to be processed if not batched.

@example
int inWorm;
@end example

This is a flag to be set TRUE if the DSP3 galaxy is inside a wormhole.

@example
int maxBatch;
@end example

This is the maximum number of samples to be batched in a DSP3Message.

These protected members are set by the following public member.

@example
void setProps(int @var{from}, int @var{to}, int @var{num}, int @var{maxNum}, int @var{flag});
@end example

This method sets the @code{origPE, destPE, numTok, maxBatch, inWorm} members
in the order of arguments.

This class has another protected member:

@example
int batchFactor;
@end example

This is the actual batch factor that is the number of samples in a DSP3Message.
Note that the number of samples in the last DSP3Message can be smaller than
this batch factor.
It can be set by the following public method:

@example
void setBatchFactor(int @var{n});
@end example

@example
int adjustBatchFactor(DataFlowStar* @var{s});
@end example

This is a protected method to adjust the batch factor to be consistent with
the sample rate. If the DSP3 galaxy is not inside a wormhole, we set the
batch factor with the @code{maxBatch}. Otherwise, we compute the
total number samples to be transferred in one execution of the DSP3 galaxy,
which is the product of the @code{numTok} member and the repetition count
of the argument star, @var{s}. We set the batch factor with the greatest
divisor of this product that is also not greater than the @code{maxBatch}
value. This method returns the repetition count of the argument star.

If the Ptolemy wants to send data to the DSP3, it must form DSP3Messages.
Suppose we have a SDF universe that has a wormhole of the DSP3 domain.
We use two stars, SDFFtoDSP3 and SDFFfromDSP3, to form DSP3Messages
at the wormhole interface in the SDF domain side. At the wormhole boundaries
inside, we put CGdsp3FrdDSP3Msg and CGdsp3rdDSP3Msg stars to receive and send
the DSP3Messages. These two stars are nominal communication stars that can
be used between two DSP32C processors. They are derived from 
CGdsp3CommStar class.

If we use manual scheduling, we can put communication stars manually.
CGdsp3FrdDSP3Msg and CGdsp3rdDSP3Msg stars are two example of these kinds
of communication stars. The parallel scheduler, however, will create and insert
communication stars between processors also: @code{createSend} and
@code{createReceive} methods of CGdsp3Target class. We use the same
CGdsp3AutoSend and CGdsp3AutoReceive stars whether we insert communication
stars manually or not. If we insert communication stars manually, these
AutoReceive and AutoSend stars will turn out to be dummy, or do nothing.
Otherwise, they will perform actual message transfer.

@menu
* AutoSend star::
* AutoReceive star::
@end menu

@node AutoSend star, AutoReceive star, communication stars for DSP3, communication stars for DSP3
@subsection AutoSend star

This star is derived from CGdsp3FwrDSP3Msg star. If it is connected to a
manually inserted communication star, it does nothing. In this subsection,
we assume that it is not a dummy star.

In the setup stage, we perform the following tasks in sequence.

(1) Adjust the batch factor: @code{adjustBatchFactor}.

(2) Call @code{CGdsp3FwrDSP3Msg::setup} to set the input buffer offset.

(3) Set the sample rate of the input porthole to be @code{numTok}.

(4) Request the buffer size, @code{batchFactor}, of the input porthole.

In the @code{go} method, for each execution, it reads @code{numToken} samples.
We accumulate the samples until the number of samples reaches 
the @code{batchFactor}. If the number of samples accumulated is equal to the
@code{batchFactor}, we send a DSP3Message to the destination processor:
@code{CGdsp3FwrDSP3Msg::go}. If the remaining number of samples to be
transferred is smaller than the @code{batchFactor}, we send the DSP3Message
at each execution.

@node AutoReceive star, , AutoSend star, communication stars for DSP3
@subsection AutoReceive star

This star is derived from CGdsp3rdDSP3Msg star. In this section, we assume
that it is not a dummy star.

In the setup stage, we perform the following tasks in sequence.

(1) Adjust the batch factor: @code{adjustBatchFactor}.

(2) Set the sample rate to the @code{numTok} member.

(3) Request the buffer size, @code{batchFactor}, of the output porthole. 

In the @code{go} method, for each execution, it increases an internal
counter by @code{numToken}. If the counter value reaches
the @code{batchFactor}. we read a DSP3Message: @code{CGdsp3rdDSP3Msg::go}. 
If the remaining number of samples to be
read is smaller than the @code{batchFactor}, we read a DSP3Message at
each execution.

@node class CoopCode, chainScheduler, communication stars for DSP3, CGdsp3 Domain
@section Class CoopCode

Sometimes, we need to make a procedure that many stars cooperate to define.
Interrupt handler for I/O operation in DSP32C might be an example.
Class CoopCode, derived from CodeStream class, is a code stream designed for
that purpose. It consists of StringLists sorted in a PriorityQueue with IDs.

@example
PriorityQueue sections;
@end example

This is a protected data structure that StringLists with IDs are maintained.

A StringList with an even ID forms a unique part of the procedure, 
meaning that only one star can write the code for it. A StringList with an
odd ID forms a shared part of the procedure, meaning that multiple stars
write the code for it. The general code structure becomes:

@example
global_declaration @{
	common initializer;		--> ID = 0

	shared initializer;		--> ID = 1

	unique-body #1;			--> ID = 2

	shared-body #1;			--> ID = 3

  ... (unique and shared body alternate) --> ID = (even, odd)

end_declaration				--> ID = last even
@}
@end example

The StringLists of different IDs are merged into a single code by
the following public method.

@example
StringList wholeCode();
@end example

Since StringLists are sorted by IDs, the ID determines the positions
of the StringLists in the final code.

StringLists in the @code{sections} list are cleared in the following public
method.

@example
void initialize();
@end example

@example
int putCode(int @var{id}, const char* @var{code});
@end example

This method appends the @var{code} to the StringList of the given ID when
the @var{id} is odd. If the @var{id} is even, we do nothing if the StringList
of the given ID exists. If the StringList of the given ID does not exist,
we create a StringList with the given ID and insert the StringList into
the @code{sections} list. This method is called in the @code{addCoopSection}
method of DSP32CTarget class.

The star writer can add code segments into a CoopCode stream by the following
protected method of the CGdsp3Star class.

@example
int addCoopSect(const char* @var{code}, const char* @var{name}, int @var{sectId});
@end example

This method calls the @code{addCoopSection} method of DSP32CTarget class.
The arguments are the code to be inserted, the name of the CoopCode stream, and
the StringList ID.

@node chainScheduler, CGdsp3 status, class CoopCode, CGdsp3 Domain
@section ChainScheduler

The kernel code for the ChainScheduler can be found in $(PTOLEMY)/src/domains/
cgdsp3/chainScheduler. It is a simple parallel scheduler that schedule an
acyclic SDF graph to a linear array topology. It assigns all invocations
of a star into the same processor. The objective of the scheduling is to
pipeline the graph with minimum period
while minimizing the communication requirements.

ChainScheduler class is derived from ParScheduler class.
The ChainScheduler class has a protected member to
point to the ChainParProcs object.

@example
ChainParProcs* parSched;
@end example

ChainParProcs class is a minimal ParProcessors class that defines
UniProcessors.

Three public methods are defined for ChainScheduler class.

@example
void setUpProcs(int @var{numP});
@end example

This method creates a ChainParProcs object.

@example
StringList displaySchedule();
@end example

This method displays the scheduling results.

@example
int scheduleIt();
@end example

This is the main body of the schedule.
The following tasks are performed in sequence.

(1) Initialize the ChainParProcs object.

(2) We make a data structure to store some information for each star: incoming
number of samples per execution, the difference between the outgoing
number of samples and the incoming number of samples, and the shorted path
to the termination stars. The path length is the number of stars on the path.
We prepare a list of runnable stars.

(3) We topologically sort the stars. The priority of a star is an
approximation of the expected
amount of communication overhead reduction by scheduling the current star
ahead of the other star already in the list. In other words, the priority of
a star is the ratio of the incoming number of samples and the shorted path
to the termination stars determined in the setp (2).

(4) We use an algorithm developed by W. S. Wang et al (see reference [5]).
The algorithm is to assign a chain-structured tasks onto chain-structured
distributed systems. The network we have for the DSP3 is chain-structure.
We use the topological sorted list obtained in step (3) as the input
chain-structured graph.

(5) The step (4) determines the assignment. To generate code, we should
perform another list scheduling based on that assignment information.

@node CGdsp3 status, , chainScheduler, CGdsp3 Domain
@section CGdsp3 Domain status

We have installed a DSP3 machine in the lab. But, it is not fully working
at this moment. In the AT&T lab, we succeeded in running some demos of
wormholes: SDF universe has a wormhole of CGdsp3 domain inside.
We can have multiple input connections to the CGdsp3 domain, but only
one connection from the CGdsp3 domain since we do not implement
message disambiguation tools in the communication Send stars of CGdsp3 Domain.

The CoopCode stream enables us to make a general interrupt handler, which is
a task of AT&T. They haven't designed that routine yet.

We now support manually inserted communication stars and 
automatically inserted stars at a single mechanism: make AutoSend and 
AutoReceive stars dummy if there exist manually inserted communication stars.

Currently, we need to put some special stars in the SDF domain and in the
CGdsp3 domain to handle DSP3Messages at the wormhole interface. Later,
we will hide this message formation inside the EventHorizon class removing
the special type conversion stars.

Currently, we use manual scheduling only. However, we have designed
the chainScheduler to perform automatic scheduling.
 
@node Status, References, CGdsp3 Domain, Top
@chapter Status

Here are the random lists of the current status.

(1) Data Parallel star is not supported yet. We believe that it will be
much the same as the wormhole of CGDDF domain since it also requires more than
one processors for scheduling. The scheduling results should be stored in 
the Profile object. One difficulty will be how to code communication routines
inside the star.

(2) Execution times of CGC stars are not well defined. They will vary
processor to processor. We estimate them by looking at CG96 stars, or
by counting the number of elementary operations. For heterogeneous
multiprocessor case, we have to design a clean way of specifying these numbers.

(3) CGDDF domain is not supported in ASM domain. To support the CGDDF domain,
the ASM target should define @code{incrementalAdd} and @code{insertGalaxy}
methods appropriately. And it has to pay special attention to
@code{switched} portholes. CGDDF domain is only for homogeneous targets.

(4) There are restrictions for the galaxy topology of CGDDF domain. First of
all, we fix the topology of each dynamic construct. The star at the wormhole
boundary should be an atomic star. The star at the output wormhole boundary
can not be a Fork star. All upsample and downsample stars should have a
control input to indicate the number of iteration for a "for" construct
even though it is not necessary for functionality (e.g. DownSampler).

(5) Some restrictions in scheduling results exists for CGDDF domain.
Communication between the CGDDF galaxy and the outside galaxy is via
a synchronization processor that is the first processor of the inside
CGDDF schedule. All invocations of a dynamic construct are assigned to the
same set of processors.
 
(6) Spread/Collect stars and buffer embedding are not supported in ASM domain.
Since Spread/Collect stars are not supported, all ASM multiprocessor
targets should set the @code{oneStarOneProc} state TRUE.

(7) The scheduling option, @code{adjustSchedule} is not implemented yet since
the current graphical editor does not support "cont" function.

(8) Overlapped communication is not supported since we haven't had any
machine of that sort.

(9) CGWormholes are CGDDF domain. We have to change some methods of CGWormBase
if we want to put other domains inside a code generation wormhole. For example,
we may want to put a SDF domain inside a wormhole for interaction with
the host workstation. Currently, the SDF domain should be the outside domain.

@node References, , Status, Top
@chapter References

[1] G.C.Sih and E.A.Lee, "Dynamic-level scheduling for heterogeneous processor networks," Second IEEE Symposium on Parallel and Distributed Processing, pp. 42-49, 1990

[2] G.C.Sih and E.A.Lee, "Declustering: A New Multiprocessor Scheduling Technique," IEEE Transactions on Parallel and Distributed Systems, 1992.

[3] S. Ha, Compile-time Scheduling of Dataflow Program Graphs with Dynamic Constructs, Ph.D. dissertation, U.C.Berkeley, 1992.
 
[4] J.L.Pino, S.Ha, E.A.Lee, J.T.Buck, "Software Synthesis for DSP 
Using Ptolemy," invited paper, Journal of VLSI Signal Processing, 1993.

[5] W.S.Wang, et al, "Assignment of Chain-Structured Tasks onto
Chain-structured Distributed Systems," source unknown.

@contents
@bye
