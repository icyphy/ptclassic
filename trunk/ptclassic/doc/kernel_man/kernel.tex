\comment Version $Id$
\begin{iftex}
\date{$Date$}
\end{iftex}
\node Basic concepts
\chapter{Basic concepts, classes, and facilities}

This section describes some basic classes and low-level concepts that
are used throughout Ptolemy.  There are a number of iterator classes,
all with the same interface.  Several important non-class library
functions are provided.  A basic linked list class called
SequentialList is heavily used.  States (\pxref{class State})
and Portholes (\pxref{class PortHole}) can have
\emph{attributes}; these are particularly important in code generation.
Finally, many of the significant classes in Ptolemy -- functional
blocks, portholes to implement connections, parameters -- are derived
from NamedObj, the basic object for implementing a named object that
lives in a hierarchy.

\node Language subset
\section{The C++ Subset Used In Ptolemy}

The Ptolemy system has grown up with the C++ language, so it does not
use all the latest features in the newest compilers or every nook and
cranny of Ellis and Stroustrup's Annotated Reference Manual, because
of unimplemented features or lack of stability of implementation.
Instead, we focused on stability.  Accordingly, Ptolemy can be built with
a number of different C++ compilers.

This means, for one thing, that templates are not used (except in the
experimental IPUS domain).
In addition, some features that do not work that well yet under g++,
such as nested classes, are also avoided.
Nested enumerations, however, are used in several places.

\node Iterators
\section{Iterators}

Iterators are a very basic and widely used concept in Ptolemy, and are
used repeatedly in Ptolemy programming in almost any situation where a
composite object contains other objects.
We have chosen to use a consistent interface for all iterator objects.
The typical iterator class has the following basic interface
(some iterators provide additional functions as well):

\begin{example}
class MyIterator \{
public:
    // constructor: argument is associated outer object
    MyIterator(OuterObject&);
    // next: return a pointer to the next object,
    // or a null pointer if no more
    InnerObject* next();
    // operator form: a synonym for next
    InnerObject* operator++(POSTFIX_OP) \{ return next(); \}
    // reset the iterator to point to the first object
    void reset();
\}
\end{example}

\code{POSTFIX\_OP} is a macro that is defined to be an empty string on
older compilers (such as cfront 2.1 and versions of g++ before 2.4) and
to the string "int" with newer compilers.  This conditional behavior is
required because of the evolution of the C++ language; previously,
postfix and prefix forms of the operators ++ and -- were not
distinguished when overloaded; now, a dummy int argument indicates that
the postfix form is intended.

A typical programming application for iterators might be something like

\begin{example}
// print the names of all objects in the container
ListIter nextItem(myList);
Item *itemP;
while ((itemP = nextItem++) != 0)
    cout << itemP->name() << "\back n";
\end{example}

It is, as a rule, not safe to modify most container classes in parallel
with the use of an iterator, as the iterator may attempt to access an
object that does not exist any more.  However, the \code{reset} member
function will always make the iterator safe to use even if the list has
been modified (user-written iterators should preserve this property).

\node utility functions
\section{Non-class utility functions}

The kernel provides several useful ordinary (non-class) functions,
primarily for manipulating strings and path names.  Some are defined
in \file{miscFuncs.h}, others in \file{paths.h}.

\begin{example}
char* savestring(const char* \var{text});
\end{example}

The \code{savestring} function creates a copy of the \var{text} argument
with \code{new} and returns a pointer to it.
It is the caller's responsibility to assure that the string is eventually
deleted by using the \code{delete []} operator.
The argument \var{text} must not be a null pointer.

\begin{example}
const char* hashstring(const char* \var{text});
\end{example}

This function enters a copy of \var{text} into a hash table and returns
a pointer to the entry.  If two strings compare equal when passed to
\code{strcmp}, then if both are passed to \code{hashstring}, the return
values will be the same pointer.

\begin{example}
const char* expandPathName(const char* \var{fileName});
\end{example}

This function accepts a string and interprets it as a Unix path name.
If the string does not begin with a \code{~} or \code{\$} character,
the string itself is returned.  A leading ``\code{\~/}'' is replaced
by the user's home directory; a leading ``\code{\~\var{user}/}'' is
replaced by the home directory for \var{user}, unless there is no
such user, in which case the original string is returned.  Finally,
a leading ``\code{\$\var{env}}'' is replaced by the value of the
environment variable \var{env}; if there is no such environment
variable, the original string is returned.  Note that references
to environment variables other than at the beginning are \emph{not}
substituted.

If any substitutions are made, the return value is actually a pointer
into a static buffer.  This means that a second call to this function
may write on top of a value returned by a previous call.

\begin{example}
const char* pathSearch(const char* \var{file},const char* \var{path}=0);
\end{example}

For this function, \var{path} is a series of Unix-style directory names,
separated by colons.  If no second argument is supplied or if the value
is null, the value of the PATH environment variable is used instead.
For each of the colon-separated directory strings, the function checks
to see whether \var{dir}/\var{file} exists.  If it finds a match, it
returns a pointer to an internal buffer containing the full path of the
match.  If it does not find a match, it returns a null pointer.

\begin{example}
int progNotFound(const char* \var{program},const char* \var{extra}=0);
\end{example}

This function searches for \var{program} in the user's PATH using the
\code{pathSearch} function.  If a match is found, the function returns
false (0).  Otherwise it returns true (1) and also generates an error
message with the \code{Error::abortRun} function.  If the \var{extra}
argument is given, it forms the second line of the error message.

\node Generic Data Structures
\section{Generic Data Structures}

As Ptolemy does not use templates, our generic lists use the generic pointer
technique, with

\begin{example}
typedef void * Pointer;
\end{example}

The most commonly used generic data structure in Ptolemy is
\code{SequentialList}.  Other lists are, as a rule, privately inherited
from this class, so that type safety can be preserved.  It is possible
to insert and retrieve items at either the head or the tail of the list.

\node class SequentialList
\section{Class SequentialList}

This class implements a single linked list with a count of the number of
elements.  The constructor produces a properly initialized empty list,
and the destructor deletes the links.  However, the destructor does
not delete the items that have been added to the list; this is not
possible because it has only \code{void *} pointers and would not know
how to delete the items.

There is an associated iterator class for SequentialList called ListIter.

\node SequentialList information functions
\subsection{SequentialList information functions}

These functions return information about the SequentialList but do not
modify it.

\begin{example}
int size() const;
\end{example}

Return the size of the list.

\begin{example}
Pointer head() const;
\end{example}

Return the first item from the list (0 if the list is empty).  The
list is not changed.

\begin{example}
Pointer tail() const;
\end{example}

Return the last item from the list (0 if the list is empty).  The
list is not changed.

\begin{example}
Pointer elem(int \var{n}) const;
\end{example}

Return the \var{n}th item on the list (0 if there are fewer than \var{n} items).
Note that the time required is proportional to \var{n}.

\begin{example}
int empty() const;
\end{example}

Return 1 if the list is empty, 0 if it is not.

\begin{example}
int member(Pointer \var{arg}) const;
\end{example}

Return 1 if the list has a Pointer that is equal to \var{arg}, 0 if not.

\node other SequentialList functions
\subsection{other SequentialList functions}

These functions modify the list they are applied to.

\begin{example}
void prepend(Pointer \var{p});
\end{example}

Add an item at the beginning of the list.

\begin{example}
void append(Pointer \var{p});
\end{example}

Add an item at the end of the list.

\begin{example}
int remove(Pointer \var{p});
\end{example}

Remove the pointer \var{p} from the list if it is present (the test is pointer
equality).  Return 1 if present, 0 if not.

\begin{example}
Pointer getAndRemove();
\end{example}

Return and remove the head of the list.  If the list is empty, return
a null pointer (0).

\begin{example}
Pointer getTailAndRemove();
\end{example}

Return and remove the last item on the list.

\begin{example}
void initialize();
\end{example}

Remove all links from the list.  This does not delete the items pointed
to by the pointers that were on the list.

\node class ListIter
\subsection{Class ListIter}

ListIter is a standard iterator class for use with objects of class
SequentialList.  The constructor takes an argument of type

\begin{example}
const SequentialList
\end{example}

and the ++ operator (or \code{next} function) returns a \code{Pointer}.
Class ListIter is a friend of class SequentialList.
In addition to the standard iterator functions \code{next} and
\code{reset}, this class also provides a function

\begin{example}
void reconnect(const SequentialList& \var{newList});
\end{example}

that attaches the ListIter to a different SequentialList.

\node Doubly linked lists
\section{Doubly linked lists}

Support for doubly linked lists is found in \file{DoubleLink.h}.  The class
DoubleLink implements a base class for nodes in the list, class
DoubleLinkList implements the list itself, and class DoubleLinkIter forms an
iterator.

We consider this class to have serious design flaws, so it may be
reworked quite a bit in subsequent Ptolemy releases.

\node class DoubleLink
\subsection{Class DoubleLink}

Class DoubleLink is the base type for links in DoubleLinkList objects.
There are two constructors:

\begin{example}
DoubleLink(Pointer \var{p}, DoubleLink* \var{next}, DoubleLink* \var{prev}):
DoubleLink(Pointer \var{p});
\end{example}

The first form initializes the \var{next} and \var{prev} pointers of the
node as well as the contents.  The second form sets these pointers to null.

\begin{example}
Pointer content();
\end{example}

Returns the content pointer of the node.

\begin{example}
virtual ~DoubleLink();
\end{example}

This is a do-nothing destructor, but making it virtual makes the right
thing happen for derived classes.

\begin{example}
void unlinkMe();
\end{example}

This method deletes the node from the list it is contained in, by
connecting together the elements pointed to by the \var{prev} and
\var{next} pointers.

The following data members are protected:

\begin{example}
DoubleLink *next; // next node in the list
DoubleLink *prev; // previous node in the list
Pointer e;        // contents of this node
\end{example}

\node class DoubleLinkList
\subsection{Class DoubleLinkList}

\begin{example}
DoubleLinkList();
DoubleLinkList(Pointer* \var{e});
\end{example}

The first form creates an empty list.  The second creates a one
node list containing \var{e}; the node is on the heap.

\begin{example}
virtual ~DoubleLinkList();
\end{example}

The destructor.

\begin{example}
void insertLink(DoubleLink *x);
void insert(Pointer e);
\end{example}

These functions insert at the beginning of the list.  The first inserts
a DoubleLink; the second creates a DoubleLink with \code{createLink}
and inserts that.

\begin{example}
void appendLink(DoubleLink *x);
void append(Pointer e);
\end{example}

These functions append at the end of the list.  The first appends
a DoubleLink; the second creates a DoubleLink with \code{createLink}
and appends that.

\begin{example}
void insertAhead(DoubleLink *y, DoubleLink *x);
void insertBehind(DoubleLink *y, DoubleLink *x);
\end{example}

The first one inserts y immediately ahead of x; the second
inserts y immediately after x.  Both these functions assume
that x is in the list; disaster may result otherwise.

\begin{example}
DoubleLink* unlink(DoubleLink *x);
\end{example}

Unlink the link x from the list and return a pointer to it.
Make sure that x is in the list before calling this method,
or disaster may result.

\begin{example}
void removeLink(DoubleLink *x);
\end{example}

This is the same as \code{unlink}, except that x is deleted
as well.  The same cautions apply.

\begin{example}
void remove(Pointer e);
\end{example}

The list is searched for a DoubleLink whose contents match e.  If
a match is found, the node is deleted.  The search is made in the
``forward'' direction.

\begin{example}
int find(Pointer e);
\end{example}

The list is searched for a DoubleLink whose contents match e.  If
a match is found, 1 (true) is returned; otherwise 0 (false) is
returned.

\begin{example}
virtual void initialize();
\end{example}

This function deletes all links of the list and makes the list empty.

\begin{example}
void reset();
\end{example}

This function resets the fields of the DoubleLinkList object without
doing anything to the nodes.

\begin{example}
int size();
\end{example}

Return the number of elements in the list.  Should be const.

\begin{example}
DoubleLink *head();
DoubleLink *tail();
\end{example}

Return a pointer to the head, or to the tail, of the list.  If
the list is empty both will return a null pointer.

\begin{example}
DoubleLink *getHeadLink();
Pointer takeFromFront();
\end{example}

The former function gets and removes the head link from the list,
returning a pointer to it.  The second function calls the first
to obtain the head node; it gets the node, saves the contents,
deletes the node, and returns the contents.  If the list is empty,
both functions return a null pointer.

\begin{example}
DoubleLink *getTailLink();
Pointer takeFromBack();
\end{example}

These functions are identical to the previous pair except that
they remove the last node rather than the first.

The following two data members are protected:

\begin{example}
DoubleLink *myHead;
DoubleLink *myTail;
\end{example}

\node class DoubleLinkIter
\subsection{Class DoubleLinkIter}

DoubleLinkIter is an iterator for DoubleLinkList.  It is only capable
of moving ``forward'' through the list (following the ``next'' links,
not the ``prev'' links).

Its \code{next} operator returns the Pointer values contained within
the nodes; it is also possible to use the non-standard \code{nextLink}
function to return successive DoubleLink pointers.

\node Other containers
\section{Other generic container classes}

The file \code{DataStruct.h} defines two other generic container classes
that are privately derived from SequentialList: Queue and Stack.

Class Queue may be used to implement a FIFO or a LIFO queue, or a
mixture.

Class Stack implements a stack.

\node class Queue
\subsection{Class Queue}

The constructor for class Queue builds an empty queue.  The following
four functions move pointers into or out of the queue:

\begin{example}
void putTail(Pointer \var{p});
void putHead(Pointer \var{p});
Pointer getHead();
Pointer getTail();
\end{example}

\code{put} is a synonym for \code{putTail}, and \code{get} is a synonym
for \code{getHead}.  All these functions are implemented on top of the
(hidden) SequentialList functions.  The SequentialList functions
\code{size} and \code{initialize} are re-exported (that is, are
accessible as public member functions of class Stack).

\node class Stack
\subsection{Class Stack}

The constructor for class Stack builds an empty stack.  The following
functions move pointers onto or off of the stack:

\begin{example}
void pushTop(Pointer \var{p});
Pointer popTop();
pushBottom(Pointer \var{p});
\end{example}

\code{pushTop} and \code{popTop} are the functions traditionally
associated with a stack; \code{pushBottom} adds an item at the bottom,
which is non-traditional.  The following non-destructive function
also exists:

\begin{example}
Pointer accessTop() const;
\end{example}

It accesses but does not remove the element from the top of the stack.

All these functions are implemented on top of the (hidden)
SequentialList functions.  The SequentialList functions \code{size} and
\code{initialize} are re-exported.

\node class NamedObj
\section{Class NamedObj}

NamedObj is the base class for most of the common Ptolemy objects.  A
NamedObj is, simply put, a named object; in addition to a name, a
NamedObj has a pointer to a parent object, which is always a Block (a
type of NamedObj).  This pointer can be null.  A NamedObj also has a
descriptor.

Warning!  NamedObj assumes that the name and descriptor ``live'' as long
as the NamedObj does.  They are not deleted by the destructor, so
that they can be compile-time strings.

Important derived types of NamedObj include
Block (\pxref{class Block}),
GenericPort (\pxref{class GenericPort}),
State (\pxref{class State}), and
Geodesic (\pxref{class Geodesic}).

\node NamedObj constructors
\subsection{NamedObj constructors and destructors}

All constructors and destructors are public.

NamedObj has a default constructor, which sets the name and
descriptor to empty strings and the parent pointer to null, and a
three-argument constructor:

\begin{example}
NamedObj(const char* \var{name},Block* \var{parent},const char* \var{descriptor})
\end{example}

NamedObj's destructor is virtual and does nothing.

\node NamedObj public members
\subsection{NamedObj public members}

\begin{example}
virtual const char* className() const;
\end{example}

className returns the name of the class.  It should have a new
implementation supplied for every derived class (except for abstract
classes, where this is not necessary).

\begin{example}
const char* name() const;
\end{example}

name returns the local portion of the name of the class.

\begin{example}
const char* descriptor() const;
\end{example}

descriptor returns the descriptor.

\begin{example}
Block* parent() const;
\end{example}

parent returns a pointer to the parent block.

\begin{example}
virtual StringList fullName() const;
\end{example}

\code{fullName} returns the full name of the object.  This has no
relation to the class name; it specifies the specific instance's place
in the universe-galaxy-star hierarchy.  The default
implementation returns names that might look like

\begin{example}
universe.galaxy.star.port
\end{example}

for a porthole; the output is the fullName of the parent, plus a period,
plus the name of the NamedObj it is called on.

\begin{example}
void setNameParent (const char* \var{my_name},Block* \var{my_parent})
\end{example}

This method changes the name and parent pointer of the object.

\begin{example}
virtual void initialize() = 0;
\end{example}

initialize is a pure virtual method.  Its function is to initialize the
object to prepare for system execution.

\begin{example}
virtual StringList print (int \var{verbose}) const;
\end{example}

print returns a verbose description of the object.  If verbose is 0, a
somewhat more compact form is printed than if verbose is 1.

\begin{example}
virtual int isA(const char* \var{cname}) const;
\end{example}

The isA method should be redefined for all classed derived from
NamedObj.  Its function is to return TRUE if the argument is the name
either of the class or of one of the base classes.  To make this easy to
implement, a macro \code{ISA\_FUNC} is provided; for example, in the
file \code{Block.cc} we see the line

\begin{example}
ISA_FUNC(Block,NamedObj);
\end{example}

since NamedObj is the base class from which Block is derived.  This
macro creates the function definition

\begin{example}
int Block::isA(const char* cname) const \{
        if (strcmp(cname,"Block") == 0) return TRUE;
        else return NamedObj::isA(cname);
\}
\end{example}

Methods \code{isA} and \code{className} are overridden in derived
classes; the redefinitions will not be described for each individual
class.

\node NamedObj protected members
\subsection{NamedObj protected members}

\begin{example}
void setDescriptor(const char* \var{desc});
\end{example}

The descriptor is set to \var{desc}.  The string pointed to by
\var{desc} must live as long as the NamedObj does.

\node class NamedObjList
\section{Class NamedObjList}

Class NamedObjList is simply a list of objects of class NamedObj.
It is privately inherited from class SequentialList
(\pxref{class SequentialList}), and, as a rule,
other classes privately inherit from it.  It supports only a subset
of the operations provided by SequentialList; in particular, objects
are added only to the end of the list.  It provides extra operations,
like searching for an object by name and deleting objects.

This object enforces the rule that only const pointers to members can
be obtained if the list is itself const; hence, two versions of some
functions are provided.

\node NamedObjList information
\subsection{NamedObjList information functions}

The \code{size} and \code{initialize} functions of SequentialList
are re-exported.  Note that \code{initialize} removes only the links
to the objects and does not delete the objects.

Here's what's new:

\begin{example}
const NamedObj* objWithName(const char* \var{name}) const;
NamedObj* objWithName(const char* \var{name});
\end{example}

Find the first NamedObj on the list whose name is equal to \var{name},
and return a pointer to it.  Return 0 if it is not found.

\begin{example}
NamedObj* head();
const NamedObj* head() const;
\end{example}

Return a pointer to the first object on the list (0 if none).  There
are two forms, one of which can be applied to const NamedObjList objects.

\node other NamedObjList functions
\subsection{other NamedObjList functions}

\begin{example}
void put(NamedObj& \var{obj})
\end{example}

Add a pointer to \var{obj} to the list, at the end.

\begin{example}
void initElements();
\end{example}

Apply the \code{initialize} method to each NamedObj on the list.

\begin{example}
int remove(NamedObj* \var{obj});
\end{example}

Remove \var{obj} from the list, if present (this does not delete
\var{obj}).  Return 1 if it was present, 0 if not.

\begin{example}
void deleteAll();
\end{example}

Delete all elements from the list, and reset it to be an empty list.
WARNING: this assumes that the members of the list are on the heap
(allocated by \code{new}, so that deleting them is valid)!

\node NamedObjList iterators
\subsection{NamedObjList iterators}

There are two different iterators associated with NamedObjList;
class NamedObjListIter and class CNamedObjListIter.  The latter may
be applied to const NamedObjList objects and returns const NamedObj
pointers; the former requires non-const NamedObjList objects and
returns non-const NamedObj pointers.  They obey the standard iterator
interface and are privately derived from class ListIter.

\node Attributes
\section{Attributes}

Attributes represent logical properties that an object may or may
not have.  A parameter may or may not be settable by the user;
an assembly-language buffer may be allocated in ROM or RAM, fast
memory or slow memory, etc.

The set of attributes of an object is stored in an entity called
a bitWord.  At present, a bitWord is represented as an unsigned
long, which restricts the number of distinct attributes to 32;
this may be changed in future releases.

An Attribute object represents a request to turn certain attributes of
an object off, and to turn other attributes on.  As a rule, constants of
class Attribute are used to represent attributes, and users have no need
to know whether a given property is represented by a true or false
bit in the bitWord.

Although we would prefer to have a constructor for Attribute objects
of the form

\begin{example}
Attribute(bitWord \var{bitsOn}, bitWord \var{bitsOff});
\end{example}

it has turned out that doing so presents severe problems with order of
construction, since a number of global Attribute objects are used and
there is no simple, portable way of guaranteeing that these objects
are constructed before any use.  As a result, the \code{bitsOn} and
\code{bitsOff} members are public, but we forbid use of that fact
except in one place: constant Attribute objects can be initialized
by the C ``aggregate form'', as in the following example:

\begin{example}
extern const Attribute P_HIDDEN = \{PB_HIDDEN, 0\};
\end{example}

The first word specified is the \code{bitsOn} field, and the second
word specified is the \code{bitsOff} field.  Other than to initialize
objects, we pretend that these data members are private.

\node Attribute member functions
\subsection{Attribute member functions}

\begin{example}
Attribute& operator |= (const Attribute& \var{arg});
Attribute& operator &= (const Attribute& \var{arg});
\end{example}

These operations combine attributes, by applying the \code{|=} and
\code{\&=} operators to the bitsOn and bitsOff fields.  The first
operation, as attributes are commonly used, represents a requirement
that two sets of attributes be met, so it has been argued that it
really should be the ``and'' operation.   However, the current scheme
has the virtue of consistency.

\begin{example}
bitWord eval(bitWord \var{defaultVal}) const;
\end{example}

Evaluate an attribute given a default value.  Essentially, bits
corresponding to bitsOn are turned on, and then bits corresponding
to bitsOff are turned off.

\begin{example}
bitWord clearAttribs(bitWord \var{defaultVal}) const;
\end{example}

This method essentially applies the attribute backwards, reversing
the roles of bitsOn and bitsOff in \code{eval}.

\begin{example}
bitWord on() const;
bitWord off() const;
\end{example}

Retrieve the bitsOn and bitsOff values, respectively.

Inline definitions of operators \code{\&} and \code{|} are also defined
to implement nondestructive forms of the \code{\&=} and \code{|=}
operations.

\node FlagArray
\section{FlagArray}

\code{FlagArray} is a lightweight, self-expanding array of integers.
It is meant to store an array of flags or counters, and its main
appearance in Ptolemy is as a public member of class \code{Block}.
Targets and schedulers use this member to keep track of various kinds
of data. Many schedulers and targets need to be able to mark blocks
in various ways, for example to count invocations, or flag
that the block has been visited, or to classify it
as a particular type of block. This class provides a simple
mechanism for doing this.

A \code{FlagArray} object is indexed like an array, using
square brackets.  If \code{x} is a \code{FlagArray} and \code{i}
is a non-negative integer, then \code{x[i]} is a reference to
an integer element of the array. If \code{i} is out of bounds
(beyond the currently allocated limits of the array), then
the class automatically increases the size of the array.
New elements are filled with zeros.  Thus, a \code{FlagArray}
may be viewed as an infinite dimensional array of integers initialized
with zeros.
If \code{i} is a negative integer, then \code{x[i]} is an
error.  For efficiency, the class does not test for this error
at run time, so you could get a core dump if you make this error.
 
\node FlagArray constructors and destructor
\subsection{FlagArray constructors and destructor}

\begin{example}
FlagArray()
\end{example}

This constructor creates a zero-length flag array.

\begin{example}
FlagArray(int size)
\end{example}

This constructor creates a flag array with the specified
size already allocated and filled with zeros.

\begin{example}
FlagArray(int size, int fill_value)
\end{example}

This constructor creates a flag array with the specified
size filled with the specified integer value.

The destructor frees the memory allocated to store the array
of integers.

\node FlagArray public methods
\subsection{FlagArray public methods}

\begin{example}
FlagArray &	operator = (const FlagArray & v)
\end{example}

An assignment to one \code{FlagArray} from another simply copies
its size and data.

\begin{example}
int size() const
\end{example}

Return the current allocated size of the array.

\begin{example}
int & operator [] (int n)
\end{example}

If \code{n} is less than the currently allocated size
of the array, then this returns a reference to the n-th element
of the array. If \code{n} is greater than or equal to
the currently allocated size of the array, then the size
of the array is increased, the new elements are filled with zeros,
and a reference to the n-th element is returned.
Indexing of elements begins with zero.
The returned reference, of course,
can be used on the left-hand side of an assignment.
This is how values are written into an array.

\node Support for multithreading
\chapter{Support for multithreading}

Multithreading means that there are multiple \emph{threads of control},
or \emph{lightweight processes}, in the same Ptolemy process.  The
principal consequence of the existence of multithreading is that it is
necessary to provide mechanisms that guarantee exclusive access to
resources.

The Ptolemy kernel does not provide a multithreading library, as this
is currently a very OS and CPU-specific operation.  There are a variety
of such libraries that might be used; Sun's lightweight processes
library and the University of Colorado's Awesime package are two
examples.  What the kernel does provide is a locking mechanism for
implementing \emph{critical regions}, noninterruptable regions of code
in which only one thread can be active at a time.  This facility is used
to protect critical resources in the kernel that might be accessed by
multiple threads.

\node class PtGate
\section{Class PtGate}

Objects of classes derived from PtGate are used as semaphores to obtain
exclusive access to some resource.  PtGate is an abstract base class: it
specifies certain functionality but does not provide an implementation.
Derived classes typically provide the desired semantics for use with a
particular threading library.

PtGate has three virtual functions that must be implemented by each
derived class.  The first is a public method:

\begin{example}
virtual PtGate* makeNew() const = 0;
\end{example}

The \code{makeNew} method returns a new object of the same class as the
object it is called for, which is created on the heap.  For example, a
hypothetical SunLWPGate object would return a new SunLWPGate.

The other two methods are protected.  They are:

\begin{example}
virtual void lock() = 0;
virtual void unlock() = 0;
\end{example}

The first call requests access for a resource; the second call releases
access.  If code in another thread calls \code{lock()} on the same
PtGate after \code{lock()} has already been called on it, the second
call will block until the first thread does an \code{unlock()} call.
Note that two successive calls to \code{lock()} on the same PtGate from
the same thread will cause that thread to hang.  It is for this reason
that these calls are protected, not public.  Access to PtGates by user
code is accomplished by means of another class, CriticalSection.  The
CriticalSection class is a friend of class PtGate.

\node class CriticalSection
\section{Class CriticalSection}

CriticalSection objects exploit the properties of constructors and
destructors in C++ to provide a convenient way to implement
\emph{critical sections}: sections of code whose execution can be
guaranteed to be atomic.  Their use ensures that data structures can be
kept consistent even when accessed from multiple threads.  The
CriticalSection class implements no methods other than constructors and
a destructor.  There are three constructors:

\begin{example}
CriticalSection(PtGate *);
CriticalSection(PtGate &);
CriticalSection(GateKeeper &);
\end{example}

The function of all of these constructors is to optionally set a lock.
The first constructor will set the lock on the given PtGate unless it
gets a null pointer; the second form always sets the lock.  The third
form takes a reference to an object known as a GateKeeper (discussed in
the next section) that, in a sense, may "contain" a PtGate.  If it
contains a PtGate, a lock is set; otherwise no lock is set.  The lock
is set by calling \code{lock()} on the PtGate object.

The CriticalSection destructor frees the lock by calling \code{unlock()}
on the PtGate object, if a lock was set.

CriticalSection objects are used only for their side effects.  For
example:

\begin{example}
PtGate& MyClass::gate;
...
void MyClass::updateDataStructure() \{
        CriticalSection region(MyClass::gate);
        code;
        ...
\}
\end{example}

The code between the declaration of the CriticalSection and the end
of its scope will not be interrupted.

\node class GateKeeper
\section{class GateKeeper}

The GateKeeper class provides a means of registering a number of PtGate
pointers in a list, together with a way of creating or deleting a series
of PtGate objects all at once.  The motivation for this is that most
Ptolemy applications do not use multithreading, and we do not wish to
pay the overhead of locking and unlocking where it is not needed.  We
also want to have the ability to create a number of fine-grain locks
all at once.

GateKeeper objects should be declared only at file scope (never as
automatic variables or on the heap).

The constructor takes the form

\begin{example}
GateKeeper(PtGate *& gateToKeep);
\end{example}

The argument is a reference to a pointer to a GateKeeper, and the
function of the constructor is to add this reference to a master list.
It will later be possible to ``enable'' the pointer, by setting it to
point to a newly created PtGate of the appropriate type, or ``disable''
it, by deleting the PtGate object and setting the pointer to null.

The GateKeeper destructor deletes the reference from the master list and
also deletes any PtGate object that may be pointed to by the PtGate
pointer.

The public method

\begin{example}
int enabled() const;
\end{example}

returns 1 if the GateKeeper's PtGate pointer is enabled (points to a
PtGate) and 0 otherwise (the pointer is null).

There are two public static functions:

\begin{example}
static void enableAll(const PtGate& master);
\end{example}

This function creates a PtGate object for each GateKeeper on the list,
by calling \code{makeNew()} on the master object.

\begin{example}
static void disableAll();
\end{example}

This function destroys all the PtGate objects and sets the pointers to
be null.  This function must never be called from within a block
controlled by a CriticalSection, or while multithreading operation is
in progress.

A GateKeeper may be used as the argument to a CriticalSection
constructor call; the effect is the same as if the PtGate pointer were
passed to the constructor directly.

\node class KeptGate
\section{Class KeptGate}

A KeptGate object is simply a GateKeeper that contains its own PtGate
pointer.  It is derived from GateKeeper, has a private PtGate pointer
member, and a constructor with no arguments.  Like a GateKeeper, it
should be declared only at file scope and may be used as an argument
to a CriticalSection constructor call.

\node Block and related classes
\chapter{Block and related classes}

This section describes Block, the basic functional block class, and
those objects derived from it.  It is Blocks more than anything else
that a user of Ptolemy deals with.  Actors as well as collections of
actors are Blocks.

Although the Target class is derived from class Block, it is documented
elsewhere, as it falls under control of execution (\pxref{class Target}).

\node class Block
\section{Class Block}

Block is the basic object for representing an actor in Ptolemy.
It is derived from NamedObj (\pxref{class NamedObj}).

Important derived types of Block are Star (\pxref{class Star}),
representing an atomic actor;
Galaxy (\pxref{class Galaxy}),
representing a collection of actors that can be thought of as
one actor, and Universe (\pxref{class Universe}),
representing an entire runnable system.

A Block has portholes (connections to other blocks
--- \pxref{class PortHole}),
states (parameters and internal states --- \pxref{class State}),
and multiportholes (organized collections of portholes
--- \pxref{class MultiPortHole}).

While the exact data structure used to represent each is a secret of
class Block, it is visible that there is an order to each list, in that
iterators return the contained states, portholes, and multiportholes in
this order.  Iterators (\pxref{Iterators}) are a set of helper classes
that step through the states, portholes, or multiportholes that belong
to the Block, see the menu entry.

Furthermore, Blocks can be cloned, an operation that produces a
duplicate block.  There are two cloning functions: \code{makeNew},
which resembles making a new block of the same class, and \code{clone},
which makes a more exact duplicate (with the same values for states,
for example).  This feature is used by the KnownBlock class
(\pxref{class KnownBlock}) to create blocks on demand.

\node Block constructors and destructors
\subsection{Block constructors and destructors}

Block has a default constructor, which sets the name and
descriptor to empty strings and the parent pointer to null, and a
three-argument constructor:

\begin{example}
Block(const char* \var{name},Block* \var{parent},const char* \var{descriptor});
\end{example}

Block's destructor is virtual and does nothing, except for the standard
action of destroying the Block's data members.

In addition, Block possesses two types of ``virtual constructors'', the
public member functions \code{makeNew} and \code{clone}.

\node Block public "information" members
\subsection{Block public ``information'' members}

\begin{example}
int numberPorts() const;
int numberMPHs() const;
int numberStates() const;
\end{example}

The above functions return the number of ports, the number of
multiports, or the number of states in the Block.

\begin{example}
virtual int isItAtomic() const;
virtual int isItWormhole() const;
\end{example}

These functions return TRUE or FALSE, based on whether the Block is
atomic or not, or a wormhole or not.  The base implementations return
TRUE for isItAtomic, FALSE for isItWormhole.

\begin{example}
virtual StringList print(int \var{verbose}) const;
\end{example}

Overrides \code{NamedObj::print}.  This function gives a basic printout of
the information in the block.

\begin{example}
GenericPort* genPortWithName(const char* \var{name});
PortHole* portWithName(const char* \var{name});
MultiPortHole* multiPortWithName(const char* \var{name});
virtual State *stateWithName(const char* \var{name});
\end{example}

These functions search the appropriate list and return a pointer
to the contained object with the matching name.  \code{genPortWithName}
searches both the multiport and the regular port lists (multiports
first).  If a match is found, it returns a pointer to the matching
object as a \code{GenericPort} pointer.

\begin{example}
int multiPortNames (const char** \var{names}, const char** \var{types},
                    int* \var{io}, int \var{nMax}) const;
\end{example}

Get a list of multiport names.

\begin{example}
StringList printPorts(const char* \var{type}, int \var{verbose}) const;
\end{example}

Print portholes as part of the info-printing method.

\begin{example}
virtual Scheduler* scheduler() const;
\end{example}

Return the controlling scheduler (\pxref{class Scheduler})
for this block.  The default
implementation simply recursively calls the \code{scheduler()} function on the parent, or returns 0
if there is no parent.  The intent is that eventually a block with
a scheduler will be reached (the top-level universe has a scheduler,
and so do wormholes).

\begin{example}
virtual Star& asStar();
virtual const Star& asStar() const;
\end{example}

Return reference to me as a Star, if I am one.  Warning: it is a
fatal error (the entire program will halt with an error message)
if this method is invoked on a Galaxy!  Check with \code{isItAtomic}
before calling it.

\begin{example}
virtual Galaxy& asGalaxy();
virtual const Galaxy& asGalaxy() const;
\end{example}

Return reference to me as a Galaxy, if I am one.  Warning: it is a
fatal error (the entire program will halt) if this method is invoked
on a Star!  Check with \code{isItAtomic} before calling it.

\begin{example}
virtual const char* domain() const;
\end{example}

Return my domain (e.g. SDF, DE, etc.)

\node other Block public members
\subsection{other Block public members}

\begin{example}
virtual void initialize();
\end{example}

overrides NamedObj::initialize.  Block::initialize initializes the
portholes and states belonging to the block, and calls \code{setup()}, which
is intended to be the ``user-supplied'' initialization function.

\begin{example}
virtual void preinitialize();
\end{example}

Perform a "pre-initialization" step.  The default implementation does nothing.
This method is redefined by HOF stars and other stars that need to rewire a
galaxy before the main initialization phase starts.  Blocks must act safely
if preinitialized multiple times (unless they remove themselves from the
galaxy when preinitialized, as the HOF stars do).  Preinitialize is invoked
by Galaxy::preinitialize, which see.

\begin{example}
virtual int run();
\end{example}

This function is intended to ``run'' the block.  The default
implementation does nothing.

\begin{example}
virtual void wrapup();
\end{example}

This function is intended to be run after the completion of execution
of a universe, and provides a place for wrapup code.  The default does
nothing.

\begin{example}
virtual Block& setBlock(const char* \var{name},Block* \var{parent}=0);
\end{example}

Set the name and parent of a block.

\begin{example}
virtual Block* makeNew() const
\end{example}

This is a very important function.  It is intended to be overloaded in
such a way that calling it produces a newly constructed object of the
same type.  The default implementation causes an error.  Every derived
type should redefine this function.  Here is an example implementation
of an override for this function:

\begin{example}
Block* MyClass::makeNew() const \{ return new MyClass;\}
\end{example}

\begin{example}
virtual Block* clone() const
\end{example}

The distinction between \code{clone} and \code{makeNew} is that the
former does some extra copying.  The default implementation calls
\code{makeNew} and then \code{copyStates},
and also copies additional members like \code{flags};
it may be overridden in derived classes to
copy more information.  The intent is that \code{clone} should produce
an identical object.

\begin{example}
void addPort(PortHole& \var{port})
void addPort(MultiPortHole& \var{port})
\end{example}

Add a porthole, or a multiporthole, to the block's list of known ports
or multiports.

\begin{example}
int removePort(PortHole& \var{port})
\end{example}

Remove \var{port} from the Block's port list, if it is present.
1 is returned if \var{port} was present and 0 is returned if it
was not.  Note that \var{port} is not deleted.  The destructor
for class PortHole calls this function on its parent block.

\begin{example}
void addState(State& \var{s});
\end{example}

Add the state \var{s} to the Block's state list.

\begin{example}
virtual void initState();
\end{example}

Initialize the States contained in the Block's state list.

\begin{example}
StringList printStates(const char* \var{type},int \var{verbose}) const;
\end{example}

Return a printed representation of the states in the Block.  This
function is used as part of the Block's \code{print} method.

\begin{example}
int setState(const char* \var{stateName}, const char* \var{expression});
\end{example}

Search for a state in the block named \var{stateName}.  If not found,
return 0.  If found, set its initial value to \var{expression} and
return 1.

\begin{example}
FlagArray flags
\end{example}

Many schedulers and targets need to be able to mark blocks
in various ways, to count invocations, or flag
that the block has been visited, or to classify it
as a particular type of block.  To support this,
we provide an array of flags that are not used
by class Block, and may be used in any way by a Target.
The target may defer their use to its schedulers.
The array can be of any size, and the size
will be increased automatically as elements are referenced.
For readability and consistency, the user should define an enum
in the target or scheduler class to give the indices,
so that mnemonic names
can be associated with flags, and so that multiple schedulers
for the same target are consistent.
For instance, if \code{b} is a pointer to a \code{Block},
a target might contain the following:
\begin{example}
private:
   enum {
      visited = 0,
      fired = 1
   }
\end{example}
which can then be used in code to set and read flags in a
readable way,
\begin{example}
   b->flags[visited] = TRUE;
   ...
   if (b->flags[visited]) { ... }
\end{example}

\emph{WARNING:} For efficiency, there is no checking to prevent
two different pieces of code (say a target and scheduler) from
using the same flags (which are indexed only by non-negative
integers) for different purposes.  The policy, therefore, is
that \emph{the target is in charge}.  It is incumbent upon
the writer of the target to know what flags are used by schedulers
invoked by that target, and to avoid corrupting those flags
if the scheduler needs them preserved.
We weighed a more modular, more robust solution, but ruled
in out in favor of something very lightweight and fast.

\node Block protected members
\subsection{Block protected members}

\begin{example}
virtual void setup();
\end{example}

User-specified additional initialization.  By default, it does nothing.
It is called by Block::initialize (and should also be called if
initialize is redefined).

\begin{example}
Block* copyStates(const Block& \var{src});
\end{example}

method for copying states during cloning.  It is designed for use
by clone methods, and it assumes that the src argument has the same
state list as the \code{this} object.

\node Block iterator classes
\subsection{Block iterator classes}

There are three types of iterators that may be used on Blocks:
BlockPortIter, BlockStateIter, and BlockMPHIter.
Each takes one argument for its constructor, a reference to Block.
They step through the portholes, states, or multiportholes, of the
Block, respectively, using the standard iterator interface.

There are also variant versions with a ``C'' prefix (CBlockPortIter, etc)
defined in the file \file{ConstIters.h} that take a reference to a const Block
and return a const pointer.

\node class Star
\section{Class Star}

Class Star represents the basic executable atomic version of Block.
It is derived from Block (\pxref{class Block}).

Stars have an associated Target (\pxref{class Target}), an index value,
and an indication of whether or not there is internal state.

The default constructor sets the target pointer to null, sets the internal
state flag to TRUE, and sets the index value to -1.

\node Star public members
\subsection{Star public members}

\begin{example}
int run();
\end{example}

Execute the Star.  This method also interfaces to the SimControl
class to provide for control over simulations.  All derived classes
that override this method must invoke \code{Star::run}.

\begin{example}
StringList print (int \var{verbose} = 0) const;
\end{example}

Print out info on the star.

\begin{example}
Star& asStar();
const Star& asStar() const;
\end{example}

These simply return a reference to \code{this}, overriding \code{Block::asStar}.

\begin{example}
int index() const;
\end{example}

Return the index value for this star.  Index values are a feature
that assists with certain schedulers; the idea is to assign a numeric
index to each star at any level of a particular Universe or Galaxy.

\begin{example}
virtual void setTarget(Target* \var{t});
\end{example}

Set the target associated with this star.

\begin{example}
void noInternalState();
\end{example}

Declare that this star has no internal state (This function may
change to protected in future Ptolemy releases).

\begin{example}
int hasInternalState();
\end{example}

Return TRUE if this star has internal state, false if it doesn't.
Useful in parallel scheduling.

\node Star protected members
\subsection{Star protected members}

\begin{example}
virtual void go();
\end{example}

This is a method that is intended to be overridden to provide the
principal action of executing this block.  It is protected and is
intended to be called from the \code{run()} member function.  The
separation is so that actions common to a domain can be provided
in the run function, leaving the writer of a functional block to
only implement \code{go()}.

\begin{example}
Target* targetPtr;
\end{example}

This is a protected data member, set by the setTarget public member
function.

\node class Galaxy
\section{Class Galaxy}

A Galaxy is a type of Block (\pxref{class Block})
that has an internal hierarchical structure.
In particular, it contains other Blocks (some of which may also be
galaxies).  It is possible to access only the top-level blocks or to
flatten the hierarchy and step through all the blocks, by means
of the various iterator classes associated with Galaxy.

While we generally define a different derived type of Star for each
domain, the same kinds of Galaxy (and derived classes such as
InterpGalaxy --- \pxref{class InterpGalaxy})
are used in each domain.  Accordingly,
a Galaxy has a data member containing its associated domain (which
is set to null by the constructor).

PortHoles belonging to a Galaxy are, as a rule, aliased so that they
refer to PortHoles of an interior Block, although this is not a
requirement.

\node Galaxy public members
\subsection{Galaxy public members}

\begin{example}
void initialize();
\end{example}

System initialize method.  Derived Galaxies should not redefine
initialize; they should write a \code{setup()} method to do any
class-specific startup.

\begin{example}
virtual void preinitialize();
\end{example}

Preinitialization of a Galaxy invokes preinitialization of all its member
blocks.  Preinitialization of the member blocks is done in two passes: the
first pass preinits atomic blocks only, the second all blocks.  This allows
clean support of graphical recursion; for example, a HOFIfElseGr star can
control a recursive reference to the current galaxy.  The IfElse star is
guaranteed to get control before the subgalaxy does, so it can delete the
subgalaxy to stop the recursion.  The second pass must preinit all blocks in
case a non-atomic block adds a block to the current galaxy.
Galaxy::preinitialize is called from Galaxy::initialize.  (It would be
somewhat cleaner to have the various schedulers invoke preinitialize()
separately from initialize(), but that would require many more pieces of the
system to know about preinitialization.)  Because of this decision, blocks in
subgalaxies will see a preinitialize call during the outer galaxy's
preinitialize pass and then another one when the subgalaxy is itself
initialized.  Thus, blocks must act safely if preinitialized multiple times.
(HOF stars generally destroy themselves when preinitialized, so they can't
see extra calls.)

\begin{example}
void wrapup();
\end{example}

System wrapup method.  Recursively calls wrapup in subsystems

\begin{example}
void addBlock(Block& \var{b},const char* \var{bname});
\end{example}

Add block to the galaxy and set its name.

\begin{example}
int removeBlock(Block& \var{b});
\end{example}

Remove the block \var{b} from the galaxy's list of blocks, if it is in
the list.  The block is not deleted.  If the block was present, 1 is
returned; otherwise 0 is returned.

\begin{example}
virtual void initState();
\end{example}

Initialize states.

\begin{example}
int numberBlocks() const;
\end{example}

Return the number of blocks in the galaxy.

\begin{example}
StringList print(int \var{verbose}) const;
\end{example}

Print a description of the galaxy.

\begin{example}
int isItAtomic () const;
\end{example}

Returns FALSE (galaxies are not atomic blocks).

\begin{example}
Galaxy& asGalaxy();
const Galaxy& asGalaxy() const;
\end{example}

These return myself as a Galaxy, overriding \code{Block::asGalaxy}.

\begin{example}
const char* domain () const;
\end{example}

Return my domain.

\begin{example}
void setDomain(const char* \var{dom});
\end{example}

Set the domain of the galaxy (this may become a protected member
in the future).

\begin{example}
Block* blockWithName (const char* \var{name});
\end{example}

Support blockWithName message to access internal block list.

\node Galaxy protected members
\subsection{Galaxy protected members}

\begin{example}
void addBlock(Block& \var{b})
\end{example}

Add \var{b} to my list of blocks.

\begin{example}
void connect(GenericPort& \var{source}, GenericPort& \var{destination},
             int \var{numberDelays} = 0)
\end{example}

Connect sub-blocks with a delay (default to zero delay).


\begin{example}
void alias(PortHole& \var{galPort}, PortHole& \var{blockPort});
void alias(MultiPortHole& \var{galPort}, MultiPortHole& \var{blockPort});
\end{example}

Connect a Galaxy PortHole to a PortHole of a sub-block, or same for
a MultiPortHole.


\begin{example}
void initSubblocks();
void initStateSubblocks();
\end{example}

Former: Initialize subblocks only.  Latter: initialize states in
subblocks only.

\node Galaxy iterators
\subsection{Galaxy iterators}

There are three types of iterators associated with a Galaxy:
GalTopBlockIter, GalAllBlockIter, and GalStarIter.  The first
two iterators return pointers to Block; the final one returns
a pointer to Star.

As its name suggests, GalTopBlockIter returns only the Blocks
on the top level of the galaxy.  GalAllBlockIter returns
Blocks at all levels of the hierarchy, in depth-first order;
if there is a galaxy inside the galaxy, first it is returned,
then its contents are returned.  Finally, GalStarIter returns
only the atomic blocks in the Galaxy, in depth-first order.

There is also a const form of GalTopBlockIter, called CGalTopBlockIter.

Here is a function that prints out the names of all stars at any
level of the given galaxy onto a given stream.

\begin{example}
void printNames(Galaxy& g,ostream& stream) \{
    GalStarIter nextStar(g);
    Star* s;
    while ((s = nextStar++) != 0)
        stream << s->fullName() << "\back n";
\}
\end{example}

\node class DynamicGalaxy
\section{Class DynamicGalaxy}

A DynamicGalaxy is a type of Galaxy for which all blocks, ports, and
states are allocated on the heap.  When destroyed, it destroys all of
its blocks, ports, and states in a clean manner.  There's not much
more to it than that: it provides a destructor, class identification
functions \code{isA} and \code{className}, and little else.

\node class InterpGalaxy
\section{Class InterpGalaxy}

InterpGalaxy is derived from DynamicGalaxy.  It is the key workhorse
for interfacing between user interfaces, such as ptcl or pigi, and
the Ptolemy kernel, because it has commands for building structures
given commands specified in the form of text strings.  These commands
add stars and galaxies of given types and build connections between
them.  InterpGalaxy interacts with the KnownBlock class
(\pxref{class KnownBlock}) to create stars and galaxies,
and the Domain class (\pxref{class Domain}) to create wormholes.

InterpGalaxy differs from other classes derived from Block in that
the ``class name'' (the value returned by \code{className()}) is a
variable; the class is used to create many different ``derived classes''
corresponding to different topologies.

In order to use InterpGalaxy to make a user-defined galaxy type,
a series of commands are executed that add stars, connections, and
other features to the galaxy.  When a complete galaxy has been
designed, the \code{addToKnownList} member function adds the complete
object to the known list, an action that has the effect of adding a
new ``class'' to the system.

InterpGalaxy methods that return an int return 1 for success and 0
for failure.  On failure, an appropriate error message is generated
by means of the Error class.


\node building structures
\subsection{building structures with InterpGalaxy}

The no-argument constructor creates an empty galaxy.  There is a
constructor that takes a single \code{const char *} argument
specifying the class name (the value to be returned by \code{className()}.
The copy constructor creates another InterpGalaxy with the identical
internal structure.  There is also an assignment operator that does
much the same.

\begin{example}
void setDescriptor(const char* \var{dtext})
\end{example}

Set the descriptor.  Note that this is public, though the NamedObj
function is protected. \var{dtext} must live as long as the InterpGalaxy
does.

\begin{example}
int addStar(const char* \var{starname}, const char* \var{starclass});
\end{example}

Add a new star or galaxy with class name \var{starclass} to this
InterpGalaxy, naming the new instance \var{starname}.  The known block
list for the current domain is searched to find \var{starclass}.
Returns 1 on success, 0 on failure.  On failures, an error message
of the form

\begin{example}
No star/galaxy named '\var{starclass}' in domain '\var{current-domain}'
\end{example}

will be produced.  The name is a misnomer since \var{starclass} may
name a galaxy or a wormhole.

\begin{example}
int connect(const char* \var{srcblock}, const char* \var{srcport},
            const char* \var{dstblock}, const char* \var{dstport},
            const char* \var{delay} = 0);
\end{example}

This method creates a point-to-point connection between the port
\var{srcport} in the subblock \var{srcblock} and the port \var{dstport}
in the subblock \var{dstblock}, with a delay value represented by
the expression \var{delay}.
If the delay parameter is omitted there is no delay.

The delay expression has the same form as an initial value for an
integer state (class IntState), and is parsed in the same way as
an IntState belonging to a subblock of the galaxy would be.

1 is returned for success, 0 for failure.
A variety of error messages relating to nonexistent blocks or ports
may be produced.

\begin{example}
int busConnect(const char* \var{srcblock}, const char* \var{srcport},
               const char* \var{dstblock}, const char* \var{dstport},
               const char* \var{width}, const char* \var{delay} = 0);
\end{example}

This method creates a point-to-point bus connection between the multiport
\var{srcport} in the subblock \var{srcblock} and the multiport \var{dstport}
in the subblock \var{dstblock}, with a width value represented by the
expression \var{width} and delay value represented by
the expression \var{delay}.  If the delay parameter is omitted there is
no delay.

A bus connection is a series of parallel connections: each multiport
contains \var{width} portholes and all are connected in parallel.

The delay and width expressions have the same form as an initial value for an
integer state (class IntState), and are parsed in the same way as
an IntState belonging to a subblock of the galaxy would be.

1 is returned for success, 0 for failure.
A variety of error messages relating to nonexistent blocks or multiports
may be produced.

\begin{example}
int alias(const char* \var{galport}, const char* \var{block}, const char *\var{blockport});
\end{example}

Create a new port for the galaxy and make it an alias for the porthole
\var{blockport} contained in the subblock \var{block}.  Note that this
is unlike the Galaxy \code{alias} method in that this method creates
the galaxy port.

\begin{example}
int addNode(const char* \var{nodename});
\end{example}

Create a node for use in netlist-style connections and name it
\var{nodename}.

\begin{example}
int nodeConnect(const char* \var{blockname}, const char* \var{portname},
                const char* \var{node}, const char* \var{delay} = 0);
\end{example}

Connect the porthole named \var{portname} in the subblock named
\var{blockname} to the node named \var{node}.  Return 1 for success,
0 and an error message for failure.

\begin{example}
int addState(const char* \var{statename}, const char* \var{stateclass},
             const char* \var{statevalue});
\end{example}

Add a new state named \var{statename}, of type \var{stateclass},
to the galaxy.  Its default initial value is given by \var{statevalue}.

\begin{example}
int setState(const char* \var{blockname}, const char* \var{statename},
             const char* \var{statevalue});
\end{example}

Change the initial value of the state named \var{statename} that belongs
to the subblock \var{blockname} to the string given by \var{statevalue}.
As a special case, if \var{blockname} is the string \code{this}, the
state belonging to the galaxy, rather than one belonging to a subblock,
is changed.

\begin{example}
int setDomain(const char* \var{newDomain});
\end{example}

Change the inner domain of the galaxy to \var{newDomain}.  This is the
technique used to create wormholes (that are one domain on the outside
and a different domain on the inside).  It is not legal to call this
function if the galaxy already contains stars.

\begin{example}
int numPorts(const char* \var{blockname}, const char* \var{portname}, int \var{numP});
\end{example}

Here \var{portname} names a multiporthole and \var{blockname} names the
block containing it.  \var{numP} portholes are created within the
multiporthole; these become ports of the block as a whole.  The names of
the portholes are formed by appending \code{#1}, \code{#2}, etc. to the
name of the multiporthole.

\node deleting InterpGalaxy structures
\subsection{deleting InterpGalaxy structures}

\begin{example}
int delStar(const char* \var{starname});
\end{example}

Delete the instance named \var{starname} from the current galaxy.
Ports of other stars that were connected to ports of \var{starname}
will become disconnected.  Returns 1 on success, 0 on failure.  On
failure an error message of the form

\begin{example}
No instance of ``\var{starname}'' in ``\var{galaxyname}''
\end{example}

will be produced.  The name is a misnomer since \var{starclass} may
name a galaxy or a wormhole.

\begin{example}
int disconnect(const char* \var{block}, const char* \var{port});
\end{example}

Disconnect the porthole \var{port}, in subblock \var{block}, from
whatever it is connected to.  This works for point-to-point or netlist
connections.

\begin{example}
int delNode(const char* \var{nodename});
\end{example}

Delete the node \var{nodename}.

\node InterpGalaxy and cloning
\subsection{InterpGalaxy and cloning}

\begin{example}
Block *makeNew() const;
Block *clone() const;
\end{example}

For InterpGalaxy the above two functions have the same implementation.
An identical copy of the current object is created on the heap.

\begin{example}
void addToKnownList(const char* \var{outerDomain},Target* \var{innerTarget} = 0);
\end{example}

This function adds the galaxy to the known list, completing the
definition of a galaxy class.  The ``class name'' is determined by
the name of the InterpGalaxy (as set by \code{Block::setBlock} or
in some other way).  This class name will be returned by the
\code{className} function, both for this InterpGalaxy and for any
others produced from it by cloning.

If \var{outerDomain} is different from the system's current domain (read
from class KnownBlock), a wormhole will be created.  A wormhole will
also be created if \var{innerTarget} is specified, or if galaxies for
the domain \var{outerDomain} are always wormholes (this is determined by
asking the Domain class).

Once \code{addToKnownList} is called on an InterpGalaxy object,
that object should not be modified further or deleted.  The KnownBlock
class (\pxref{class KnownBlock})
will manage it from this point on.  It will be deleted if a second
definition with the same name is added to the known list, or when the
program exits.


\node other InterpGalaxy functions
\subsection{other InterpGalaxy functions}

\begin{example}
const char* className() const
\end{example}

Return the current class name (which can be changed).  Unlike most
other classes, where this function returns the C++ class name, we
consider the class name of galaxies built by InterpGalaxy to be
variable; it is set by \code{addToKnownList} and copied from one
galaxy to another by the copy constructor or by cloning.

\begin{example}
void preinitialize();
\end{example}

Overrides `Galaxy::preinitialize()'.  This re-executes initialization
steps that depend on variable parameters, such as delays and bus connections
for which the delay value or bus width is an expression with variables.
Galaxy::preinitialize is then invoked to preinitialize the member blocks.

\begin{example}
Block* blockWithDottedName(const char* \var{name});
\end{example}

Returns a pointer to an inner block, at any depth, whose name matches
the specification \var{name}.  For example, \code{blockWithDottedName("a.b.c")}
would look first for a subgalaxy named \code{"a"}, then within that
for a subgalaxy named \code{"b"}, and finally with that for a subgalaxy
named \code{"c"}, returning either a pointer to the final Block or a
null pointer if a match is not found.

\node class Runnable
\section{Class Runnable}

The Runnable class is a sort of ``mixin class'' intended to be used with
multiple inheritance to create runnable universes and wormholes.  It
is defined in the file \code{Universe.h}.

Constructors:
\begin{example}
Runnable(Target* \var{tar}, const char* \var{ty}, Galaxy* \var{g});
Runnable(const char* \var{targetname}, const char* \var{dom}, Galaxy* \var{g});
\end{example}

\begin{example}
void initTarget();
\end{example}

This function initializes target and/or generates the schedule.

\begin{example}
int run();
\end{example}

This function causes the object to run, until the stopping condition is reached.

\begin{example}
virtual void setStopTime(double \var{stamp});
\end{example}

This function sets stop time.  The default implementation just
calls the identical function in the target.

\begin{example}
StringList displaySchedule();
\end{example}

Display schedule, if appropriate (some types of schedulers will return a
string saying that compile-time scheduling is not performed, e.g. DE
and DDF schedulers).

\begin{example}
virtual ~Runnable();
\end{example}

The destructor deletes the Target.

A Runnable object has the following protected data members:

\begin{example}
const char* type;
Target* target;
Galaxy* galP;
\end{example}

As a rule, when used as one of the base classes for multiple inheritance,
the \code{galP} pointer will point to the galaxy provided by the other
half of the object.

\node class Universe
\section{Class Universe}

Class Universe is inherited from both Galaxy and Runnable.  It is
intended for use in standalone Ptolemy applications.  For applications
that use a user interface to dynamically build universes, class
InterpUniverse is used instead.

In addition to the Runnable and Galaxy functions, it has:

\begin{example}
Universe(Target* \var{s},const char* \var{typeDesc});
\end{example}

The constructor specifies the target and the universe type.

\begin{example}
Scheduler* scheduler() const;
\end{example}

Returns the scheduler belonging to the universe's target.

\begin{example}
int run();
\end{example}

Return Runnable::Run.

\node class InterpUniverse
\section{Class InterpUniverse}

Class InterpUniverse is inherited from both InterpGalaxy and Runnable.
Ptolemy user interfaces build and execute InterpUniverses.

In addition to the standard InterpGalaxy functions, it provides:

\begin{example}
InterpUniverse (const char* \var{name} = "mainGalaxy");
\end{example}

This creates an empty universe with no target and the given name.
If no name is specified, \code{mainGalaxy} is the default.

\begin{example}
int newTarget(const char* \var{newTargName} = 0);
\end{example}

This creates a target of the given name (from the KnownTarget list),
deleting any existing target.

\begin{example}
const char* targetName() const;
\end{example}

Return the name of the current target.

\begin{example}
Scheduler* scheduler() const;
\end{example}

Return the scheduler belonging to the current target (0 if none).

\begin{example}
Target* myTarget() const;
\end{example}

Return a pointer to the current target.

\begin{example}
int run();
\end{example}

Invokes Runnable::run.

\begin{example}
void wrapup();
\end{example}

Invokes wrapup on the target.

\node Control of execution
\chapter{Control of Execution and Error Reporting}

The principal classes responsible for control of the execution of the
universe are the Target and the Scheduler.  The Target has high-level
control over what happens when a user types ``run'' from the interface;
Targets take on particular importance in code generation domains where
they describe all the features of the target of execution, but they
are used to control execution in simulation domains as well.

Targets use Schedulers to control the order of execution of Blocks under
their control.  In some domains, the Scheduler does almost everything;
the Target simply starts it up.  In others, the Scheduler determines
an execution order and the Target takes care of a many other
details, such as generating code in accordance with the schedule,
downloading the code to an embedded processor, and executing it.

The Error class provides a means to format error messages and optionally
to halt execution.  The interface is always the same, but different
user interfaces typically provide different implementations of the
methods of this class.

The SimControl class provides a means to register actions for execution
during a simulation, as well as facilities to cleanly halt execution
on an error.

\node class Target
\section{Class Target}

Class Target is derived from class Block (\pxref{class Block});
as such, it can have states
and a parent (the fact that it can also have portholes is not currently
used).  A Target is capable of supervising the execution of only certain
types of Stars; the \var{starClass} argument in its constructor
specifies what type.  A Universe or InterpUniverse is run by executing
its Target.  Targets have Schedulers, which as a rule control order of
execution, but it is the Target that is ``in control''.

A Target can have children that are other Targets; this is used, for
example, to represent multi-processor systems for which code is being
generated (the parent target represents the system as a whole, and
child targets represent each processor).

\node Target public members
\subsection{Target public members}

\begin{example}
Target(const char* \var{name}, const char* \var{starClass},const char* \var{desc} = "");
\end{example}

This is the signature of the Target constructor. \var{name} specifies
the name of the Target and \var{desc} specifies its descriptor (these
fields end up filling in the corresponding NamedObj fields).

The \var{starClass} argument specifies the class of stars that can be
executed by the Target.  For example, specifying \code{DataFlowStar}
for this argument means that the Target can run any type of star of
this class or a class derived from it.  The \code{isA} function is
used to perform the check.

See the description of \code{auxStarClass} below.

\begin{example}
const char* starType() const;
\end{example}

Return the supported star class (the \var{starClass} argument from
the constructor).

\begin{example}
Scheduler* scheduler() const;
\end{example}

Return a pointer to my scheduler.

\begin{example}
Target* cloneTarget() const;
\end{example}

This simply returns the result of the \code{clone} function as a Target.
It is used by the KnownTarget class, for example to create a Target
object corresponding to a name specified from a user interface.

\begin{example}
virtual StringList displaySchedule();
\end{example}

The default implementation simply passes this call along to the
scheduler; derived classes may modify this.

\begin{example}
virtual StringList pragma () const;
\end{example}

A Target may understand certain annotations associated with Blocks
called ``Pragmas''.  For example, an annotation may specify how
many times a particular Star should fire.
Or it could specify that a particular Block should be mapped
onto a particular processor.  Or it could specify that a particular
State of a particular Block should be settable on the command line
that invokes a generated program.

The above method returns the list of names
pragmas that a particular target understands (e.g. ``firingsPerIteration'' or
``processorNumber'').
In derived classes, each item in the list is a three
part string, ``name type value'', separated by spaces.
The ``value'' will be a default value.
The implementation in class Target returns a StringList
with only a single zero-length string in it.
The ``type'' can be any type used in states.

\begin{example}
virtual StringList pragma (const char* \var{parentname}, const char* \var{blockname}) const;
\end{example}

To determine the value of all pragmas that have been specified for a
particular block, call this method.
In derived classes, it returns a list of ``name value'' pairs, separated
by spaces.
In the base class, it returns an empty string.
The \var{parentname} is the name of the parent class (universe or
galaxy master name).

\begin{example}
virtual StringList pragma (const char* \var{parentname},
	const char* \var{blockname},
	const char* \var{pragmaname}) const;
\end{example}

To determine the value of a pragma of a particular type
that has been specified for a particular block, call this
method. In derived classes, it returns a value.
In the base class, it returns a zero-length string.

\begin{example}
virtual StringList pragma (const char* \var{parentname},
	const char* \var{blockname},
	const char* \var{pragmaname},
	const char* \var{value}) const;
\end{example}

To specify a pragma to a target, call this method.
The implementation in the base class ``Target'' does nothing.
In derived classes, the pragma will be registered in some way.
The return value is always a zero-length string.

\begin{example}
Target* child(int \var{n});
\end{example}

Return the \var{n}th child Target, null if no children or if
\var{n} exceeds the number of children.

\begin{example}
Target* proc(int \var{n});
\end{example}

This is the same as \code{child} if there are children.  If
there are no children, an argument of 0 will return a pointer
to the object on which it is called, otherwise a null pointer
is returned.

\begin{example}
int nProcs() const;
\end{example}

Return the number of processors (1 if no children, otherwise the
number of children).

\begin{example}
virtual int hasResourcesFor(Star& \var{s},const char* \var{extra}=0);
\end{example}

Determine whether this target has the necessary resources to run the
given star.  It is virtual in case later necessary.  The default implementation
uses ``resources'' states of the target and the star.

\begin{example}
virtual int childHasResources(Star& \var{s},int \var{childNum});
\end{example}

Determine whether a particular child target has resources
to run the given star.  It is virtual in case later necessary.

\begin{example}
virtual void setGalaxy(Galaxy& \var{g});
\end{example}

Associate a Galaxy with the Target.  The default implementation
just sets its galaxy pointer \code{gal} to point to \var{g}.

\begin{example}
virtual void setStopTime(double \var{when});
\end{example}

Set the stopping condition.  The default implementation just passes
this on to the scheduler.

\begin{example}
virtual void resetStopTime(double \var{when});
\end{example}

Reset the stopping condition for the wormhole containing this Target.
The default implementation just passes this on to the scheduler.  In
addition to the action performed by \code{setStopTime}, this function
also does any synchronization required by wormholes.

\begin{example}
virtual void setCurrentTime(double \var{now});
\end{example}

Set the current time to \var{now}.

\begin{example}
virtual int run();
\end{example}

\begin{example}
virtual void wrapup();
\end{example}

The following methods are provided for code generation; schedulers may
call these.  They may move to class CGTarget in a future Ptolemy release.

\begin{example}
virtual void beginIteration(int \var{repetitions}, int \var{depth});
\end{example}

Function called to begin an iteration (default version
does nothing).

\begin{example}
virtual void endIteration(int \var{repetitions}, int \var{depth});
\end{example}

Function called to end an iteration (default version
does nothing).

\begin{example}
virtual void writeFiring(Star& \var{s}, int \var{depth});
\end{example}

Function called to generate code for the star, with any modifications
required by this particular Target (the default version does nothing).

\begin{example}
virtual void beginIf(PortHole& \var{cond}, int \var{truthdir},
        int \var{depth}, int \var{haveElsePart});
virtual void beginElse(int \var{depth});
virtual void endIf(int \var{depth});
virtual void beginDoWhile(PortHole& \var{cond}, int \var{truthdir}, int \var{depth});
virtual void endDoWhile(PortHole& \var{cond});
\end{example}

These functions are used in code generation to generate conditionals.
The default implementations do nothing.

\begin{example}
virtual int commTime(int \var{sender},int \var{receiver},int \var{nUnits}, int \var{type});
\end{example}

Return the number of time units required to send \var{nUnits} units of
data whose type is the code indicated by \var{type} from the child Target
numbered \var{sender} to the child target numbered \var{receiver}.
The default implementation returns 0 regardless of the parameters.
No meaning is specified at this level for the type codes, as different
languages have different types; all that is required is that different
types supported by a particular target map into distinct type codes.

\begin{example}
Galaxy* galaxy();
\end{example}

Return my galaxy pointer (0 if it has not been set).

\node Target protected members
\subsection{Target protected members}

\begin{example}
virtual void setup();
\end{example}

This is the main initialization function for the target.  It is called
by the \code{initialize} function, which by default initializes the
Target states.  The default implementation calls \code{galaxySetup()},
and if it returns a nonzero value, then calls \code{schedulerSetup()}.

\begin{example}
virtual int galaxySetup();
\end{example}

This method (and overloaded versions of it) is responsible for checking
the galaxy belonging to the target.  In the default implementation,
each star is checked to see if its type is
supported by the target (because the \code{isA} function reports
that it is one of the supported star classes).  If a star does not
match this condition an error is reported.  In addition,
\code{setTarget()} is called for each star with a pointer to the Target
as an argument.  If there are errors, 0 is returned, otherwise 1.

\begin{example}
virtual int schedulerSetup();
\end{example}

This method (and overloaded versions of it) are responsible for
initializing an execution of the universe.  The default implementation
initializes the scheduler and calls \code{setup()} on it.

\begin{example}
void setSched(Scheduler* \var{sch});
\end{example}

The target's scheduler is set to \var{sch}, which must either point to a
scheduler on the heap or be a null pointer.  Any preexisting scheduler
is deleted.  Also, the scheduler's \code{setTarget} member is called,
associating the Target with the Scheduler.

\begin{example}
void delSched();
\end{example}

This function deletes the target's scheduler and sets the scheduler
pointer to null.

\begin{example}
void addChild(Target& \var{child});
\end{example}

Add \var{child} as a child target.

\begin{example}
void inheritChildren(Target* \var{parent}, int \var{start}, int \var{stop});
\end{example}

This method permits two different Target objects to share child Targets.
The child targets numbered \var{start} through \var{stop} of the Target
pointed to by \var{parent} become the children of this Target (the one
on which this method is called).  Its primary use is in multi-processor
scheduling or code generation, in which some construct is assigned to
a group of processors.  It has a big disadvantage; the range of child
targets must be continuous.

\begin{example}
void remChildren();
\end{example}

Remove the ``children'' list.  This does not delete the child targets.

\begin{example}
void deleteChildren();
\end{example}

Delete all the ``children''.  This assumes that the child Targets
were created with \code{new}.

\begin{example}
virtual const char* auxStarClass() const;
\end{example}

Auxiliary star class: permits a second type of star in addition
to supportedStarClass.  The default implementation returns a
null pointer, indicating no auxiliary star class.

Sorry, there is no present way to support yet a third type.

\begin{example}
const char* writeDirectoryName(const char* \var{dirName} = 0);
\end{example}

This method returns a directory name that is intended for
use in writing files, particularly for code generation targets.
If the directory does not exist, it attempts create it.
Returns the fully expanded path name (which is saved by
the target).

\begin{example}
const char* workingDirectory() const;
\end{example}

Return directory name previously set by \code{writeDirectoryName}.

\begin{example}
char* writeFileName(const char* \var{fileName} = 0);
\end{example}

Method to set a file name for writing.  \var{writeFileName} prepends
dirFullName (which was set by \code{writeDirectoryName}) to
\var{fileName} with ``/'' between.  Always returns a pointer to a string
in new memory.  It is up to the user to delete the memory when no longer
needed.  If dirFullName or \var{fileName} is NULL then it returns a pointer to
a new copy of the string ``/dev/null''.

\node class Scheduler
\section{Class Scheduler}

Scheduler objects determine the order of execution of Stars.  As a rule,
they are created and managed by Targets.  Some schedulers, such as those
for the SDF domain, completely determine the order of execution of
blocks before any blocks are executed; others, such as those for the
DE domain, supervise the execution of blocks at run time.

The Scheduler class is an abstract base class; you can't have an object
of class Scheduler.

All schedulers have a pointer to the Target that controls them as well
as to a Galaxy.  Usually the Galaxy will be the same one that the
Target points to, but this is not a requirement.

The Scheduler constructor just zeros its target, galaxy pointers.  The
destructor is virtual and do-nothing.

\node Scheduler public members
\subsection{Scheduler public members}

\begin{example}
virtual void setGalaxy(Galaxy& \var{g});
\end{example}

This function sets the galaxy pointer to point to \var{g}.

\begin{example}
Galaxy* galaxy();
\end{example}

This function returns the galaxy pointer.

\begin{example}
virtual void setup() = 0;
\end{example}

This function (in derived classes) sets up the schedule.  In
compile-time schedulers such as those for SDF, a complete schedule is
computed; others may do little more than minimal checks.

\begin{example}
virtual void setStopTime(double \var{limit}) = 0;
\end{example}

Set the stop time for the scheduler.  Schedulers have an abstract
notion of time; this determines how long the scheduler will run for.

\begin{example}
virtual double getStopTime() = 0;
\end{example}

Retrieve the stop time.

\begin{example}
virtual void resetStopTime(double \var{limit});
\end{example}

Reset the stopping condition for the wormhole containing this Scheduler.
The default implementation simply calls \code{setStopTime} with
the same argument.  For some derived types of schedulers, additional
actions will be performed as well by derived Scheduler classes.

\begin{example}
virtual int run() = 0;
\end{example}

Run the scheduler until the stop time is reached, an error condition
occurs, or it stops for some other reason.

\begin{example}
virtual void setCurrentTime(double \var{val});
\end{example}

Set the current time for the scheduler.

\begin{example}
virtual StringList displaySchedule();
\end{example}

Return the schedule, if this makes sense.

\begin{example}
double now() const;
\end{example}

Return the current time (the value of the protected member
\code{currentTime}).

\begin{example}
int stopBeforeDeadlocked() const;
\end{example}

Return the value of the \code{stopBeforeDeadFlag} protected member.
It is set in timed domains to indicate that a scheduler inside a
wormhole was suspended even though it had more work to do.

\begin{example}
virtual const char* domain() const;
\end{example}

Return the domain for this scheduler.  This method is no longer used and
will be removed from future releases; it dates back to the days
in which a given scheduler could only be used in one domain.

\begin{example}
void setTarget(Target& \var{t});
\end{example}

Set the target pointer to point to \var{t}.

\begin{example}
Target& target ();
\end{example}

Return the target.

\begin{example}
virtual void compileRun();
\end{example}

Call code-generation functions in the Target to generate
code for a run.
In the base class, this just causes an error.

The following functions now forward requests to SimControl,
which is responsible for controlling the simulation.

\begin{example}
static void requestHalt();
\end{example}

Calls \code{SimControl::declareErrorHalt}.

NOTE: \code{SimControl::requestHalt} only sets the halt bit,
not the error bit.

\begin{example}
static int haltRequested();
\end{example}

Calls \code{SimControl::haltRequested}.  Returns TRUE if the
execution should halt.

\begin{example}
static void clearHalt();
\end{example}

Calls \code{SimControl::clearHalt}.  Clears the halt and error
bits.

\node Scheduler protected members
\subsection{Scheduler protected members}

The following two data members are protected.

\begin{example}
// current time of the scheduler
double currentTime;

// flag set if stop before deadlocked.
// for untimed domain, it is always FALSE.
int stopBeforeDeadlocked;
\end{example}

\node class Error
\section{Class Error}

Class Error is used for error reporting.  While the interfaces to
these functions are always the same, different user interfaces provide
different implementations: \file{ptcl} connects to the Tcl error
reporting mechanism, \file{pigi} pops up windows containing error
messages, and \file{interpreter} simply prints messages on the standard
error stream.  All member functions of Error are static.

There are four ``levels'' of messages that may be produced by the error
facility: \code{Error::abortRun} is used to report an error and cause execution
of the current universe to halt.
\code{Error::error} reports an error.
\code{Error::warn} reports a warning, and \code{Error::message} prints
an information message that is not considered an error.

Each of these four functions is available with two different signatures.
For example:

\begin{example}
static void abortRun (const char*, const char* = 0, const char* = 0);
static void abortRun (const NamedObj& \var{obj}, const char*, const char* = 0,
                      const char* = 0);
\end{example}

The first form produces the error message by simply concatenating its
arguments (the second and third arguments may be omitted); no space is
added.

The second form prepends the full name of the \var{obj} argument, a
colon, and a space to the text provided by the remaining arguments.
If the implementation provides a marking facility, the object named
by \var{obj} is marked by the user interface (at present, the interface
associated with \file{pigi} will highlight the object if its icon
appears on the screen).

The remaining static Error functions \code{error}, \code{warn}, and
\code{message} have the same signatures as does \code{abortRun} (there
are the same two forms for each function).

In addition, the Error class provides access to the marking facility,
if it exists:

\begin{example}
static int canMark();
\end{example}

This function returns TRUE if the interface can mark NamedObj objects
(generally true for graphic interfaces), and FALSE if it cannot
(generally true for text interfaces).

\begin{example}
static void mark (const NamedObj& \var{obj});
\end{example}

This function marks the object \var{obj}, if marking is implemented for
this interface.  It is a no-op if marking is not implemented.

\node class SimControl
\section{Class SimControl}

The SimControl class controls execution of the simulation.  It has
some global status flags that indicate whether there has been an
error in the execution or if a halt has been requested.  It also
has mechanisms for registering functions to be called before or
after star executions, or in response to a particular star's execution,
and responding to interrupts.

This class interacts with the Error class (which sets error and halt
bits) and the Star class (to permit execution of registered actions when
stars are fired).  Schedulers and Targets are expected to monitor
the SimControl halt flag to halt execution when errors are signaled
and halts are requested.  Once exceptions are commonplace in C++
implementations, a cleaner implementation could be produced.

\node SimControl status flags
\subsection{Access to SimControl status flags.}

SimControl currently has four global status bits: the error bit,
the halt bit, the interrupt bit, and the poll bit.  These functions
set, clear, or report on these bits.

\begin{example}
static void requestHalt ();
\end{example}

This function sets the halt bit.  The effect is to cause schedulers
and targets to cease execution.  It is important to note that this
function does not alter flow of control; it only sets a flag.

\begin{example}
static void declareErrorHalt ();
\end{example}

This is the same as \code{requestHalt} except that it also sets the
error bit.  It is called, for example, by \code{Error::abortRun}.

\begin{example}
static int haltRequested ();
\end{example}

This function returns true if the halt bit is set, false otherwise.
If the poll or interrupt bits are set, it calls handlers for them
(see the subsection describing these).

\begin{example}
static void clearHalt ();
\end{example}

This function clears the halt and error flags.

\node pre- and post-actions
\subsection{Pre-actions and Post-actions}

SimControl can register a function that will be called before
or after the execution of a particular star, or before or after
the execution of all stars.  A function that is called before
a star is a \emph{preaction}; on that is called after a star is
a \emph{post-action}.

The functions that can be registered have take two arguments: a
pointer to a Star (possibly null), and a \code{const char*} pointer
that points to a string (possibly null).  The type definition

\begin{example}
typedef void (*SimActionFunction)(Star*,const char*);
\end{example}

gives the name SimActionFunction to functions of this type;
several SimControl functions take arguments of this form.

\begin{example}
static SimAction* registerAction(SimActionFunction action, int pre,
 const char* textArg = 0, Star* which = 0);
\end{example}

Register a pre-action or post-action.  If "pre" is TRUE it is a preaction.
If \var{textArg} is given, it is passed as an argument when the
action function is called.  If \var{which} is 0, the function will
be called unconditionally by \code{doPreActions} (if it is a preaction)
or \code{doPostActions} (if it is a post-action; otherwise it will
only be called if the star being executed has the same address as
\code{which}.

The return value represents the registered action; class SimAction
is treated as an ``opaque class'' (I'm not telling you what is in it)
which can be used for \code{cancel} calls.

\begin{example}
static int doPreActions(Star * which);
static int doPostActions(Star * which);
\end{example}

Execute all pre-actions, or post-actions, for a the particular Star
\var{which}.  The \var{which} pointer is passed to each action
function, along with any text argument declared when the action
was registered.

Return TRUE if no halting condition arises, FALSE if we are to halt.

\begin{example}
static int cancel(SimAction* \var{action});
\end{example}

Cancel \var{action}.  Warning: argument is deleted.

Future versions will provide more ways of cancelling actions.

\node SimControl interrupts and polling
\subsection{SimControl interrupts and polling}

Features in this section will be used in a new graphic interface;
they are mostly untested at this point.

The SimControl class can handle interrupts and can register a
polling function that is called for every star execution.
It only provides one handler.

\begin{example}
static void catchInt(int signo = -1, int always = 0);
\end{example}

This static member function installs a simple
interrupt handler for the signal with
Unix signal number \var{signo}.  If \var{always} is true, the
signal is always caught; otherwise the signal is not caught
if the current status of the signal is that it is ignored
(for example, processes running in the background ignore
interrupt signals from the keyboard).  This handler simply sets
the SimControl interrupt bit; on the next call to \code{haltRequested},
the user-specified interrupt handler is called.

\begin{example}
static SimHandlerFunction setInterrupt(SimHandlerFunction \var{f});
\end{example}

Set the user-specified interrupt handler to \var{f}, and return
the old handler, if any.  This function is called in response to
any signals specified in \code{catchInt}.

\begin{example}
static SimHandlerFunction setPoll(SimHandlerFunction f);
\end{example}

Register a function to be called by \code{haltRequested} if the poll
flag is set, and set the poll flag.  Returns old handler if any.

\node Interfacing domains
\chapter{Interfacing domains -- wormholes and related classes}

This section describes the classes that implement the mechanism that
allows different domains to be interfaced.  It is this ability to
integrate different domains that sets Ptolemy apart from other systems.

\node class Wormhole
\section{Class Wormhole}

A wormhole for a domain is much like a star belonging to that domain,
but it contains pointers to a subsystem that operates in a different
domain.  The interface to that other domain is through a ``universal
event horizon''.  The wormhole design, therefore, does not depend on the
domain it contains, but only on the domain in which it is used as a
block.  It must look like a star in that outer domain.

The base Wormhole class is derived from
class Runnable (\pxref{class Runnable}), just like the
class Universe (\pxref{class Universe}).
Every member of the Runnable class has a pointer to a
component Galaxy (\pxref{class Galaxy}) and a Target (\pxref{class
Target}).

Like a Universe, a Wormhole can perform
the scheduling actions on the component Galaxy. A Wormhole is different
from a Universe in that it is not a stand-alone object.  Instead, it is
triggered from the outer domain to initiate the scheduling.  Also, since
Wormhole is an abstract base class, you cannot create an object of class
Wormhole; only derived Wormholes can be created.

Each domain has a derived Wormhole class.  For example, the SDF domain
has class SDFWormhole.  This domain-specific Wormhole is derived from
not only the base Wormhole class but also from the domain-specific star
class, SDFStar.  This multiple inheritance realizes the inherent nature
of the Wormhole.  First, the Wormhole behaves exactly like a Star from
the outer domain (SDF) since it is derived from SDFStar.  Second,
internally it can encapsulate an entire foreign domain with a separate
Galaxy and a separate Target and Scheduler.

\node Wormhole public members
\subsection{Wormhole public members}

\begin{example}
void setup();
\end{example}

The default implementation calls \code{initTarget}.

\begin{example}
int run();
\end{example}

This function executes the inside of the wormhole for the appropriate
amount of time.

\begin{example}
const char* insideDomain() const;
\end{example}

This function returns the name of the inside domain.

\begin{example}
void setStopTime(double \var{stamp});
\end{example}

This function sets the stop time for the inner universe.

\begin{example}
Wormhole(Star& \var{self}, Galaxy& \var{g}, const char* \var{targetName} = 0);
Wormhole(Star& \var{self}, Galaxy& \var{g}, Target* \var{innerTarget} = 0);
\end{example}

The above two signatures represent the constructors provided for class
Wormhole.  We never use plain Wormholes; instead we always have objects derived
from Wormhole and some kind of Star.  For example:

\begin{example}
class SDFWormhole : public Wormhole, public SDFStar \{
public:
    SDFWormhole(Galaxy& g,Target* t) : Wormhole(*this,g,t) \{
        buildEventHorizons();
    \}
\};
\end{example}

The first argument to the constructor should always be a reference to
the object itself, and represents ``the wormhole as a star''.  The second
argument is the inner galaxy.  The third argument describes the target
of the Wormhole, and may be provided either as a Target object or by
name, in which case it is created by using the KnownTarget class.

\begin{example}
Scheduler* outerSched();
\end{example}

This returns a pointer to the scheduler for the outer domain (the one
that lives above the wormhole).  The scheduler for the inner domain
for derived wormhole classes can be obtained from the \code{scheduler()}
method.

\node Wormhole protected members
\subsection{Wormhole protected members}

\begin{example}
void buildEventHorizons ();
\end{example}

This function creates the EventHorizon objects that connect the inner
galaxy ports to the outside.  A pair of EventHorizons is created for
each galaxy port.  It is typically called by the constructor for
the XXXWormhole, where XXX is the outer domain name.

\begin{example}
void freeContents();
\end{example}

This function deletes the event horizons and the inside galaxy.  It
is intended to be called from XXXWormhole destructors.  It cannot be
part of the Wormhole constructor due to an ordering problem (we want
to assure that it is called before the destructor for either of
XXXWormhole's two base classes is called).

\begin{example}
virtual double getStopTime() = 0;
\end{example}

Get the stopping condition for the inner domain.  This is a pure
virtual function and must be redefined in the derived class.

\begin{example}
virtual void sumUp();
\end{example}

This function is called by \code{Wormhole::run} after running the
inner domain.  The default implementation does nothing.  Derived
wormholes can redefine it to put in any ``summing up'' work that is
required after running the inner domain.

\begin{example}
Galaxy& gal;
\end{example}

The member \code{gal} is a reference to the inner galaxy of the Wormhole.

\node class EventHorizon
\section{Class EventHorizon}

Class EventHorizon is another example of a ``mixin class''; EventHorizon has
the same relationship to PortHoles as Wormhole has to Stars.  The name
is chosen from cosmology, representing the point at which an object
disappears from the outside universe and enters the interior of a black
hole, which can be thought of as a different universe entirely.

As for wormholes, we never consider objects that are ``just an
EventHorizon''.  Instead, all objects that are actually used are multiply
inherited from EventHorizon and from some type of PortHole class.  For
each type of domain we require two types of EventHorizon.  The first, derived
from ToEventHorizon, converts from a format suitable for a particular
domain to the ``universal form''.  The other, derived from FromEventHorizon,
converts from the universal form to the domain-specific form.

\node How EventHorizons are used
\subsection{How EventHorizons are used}

Generally, EventHorizons are used in pairs to form a connection
across a domain boundary between domain XXX and domain YYY.  An object
of class XXXToUniversal (derived from XXXPortHole and ToEventHorizon)
and an object of class YYYFromUniversal (derived from YYYPortHole and
FromEventHorizon) are inserted between the ordinary, domain-specific
PortHoles.  The \code{far()} member of the XXXToUniversal points
to the XXXPortHole; the \code{ghostAsPort()} member points to
the YYYFromUniversal object.  Similarly, for the YYYFromUniveral
object, \code{far()} points to the YYYPortHole and \code{ghostAsPort()}
points to the XXXToUniversal object.

These pairs of EventHorizons are created by the
\code{buildEventHorizons} member function of class Wormhole.

\node EventHorizon public members
\subsection{EventHorizon public members}

\begin{example}
EventHorizon(PortHole* \var{self});
\end{example}

The constructor for EventHorizon takes one argument, representing (for
derived classes that call this constructor from their own), ``myself'' as
a PortHole (a pointer to the PortHole part of the object).

The destructor is declared virtual and does nothing.

\begin{example}
PortHole* asPort();
\end{example}

This returns ``myself as a PortHole''.

\begin{example}
PortHole* ghostAsPort();
\end{example}

This returns a pointer to the ``matching event horizon'' as a porthole.

\begin{example}
virtual void ghostConnect(EventHorizon& \var{to} );
\end{example}

This connects another EventHorizon to myself and makes it my ``ghost
port''.

\begin{example}
virtual int isItInput() const;
virtual int isItOutput() const;
\end{example}

Say if I am an input or an output.

\begin{example}
virtual int onlyOne() const;
\end{example}

Derived EventHorizon classes should redefine this method to return TRUE
for domains in which only one particle may cross the event horizon
boundary per execution.  The default implementation returns FALSE.

\begin{example}
virtual void setEventHorizon(inOutType \var{inOut}, const char* \var{portName},
     Wormhole* \var{parentWormhole}, Star* \var{parentStar},
     DataType \var{type} = FLOAT, unsigned \var{numTokens} = 1 );
\end{example}

Sets parameters for the EventHorizon.

\begin{example}
double getTimeMark();
void setTimeMark(double \var{d});
\end{example}

Get and set the time mark.  The time mark is an internal detail used for
bookkeeping by schedulers.

\begin{example}
virtual void initialize();
\end{example}

\begin{example}
Scheduler *innerSched();
Scheduler *outerSched();
\end{example}

These methods return a pointer to the scheduler that lives inside the
wormhole, or outside the wormhole, respectively.

\node EventHorizon protected members
\subsection{EventHorizon protected members}

\begin{example}
void moveFromGhost(EventHorizon& \var{from}, int \var{numParticles});
\end{example}

Move \var{numParticles} from the buffer of \var{from}, another
EventHorizon, to mine (the object on which this function is called).
This is used to implement \code{ToEventHorizon::transferData}.

\begin{example}
CircularBuffer* buffer();
\end{example}

Access the myBuffer of the porthole.

\begin{example}
EventHorizon* ghostPort;
\end{example}

This is the peer event horizon.

\begin{example}
Wormhole* wormhole;
\end{example}

This points to the Wormhole I am a member of.

\begin{example}
int tokenNew;
\end{example}

\begin{example}
double timeMark;
\end{example}

TimeMark of the current data, which is necessary for interface
of two domains.  This may become a private member in future versions
of Ptolemy.

\node class ToEventHorizon
\section{Class ToEventHorizon}

A ToEventHorizon is responsible for converting from a domain-specific
representation to a universal representation.  It is derived from
EventHorizon.

\begin{example}
ToEventHorizon(PortHole* \var{p});
\end{example}

The constructor simply calls the base class constructor, passing along
its argument.

\begin{example}
void initialize();
\end{example}

The initialize function prepares the object for execution.

\begin{example}
void getData();
\end{example}

This protected member transfers data from the outside to the universal
event horizon (myself).

\begin{example}
void transferData();
\end{example}

This protected member transfers data from myself to my peer
FromEventHorizon (the ghostPort).

\node class FromEventHorizon
\section{Class FromEventHorizon}

A FromEventHorizon is responsible for converting from a universal
representation to a domain-specific representation.  It is derived from
EventHorizon.

\begin{example}
FromEventHorizon(PortHole* \var{p});
\end{example}

The constructor simply calls the EventHorizon constructor.

\begin{example}
void initialize();
\end{example}

The initialize function prepares the object for execution.

\begin{example}
void putData();
\end{example}

This protected member transfers data from Universal EventHorizon to outside.

\begin{example}
void transferData();
\end{example}

This protected member transfers data from peer event horizon to me.

\begin{example}
virtual int ready();
\end{example}

This is a protected member.  By default, it always returns TRUE (1).
Derived classes have it return TRUE if the event horizon is ``ready''
(there is enough data for execution to proceed), and false otherwise.

\node class WormMultiPort
\section{Class WormMultiPort}

The class WormMultiPort, which is derived from MultiPortHole
(\pxref{class MultiPortHole}), exists to
handle the case where a galaxy with a multiporthole is embedded in a
wormhole.  Its \code{newPort} function correctly creates a pair of
EventHorizon objects when a new port is created in the multiporthole.
Instances of this object are created by Wormhole::buildEventHorizons
when the inner galaxy has one or more MultiPortHole objects.
Its \code{newConnection} method always calls \code{newPort}.

\node connection classes
\chapter{Classes for connections between blocks}

This chapter describes the classes that implement connections between
blocks.  For simulation domains, these classes are responsible for
moving objects called Particles (\pxref{class Particle})
from one Block to another.  For code
generation domains, the Particles typically only move during scheduling
and these objects merely provide information on the topology.

Currently, class PortHole is also responsible for the type resolution
algorithm that assigns specific types to ANYTYPE portholes.  It would
probably be better to put that function in Geodesic, which would make
it simpler to provide domain-specific type resolution rules.  This
improvement must await a redesign of the PortHole/Geodesic structure.

\node class GenericPort
\section{Class GenericPort}

The class GenericPort is a base class that provides common elements
between class PortHole (\pxref{class PortHole})
and class MultiPortHole (\pxref{class MultiPortHole}).
Any GenericPort object
can be assumed to be either one or the other; we recommend avoiding
deriving any new objects directly from GenericPort.

GenericPort is derived from class NamedObj (\pxref{class NamedObj}).

GenericPort provides several basic facilities: aliases, which specify
that another GenericPort should be used in place of this port, types,
which specify the type of data to be moved by the port, and typePort,
which specifies that this port has the same type as another port.
When a GenericPort is destroyed, any alias or typePort pointers are
automatically cleaned up, so that other GenericPorts are never left
with dangling pointers.

The type() and typePort() functions belong to GenericPort, not PortHole,
because multiportholes have a declared type and can be type-equivalenced
to other portholes.  However, type resolution is strictly a PortHole notion.
Multiportholes need no resolved type because they do not themselves transport
particles, and indeed the concept would be ambiguous since the member ports
of a multiporthole might have different resolved types.  The declared type of
a multiporthole is automatically assigned to its children, and its children
are automatically brought into any type equivalence set the multiporthole is
made part of.  Thereafter, type resolution considers only the member
portholes and not the multiporthole itself.

\node GenericPort query functions
\subsection{GenericPort query functions}

\begin{example}
virtual int isItInput () const;
virtual int isItOutput () const;
virtual int isItMulti () const;
\end{example}

Each of the above functions returns TRUE (1) or FALSE (0).

\begin{example}
StringList print (int \var{verbose} = 0) const;
\end{example}

Print human-readable information on the GenericPort.

\begin{example}
DataType type () const;
\end{example}

Return my DataType.  This may be one of the DataType values associated
with Particle classes, or the special type `ANYTYPE', which indicates
that the type must be resolved during setup.  Note that type() returns
the port's declared type, as supplied to setPort().  This is not
necessarily the datatype that will be chosen to pass through the port at
runtime.  That type is available from the PortHole::resolvedType()
function.

\begin{example}
GenericPort* alias() const;
\end{example}

Return my alias, or a null pointer if I have no alias.  Generally,
Galaxy portholes have aliases and Star portholes do not, but this
is not a strict requirement.

\begin{example}
GenericPort* aliasFrom() const;
\end{example}

Return the porthole that I am the alias for (a null pointer if none).
It is guaranteed that if \code{gp} is a pointer to GenericPort and if
\code{gp->alias()} is non-null, then the boolean expression

\begin{example}
gp->alias()->aliasFrom() == gp
\end{example}

is always true.

\begin{example}
bitWord attributes() const;
\end{example}

Return my attributes.  Attributes are a series of bits.

\begin{example}
GenericPort& realPort();
const GenericPort& realPort() const;
\end{example}

Return the real port after resolving any aliases.  If I have no alias,
then a reference to myself is returned.

\begin{example}
GenericPort* typePort() const;
\end{example}

Return another generic port that is constrained to have the same type as
me (0 if none).  If a non-null value is called, successive calls will
form a circular linked list that always returns to its starting point;
that is, the loop

\begin{example}
void printLoop(GenericPort& g) \{
        if (g->typePort()) \{
                GenericPort* gp = g;
                while (gp->typePort() != g) \{
                        cout << gp->fullName() << "\back n";
                        gp = gp->typePort();
                \}
        \}
\}
\end{example}

is guaranteed to terminate and not to dereference a null pointer.

\begin{example}
inline int hidden(const GenericPort& \var{p})
\end{example}

IMPORTANT: \code{hidden} is not a member function of GenericPort,
but is a ``plain function''.  It returns TRUE if the port in question
has the HIDDEN attribute.

\node other GenericPort public members
\subsection{other GenericPort public members}

\begin{example}
virtual PortHole& newConnection();
\end{example}

Return a reference to a porthole to be used for new connections.
Class PortHole uses this one unchanged; MultiPortHole has to create
a new member PortHole.

\begin{example}
GenericPort& setPort(const char* \var{portName}, Block* \var{blk}, DataType \var{typ}=FLOAT);
\end{example}

Set the basic PortHole parameters: the name, parent, and data type.

\begin{example}
void inheritTypeFrom(GenericPort& \var{p});
\end{example}

Link to another port for determining the type of `ANYTYPE' connections.
The "inheritance" relationship is actually a completely symmetric constraint,
and so this function would have been better named sameTypeAs().  Any number
of portholes can be tied together by inheritTypeFrom() calls.  Internally
this is represented by chaining all the members of such a type equivalence
set into a circular loop, which can be walked via typePort() calls.  If a
multiporthole is made part of a type equivalence set, all its current and
future children become part of the set automatically.

\begin{example}
virtual Plasma* setPlasma(Plasma *\var{useType} = NULL) = 0;
\end{example}

This function associates the appropriate pool of particles, called a
Plasma, with the PortHole or MultiPortHole.  The effect is also to
determine how type conversion will be performed, since the type of
a porthole is determined by its associated Plasma.

\begin{example}
virtual void connect(GenericPort& \var{destination},int \var{numberDelays});
\end{example}

Connect me with the indicated peer.

\begin{example}
bitWord setAttributes(const Attribute& \var{attr});
\end{example}

Set my attributes (some bits are turned on and others are turned off).

\begin{example}
void setAlias (GenericPort& \var{gp});
\end{example}

Set gp to be my alias.  The aliasFrom pointer of gp is set to
point to me.

\node GenericPort protected members
\subsection{GenericPort protected members}

\begin{example}
GenericPort* translateAliases();
\end{example}

The above is a protected function.  If this function is called on
a port with no alias, the address of the port itself is returned;
otherwise, \code{alias()->translateAliases()} is returned.

\node class PortHole
\section{Class PortHole}

PortHole is the means that Blocks use to talk to each other.  It is
derived from GenericPort; as such, it has a type, an optional alias,
and is optionally a member of a ring of ports of the same type connected
by \code{typePort} pointers.  It guarantees that \code{alias()} always
returns a PortHole.

In addition, a PortHole has a peer (another port that it is connected
to, which is returned by \code{far()}), a Geodesic (a path along which
particles travel between the PortHole and its peer), and a Plasma (a
pool of particles, all of the same type).  In simulation domains,
during the execution of the simulation objects known as Particles
traverse a circular path: from an output porthole through a Geodesic to
an input porthole, and finally to a Plasma, where they are recirculated
back to the input porthole.

Like all NamedObj-derived objects, a PortHole has a parent Block.  It
may also be a member of a MultiPortHole, which is a logical group of
PortHoles.

\node PortHole public members
\subsection{PortHole public members}

The constructor sets just about everything to null pointers.

The destructor disconnects the PortHole, and if there is a parent Block,
removes itself from the parent's porthole list.

\begin{example}
PortHole& setPort(const char* \var{portName}, Block* \var{parent},
                 DataType \var{type} = FLOAT);
\end{example}

This function sets the name of the porthole, its parent, and
its type.

\begin{example}
void initialize();
\end{example}

This function is responsible for initializing the internal buffers
of the porthole in preparation for a run.

\begin{example}
virtual void disconnect(int \var{delGeo} = 1);
\end{example}

Remove a connection, and optionally attempt to delete the geodesic.  The
is set to zero when the geodesic must be preserved for some reason (for
example, from the Geodesic's destructor).  The Geodesic is deleted only
if it is ``temporary''; we do not delete ``persistent'' geodesics when
we disconnect them.

\begin{example}
PortHole* far() const;
\end{example}

Return the PortHole we are connected to.

\begin{example}
void setAlias (PortHole& \var{blockPort});
\end{example}

Set my alias to \var{blockPort}.

\begin{example}
int atBoundary() const;
\end{example}

Return TRUE if this PortHole is at the wormhole boundary (if its peer is
an inter-domain connection); FALSE otherwise.

\begin{example}
virtual EventHorizon* asEH();
\end{example}

Return myself as an EventHorizon, if I am one.  The base class returns
a null pointer.  EventHorizon objects (objects multiply inherited from
EventHorizon and some type of PortHole) will redefine this
appropriately.

\begin{example}
virtual void receiveData();
\end{example}

Used to receive data in derived classes.  The default implementation
does nothing.

\begin{example}
virtual void sendData();
\end{example}

Used to send data in derived classes.  The default implementation
does nothing.

\begin{example}
Particle& operator % (int \var{delay});
\end{example}

This operator returns a reference to a Particle in the PortHole's
buffer.  A \var{delay} value of 0 returns the ``newest'' particle.
In dataflow domains, the argument represents the delay associated
with that particular particle.

\begin{example}
void setMaxDelay(int \var{delay});
\end{example}

Set the maximum delay that past Particles can be accessed -- defaults to
zero if never called.

\begin{example}
DataType resolvedType () const;
\end{example}

Return the data type computed by `PortHole::initialize' to resolve type
conversions.  For example, if an INT output porthole is connected to a FLOAT
input porthole, the resolved type (the type of the Particles that travel
between the ports) will be FLOAT.  Two connected portholes will always return
the same resolvedType.  A null pointer will be returned if the type has not
yet been resolved, e.g. before initialization.

\begin{example}
DataType preferredType () const;
\end{example}

Return the "preferred" type of the porthole.  This is the same as the
declared type (GenericPort::type()) if the declared type is not ANYTYPE.
If the declared type is ANYTYPE, the preferredType is the type of the
connected porthole or type equivalence set from which the ANYTYPE's true type
was determined.  (If preferredType and resolvedType are not the same, the
need for a run-time type conversion is indicated.  Code generation domains
may choose to splice in type conversion stars to ensure that preferredType
and resolvedType are the same at all ports.)  A null pointer will be returned
if the type has not yet been resolved, e.g. before initialization.

\begin{example}
int numXfer() const;
\end{example}

Returns the nominal number of tokens transferred per execution of the
PortHole.  It returns the value of the protected member \code{numberTokens}.

\begin{example}
int numTokens() const;
\end{example}

Returns the number of particles on my Geodesic.

\begin{example}
int numInitDelays() const;
\end{example}

Returns the number of initial delays on my Geodesic (the initial tokens,
strictly speaking, are only delays in dataflow domains).

\begin{example}
Geodesic* geo();
\end{example}

Return a pointer to my Geodesic.

\begin{example}
Plasma* setPlasma(Plasma *\var{useType} = NULL);
\end{example}

Initialize the Plasma, which has the effect of resolving the type, since
the Particles provided by the Plasma determine the type of data that can
be transferred.  This function should be protected.

\begin{example}
int index() const;
\end{example}

Return the index value.  This is a mechanism for assigning all the
portholes in a universe a unique integer index, for use in table-driven
schedulers.

\begin{example}
MultiPortHole* getMyMultiPortHole() const;
\end{example}

Return the MultiPortHole that spawned this PortHole, or NULL
if there is no such MultiPortHole.

\begin{example}
virtual void setDelay (int \var{newDelayValue});
\end{example}

Set the delay value for the connection.

\begin{example}
virtual Geodesic* allocateGeodesic();
\end{example}

Allocate a return a Geodesic compatible with this type of PortHole.
This may become a protected member in future Ptolemy releases.

\node PortHole protected members
\subsection{PortHole protected members}

\begin{example}
Geodesic* myGeodesic;
\end{example}

My geodesic, which connects to my peer.  Initialized to NULL.

\begin{example}
PortHole* farSidePort;
\end{example}

The port on the far side of the connection.  NULL for disconnected ports.

\begin{example}
Plasma* myPlasma;
\end{example}

Pointer to the Plasma where we get our Particles or replace unused
Particles.  Initialized to NULL.

\begin{example}
CircularBuffer* myBuffer;
\end{example}

Buffer where the Particles are stored.  This is actually a buffer of
pointers to Particles, not to Particles themselves.

\begin{example}
int bufferSize;
\end{example}

This gives the size of the CircularBuffer to allocate.

\begin{example}
void getParticle();
\end{example}

Get \code{numberTokens} particles from the Geodesic and move them into
my CircularBuffer.  Actually, only Particles move.  The same number of
existing Particles are returned to their Plasma, so that the total
number of Particles contained in the buffer remains constant.

\begin{example}
void putParticle();
\end{example}

Move \code{numberTokens} particles from my CircularBuffer to the
Geodesic.  Replace them with the same number of Particles from the Plasma.

\begin{example}
void clearParticle();
\end{example}

Clear \code{numberTokens} particles in the CircularBuffer.  Leave the
buffer position pointing to the last one.

\node class CircularBuffer
\subsection{CircularBuffer -- a class used to implement PortHole}

This class is misnamed; it is not a general circular buffer but
rather an array of pointers to Particle that is accessed in a
circular manner.  It has a pointer representing the current position.
This pointer can be advanced or backed up; it wraps around the end
when this is done.  The class also has a facility for keeping
track of error conditions.

The constructor takes an integer argument, the size of the buffer.
It creates an array of pointers of that size and sets them all to
null.  The destructor returns any Particles in the buffer to their
Plasma and then deletes the buffer.

\begin{example}
void reset();
\end{example}

Set the access pointer to the beginning of the buffer.

\begin{example}
Particle** here() const;
\end{example}

Return the access pointer.  Note the double indirection; since the
buffer contains pointers to Particles, the buffer pointer points
to a pointer.

\begin{example}
Particle** next();
\end{example}

Advance the pointer one position (circularly) and return the new value.

\begin{example}
Particle** last();
\end{example}

Back up the pointer one position (circularly) and return the new value.

\begin{example}
void advance(int \var{n});
\end{example}

Advance the buffer pointer by \var{n} positions.  This will not work correctly
if \var{n} is larger than the buffer size.  \var{n} is assumed positive.

\begin{example}
void backup(int \var{n});
\end{example}

Back up the buffer pointer by \var{n} positions.  This will not work correctly
if \var{n} is larger than the buffer size.  \var{n} is assumed positive.

\begin{example}
Particle** previous(int \var{offset}) const;
\end{example}

Find the position in the buffer \var{offset} positions in the past
relative to the current position.  The current position is unchanged.
\var{offset} must not be negative, and must be less than the buffer
size, or a null pointer is returned an an appropriate error message
is set; this message can be accessed by the \code{errMsg} function.

\begin{example}
int size() const;
\end{example}

Return the size of the buffer.

\begin{example}
static const char* errMsg();
\end{example}

Return the last error message (currently, only \code{previous()} sets
error messages).

\node class MultiPortHole
\section{Class MultiPortHole}

A MultiPortHole is an organized connection of related PortHoles.  Any
number of PortHoles can be created within the PortHole; their names have
the form \code{\var{mphname}#1}, \code{\var{mphname}#2}, etc., where
\var{mphname} is replaced by the name of the MultiPortHole.  When a
PortHole is added to the MultiPortHole, it is also added to the porthole
list of the Block that contains the MultiPortHole.  As a result, a Block
that contains a MultiPortHole has, in effect, a configurable number of
portholes.

A pair of MultiPortHoles can be connected by a ``bus connection''.  This
technique creates \var{n} PortHoles in each MultiPortHole and connects
them all ``in parallel''.

The MultiPortHole constructor sets the ``peer MPH'' to 0.  The destructor
deletes any constituent PortHoles.

\node MultiPortHole public members
\subsection{MultiPortHole public members}

\begin{example}
void initialize();
\end{example}

Does nothing.

\begin{example}
void busConnect (MultiPortHole& \var{peer}, int \var{width}, int \var{delay} = 0);
\end{example}

Makes a bus connection with another multiporthole, \var{peer}, with
width \var{width} and delay \var{delay}.  If there is an existing bus
connection, it is changed as necessary; an existing bus connection may
be widened, or, if connected to a different peer, all constituent
portholes are deleted and a bus is made from scratch.

\begin{example}
int isItMulti() const;
\end{example}

Returns TRUE.

\begin{example}
MultiPortHole& setPort(const char* \var{portName},
                       Block* \var{parent},DataType \var{type} = FLOAT);
\end{example}

\begin{example}
int numberPorts() const;
\end{example}

Return the number of PortHoles in the MultiPortHole.

\begin{example}
virtual PortHole& newPort();
\end{example}

Add a new physical port to the MultiPortHole list.

\begin{example}
MultiPortHole& realPort();
\end{example}

Return the real MultiPortHole associated with me, translating any
aliases.

\begin{example}
void setAlias (MultiPortHole &\var{blockPort});
\end{example}

Set my alias to \var{blockPort}.

\begin{example}
virtual PortHole& newConnection();
\end{example}

Return a new port for connections.  If there is an unconnected porthole,
return the first one; otherwise make a new one.

\begin{example}
Plasma* setPlasma(Plasma *\var{useType} = NULL);
\end{example}

Sets the Plasma for all the portholes in the multiporthole.

\node MultiPortHole protected members
\subsection{MultiPortHole protected members}

\begin{example}
PortList ports;
\end{example}

The list of portholes (should be protected).

\begin{example}
const char* newName();
\end{example}

This function generates names to be used for contained PortHoles.  They
are saved in the hash table provided by the \code{hashstring} function
(\pxref{utility functions}).

\begin{example}
PortHole& installPort(PortHole& \var{p});
\end{example}

This function adds a newly created port to the multiporthole.  Derived
MultiPortHole classes typically redefine \code{newPort} to create a
porthole of the appropriate type, and then use this function to register
it and install it.

\begin{example}
void delPorts();
\end{example}

This function deletes all contained portholes.

\node AutoFork and AutoForkNode
\section{AutoFork and AutoForkNode}

AutoForks are a method for implementing netlist-style connections.
An AutoForkNode is a type of Geodesic built on top of AutoFork.
The classes are separate to allow a ``mixin approach'', so that if
a domain requires special actions in its Geodesics, these special
actions can be written only once and be implemented in both
temporary and permanent connections.

The implementation technique used is to automatically insert a Fork
star to allow the n-way connection; this Fork star is created by
invoking \code{KnownBlock::makeNew("Fork")}, which works only for
domains that have a fork star.

\node class AutoFork
\subsection{Class AutoFork}

An AutoFork object has an associated Geodesic and possibly an associated
Fork star (which it creates and deletes as needed).  It is normally used
in a multiply inherited object, inherited from AutoFork and some kind
of Geodesic; hence the associated Geodesic is the object itself.

The constructor for class AutoFork takes a single argument, a reference
to the Geodesic.  It sets the pointer to the fork star to be null.

The destructor removes the fork star, if one was created.

There are two public member functions, \code{setSource} and
\code{setDest}.

\begin{example}
PortHole* setSource(GenericPort& \var{port}, int \var{delay} = 0);
\end{example}

If there is already an originating port for the geodesic, this method
returns an error.  Otherwise it connects it to the node.

\begin{example}
PortHole* setDest(GenericPort& \var{port}, int \var{alwaysFork} = 0);
\end{example}

This function may be used to add any number of destinations to the
port.  Normally, when there is more than one output, a Fork star is
created and inserted to support the multi-way connection, but if there
is only one output, a direct connection is used.  However, if
\var{alwaysFork} is true, a Fork is inserted even for the first output.
When the fork star is created, it is inserted in the block list for
the parent galaxy (the parent of the geodesic).

\node class AutoForkNode
\subsection{Class AutoForkNode}

Class AutoForkNode is multiply inherited from Geodesic and AutoFork.

This class redefines \code{isItPersistent} to return TRUE, and redefines
the \code{setSourcePort} and \code{setDestPort} functions to call the
\code{setSource} and \code{setDest} functions of AutoFork.
The exact same form could be used to generate other types of
auto-forking nodes (that is, this class could have been done with
a template).

\node class ParticleStack
\section{Class ParticleStack}

ParticleStack is an efficient base class for the implementation of
structures that organize Particles.  As Particles have a link field,
ParticleStack is simply implemented as a linked list of Particles.

Strictly speaking, a dequeue is implemented; particles can be inserted
from either end.  ParticleStack has some odd attributes; it is designed
for very efficient implementation of Geodesic and Plasma to move around
large numbers of Particle objects very efficiently.

\begin{example}
ParticleStack(Particle* \var{h});
\end{example}

The constructor takes a Particle pointer.  If it is a null pointer an
empty ParticleStack is created.  Otherwise the stack has one particle.
Adding a Particle to a ParticleStack modifies that Particle's link
field; therefore a Particle can belong to only one ParticleStack at a
time.

\begin{example}
~ParticleStack();
\end{example}

The destructor deletes all Particles EXCEPT for the last one; we do not
delete the last one because it is the ``reference'' particle (for
Plasma) and is normally not dynamically created (this code may be moved
in a future release to the Plasma destructor, as this behavior is needed
for Plasma and not for other types of ParticleStack).

\begin{example}
void put(Particle* \var{p});
\end{example}

Push \var{p} onto the top (or head) of the ParticleStack.

\begin{example}
Particle* get();
\end{example}

Pop the particle off the top (or head) of the ParticleStack.

\begin{example}
void putTail(Particle* \var{p});
\end{example}

Add \var{p} at the bottom (or tail) of the ParticleStack.

\begin{example}
int empty() const;
\end{example}

Return TRUE (1) if the ParticleStack is empty, otherwise 0.

\begin{example}
int moreThanOne() const;
\end{example}

Return TRUE (1) if the ParticleStack has two or more particles,
otherwise 0.  This is provided to speed up the derived class Plasma a
bit.

\begin{example}
void freeup();
\end{example}

Returns all Particles on the stack to their Plasma (the allocation pool
for that particle type).

There is one protected data member:

\begin{example}
Particle* head;
\end{example}

This is the head of the list (or the top of the stack).

\node class Geodesic
\section{Class Geodesic}

A Geodesic implements the connection between a pair, or a larger
collection, of PortHoles.  A Geodesic may be temporary, in which case it
is deleted when the connection it implements is broken, or it can be
permanent, in which case it can live in disconnected form.  As a rule,
temporary geodesics are used for point-to-point connections and
permanent geodesics are used for netlist connections.  In the latter
case, the Geodesic has a name and is a member of a galaxy; hence,
Geodesic is derived from NamedObj (\pxref{class NamedObj}).

The base class Geodesic, which is temporary, suffices for most simulation
and code generation domains.  In fact, in a number of these domains it
contains unused features, so it is perhaps too ``heavyweight'' an object.
A Geodesic contains a ParticleStack member which is used as a queue for
movement of Particles between two portholes; it also has an originating
port and a destination port.

A Geodesic can be asked to have a specific number of initial particles.
When initialized, it creates that number of particles in its
ParticleStack; these particles are obtained from the Plasma of the
originating port (so they will be of the correct type).

A severe limitation of the current Geodesic class is that it is designed
around point-to-point connections, ie, a single source port to a single
destination port.  This is a problem for domains that wish to support
one-to-many geodesics (single source to multiple receivers) or many-to-many
geodesics (such as multiple in/out ports connected to a common bus).
Geodesic ought to be redesigned as a base class that supports any number of
connected ports, with the restriction to point-to-point being a specialized
subclass.  This would also allow a cleaner treatment of autofork (autoforking
geodesics could just be a subclass of Geodesic).  It would be necessary
to remove PortHole's belief that there is a unique far-side porthole, and
that would require rethinking the porthole type resolution algorithm;
probably type resolution should become a Geodesic function, not a PortHole
function.  This area will be addressed in some future version of Ptolemy.

\node Geodesic public members
\subsection{Geodesic public members}

\begin{example}
virtual PortHole* setSourcePort (GenericPort &\var{src}, int \var{delay} = 0);
\end{example}

Set the source port and the number of initial particles.  The actual
source port is determined by calling \code{newConnection} on \var{src};
thus if \var{src} is a MultiPortHole, the connection will be made to
some port within that MultiPortHole, and aliases will be resolved.
The return value is the ``real porthole'' used.

In the default implementation, if there is already a destination port,
any preexisting connection is broken and a new connection is completed.


\begin{example}
virtual PortHole* setDestPort (GenericPort &\var{dest});
\end{example}

Set the destination port to \code{\var{dest}.newConnection()}.  The
return value is the ``real porthole'' used.

In the default implementation, if there is already a source port,
any preexisting connection is broken and a new connection is completed.

\begin{example}
virtual int disconnect (PortHole & \var{p});
\end{example}

In the default implementation, if \var{p} is either the source port or
the destination port, both the source port and destination port are set
to null.  This is not enough to break a connection; as a rule,
\code{disconnect} should be called on the porthole, and that method
will call this one as part of its work.

\begin{example}
virtual void setDelay (int \var{newDelay});
\end{example}

Modify the delay (number of initial tokens) of a connection.  The
default implementation simply changes a count.

\begin{example}
virtual int isItPersistent() const;
\end{example}

Return true if the Geodesic is persistent (may exist in a disconnected
state) and false otherwise.  The default implementation returns false.

\begin{example}
PortHole* sourcePort () const;
PortHole* destPort () const;
\end{example}

Return my source and destination ports, respectively.

\begin{example}
virtual void initialize();
\end{example}

In the default implementation, this function initializes the number of
Particles to that given by the numInitialParticles field (the value
returned by \code{numInit()}; these Particles are obtained from the
Plasma (allocation pool) for the source port.  The particles will
have zero value for numeric particles, and will hold the ``empty message''
for message Particles.

\begin{example}
void put(Particle* \var{p});
\end{example}

Put a particle into the Geodesic (using a FIFO discipline).

\begin{example}
Particle* get();
\end{example}

Retrieve a particle from the Geodesic (using a FIFO discipline).
Return a null pointer if the Geodesic is empty.

\begin{example}
void pushBack(Particle* \var{p});
\end{example}

Push a Particle back into the Geodesic (onto the front of the queue,
instead of onto the back of the queue as \code{put} does).

\begin{example}
int size() const;
\end{example}

Return the number of Particles on the Geodesic at the current time.

\begin{example}
int numInit() const;
\end{example}

Return the number of initial particles.  This call is valid at any
time.  Immediately after \code{initialize}, \code{size} and
\code{numInit} return the same value (and this should be true for
any derived Geodesic as well), but this will not be true during
execution (where \code{numInit} stays the same and \code{size}
changes).

\begin{example}
StringList print(int verbose) const;
\end{example}

Print information on the Geodesic, overrides NamedObj function.

\begin{example}
virtual void incCount(int);
virtual void decCount(int);
\end{example}

These methods are available for schedulers such as the SDF scheduler to
simulate a run and keep track of the number of particles on the
geodesic.  \code{incCount} increases the count, \code{decCount}
decreases it, They are virtual to allow additional bookkeeping in
derived classes.

\node Geodesic protected members
\subsection{Geodesic protected members}

\begin{example}
void portHoleConnect();
\end{example}

This function completes a connection if the originating and
destination ports are set up.

\begin{example}
PortHole *originatingPort;
PortHole *destinationPort;
\end{example}

These protected members point to my neighbors.

\node class Plasma
\section{Class Plasma}

Class Plasma is a pool for particles.  It is derived from ParticleStack
(\pxref{class ParticleStack}).
Rather than allocating Particles as needed with \code{new} and freeing
them with \code{delete}, we instead provide an allocation pool for each
type of particle, so that very little dynamic memory allocation activity
will take place during simulation runs.

All Plasma objects known to the system are linked together.  As a rule,
there is one Plasma for each type of particle; however, each of these
objects is of type Plasma, not a derived type.  At all times, a Plasma
has at least one Particle in it; that Particle's virtual functions are
used to clone other particles as needed, determine the type, etc.

The constructor takes one argument, a reference to a Particle.  It
creates a one-element ParticleStack, and links the Plasma into a linked
list of all Plasma objects.

The \code{put} function (for putting a particle into the Plasma) adds a
particle to the Plasma's ParticleStack.  As a rule, it should not be
used directly; the Particle's \code{die} method will automatically add
it to the right Plasma (future releases may protect this method to
prevent its general use).

\begin{example}
Particle* get();
\end{example}

This function gets a Particle from the Plasma, creating a new one if
the Plasma has only one Particle on it (we never give away the last
Particle).

\begin{example}
DataType type();
\end{example}

Returns the type of the particles on the list (obtained by asking the
head Particle).

\begin{example}
static Plasma* getPlasma(DataType \var{type});
\end{example}

Searches the list of Plasmas for one whose type matches the argument,
and returns a pointer to it.  A null pointer is returned if there is
no match.

\node class ParticleQueue
\section{Class ParticleQueue}

Class ParticleQueue implements a queue of Particles.  It uses a member
of class ParticleStack to store the particles; it is not implemented
by deriving from ParticleStack.  It can implement a queue with finite
or unlimited capacity.

Rather than placing user-supplied Particles on the queue and removing
them directly, it takes over the responsibility for memory management
by allocating its own Particles from the Plasma and returning them
as needed.  When a user puts a Particle into the queue, the value of
the Particle is copied (with the Particle \code{clone} method);
similarly, when a user gets a Particle from the queue, he or she
supplies a Particle to received the copied value.  The advantage of
this is that the user need not worry about lifetimes of Particles --
when to create them, when it is safe to return them to the Plasma
or delete them.

The ParticleQueue default constructor forms an empty, unlimited capacity
queue.  There is also a constructor of the form

\begin{example}
ParticleQueue(unsigned int \var{cap});
\end{example}

This creates a queue that can hold at most \var{cap} particles.

The destructor returns all Particles in the queue to their Plasma.

\begin{example}
int empty() const;
\end{example}

Return TRUE if the queue is empty, else FALSE.

\begin{example}
int full() const;
\end{example}

Return TRUE if the length equals the capacity, else FALSE.

\begin{example}
unsigned int capacity() const;
\end{example}

Return the queue's capacity.  If unlimited, the largest possible
unsigned int on the machine will be returned.

\begin{example}
unsigned int length() const;
\end{example}

Return the number of particles in the queue.

\begin{example}
int putq(Particle& \var{p});
\end{example}

Put a copy of particle \var{p} into the queue, if there is room.
Returns TRUE on success, FALSE if the queue is already at capacity.

\begin{example}
int getq(Particle& \var{p});
\end{example}

Get a particle from the queue, and copy it into the user-supplied
particle \var{p}.  This returns TRUE on success, FALSE (and \var{p}
is unaltered) if the queue is empty.

\begin{example}
void setCapacity(int \var{sz});
\end{example}

Modify the capacity to \var{sz}, if \var{sz} is positive or zero.  If
negative, the capacity becomes infinite.

\begin{example}
void initialize();
\end{example}

Free up the queue contents.  Particles are returned to their pools and
the queue becomes empty.

\begin{example}
void initialize(int \var{n});
\end{example}

Equivalent to \code{initialize()} followed by \code{setCapacity(\var{n})}.

\node classes for Galaxy ports
\section{Classes for Galaxy ports}

Class GalPort is derived from class PortHole (\pxref{class PortHole}).

Class GalMultiPort is derived from class MultiPortHole
(\pxref{class MultiPortHole}).

These classes are used by InterpGalaxy (\pxref{class InterpGalaxy}),
and in other places, to create
galaxy ports and multiports that are aliased to some port of a member
block.  The constructor for each of these classes takes one argument,
the interior port that is to be the alias.  The \code{isItInput} and
\code{isItOutput} functions are implemented by forwarding the request
to the alias.

The PortHole type resolution algorithm
--------------------------------------

The type resolution algorithm is concerned with assigning concrete types
to ANYTYPE portholes and resolving conflicts between the types of connected
portholes.  The algorithm is somewhat complex since it tries to produce
convenient results in an area where the "right" behavior is not always easy
to define.  Ptolemy 0.7 introduces a new resolution algorithm that is hoped
to produce more convenient and less surprising results than the method
previously used.

The problem of connecting ports of different types is simple to resolve:
we say that the input porthole determines what particle type to use, and
that any necessary type conversion takes place when the output porthole
puts data into a particle (or buffer variable, in the case of codegen
domains).  The opposite convention would be about equally defensible, but
this is the one that has historically been used in Ptolemy.  It has the
advantage that star writers can presume that the declared type of an input
porthole is the data type that will actually be received, whenever the
declared type is not ANYTYPE.

Resolving ANYTYPE portholes is much more difficult.  We need to handle
several fundamental cases:

1) Printer and similar polymorphic stars, which accept any input type.
These simply declare their inputs to be ANYTYPE, and we need to resolve
them to the type of the connected output.  (Introducing any forced particle
type conversion would be very undesirable.)

2) Fork and similar stars, which want to bind multiple outputs to the type
of a given input.  Here the input porthole and output portholes are ANYTYPE,
and are bound into a type equivalence set by inheritTypeFrom().  If possible
we want to resolve all these portholes to the type of the output porthole
connected to the input.

3) Merge and similar stars, which have a single output type-equivalenced to
multiple inputs.  If the inputs all receive the same type of data, we should
resolve the output to that type.  If there is no common input type, but the
input connected to the single output has determinable type, we can resolve
the output porthole to that type (since the data would ultimately get
converted to that type, anyway).  If the connected input is ANYTYPE, we must
declare error, because we have no good way to choose a type for the Merge's
output.

We have to recursively propagate type information in order to deal with
chains of ANYTYPE stars, such as one Fork following another.

In some cases the type is really undefined.  Consider this universe
(using ptcl syntax)

\begin{example}
star f Fork; star p Printer
connect f output f input 1
connect f output p input
\end{example}

There are no types anywhere in the system.  We have little choice
but to declare an error.  Thus, the fact that we will sometimes
fail to assign a type is not an implementation shortcoming but an
unavoidable property of the problem.

These considerations lead to the following algorithm.  We first perform
a recursive scan to resolve ANYTYPE portholes, the results of which are
represented by a "preferred" type assigned to each porthole.  (A porthole
of non-ANYTYPE declared type always has that type as its preferred type;
so preferred type assignment is only interesting for ANYTYPE portholes.)
Then, the "resolved" type of each connected pair of input and output
portholes is the preferred type of the input porthole.  This is the type
that will be used for actual data transported between those portholes.
It is useful to explicitly store the preferred type, so that codegen domains
can detect type mismatches just by looking at individual output portholes.
A type conversion star can be spliced in wherever an output is found that
has preferredType != resolvedType.

Assignment of preferred types proceeds in two passes.  Pass 1 is "feed
forward" from outputs to inputs.  Pass 2 is "feed back" from inputs to
outputs; it is the dual of Pass 1.  Pass 2 is invoked only if Pass 1 is
unable to choose a type for a porthole.  The details are:

Pass 1: Non-ANYTYPE portholes are simply assigned their declared type as
preferred type.  If an ANYTYPE porthole is not a member of an equivalence
group, but is an input porthole and is connected to a porthole of
pass-1-assignable type, that porthole's type becomes its preferred type.
When an ANYTYPE porthole is a member of an equivalence group, the group is
scanned to see if it includes any non-ANYTYPE portholes; if so, they must all
agree in type, and that type becomes the preferred type of all members of the
group.  But usually, all the members of an equivalence set will be ANYTYPE.
Then, pass 1 scans all the input portholes of the group to see whether their
connected portholes have pass-1-assignable type.  If at least one does, and
all of the assignable ones have the same preferred type, then that common
type becomes the preferred type of all the members of the equivalence group.

Pass 2: If an unassigned ANYTYPE porthole is not a member of an equivalence
group, but is connected to a porthole of type assignable by either pass 1 or
pass 2, that porthole's type becomes its preferred type.  When an ANYTYPE
porthole is a member of an equivalence group, all the output portholes of the
group are scanned to see whether their connected portholes have type
assignable by either pass 1 or pass 2.  If at least one does, and all of the
assignable ones have the same preferred type, then that common type becomes
the preferred type of all the members of the equivalence group.

Pass 1 handles Fork-like stars as well as Merge stars whose inputs all have
the same type.  Pass 2 does something reasonable with Merge stars that have
inputs of different types: if the merge output is going to a port of knowable
type, we may as well just output particles of that type.  An error is
declared if a porthole's type remains unassigned after both passes.  This
occurs if a Merge-like star has inputs of nonidentical types and an output
connected to an (unresolvable) ANYTYPE input.  The user must insert type
conversion stars to coerce the Merge inputs to a common type, so that the
system can figure out what type to use for the Merge output.

Notice that each pass will resolve an equivalence set if all the
<b>assignable</b> connected portholes agree on a type; it is not required
that all the connected portholes be assignable.  This rule is needed to allow
resolution of schematics that contain type-free loops.  Here is an example:

\begin{example}
	star imp Impulse; star f Fork; star d Delay; star p Printer
	connect imp output f input#1
	connect f output d input
	connect d output f input#2
	connect f output p input
\end{example}

This schematic will work if we resolve all the ports to FLOAT (the output
type of Impulse).  But if we insist on both Fork inputs being resolved before
we assign a type to the Fork output, we will be unable to resolve the
schematic.  So, once Pass 1 has recursively traversed the schematic and
concluded that it can't yet assign a type to Fork's input#2, it uses the
FLOAT type found at input#1 to resolve the type of the Fork portholes.
Further recursion then propagates this result around the schematic.

This rather baroque-looking algorithm does have some simple properties.  In
particular, all members of an equivalence set are guaranteed to be assigned
the same preferred type; an error will be reported if this is not possible.

In some domains it is important that members of an equivalence set
have the same resolved type, not just the same preferred type.  (For
example, the CGC Fork star fails if this is not so, because its various
portholes are all just aliases for a single variable.)  The domain can
check this by seeing whether preferred type = resolved type for all
portholes.  If the types are not the same, it can either report an error
or splice in a type-conversion star to make them the same.

Note: it might be better to cause this to happen on a per-star-type basis,
not a per-domain basis, since one can imagine that some CG blocks would
need strict type equality of portholes while others would not.  This
improvement is not currently implemented.

The porthole type resolution algorithm is dependent on the notion that every
porthole is connected to just one other porthole.  If class Geodesic is ever
redesigned to support multiple connections directly, some work would be
needed.  A likely tactic is to move some or all of the resolution work into
Geodesic.  A one-to-one Geodesic could enforce the same behavior described
above, but one-to-many or many-to-many Geodesics would need different,
possibly domain-dependent behavior.

\node changes since Ptolemy 0.6
\section{Changes since Ptolemy0.6}

Ptolemy 0.7 introduces several changes related to porthole type resolution.

Older versions used a much simpler ANYTYPE resolution algorithm, which
essentially amounted to just pass 2 ("feed back") of the present method.
That had the serious deficiency that it couldn't decide what to do with
fork stars feeding inputs of multiple types.  For example, a fork star
receiving INT and outputting to INT and FLOAT portholes would lead to
a type resolution error.  In essence, the old code insisted on being
able to push type conversions back across a fork, and would fail if it
couldn't assign the same type to all the fork outputs.  The new algorithm
solves this problem by delaying type conversions until after a fork.
Occasionally this will introduce some inefficiency.  For example, if a
fork receives INT and feeds two FLOATs, the new method leads to a type
conversion being done separately on each fork output, whereas the old
method would have generated only one conversion at the fork input.
The improved ease of use of the new method is judged well worth this loss.

Formerly, the member ports of a multiporthole were always constrained to have
the same resolved type.  This is no longer true, since it gets in the way for
polymorphic stars.  But if a multiporthole is tied to another porthole via
inheritTypeFrom, then each member porthole will still be constrained to match
the type of that other porthole, at least in terms of preferred type.

Formerly, the HOF stars acted during the galaxy "setup" phase, in which each
block within the galaxy receives its setup call.  This proved inadequate
because porthole type resolution is done during setup; by the time a HOF star
acted, the types of the portholes connected to it would already have been
resolved.  For example, a HOFNop star formerly constrained all the particles
passing through it to be of the same type, because the porthole resolver
insisted on being able to choose a unique type for the HOFNop's output
porthole, even though that porthole is just a dummy that won't even exist at
runtime.  In Ptolemy 0.7, a "preinitialize" phase has been added so that HOF
stars can rewire the galaxy and remove themselves before any block setup or
porthole type resolution occurs.  The constraints on porthole types are then
only those resulting from the rewired schematic.

\node Particles and Messages
\chapter{Particles and Messages}

\node class Particle
\section{Class Particle}

A Particle is a little package that contains data; they represent the
principal communication technique that blocks use to pass results
around.  They move through PortHoles and Geodesics; they are allocated
in pools called Plasmas.  The class Particle is an abstract base class;
all real Particle objects are really of some derived type.

All Particles contain a link field that allows queues and stacks of
Particles to be manipulated efficiently (class ParticleStack is a base
class for everything that does this).

Particles also contain virtual operators for loading and accessing the
data in various forms; these functions permit automatic type conversion
to be easily performed.

\node Particle public members
\section{Particle public members}

\begin{example}
virtual DataType type() const = 0;
\end{example}

Return the type of the particle.  DataType is actually just a typedef
for \code{const char*}, but when we use DataType, we treat it as an
abstract type.  Furthermore, two DataType values are considered the
same if they compare equal, which means that we must assure that
the same string is always used to represent a given type.

\begin{example}
virtual operator int () const = 0;
virtual operator float () const = 0;
virtual operator double () const = 0;
virtual operator Complex () const = 0;
\end{example}

These are the virtual casting functions, which convert the data in
the Particle into the desired form.  The arithmetic Particles support
all these functions cleanly.  Message particles may return errors for
some of these functions (they must return a value, but may also call
\code{Error::abortRun}.

\begin{example}
virtual StringList print () const = 0;
\end{example}

Return a printable representation of the Particle's data.

\begin{example}
virtual void initialize() = 0;
\end{example}

This function zeros the Particle (where this makes sense), or
initializes it to some default value.

\begin{example}
virtual void operator << (int \var{arg}) = 0;
virtual void operator << (double \var{arg}) = 0;
virtual void operator << (const Complex& \var{arg}) = 0;
\end{example}

These functions are, in a sense, the inverses of the virtual casting
operators.  They load the particle with data from \var{arg}, performing
the appropriate type conversion.

\begin{example}
virtual Particle& operator = (const Particle& \var{arg}) = 0;
\end{example}

Copy a Particle.  In general, we permit this only for Particles of the
same type, and otherwise assert an error.  But the arithmetic particle
types invoke type conversion, via the virtual casting operators, so as to
allow assignment from other arithmetic particle types.  Without this
exception, useful cases such as forking an INT output to INT and FLOAT
inputs would fail in the simulation domains (because the fork stars use
particle assignment).

\begin{example}
virtual int operator == (const Particle&) = 0;
\end{example}

Compare two particles.  As a rule, Particles will be equal only if
they have the same type, and, in a sense that is separately determined
for each type, the same value.

\begin{example}
virtual Particle* clone() const = 0;
\end{example}

Produce a second, identical particle (as a rule, one is obtained from
the Plasma for the particle if possible).

\begin{example}
virtual Particle* useNew() const = 0;
\end{example}

This is similar to \code{clone}, except that the particle is allocated
from the heap rather than from the Plasma.

\begin{example}
virtual void die() = 0;
\end{example}

Return the Particle to its Plasma.

\begin{example}
virtual void getMessage (Envelope&);
virtual void accessMessage (Envelope&) const;
virtual void operator << (const Envelope&);
\end{example}

These functions are used to implement the Message interface.  The
default implementation returns errors for them; it is only if the
Particle is really a MessageParticle that they successfully send or
receive a Message from the Particle.

\node Arithmetic Particle classes
\section{Arithmetic Particle classes}

There are three standard arithmetic Particle classes: IntParticle,
FloatParticle, and ComplexParticle.  As their names suggest, each
class adds to Particle a private data member of type int, double (not
float!), and class Complex, respectively.

When a casting operator or ``\<\<'' operator is used on a particle of one of
these types, a type conversion may take place.  If the type of the
argument of cast matches the type of the particle's data, the data is
simply copied.  If the requested operation involves a ``widening''
conversion (int to float, double, or Complex; float to double or
Complex; double to Complex), the ``obvious'' thing happens.  Conversion
from double to int rounds to the nearest integer; conversion from
Complex to double returns the absolute value (not the real part!),
and Complex to int returns the absolute value, rounded to the nearest
integer.

\code{initialize} for each of these classes sets the data value to
zero (for the appropriate domain).

The DataTypes returned by these Particle types are the global symbols
INT, FLOAT, and COMPLEX, respectively.  They have the string values
``INT'', ``FLOAT'', and ``COMPLEX''.

\node Messages
\section{The Heterogeneous Message Interface}

The heterogeneous message interface is a mechanism to permit messages of
arbitrary type (objects of some derived type of class Message) to be
transmitted by blocks.  Because these messages may be very large,
facilities are provided to permit many references to the same Message;
Message objects are ``held'' in another class called Envelope.  As the
name suggests, Messages are transferred in Envelopes.  When Envelopes
are copied, both Envelopes refer to the same Message.  A Message will
be deleted when the last reference to it disappears; this means that
Messages must always be on the heap.

So that Messages may be transmitted by portholes, there is a class
MessageParticle whose data field is an Envelope.  This permits it to
hold a Message just like any other Envelope object.

\node class Envelope
\subsection{Class Envelope}

class Envelope has two constructors.  The default constructor constructs
an ``empty'' Envelope (in reality, the envelope is not empty but contains
a special ``dummy message'' -- more on this later).  There is also a
constructor of the form

\begin{example}
Envelope(Message& \var{data});
\end{example}

This constructor creates an Envelope that contains the Message
\var{data}, which MUST have been allocated with \code{new}.

Message objects have reference counts; at any time, the reference count
equals the number of Envelope objects that contain (refer to) the
Message object.  When the reference count drops to zero (because of
execution of a destructor or assignment operator on an Envelope object),
the Message will be deleted.

Class Envelope defines an assignment operator, copy constructor, and
destructor.  The main work of these functions is to manipulate reference
counts.  When one Envelope is copied to another, both Envelopes refer
to the same message.

\begin{example}
int empty() const;
\end{example}

Return TRUE if the Envelope is ``empty'' (points to the dummy message),
FALSE otherwise.

\begin{example}
const Message* myData() const;
\end{example}

Return a pointer to the contained Message.  This pointer must not be
used to modify the Message object, since other Envelopes may refer to
the same message.

\begin{example}
Message* writableCopy();
\end{example}

This method produces a writable copy of the contained Message, and
also zeros the Envelope (sets it to the empty message).  If this
Envelope is the only Envelope that refers to the message, the
return value is simply the contained message.  If there are multiple
references to the message, the \code{clone} method is called on the
Message, making a duplicate, and the duplicate is returned.

The user is now responsible for memory management of the resulting
Message.  If it is put into another Envelope, that Envelope will
take over the responsibility, deleting the message when there is
no more need for it.  If it is not put into another Envelope, the
user must make sure it is deleted somehow, or else there will be
a memory leak.

\begin{example}
int typeCheck(const char* \var{type}) const;
\end{example}

This member function asks the question ``is the contained Message
of class \var{type}, or derived from \var{type}''?  It is implemented by
calling \code{isA} on the Message.  Either TRUE or FALSE is returned.

\begin{example}
const char* typeError(const char* \var{expected}) const;
\end{example}

This member function may be used to format error messages for when
one type of Message was expected and another was received.  The
return value points to a static buffer that is wiped out by subsequent
calls.

\begin{example}
const char* dataType() const;
int asInt() const;
double asFloat() const;
Complex asComplex() const;
StringList print() const;
\end{example}

All these methods are ``passthrough methods''; the return value is the
result of calling the identically named function on the contained
Message object.

\node class Message
\subsection{Class Message}

Message objects can be used to carry data between blocks.  Unlike
Particles, which must all be of the same type on a given connection,
connections that pass Message objects may mix message objects of
many types on a given connection.  The tradeoff is that blocks that
receive Message objects must, as a rule, type-check the received
objects.

The base class for all messages, named Message, contains no data, only
a reference count (accordingly, all derived classes have a reference
count and a standard interface).  The reference count counts how many
Envelope objects refer to the same Message object.

The constructor for Message creates a reference count that lives on
the heap.  This means that the reference count is non-const even when
the Message object itself is const.

The copy constructor for Message ignores its argument and creates a
new Message with a new reference count.  This is necessary so that no
two messages will share the same reference count.

The destructor, which is virtual, deletes the reference count.

The following Message functions must be overridden appropriately in any
derived class:

\begin{example}
virtual const char* dataType() const;
\end{example}

This function returns the type of the Message.  The default
implementation returns ``DUMMY''.

\begin{example}
virtual Message* clone() const;
\end{example}

This function produces a duplicate of the object it is called on.
The duplicate must be ``good enough'' so that applications work the
same way whether the original Message or one produced by \code{clone()}
is received.  A typical strategy is to define the copy constructor
for each derived Message class and write something like

\begin{example}
Message* MyMessage::clone() const \{ return new MyMessage(*this);\}
\end{example}

\begin{example}
virtual int isA(const char*) const;
\end{example}

The \code{isA} function returns true if given the name of the class
or the name of any base class.  Exception: the base class function returns
FALSE to everything (as it has no data at all).  A macro \code{ISA\_FUNC}
is defined to automate the generation of implementations of derived
class \code{isA} functions; it is the same one as that used for the
NamedObj class.

The following methods may optionally be redefined.

\begin{example}
virtual StringList print() const;
\end{example}

This method returns a printable representation of the Message.
The default implementation returns a message like

\begin{example}
Message class <\var{type}>: no print method
\end{example}

where \var{type} is the message type as returned by the \code{dataType}
function.

\begin{example}
virtual int asInt() const;
virtual double asFloat() const;
virtual Complex asComplex() const;
\end{example}

These functions represent conversions of the Message data to an integer,
a floating point value, and a complex number, respectively.  Usually
such conversions do not make sense; accordingly, the default
implementations generate an error message (using the protected member
function \code{errorConvert}) and return a zero of the appropriate type.
If a conversion does make sense, they may be overridden by a method that
does the appropriate conversion.  These methods will be used by the
MessageParticle class when an attempt is made to read a MessageParticle
in a numeric context.

One protected member function is provided:

\begin{example}
int errorConvert(const char* \var{cvttype}) const;
\end{example}

This function invokes \code{Error::abortRun} with a message of the
form

\begin{example}
Message class <\var{msgtype}>: invalid conversion to \var{cvttype}
\end{example}

where \var{msgtype} is the type of the Message, and \var{cvttype} is
the argument.

\node class MessageParticle
\subsection{Class MessageParticle}

MessageParticle is a derived type of Particle (\pxref{class Particle})
whose data field is an
Envelope; accordingly, it can transport Message objects.

MessageParticle defines no new methods of its own; it only provides
behaviors for the virtual functions defined in class Particle.
The most important such behaviors are as follows:

\begin{example}
void operator << (const Envelope& \var{env});
\end{example}

This method loads the Message contained in \var{env} into the Envelope
contained in the MessageParticle.  Since the Envelope assignment
operator is used, after execution of this method both \var{env} and
the MessageParticle refer to the message, so its reference count is at
least 2.

\begin{example}
void getMessage(const Envelope& \var{env});
\end{example}

This method loads the message contained in the MessageParticle into the
Envelope \var{env}, and removes the message from the MessageParticle
(so that it now contains the dummy message).  If \var{env} previously
contained the only reference to some other Message, that previously
contained Message will be deleted.

\begin{example}
void accessMessage(const Envelope& \var{env});
\end{example}

\code{accessMessage} is the same as \code{getMessage} except that the
message is not removed from the MessageParticle.  It can be used in
situations where the same Particle will be read again.  We recommend
that \code{getMessage} be used where possible, especially for very
large message objects, so that they are deleted as soon as possible.

\node Example Message types
\section{Example Message types}

The kernel provides two simple sample message types for transferring
arrays of data.  They are almost identical except that one holds an
array of integers and the other holds an array of single precision
floating point data.  The array contents live on the heap.  Each is
derived from class Message.

Each provides a public data member that points to the data.  As a rule,
we recommend against public data members for classes, but an exception
was made in this case, perhaps unwisely.

This section will describe the interface of the FloatVecData class.
The interface for IntVecData is almost identical.

Three constructors are provided:

\begin{example}
FloatVecData(int \var{len});
\end{example}

This form creates an uninitialized array of length \var{len} in the
FloatVecData object.  Since the pointer to the data is public the
array may easily be filled in.

\begin{example}
FloatVecData(int \var{len},const float *\var{srcData});
\end{example}

This form creates an array of length \var{len} and initializes it with
\var{len} elements from \var{srcData}.

\begin{example}
FloatVecData(int \var{len},const double *\var{srcData});
\end{example}

This form is the same, except that the source data is double precision
(it is converted to single precision).  This is the only function for
which an analogous function does not exist in IntVecData (an IntVecData
can only be initialized from an integer array).

An appropriate copy constructor, assignment operator, and destructor
are defined.

\begin{example}
int length() const;
\end{example}

Return the length of the array.

\begin{example}
float *data;
\end{example}

Public data member; points to the array.  It is permissible to read or
assign the \var{len} elements starting at \code{data}; the effect of
altering the \code{data} pointer itself is undefined.

\begin{example}
const char* dataType() const;
\end{example}

Returns the string \code{"FloatVecData"}.

\begin{example}
int isA(const char* \var{type}) const;
\end{example}

TRUE for \var{type} equal to \code{"FloatVecData"}, otherwise false.

\begin{example}
StringList print() const;
\end{example}

Returns a comma-separated list of elements enclosed in curly braces.

\begin{example}
Message* clone() const;
\end{example}

Creates an identical copy with \code{new}.

\node The incremental linker
\chapter{The incremental linker}

The incremental linker permits user written code to be added to the
system at runtime.  Two different mechanisms are provided, called
a temporary link and a permanent link.  

With either a temporary link or a permanent link, code is linked using
the incremental linking facilities of the Unix linker, the new code is
read into the Ptolemy executable, and symbols corresponding to C++
global constructors are located and called.  This means that such code
is expected to register objects on Ptolemy's known lists
(e.g. KnownBlock, KnownState, or KnownTarget) so that new classes
become usable.

\emph{Warning:} if the executable containing the Linker class is
stripped, the incremental linker will not work!

\node ld -A style linking vs. dlopen() style linking
\subsection{ld -A style linking vs. dlopen() style linking}

There are two ways incremental linking is implemented: ``ld -A'' and
``dlopen()'' style linking.

1. The first type of implementation uses a BSD Sun-style loader with
the -A flag to load in .o files.  Usually, binaries that are to be
dynamically linked must be built with the -N option.  This is the
older style of linking present in Ptolemy0.5 and earlier.

2. The second type of implementation uses the System V Release 4
\code{dlopen()} call to load in shared objects (.so files).
SunOS4.1.x, Solaris2.x and Irix5.x support this style of dynamic
linking.  In Ptolemy0.6, only the sol2, sol2.cfront, and hppa architectures
support dynamic linking of shared objects.

The interface to both styles of linking is very similar, though there
are differences.

\node Types of links
\subsection{Temporary vs. Permanent Incremental Linking}

Code that is linked in by the ``temporary link'' technique does not
alter the symbol table in use.  For that reason, subsequent incremental
links, whether temporary or permanent, cannot ``see'' any code that
was linked in by previous temporary links.  The advantage is that the
same symbols (for example, a Ptolemy star definition) may be redefined,
which is useful in code development, as buggy star definitions can be
replaced by valid ones without exiting Ptolemy.

Code that is linked in by the ``permanent link'' method has the same
status as code that was linked into the original executable.  

With ``ld -A'' style incremental linking, a permanent link creates or
replaces the \file{.pt\_symtable} file in the directory in which
Ptolemy was started.  This file contains the current symbol table for
use by subsequent links, temporary or permanent.  This file is deleted
when the Ptolemy process exits normally.  It is left around when the
process crashes, as it is useful for debugging (as it contains symbols
for object files that were incrementally linked using the permanent
method as well as those in the original executable).

With \code{dlopen()} style incremental linking, we keep track of all
the files that have been permanently linked in.  After a file has been
permanently linked in, each successive link (permanent or not)
includes all the permanently linking in files.  That is, if we permanently
link in foo.o, then when we link in bar.o, we will generate a shared
object file that includes both foo.o and bar.o, and then call
\code{dlopen()} on that shared object file.  

Note that with \code{dlopen()} style linking it is possible to relink
in stars that have been permanently linked.  When a file is to be
linked in, we check against the list of permanently linked in file
names and remove any duplicates.  This method of checking will fail if
one permanently links in a file, and then links in the same file as a
different name, perhaps through the use of symbolic links. That is, if
we permanently link in \file{./foo.o} and \code{./bar.o} is a link to
\file{./foo.o}, when we link in \code{./bar.o}, we will have multiple
symbols defined, and we will get an error. In other words, we only
check for duplicate file names, we do not check for duplicate symbols
in any files, the loader does this for us.

Currently each
\code{dlopen()} style link generates a temporary shared object in
\file{/tmp}.  If you are doing a large number of \code{dlopen()} style
permanent links, you will have many files in \file{/tmp}.  We hope to
resolve this potential problem in a later release.  Eventually, it
would be nice if the code read the value of an optional environment
variable, such as \code{TMPDIR}.


\node Linker public members
\subsection{Linker public members}


\begin{example}
static void init(const char* \var{execName});
\end{example}

This function initializes the linker module by telling it where the
executable for this program is.  For most purposes, passing it the
value of \code{argv[0]} passed to the \code{main} function will
suffice.

\begin{example}
static int linkObj(const char* \var{objName});
\end{example}

Link in a single object module using the temporary link mechanism
(this entry point is provided for backward compatibility).

\begin{example}
static int multiLink(const char* \var{args}, int \var{permanent});
static int multiLink(int \var{argc}, char** \var{argv});
\end{example}

Both of these functions give access to the main function for doing
an incremental link.  They permit either a temporary or a permanent
link of multiple files; flags to the Unix linker such as \code{-l}
to specify a library or \code{-L} to specify a search directory for
libraries are permitted.  For the first form, \var{args} are passed
as part of a linker command that is expanded by the Unix shell.  A
permanent link is performed if \var{permanent} is true (nonzero);
otherwise a temporary link is performed.

The second form is provided for ease of interfacing to the Tcl
interpreter, which likes to pass arguments to commands in this
style.  In this case, \code{\var{argv}[0]} indicates the type of
link: if it begins with the character \code{p}, a permanent link
is performed; otherwise a temporary link is performed.  The remaining
arguments are concatenated (separated by spaces) and appear in the
argument to the Unix linker.

\begin{example}
static int isActive();
\end{example}

This function returns TRUE if the linker is currently active (so objects
can be marked as dynamically linked by the known list classes).
Actually the flag it returns is set while constructors or other
functions that have just been linked are being run.

\begin{example}
static int enabled();
\end{example}

Returns true if the linker is enabled (it is enabled by calling
\code{Linker::init} if that function returns successfully).  On
platforms that do not support dynamic linking, this function
always returns false (zero).

\begin{example}
static const char* imageFileName();
\end{example}

Return the fully-expanded name of the executable image file (set by
\code{Linker::init}).

\begin{example}
static void setDefaultOpts(const char* \var{newValue});
static const char* defaultOpts();
\end{example}

These functions set or return the linker's default options, a set of
flags appended to the end of the command line by all links.

\node Linker implementation
\subsection{Linker implementation}

For each port of Ptolemy to a particular release, the Linker is
implemented in one of two styles: ``ld -A'' style  or ``dlopen()''
style.  We discuss each style below.

\node Shared Objects
\subsection{Shared Objects and dlopen() style linking}

If a Ptolemy release on a platform supports \code{dlopen} style
dynamic linking, then the ptcl \code{link} command can be called with
either a \file{.o} file or a \file{.so} file.

If the \code{link} ptcl command is passed a \file{.o} file, then a
\file{.so} file will be generated.

If link ptcl command is passed a \file{.so} file, then the \file{.so}
file will be loaded.  If the \file{.so} file does not exist, then an
error message will be produced and the link will return.

There are several ways to specify the path to a shared object.

1) Using just a file name ``link foo.so'' will not work unless
LD\_LIBRARY\_PATH includes the directory where \file{foo.so} resides.
The man pages for code{dlopen()} and code{ld} discuss LD\_LIBRARY\_PATH

Interestingly, using code{putenv()} to set LD\_LIBRARY\_PATH from within ptcl
has no effect on the runtime loader.
	
2) If the file name begins with ``./'', then the current directory is
searched.  ``link ./foo.so'' should work, as will ``link ./mydir/foo.so''

3) If the file name is an absolute path name, then the shared object
will be loaded. ``link /tmp/foo.so'' should work.

4) Dynamic programs can have a run path specified at link time.  The
run path is the path searched at runtime for shared object.  (Under
Solaris2.3, the -R option to ld controls the run path.  Under Irix5.2,
the -rpath option to ld controls the run path).
If ptcl or pigiRpc has been compiled with a run path built in, and the
shared object is in that path, then the shared object will be found.

The Sun Linker Manual says:
	``To locate the shared object foo.so.1, the runtime linker will
	use any LD\_LIBRARY\_PATH definition presently in effect,
	followed by any runpath specified during the link-edit of prog
	and finally, the default location /usr/lib.  If the file name
	had been specified ./foo.so.1, then the runtime linker would
	have searched for the file only in the present working
	directory.''

	
\node Porting the Dynamic Linker
\subsection{Porting the Dynamic Linking capability}

This section is intended to assist those that attempt to port the
Linker module to other platforms.

The Linker class is implemented in three files: \file{Linker.h},
specifying the class interface, \file{Linker.cc}, specifying the
implementation, and \file{Linker.sysdep.h}, specifying all the machine
dependent parts of the implementation.

To turn on debugging, compile \file{Linker.cc} with the DEBUG flag
defined.  One way to do this would be:
\begin{example}
cd $PTOLEMY/obj.$PTARCH/kernel; rm -f Linker.o; make OPTIMIZER=-DDEBUG
\end{example}

The Linker class currently uses ``ld -A'' style dynamic linking on the
Sun4 (Sparc) running SunOS4.1 and \code{g++}, the Sun4 (Sparc) running
SunOS4.1 and Sun's \code{cfront} port, DECStations running Ultrix,
HP-PA running \code{g++} or HP's \code{cfront} port.

The Linker class currently uses ``dlopen()'' style dynamic linking on the
Sun4 (Sparc) running Solaris2.3 and \code{g++}, the Sun4 (Sparc) running
Solaris2 and Sun's \code{cfront} port (Sun \code{CC-3.0}), the Sun4 (Sparc)
running Solaris2 and Sun's native C++ compiler \code{CC-4.0}, and SGI
Indigos running IRIX-5.2 and \code{g++}.

Currently Linux does not support any form of dynamic linking within
Ptolemy. 

The intent is to structure the code in such a way that no \code{#ifdef}s
appear in \file{Linker.cc}; they should all be in \file{Linker.sysdep.h}.

\node ld -A style linking
\subsection{ld -A Style Dynamic Linking}

The linker reads all new code into a pre-existing large array, rather
than creating blocks of the right size with \code{new}, because the
right size is not known in advance but a starting location must, as a
rule, be passed to the loader in advance.  This means that there is a
wired-in limit to how much code can be linked in.  The symbol
\code{LINK\_MEMORY}, which is set to one megabyte by default, is easily
changed if required.

Here are the steps taken by the linker to do its work:

Align the memory as required.

Form the command line and execute the Unix linker.  Only certain flags
in the command line will be system-dependent.

Read in the object file.  This is heavily system-dependent.

Make the read-in text executable.  On most systems this is a
do-nothing step. On some platforms (such as HP) it is necessary to
flush the instruction cache and that would be done at this point.

Invoke constructors in the newly read in code.  Constructors are found
by use of the \file{nm} program; the output is parsed to search for
constructor symbols, whose form depends on the compiler used.

If this is a permanent link, copy the linker output to file
\file{.pt\_symtable}; otherwise delete it.

\node dlopen() style linking
\subsection{dlopen() Style Dynamic Linking}

Here's how we link in an object using \code{dlopen()} style linking.

Generate a list of files to be linked in.  If we have not yet done a
permanent link, then the list of files to be linked in will consist of
only the files in this link or multilink command.

If the link is a permanent link, then we save the object name. For
each successive link, we check the name of the object to be linked in
against the list of objects permanently linked for duplicate file
names.  For each link after a permanent link, we include the names of
all the unique permanently linked in objects in the generation of a
temporary shared object file.

Generate a shared object \file{.so} file from all the objects to be
linked in.  The \file{.so} file is created in /tmp.

Do a \code{dlopen()} on the shared object.

Most architectures use \code{nm} to search for constructors, which are then
invoked.  Currently, sol2.cfront does not need to search for, or
invoke constructors.  gcc-2.5.8 has patches that allow similar
functionality, but apparently these patches are not in gcc-2.6.0.

Shared libraries in the SVR4 implementation contain optional \code{\_\_init}
and \code{\_\_fini} functions, called when the library is first connected to
(at startup or \code{dlopen()}) and when the library is disconnected from (at
\code{dlclose()} or program exit), respectively.  Some C++ implementations
can arrange for these \code{\_\_init} and \code{\_\_fini} functions to
contain calls to all the global constructors or destructors.  On
platforms where this happens, such as sol2.cfront, there is no need
for the Linker class to explicitly call the constructors, as this will
happen automatically.

\node Parameters and States
\chapter{Parameters and States}

A State is a data structure associated with a block, used to remember
data values from one invocation to the next.
For example, the gain of an automatic gain controller is a state.
A state need not be dynamic; for instance, the gain of fixed
amplifier is a state.
A parameter is the initial value of a state.

A State actually has two values: the initial value, which is always
a character string, and a current value, whose type is different for
each derived class of State: integer for IntState, an array of real
values for FloatArrayState, etc.
In addition, states have attributes, which represent logical properties
the state either has or does not have.

\node class State
\section{Class State}

Class State is derived from class NamedObj (\pxref{class NamedObj}).

The State base class is an abstract class; you cannot create a plain State.
The base class contains the initial value, which is always a
\code{const char*}; the derived classes are expected to provide
current values of appropriate type.

The constructor for class State sets the initial value to a null
pointer, and sets the state's attributes to a value determined by
the constant AB\_DEFAULT, which is defined in ``State.h'' to be the
bitwise or of AB\_CONST and AB\_SETTABLE.
The destructor does nothing extra.

\node State public members
\subsection{State public members}

\begin{example}
State& setState(const char* \var{stateName}, Block* \var{parent},
               const char* \var{initValue}, const char* \var{desc} = NULL);
\end{example}

This function sets the name, parent, initial value, and optionally the
descriptor for a state.  The character strings representing the initial
value and descriptor must outlive the State.

\begin{example}
State& setState(const char* \var{stateName}, Block* \var{parent},
               const char* \var{initValue}, const char* \var{desc},
               Attribute \var{attr});
\end{example}

This function is the same as the other \code{setState}, but it also
sets attributes for the state.  The Attribute object represents a
set of attribute bits to turn on or off.

\begin{example}
void setInitValue(const char* \var{valueString});
\end{example}

This function sets the initial value to \var{valueString}.  This
string must outlive the State.

\begin{example}
const char* initValue () const;
\end{example}

Return the initial value.

\begin{example}
virtual const char* type() const = 0;
\end{example}

Return the type name (for use in user interfaces, for example).
When states are created dynamically (by the KnownState or InterpGalaxy
class), it is this name that is used to specify the type.

\begin{example}
virtual int size() const;
\end{example}

Return the size (number of distinct values) in the state.  The
default implementation returns 1.  Array state types will return the
number of elements.

\begin{example}
virtual int isArray() const;
\end{example}

Return TRUE if this state is an array, false otherwise.  The default
implementation returns false.

\begin{example}
virtual void initialize() = 0;
\end{example}

Initialize the state.  The \code{initialize} function for a state is
responsible for parsing the initial value string and setting the current
value appropriately; errors are signaled using the
\code{Error::abortRun} mechanism.

\begin{example}
virtual StringList currentValue() const = 0;
\end{example}

Return a string representation of the current value.

\begin{example}
void setCurrentValue(const char* \var{newval});
\end{example}

Modify the current value, in a type-independent way.  Notice that this
function is not virtual.  It exploits the semantics of \code{initialize}
to set the current value using other functions; the initial value is
not modified (it is saved and restored).

\begin{example}
virtual State* clone() const = 0;
\end{example}

Derived state classes override this method to create an identical
object to the one the method is called on.

\begin{example}
StringList print(int \var{verbose}) const;
\end{example}

Output all info.  This is NOT redefined for each type of state.

\begin{example}
bitWord attributes() const;
\end{example}

Return my attribute bits.

\begin{example}
bitWord setAttributes(const Attribute& \var{attr});
bitWord clearAttributes(const Attribute& \var{attr});
\end{example}

Set or clear attributes.

\begin{example}
InvoveInterp interp
\end{example}

An external interpreter for evaluating commands in a parameter
definition preceded by the ! character and surrounded in quotes.
By default, no interpreter is defined.
If the interpreter were defined as the Tcl interpreter, then
\code{! "expr abs(cos(1.0))"} would compute 0.540302.
Other parameters can be referenced as usual by using curly braces, e.g.
\code{! "expr abs(cos(\{gain\}))"}.


\node The State parser
\subsection{The State parser and protected members}

Most of the protected interface in the State class consists of a simple
recursive-descent parser for parsing integer and floating expressions
that appear in the initial value string.
The ParseToken class represents tokens for this parser.
It contains a token type (an integer code) and a token value, which is a
union that represents either a character value, a string value, an
integer value, a double value, a Complex value, or a State value
(for use when the initializer references another state).
Token types are equal to the ASCII character value for single-character tokens.
Other possible token values are:
\begin{itemize}
\item \code{T\_EOF} for end of file,
\item \code{T\_ERROR} for error,
\item \code{T\_Float} for a floating value,
\item \code{T\_Int} for an integer value,
\item \code{T\_ID} for a reference to a state, and
\item \code{T\_STRING} for a string value.
\end{itemize}
For most of these, the token value holds the appropriate value.

Most derived State classes use this parser to provide uniformity
of syntax and error reporting; however, it is not a requirement to
use it.
Derived State classes are expected to associate a Tokenizer object
with their initial value string.
The functions provided here can then be used to parse expressions
appearing in that string.

\begin{example}
ParseToken getParseToken(Tokenizer& \var{tok}, int \var{wantedType}= T\_Float);
\end{example}

This function obtains the next token from the input stream associated
with the Tokenizer.
If there is a pushback token, that token is returned instead.
If it receives a '<' token, then it assumes that the next string delimited
by white space is a file name.
It substitutes references to other parameters in the filename and then
uses the Tokenizer's include file capability to insert the contents of
the file into the input stream.
If it receives a '!' token, then it assumes that that the next string delimited 
by white space is a command to be evaluated by an external interpreter.
It substitutes references to other parameters in the command,
sends the resulting string to the interpreter defined by interp member
described above for evaluation, and inserts the result into the input stream.
The information both read from an external file and returned from an external
interpreter is also parsed by this function.
Therefore, the external interpreter can perform both numeric and symbolic
computations.

When the parser hits the end of the input stream, it returns T\_EOF.
The characters in the set \code{\,\[\]\+\*\-\/\(\)^} are considered to be special
and the lexical value is equal to the character value.
Integer and floating values are recognized and evaluated to produce
either T\_Int or T\_Float tokens.  However, the decision is based on
the value of \var{wantedType}; if it is T\_Float, all numeric values
are returned as T\_Float; if it is T\_Int, all numeric values are returned
as T\_Int.

Names that take the form of a
C or C++ identifier are assumed to be names of states defined at a
higher level (states belonging to the parent galaxy or some ancestor
galaxy).  They are searched for using \code{lookup}; if not found,
an error is reported using \code{parseError} and an error token is
returned.  If a State is found, a token of type T\_ID is returned if
it is an array state or COMPLEX; otherwise the state's current value
is substituted and reparsed as a token.  This means, for example, that
a name of an IntState will be replaced with a T\_Int token with the
correct value.

\begin{example}
const State* lookup(const char* \var{name}, Block* \var{b});
\end{example}

This method searches for a state named \var{name} in Block \var{b} or
one of its ancestors, and either returns it or a null pointer if
not found.

\begin{example}
void parseError (const char* \var{part1}, const char* \var{part2} = "");
\end{example}

This method produces an appropriately formatted error message with
the name of the state and the arguments and calls \code{Error::abortRun}.

\begin{example}
static ParseToken pushback();
static void setPushback(const ParseToken&);
static void clearPushback();
\end{example}

These functions manipulate the pushback token, for use in parsing.
The first function returns the current pushback token, the second
sets it to be a copy of the argument, the third clears it.
There is only one such token, so the state parser is not reentrant.

\begin{example}
ParseToken evalIntExpression(Tokenizer& \var{lexer});
ParseToken evalIntTerm(Tokenizer& \var{lexer});
ParseToken evalIntFactor(Tokenizer& \var{lexer});
ParseToken evalIntAtom(Tokenizer& \var{lexer});
\end{example}

These four functions implement a simple recursive-descent expression
parser.

An expression is either a term or a series of terms with intervening '+'
or '-' signs.

A term is either a factor or a series of factors with interventing '*'
or '/' signs.

A factor is either an atom or a series of atoms with intervening '^'
signs for exponentiation.  (Note, C fans!  ^ means exponentiation, not
exclusive-or!).

An atom is any number of optional unary minus signs, followed either
by a parenthesized expression or a T\_Int token.

If any of these methods reads too far, the pushback token is used.
All \code{getParseToken} calls use \var{wantedType} T\_Int, so any
floating values in the expression are truncated to integer.

The token types returned from each of these methods will be one of
T\_Int, T\_EOF, or T\_ERROR.

\begin{example}
ParseToken evalFloatExpression(Tokenizer& \var{lexer});
ParseToken evalFloatTerm(Tokenizer& \var{lexer});
ParseToken evalFloatFactor(Tokenizer& \var{lexer});
ParseToken evalFloatAtom(Tokenizer& \var{lexer});
\end{example}

These functions have the identical structure as the corresponding
Int functions.

The token types returned from each of these methods will be one of
T\_Float, T\_EOF, or T\_ERROR.

\node types of states
\section{types of states}

\node scalar states
\subsection{Class IntState and class FloatState}

Class IntState, derived from State, has an integer current value.
Its \code{initialize()} function uses the \code{evalIntExpression}
function to read an integer expression from the initial value
string.  If successful, it attempts to read another token from
the string; if there is another token, it reports the error
``extra text after valid expression''.

An assignment operator is provided that accepts an integer value
and loads it into the current value.  A cast to integer is also
defined for accessing the current value.  The virtual function
\code{currentValue} is overloaded to return a printed version of
the current value.

In addition to the \code{setInitValue} from class State, a second
form is provided that takes an integer argument.

Standard overrides for \code{isA}, \code{className}, and \code{clone}
are provided.

Class FloatState is almost identical to class IntState except that
its data field is a double precision value; where IntState functions
have an argument or return value of \code{int}, FloatState has a
corresponding argument or return value of \code{double}.  Both are
generated from the same pseudo-template files.

The \code{type()} function for IntState returns \code{"INT"}.
For FloatState, \code{"FLOAT"} is returned.  For both implementations, a
prototype object is added to the KnownState list.

\node class ComplexState
\subsection{Class ComplexState}

ComplexState is much like FloatState and IntState, except in the
expressions it accepts for initial values.  Its data member is
Complex and it accordingly defines an assignment operator that takes a
complex value and a conversion operator that returns one.

The initial value string for a ComplexState takes one of three forms:
it may be the name of a galaxy ComplexState, a floating expression
(of the form accepted by \code{State::evalFloatExpression}), or a
string of the form

\begin{example}
( \var{floatexp1} , \var{floatexp2} )
\end{example}

where both \var{floatexp1} and \var{floatexp2} are floating expressions.
For the second form, the imaginary part will always be zero.  For the
third form, the first expression gives the real part and the second
gives the imaginary part.

\node class StringState
\subsection{Class StringState}

A StringState's current value is a string (more correctly, of type
\code{const char*}).  The current value is created by the
\code{initialize()} function by scanning the initial value string.
This string is copied literally, except that curly braces are special.
If a pair of curly braces surrounds the name of a galaxy state, the
printed representation of that state's current value (returned by
the \code{currentValue} function) is substituted.  To get a literal
curly brace in the current value, prefix it with a backslash.

Class StringState defines assignment operators so that different
string values can be copied to the current value; the value is
copied with \code{savestring} (\pxref{utility functions})
and deleted by the destructor.

\node numeric array states
\subsection{numeric array states}

Classes IntArrayState and FloatArrayState are produced from the same
pseudo-template.  Class ComplexArrayState has a very similar design.
All return TRUE to \code{isArray}, provide an array element selection
operator (\code{operator[](int)}), and an operator that converts
the state into a pointer to the first element of its data (much like
arrays in C).

The expression parser for FloatArrayState accepts a series of ``subarray
expressions'', which are concatenated together to get the current value
when \code{initialize()} is called.  Subarray expressions may specify
a single element, some number of copies of a single element, or a
galaxy array state of the same type (another FloatArrayState).  A
single element specifier may either be a floating point value, a
scalar (integer or floating) galaxy state name, or a general floating
expression enclosed in parentheses.  A number of copies of this
single element can be specified by appending an integer expression
enclosed in square brackets.

The expression parsers for IntArrayState and ComplexArrayState differ
only that where FloatArrayState wants a floating expression,
IntArrayState wants an integer expression and ComplexArrayState
wants a complex expression (an expression suitable for initializing
a ComplexState).

\node class StringArrayState
\subsection{Class StringArrayState}

As its name suggests, the current value for a StringArrayState is
an array of strings.
White space in the initial value string separates ``words'', and
Each word is assigned by \code{initialize()} into a separate array element.
Quotes can be use to permit ``words'' to have white space.

Current values of galaxy states can be converted into single elements
of the StringArrayState value by surrounding their names with curly
braces in the initial value.  Galaxy StringArrayState names will
be translated into a series of values.

There is currently no provision for modifying the current value of
a StringArrayState other than calling of \code{initialize} to parse
the current value string.

\node known lists
\chapter{Support for known lists and such}

Ptolemy is an extensible system, and in quite a few places it must
create objects given only the name of that object.  There are therefore
several classes that are responsible for maintaining lists: the list of
all known domains, of all known blocks, states, targets, etc.  As a
general rule, these classes support a \code{clone} or \code{makeNew}
method to create a new object based on its name (you cannot clone a
domain, however).

\node class KnownBlock
\section{Class KnownBlock}

The KnownBlock class is responsible for keeping a master list of all
known types of Block objects in the system.  All member functions of
KnownBlock are static; the only non-static function of KnownBlock is
the constructor.

The KnownBlock constructor has the form

\begin{example}
KnownBlock(Block& \var{block},const char* \var{name});
\end{example}

The only reason for constructing a KnownBlock object is for the side
effects; the side effect is to add \var{block} to the known block list
for its domain under the name \var{name}, using \code{addEntry}.

The reason for using a constructor for this purpose is that constructors
for global objects are called before execution of the main program;
constructors therefore serve as a mechanism for execution of arbitrary
initialization code for a module (as used here, ``module'' is an object
file).  Hence \file{ptlang}, the Ptolemy star preprocessor, generates
code like the following for star definitions:

\begin{example}
static XXXMyClass proto;
static KnownBlock entry(proto,"MyClass");
\end{example}

This code adds a prototype entry of the class to the known list.

Dynamically constructed block types, such as interpreted galaxies,
are added to the known list with a direct call to KnownBlock::addEntry.
These cases should always supply an appropriate definition-source
string so that conflicting block type definitions can be detected.

KnownBlock keeps track of the source of the definition of every
known block type.  This allows compile.c to determine whether an Oct
facet needs to be recompiled (without the source information, different
facets that have the same base name could be mistaken for each other).
This also allows us to generate some helpful warning messages when
a block name is accidentally re-used.  The source location information
is currently rather crude for everything except Oct facets, but that's
good enough to generate a useful warning in nearly all cases.

KnownBlock assigns a sequential serial number to each definition or
redefinition of a known block type.  This can be used, for example,
to determine whether a galaxy has been compiled more recently than
any of its constituent blocks.

\begin{example}
static void addEntry (Block & \var{block}, const char* \var{name}, 
	int \var{onHeap} const char* \var{definitionSource});
\end{example}

This function actually adds the block to the list.  Separate lists are
maintained for each domain; the block is added to the list corresponding to
`block.domain()'.  If onHeap is true, the block will be destroyed when the
entry is removed or replaced from the list.
definitionSource should be NULL for any block type defined
by C++ code (this is what is passed by the KnownBlock constructor).
It should be a hashstring'ed path name for a block defined by an
identifiable file (such as an Oct facet), or a special case constant
string for other cases such as the ptcl defgalaxy command.

\begin{example}
static const Block* find (const char* \var{name}, const char* \var{dom});
\end{example}

The find method returns a pointer the appropriate block in
the specified domain.  A null pointer is returned if no match
is found.

\begin{example}
static Block* clone (const char* \var{name}, const char* \var{dom});
static Block* makeNew (const char* \var{name}, const char* \var{dom});
\end{example}

The \code{clone} method takes a string, finds the appropriate block in
the specified domain, and returns a clone of that block (the
\code{clone} method is called on the block.  This method, as
a rule, generates a duplicate of the block.

The \code{makeNew} function is similar except that \code{makeNew}
is called on the found block.  As a rule, \code{makeNew} returns
an object of the same class, but with default initializations
(for example, with default state values).

For either of these, an error message is generated (with
\code{Error::abortRun}) and a null pointer is returned if there is no
match.

To avoid a crash in the event of a self-referential galaxy definition,
recursive clone or makeNew attempts are detected, and are terminated by
generating an error message and returning a null pointer.

\begin{example}
static StringList nameList (const char* \var{domain});
\end{example}

Return the names of known blocks in
the given domain (second form).  Names are
separated by newline characters.

\begin{example}
static const char* defaultDomain ();
\end{example}

Returns the default domain name.  This is
not used internally for anything; it is just set to the first domain
seen during the building of known lists.

\begin{example}
static int setDefaultDomain (const char* newval);
\end{example}

Set the default domain name.  Return FALSE if
the specified value is not a valid domain.

\begin{example}
static int validDomain (const char* newval);
\end{example}

Return TRUE if the given name is a valid domain.

\begin{example}
static int isDynamic (const char* \var{type}, const char* \var{dom});
\end{example}

Return TRUE if the named block is dynamically linked.

There is an iterator associated with KnownBlock, called
KnownBlockIter.  It takes as an argument the name of a domain.  The
argument may be omitted, in which case the default domain is used.
Its \code{next} function returns the type \code{const Block *}; it
steps through the blocks on the known list for that domain.

\begin{example}
static int isDefined (const char* \var{type}, const char* \var{dom},
			   const char* \var{definitionSource});
\end{example}

If there is a known block of the given name and domain,
return TRUE and pass back its definition source string.

\begin{example}
static long serialNumber (const char* \var{name}, const char* \var{dom});
\end{example}

Look up a KnownBlock definition by name and domain, and return its serial
number.  Returns 0 iff no matching definition exists.

\begin{example}
static long serialNumber (Block& \var{block});
\end{example}

Given a block, find the matching KnownBlock definition,
and return its serial number (or 0 if no matching definition exists).

\node class KnownTarget
\section{Class KnownTarget}

The KnownTarget class keeps track of targets in much the same way
that KnownBlock keeps track of blocks.  There are some differences:
there is only a single list of targets, not one per domain as for
blocks.

The constructor works exactly the same way that the constructor for
KnownBlock works; the code

\begin{example}
static MyTarget proto(\var{args});
static KnownTarget entry(proto,"MyTarget");
\end{example}

adds the prototype instance to the known list with a call to
\code{addEntry}.

\begin{example}
static void addEntry (Target &\var{target}, const char* \var{name}, int \var{onHeap});
\end{example}

This function actually adds the Target to the list.  If \var{onHeap} is true,
the target will be destroyed when the entry is removed or replaced from
the list.  There is only one list of Targets.

\begin{example}
static const Target* find (const char* \var{name});
\end{example}

The find method returns a pointer the appropriate target.
A null pointer is returned if no match
is found.

\begin{example}
static Target* clone (const char* \var{name});
\end{example}

The \code{clone} method takes a string, finds the appropriate target on
the known target list, and returns a clone of that target (the
\code{cloneTarget} method is called on the target).  This method, as
a rule, generates a duplicate of the target.
An error message is generated (with \code{Error::abortRun}) and
a null pointer is returned if there is no match.

\begin{example}
static int getList (const Block& \var{b}, const char** \var{names}, int \var{nMax});
\end{example}

This function returns a list of names of targets that are compatible
with the Block \var{b}.  The return value gives the number of matches.
The \var{names} array can hold \var{nMax} strings; if there are more,
only the first \var{nMax} are returned.

\begin{example}
static int getList (const char* \var{dom}, const char** \var{names}, int \var{nMax});
\end{example}

This function is the same as above, except that it returns names of
targets that are compatible with stars of a particular domain.

\begin{example}
static int isDynamic (const char* \var{type});
\end{example}

Return true if there is a target on the known list named \var{type}
that is dynamically linked; otherwise return false.

\begin{example}
static const char* defaultName(const char* \var{dom} = 0);
\end{example}

Return the default target name for a domain (default: current domain).

There is an iterator associated with KnownTarget, called
KnownTargetIter.  Since there is only one known target list, it is
unusual for an iterator in that it takes no argument for its constructor.
Its \code{next} function returns the type \code{const Target *}; it
steps through the targets on the known list.

\node class Domain
\section{Class Domain}

The Domain class represents the information that Ptolemy needs to know
about a particular domain so that it can create galaxies, wormholes,
nodes, event horizons, and such for that domain.  For each domain,
the designer creates a derived class of Domain and one prototype object.
Thus the Domain class has two main parts: a static interface, which
manages access to the list of Domain objects, and a set of virtual
functions, which provides the standard interface for each domain to
describe its requirements.

\node Domain virtual functions
\subsection{Domain virtual functions}

\begin{example}
virtual Star& newWorm(Galaxy& \var{innerGal},Target* \var{innerTarget} = 0);
\end{example}

This function creates a new wormhole with the given inner galaxy and
inner target.  The default implementation returns an error.

XXXDomain might override this as follows:

\begin{example}
Star& XXXDomain::newWorm(Galaxy& innerGal,Target* innerTarget)  \{
        LOG\_NEW; return *new XXXWormhole(innerGal,innerTarget);
\}
\end{example}

\begin{example}
virtual EventHorizon& newFrom();
virtual EventHorizon& newTo();
\end{example}

These functions create event horizon objects to represent the
XXXfromUniversal and XXXtoUniversal functions.  The default
implementations return an error.

XXXDomain might override these as

\begin{example}
EventHorizon& XXXDomain::newFrom() \{
    LOG_NEW; return *new XXXfromUniversal;
\}

EventHorizon& XXXDomain::newTo() \{
    LOG_NEW; return *new XXXtoUniversal;
\}
\end{example}

\begin{example}
virtual Geodesic& newNode() = 0;
\end{example}

This function creates a new permanent node appropriate for netlist
connections for the domain.  There is no default implementation.

\begin{example}
virtual int isGalWorm();
\end{example}

This function returns FALSE by default.  If overridden by a function
that returns TRUE, a wormhole will be created around every galaxy
for this domain.

\node class KnownState
\section{Class KnownState}

KnownState manages two lists of states, one to represent the types of
states known to the system (integer, string, complex, array of floating,
etc), and one to represent certain predeclared global states.

It is very much like KnownBlock (\pxref{class KnownBlock})
in internal structure.  Since it manages
two lists, there are two kinds of constructors.

\begin{example}
KnownState (State &\var{state}, const char* \var{name});
\end{example}

This constructor adds an entry to the state type list.  For example,

\begin{example}
static IntState proto;
static KnownState entry(proto,"INT");
\end{example}

permits IntStates to be produced by cloning.  The \var{type} argument
must be in upper case, because of the way \code{find} works (see below).

The second type of constructor takes three arguments:

\begin{example}
KnownState (State &\var{state}, const char* \var{name}, const char* \var{value});
\end{example}

This constructor permits names to be added to the global state symbol
list, for use in state expressions.  For example, we have

\begin{example}
static FloatState pi;
KnownState k_pi(pi,"PI","3.14159265358979323846");
\end{example}

\begin{example}
static const State* find (const char* \var{type});
\end{example}

The \code{find} method returns a pointer the appropriate prototype
state in the state type list.  The argument is always changed to
upper case.  A null pointer is returned if there is no match.

\begin{example}
static const State* lookup (const char* \var{name});
\end{example}

The lookup method returns a pointer to the appropriate state in
the global state list, or null if there is no match.

\begin{example}
static State* clone (const char* type);
\end{example}

The clone method takes a string, finds the appropriate state using
\code{find}, and returns a clone of that block.  A null pointer is
returned if there is no match, and \code{Error::error} is also called.

\begin{example}
static StringList nameList();
\end{example}

Return the names of all the known state types, separated by newlines.

\begin{example}
static int nKnown();
\end{example}

Return the number of known states.

\node I/O classes
\chapter{I/O classes}

\node class StringList
\section{StringList, a kind of String class}

Class StringList provides a mechanism for organizing a list
of strings.  It can also be used to construct strings
of unbounded size, but the class InfString is preferred
for this (\pxref{class InfString}).
It is privately
derived from SequentialList (\pxref{class SequentialList}).

Its internal implementation is as a
list of \code{char *} strings, each on the heap.  A StringList
object can be treated either as a single string or as a list of
strings; the individual substrings retain their separate identity
until the conversion operator to type \code{const char *} is invoked.
There are also operators that add numeric values to the StringList;
there is only one format available for such additions.

WARNING: if a function or expression returns a StringList, and
that value is not assigned to a StringList variable or reference,
and the \code{(const char*)} cast is used, it is possible (likely under
g++) that the StringList temporary will be destroyed too soon,
leaving the \code{const char*} pointer pointing to garbage.  Always
assign a temporary StringList to a StringList variable or reference
before using the \code{const char*} conversion.  Thus, instead of

\begin{example}
function_name(\var{xxx}, (const char*)functionReturningStringList(), \var{yyy});\}
\end{example}

one should use

\begin{example}
StringList \var{temp_name} = (const char*)functionReturningStringList();
function_name(\var{xxx},  \var{temp_name}, \var{yyy});\}
\end{example}

This includes code like

\begin{example}
strcpy(destBuf,functionReturningStringList());
\end{example}

which uses the \code{const char*} conversion implicitly.

\node StringList constructors
\subsection{StringList constructors and assignment operators}

The default constructor makes an empty StringList.  There is also
a copy constructor and five single-argument constructors that can
function as conversions from other types to type StringList; they
take arguments of the types
\code{char}, \code{const char *}, \code{int}, \code{double}, and
\code{unsigned int}.

There are also six assignment operators corresponding to these
constructors: one that takes a \code{const StringList\&} argument and
also one for each of the five standard types:
\code{char}, \code{const char *}, \code{int}, \code{double}, and
\code{unsigned int}.

The resulting object has one piece, unless initialized from another
StringList in which case it has the same number of pieces.

\node adding to StringLists
\subsection{adding to StringLists}

There are six functions that can add a printed representation of an
argument to a StringList: one each for arguments of type
\code{const StringList\&}, \code{char}, \code{const char *}, \code{int},
\code{double}, and \code{unsigned int}.  In each case, the function
can be accessed in either of two equivalent ways:

\begin{example}
StringList& operator += (\var{type} \var{arg});
StringList& operator << (\var{type} \var{arg});
\end{example}

The second ``stream form'' is considered preferable; the ``+='' form is
there for backward compatibility.  If a StringList object is added,
each piece of the added StringList is added separately (boundaries
between pieces are preserved); for the other five forms, a single
piece is added.

\node StringList info functions
\subsection{StringList information functions}

\begin{example}
const char* head() const;
\end{example}

Return the first substring on the list (the first ``piece'').  A null
pointer is returned if there are none.

\begin{example}
int length() const;
\end{example}

Return the length in characters.

\begin{example}
int numPieces() const;
\end{example}

Return the number of substrings in the StringList.

\node StringList conversion
\subsection{StringList conversion to const char *}

\begin{example}
operator const char* ();
\end{example}

This function joins all the substrings in the StringList into a
single piece, so that afterwards \code{numPieces} will return 1.
A null pointer is always returned if there are no characters.

Warning: if this function is called on a temporary StringList, it
is possible that the compiler will delete the StringList object
before the last use of the returned \code{const char *} pointer.
The result is that the pointer may wind up pointing to garbage.
The best way to work around such problems is to make sure that any
StringList object ``has a name'' before this conversion is applied
to it; e.g., assign the results of functions returning StringList
objects to local StringList variables or references before trying
to convert them.

\begin{example}
char* newCopy() const;
\end{example}

This function makes a copy of the StringList's text in a single piece
as a \code{char *} in dynamic memory.  The object itself is not modified.
The caller is responsible for deletion of the returned text.

\node StringList destruction
\subsection{StringList destruction and zeroing}

\begin{example}
void initialize();
\end{example}

This function deallocates all pieces of the StringList and changes
it to an empty StringList.

\begin{example}
~StringList();
\end{example}

The destructor calls the \code{initialize} function.

\node class StringListIter
\subsection{Class StringListIter}

Class StringListIter is a standard iterator that operates on
StringLists.  Its \code{next()} function returns a pointer of type
\code{const char *} to the next substring of the StringList.
It is important to know that the operation of converting a
StringList to a \code{const char *} string joins all the substrings into
a single string, so that operation should be avoided if extensive
use of StringListIter is planned.

\node class InfString
\section{InfString, a class supporting unbounded strings}

Class InfString provides a mechanism for building strings
of unbounded size.  It provides a subset of the functions in a
typical C++ String class.  Strings can be built up piece by piece.
As segments are added, they are copied, so the caller
need not keep the segments around.
Upon casting to \code{(char*)}, the strings are collapsed into
one continuous string, and a pointer to that string is returned.
The calling function can treat this as an ordinary pointer to an ordinary
array of characters, and can modify the characters.
But the length of the string should not be changed, nor
should the string be deleted.
The InfString destructor is responsible for freeing the allocated memory.

InfString is publically
derived from StringList, adding only the cast char*
(\pxref{class StringList}).  Its internal implementation is as a
list of \code{char *} strings, each on the heap.
The individual substrings retain their separate identity
until the conversion cast to type \code{char *} is invoked,
although if access to the individual strings is needed, then StringList
should be used (\pxref{class StringList}).
There are also operators that add numeric values to the StringList;
there is only one format available for each such addition.

WARNING: if a function or expression returns an InfString, and
that value is not assigned to an InfString variable or reference,
and the \code{(char*)} cast is used, it is possible (likely under
g++) that the InfString temporary will be destroyed too soon,
leaving the \code{char*} pointer pointing to garbage.  Always
assign temporary InfStrings to InfString variables or references
before using the \code{char*} conversion.  Thus, instead of

\begin{example}
function_name(\var{xxx}, (char*)functionReturningInfString(), \var{yyy});\}
\end{example}

one should use

\begin{example}
InfString \var{temp_name} = (char*)functionReturningInfString();
function_name(\var{xxx},  \var{temp_name}, \var{yyy});\}
\end{example}

This includes code like

\begin{example}
strcpy(destBuf,functionReturningInfString());
\end{example}

which uses the \code{char*} conversion implicitly.

\node InfString constructors
\subsection{InfString constructors and assignment operators}

The default constructor makes an empty InfString.  There is also
a copy constructor and six single-argument constructors that can
function as conversions from other types to type InfString; they
take arguments of the types
\code{char}, \code{const char *}, \code{int}, \code{double}, 
\code{unsigned int}, and \code{const StringList\&}.

There are also seven assignment operators corresponding to these
constructors: one that takes a \code{const InfString\&} argument and
also one for each of the six standard types:
\code{char}, \code{const char *}, \code{int}, \code{double},
\code{unsigned int}, and \code{const StringList\&}.

\node adding to InfStrings
\subsection{adding to InfStrings}

There are seven functions that can add a printed representation of an
argument to a InfString: one each for arguments of type
\code{const InfString\&}, \code{char}, \code{const char *}, \code{int},
\code{double}, \code{unsigned int}, and \code{const StringList\&}.
In each case, the function
can be accessed in either of two equivalent ways:

\begin{example}
InfString& operator += (\var{type} \var{arg});
InfString& operator << (\var{type} \var{arg});
\end{example}

The second ``stream form'' is considered preferable; the ``+='' form is
there for backward compatibility.  If a InfString object is added,
each piece of the added InfString is added separately (boundaries
between pieces are preserved); for the other five forms, a single
piece is added.

\node InfString info functions
\subsection{InfString information functions}

\begin{example}
int length() const;
\end{example}

Return the length in characters.

\node InfString conversion
\subsection{InfString conversion to char *}

\begin{example}
operator char* ();
\end{example}

This function joins all the substrings in the InfString into a
single piece, a returns a pointer to the resulting string.
A null pointer is always returned if there are no characters.

Warning: as pointed out above,
if this function is called on a temporary InfString, it
is possible that the compiler will delete the InfString object
before the last use of the returned \code{char *} pointer.
The result is that the pointer may wind up pointing to garbage.
The best work-around for such problems is to make sure that any
InfString object ``has a name'' before this conversion is applied
to it; e.g. assign the results of functions returning InfString
objects to local InfString variables or references before trying
to convert them.

\begin{example}
char* newCopy() const;
\end{example}

This function makes a copy of the InfString's text in a single piece
as a \code{char *} in dynamic memory.  The InfString object itself is
not modified.
This is useful when
the caller wishes to be responsible for deletion of the returned text.

\node InfString destruction
\subsection{InfString destruction and zeroing}

\begin{example}
void initialize();
\end{example}

This function deallocates all pieces of the InfString and changes
it to an empty InfString.

\begin{example}
~InfString();
\end{example}

The destructor calls the \code{initialize} function.

\node class InfStringIter
\subsection{Class InfStringIter}

Class InfStringIter is a standard iterator that operates on
InfStrings.  However, the InfString class is not intended for
use when access to the individual components of the string is
desired.  Use StringList for this.

\node class Tokenizer
\section{Tokenizer, a simple lexical analyzer class}

The Tokenizer class is designed to accept input for a string or file
and break it up into tokens.  It is similar to the standard istream
class in this regard, but it has some additional facilities.  It
permits character classes to be defined to specify that certain
characters are white space and others are ``special'' and should be
returned as single-character tokens; it permits quoted strings to
override this, and it has a file inclusion facility.  In short, it
is a simple, reconfigurable lexical analyzer.


Tokenizer has a public const data member named \code{defWhite}
that contains the default white space characters: space, newline,
and tab.  It is possible to change the definition of white space
for a particular constructor.

\node Initializing Tokenizers
\subsection{Initializing Tokenizer objects}

Tokenizer provides three different constructors:

\begin{example}
Tokenizer();
\end{example}

The default constructor creates a Tokenizer that reads from the
standard input stream, \code{cin}.  Its special characters are
simply \key{(} and \key{)}.

\begin{example}
Tokenizer(istream\& \var{input},const char* \var{spec},
          const char* \var{w} = defWhite);
\end{example}

This constructor creates a Tokenizer that reads from the stream named
by \var{input}.  The other arguments specify the special characters
and the white space characters.

\begin{example}
Tokenizer(const char* \var{buffer},const char* \var{spec},
          const char* \var{w} = defWhite);
\end{example}

This constructor creates a Tokenizer that reads from the null-terminated
string in \var{buffer}.

Tokenizer's destructor closes any include files associated with the
constructor and deletes associated internal storage.

The following operations change the definition of white space and of
special characters, respectively:

\begin{example}
const char* setWhite(const char* w);
const char* setSpecial(const char* s);
\end{example}

In each case, the old value is returned.

By default, the line comment character for Tokenizer is \key{#}.
It can be changed by

\begin{example}
char setCommentChar(char n);
\end{example}

Use an argument of 0 to disable the feature.  The old comment character
is returned.

\node reading from Tokenizers
\subsection{Reading from Tokenizers}

The next operation is the basic mechanism for reading tokens from
the Tokenizer:

\begin{example}
Tokenizer& operator >> (char * \var{pBuffer});
\end{example}

Here \var{pBuffer} points to a character buffer that reads the token.
There is a design flaw: there isn't a way to give a maximum buffer
length, so overflow is a risk.

By analogy with streams, the following operation is provided:

\begin{example}
operator void* ();
\end{example}

It returns null if EOF has already been reached and non-null otherwise.
This permits loops like

\begin{example}
Tokenizer tin;
while (tin) \{ ... do stuff ... \}
\end{example}

\begin{example}
int eof() const;
\end{example}

Returns true if the end of file or end of input has been reached on
the Tokenizer.  It is possible that there is nothing left in the input
but write space, so in many situations \code{skipwhite} should be called
before making this test.

\begin{example}
void skipwhite();
\end{example}

Skip white space in the input.

\begin{example}
void flush();
\end{example}

If in an include file, the file is closed.  If at the top level,
discard the rest of the current line.

\node Tokenizer include files
\subsection{Tokenizer include files}

Tokenizer can use include files, and can nest them to any depth.
It maintains a stack of include files, and as EOF is reached in each
file, it is closed and popped off of the stack.

The method

\begin{example}
int fromFile(const char* \var{name});
\end{example}

opens a new file and the Tokenizer will then read from that.  When that
file ends, Tokenizer will continue reading from the current point in
the current file.

\begin{example}
const char* current_file() const;
int current_line() const;
\end{example}

These methods report on the file name and line number where Tokenizer is
currently reading from.  This information is maintained for include
files.  At the top level,  \code{current\_file} returns a null pointer,
but \code{current\_line} returns one more than the number of line feeds
seen so far.

\begin{example}
int readingFromFile() const;
\end{example}

Returns true (1) if the Tokenizer is reading from an include file,
false (0) if not.

\node augmented fstreams
\section{pt\_ifstream and pt\_ofstream: augmented fstream classes}

The classes pt\_ifstream and pt\_ofstream are derived from the standard
stream classes ifstream and ofstream, respectively.  They are defined
in the header file \file{pt\_fstream.h}.  They add the
following features:

First, certain special ``filenames'' are recognized.  If the filename used in
the constructor or an \code{open} call is \code{\<cin>}, \code{\<cout>},
\code{\<cerr>}, or \code{\<clog>} (the angle brackets must be part of
the string), then the corresponding standard stream of the same name
is used for input (pt\_ifstream) or output (pt\_ofstream).  In addition,
C standard I/O fans can specify \code{\<stdin>}, \code{\<stdout>}, or
\code{\<stderr>} as well.

Second, the Ptolemy \code{expandPathName} is applied to the filename
before it is opened, permitting it to start with \code{~user} or
\code{\$VAR}.

Finally, if a failure occurs when the file is opened,
\code{Error::abortRun} is called with an appropriate error message,
including the Unix error condition.

Otherwise these classes are identical to the standard ifstream and
ofstream classes and can be used as replacements.

\node class XGraph
\section{XGraph, an interface to the xgraph program}

The XGraph class provides an interface for the \file{xgraph} program for
plotting data on an X window system display.  The modified \file{xgraph}
program provided with the Ptolemy distribution should be used, not the
contributed version from the X11R5 tape.

The constructor for XGraph does not completely initialize the object;
initialization is completed by the \code{initialize()} method:

\begin{example}
void initialize(Block* \code{parent}, int \code{noGraphs},
     const char* \code{options}, const char* \code{title},
     const char* \code{saveFile} = 0, int \code{ignore} = 0);
\end{example}

The \var{parent} argument is the name of a Block that is associated
with the XGraph object; this Block is used in \code{Error::abortRun}
messages to report errors.

\var{noGraphs} specifies the number of data sets that the graph will
contain.  Each data set is a separate stream and is plotted in a
different color (a different line style for B/W displays).

\var{options} is a series of command line options that will be passed
unmodified to the xgraph program.  It is subject to expansion by the
Unix shell.

\var{title} is the title for the graph; it can contain special
characters (it is \emph{not} subjected to expansion by the Unix shell).

\var{saveFile} is the name of a file to save the graph data into, in
ASCII form.  If it is not given, the data are not saved, and a faster
binary format is used.

\var{ignore} specifies the number of initial points to ignore from
each data set.

\begin{example}
void setIgnore(int \var{n});
\end{example}

Reset the ``ignore'' parameter to \var{n}.

\begin{example}
void addPoint(float \var{y});
\end{example}

Add a single point to the first data set whose X value is
automatically generated (0, 1, 2, 3... on successive calls)
and whose Y value is \var{y}.

\begin{example}
void addPoint(float \var{x}, float \var{y});
\end{example}

Add the point (\var{x}, \var{y}) to the first data set.

\begin{example}
void addPoint(int \var{dataSet}, float \var{x}, float \var{y});
\end{example}

Add the point (\var{x}, \var{y}) to the data set indicated by
\var{dataSet}.  Data sets start with 1.

\begin{example}
void newTrace(int \var{dataSet} = 1);
\end{example}

Start a new trace for the nth dataset.  This means that there will be
no connecting line between the last point plotted and the next point
plotted.

\begin{example}
void terminate();
\end{example}

This function flushes the data out to disk, closes the files, and
invokes the xgraph program.

If the destructor is called before \code{terminate}, it will close and
delete the temporary files.

\node Histogram classes
\section{Histogram classes}

The Histogram class accepts a stream of data and accumulates a
histogram.  The XHistogram class uses a Histogram to collect the
data and an XGraph to display it.

\node class Histogram
\subsection{Class Histogram}

The Histogram class accumulates data in a histogram.  Its constructor
is as follows:

\begin{example}
Histogram(double \var{width} = 1.0, int \var{maxBins} = HISTO_MAX_BINS);
\end{example}

The default maximum number of bins is 1000.  The bin centers will be at
integer multiples of the specified bin width.  The total width of the
histogram depends on the data; however, there will always be a bin that
includes the first point.

\begin{example}
void add(double \var{x});
\end{example}

Add the point \var{x} to the histogram.

\begin{example}
int numCounts() const;
double mean() const;
double variance() const;
\end{example}

Return the number of counts, the mean, and the variance of the data
in the histogram.

\begin{example}
int getData(int \var{binno}, int& \var{count}, double& \var{binCenter});
\end{example}

Get counts and bin centers by bin number, where 0 indicates the smallest
bin.  Return TRUE if this is a valid bin.  Thus the entire histogram
data can be retrieved by stepping from 0 to the first failure.

\node class XHistogram
\subsection{Class XHistogram}

An XHistogram object has a private XGraph member and a private Histogram
member.  The functions

\begin{example}
int numCounts() const;
double mean() const;
double variance();
\end{example}

\noindent
simply pass through to the Histogram object, and

\begin{example}
void addPoint(float y);
\end{example}

adds a point to the histogram and does other bookkeeping.  There
are two remaining methods:

\begin{example}
void initialize(Block* parent, double binWidth,
   const char* options, const char* title,
   const char* saveFile, int maxBins = HISTO_MAX_BINS);
\end{example}

This method initializes the graph and histogram object.  \var{parent}
is the parent Block, used for error messages.  \var{binWidth} and
\var{maxBins} initialize the Histogram object.  \var{options} is a
string that is included in the command line to the xgraph program;
other options, including \code{-bar -nl -brw \var{value}}, are passed as
well.  \var{title} is the graph title, and \var{saveFile}, if non-null,
gives a file in which the histogram data is saved (this data is the
histogram counts, not the data that was input with \code{addPoint}).

\begin{example}
void terminate();
\end{example}

This method completes the histogram, flushes out the temporary files,
and executes xgraph.

\node Misc
\chapter{Miscellaneous classes}

This section includes classes that did not fit elsewhere.

\node Mathematical classes
\section{Mathematical classes}

\node class Complex
\subsection{class Complex}

Class Complex is a simple subset of functions provided in the Gnu and
AT\&T complex classes.  The standard arithmetic operators are
implemented, as are the assignment arithmetic operators \code{+=},
\code{-=}, \code{*=}, and \code{/=}, and equality and inequality
operators \code{==} and \code{!=}.  There is also \code{real()} and
\code{imag()} methods for accessing real and imaginary parts.

It was originally written when libg++ was subject to the GPL.
The current licensing for libg++ does not prevent us from using it
and still distributing Ptolemy the way we want, but having it makes
ports to other compilers (e.g. cfront) easier.

The following non-member functions take Complex arguments:

\begin{example}
Complex conj(const Complex& \var{arg});
double real(const Complex& \var{arg});
double imag(const Complex& \var{arg});
double abs(const Complex& \var{arg});
\end{example}

Return the conjugate, real part, imaginary part, or absolute value,
respectively.

\begin{example}
double arg(const Complex& \var{arg});
\end{example}

Return the angle between the X axis and the vector made by the argument.
The expression

\begin{example}
abs(z)*exp(Complex(0.,1.)*arg(z))
\end{example}

is in theory always equal to z.

\begin{example}
double norm(const Complex& \var{arg});
\end{example}

return the absolute value squared.

\begin{example}
Complex sin(const Complex& \var{arg});
Complex cos(const Complex& \var{arg});
Complex exp(const Complex& \var{arg});
Complex log(const Complex& \var{arg});
Complex sqrt(const Complex& \var{arg});
\end{example}

Standard mathematical functions.  \code{log} returns the principal
logarithm.

\begin{example}
Complex pow(double \var{base},const Complex& \var{expon});
Complex pow(const Complex& \var{base}, const Complex& \var{expon});
\end{example}

Raise base to expon power.

There is also an \<\< operator to print a Complex on an ostream.

\node class Fraction
\subsection{class Fraction}

Class Fraction represents fractions.  The header \file{Fraction.h}
also provides declarations for the \code{lcm} (least common multiple)
and \code{gcd} (greatest common divisor) functions, as these functions
are needed for Fraction but are generally useful.

\begin{example}
Fraction ();
Fraction (int \var{num}, int \var{den}=1);
\end{example}

The default constructor produces a fraction with numerator 0 and
denominator 1.  The other constructor allows the numerator and
denominator to be specified arbitrarily.

\begin{example}
int num() const;
int den() const;
\end{example}

Return the numerator or denominator.

\begin{example}
operator double() const;
\end{example}

Return the value of the fraction as a double.

Class Fraction implements the basic binary math operators
\code{+}, \code{-}, \code{*}, \code{/}; the assignment
operators \code{=}, \code{+=}, \code{-=}, \code{*=},
and \code{/=}, and the equality test operators \code{==}
and \code{!=}.

The method

\begin{example}
Fraction& simplify();
\end{example}

reduces the fraction to lowest terms, and returns a reference
to the fraction.

There is also an \<\< operator to print a Fraction on an ostream.

\node class IntervalList
\section{Class IntervalList}

The IntervalList class represents a set of unsigned integers, represented
as a series of intervals of integers that belong to the set.

It is built on top of a class Interval that represents a single
interval.

There is also a text representation for IntervalLists.  This
representation can be used to read or write IntervalList objects
to streams, and also can be used in the IntervalList constructor.
This text representation looks exactly like the format the ``rn''
newsreader uses to record which articles have been read in a
Usenet newsgroup (which is where we got it from; thank you, Larry
Wall).

In the text representation, an IntervalList is specified as one
or more Intervals, separated by commas.  An Interval is either
an unsigned integer or two unsigned intervals with an intervening
minus sign.  Here is one possible IntervalList specification:

1-1003,1006,1008-1030,1050

White space is not permitted in this representation.

IntervalList specifiers do not have to be in increasing order,
but if they are not, they are changed to "canonical form", in which
any overlapping intervals are merged and the intervals are sorted
to appear in increasing order.

An IntervalList is best thought of as a set of unsigned integers.
Its methods in many cases perform set operations: forming the
union, intersection, or set difference of two IntervalLists.

\node class Interval
\subsection{class Interval and methods}

The Interval class is in some ways simply an implementation detail of
class IntervalList, but since its existence is exposed by public
methods, it is documented here.

An Interval has an \var{origin} and a \var{length}, and represents the
set of \var{length} unsigned integers beginning with \var{origin}.  It
also has a pointer that can point to another Interval.

The constructor

\begin{example}
Interval(unsigned \var{origin}=0, unsigned \var{length}=0,
    Interval* \var{nxt} = 0);
\end{example}

permits all these members to be set.  The copy constructor copies
the origin and length values but always sets the next pointer to null.
A third constructor

\begin{example}
Interval(const Interval& \var{i1},Interval* \var{nxt});
\end{example}

permits a combination of a copy and a next-pointer initialization.

The members

\begin{example}
unsigned origin() const;
unsigned length() const;
\end{example}

return the origin and length values.

\begin{example}
unsigned end() const;
\end{example}

The \code{end} function returns the last unsigned integer that is a
member of the Interval; 0 is returned for empty Intervals.

There are a number of queries that are valuable for building a set
class out of Intervals:

\begin{example}
int isAfter(const Interval &\var{i1}) const;
\end{example}

\code{isAfter} returns true if this Interval begins after the end of
interval \var{i1}
.
\begin{example}
int endsBefore(const Interval &\var{i1}) const;
\end{example}

\code{endsBefore} returns true if this Interval ends strictly before
the origin of interval i1.

\begin{example}
int completelyBefore(const Interval &\var{i1}) const;
\end{example}

\code{completelyBefore} returns true if \code{endsBefore} is true and there
is space between the intervals (they cannot be merged).

\begin{example}
int mergeableWith(const Interval& \var{i1}) const;
\end{example}

\code{mergeableWith} returns true if two intervals overlap or are
adjacent, so that their union is also an interval.

\begin{example}
int intersects(const Interval& \var{i1}) const;
\end{example}

\code{intersects} returns true if two intervals have a non-null
intersection.

\begin{example}
int subsetOf(const Interval& \var{i1}) const;
\end{example}

\code{subsetOf} returns true if the argument is a subset of this interval.

\begin{example}
void merge(const Interval& \var{i1});
\end{example}

\code{merge} alters the interval to the result of merging it with \var{i1}.
It is assumed that \code{mergeableWith} is true.

\begin{example}
Interval& operator&=(const Interval& \var{i1});
\end{example}

This Interval is changed to the intersection of itself and of \var{i1}.

\node IntervalList public members
\subsection{IntervalList public members}

\begin{example}
IntervalList();
\end{example}

The default constructor produces the empty IntervalList.

\begin{example}
IntervalList(unsigned \var{origin},unsigned \var{length});
\end{example}

This constructor creates an IntervalList containing \var{length}
integers starting with \var{origin}.

\begin{example}
IntervalList(const char* \var{definition});
\end{example}

This constructor takes a definition of the IntervalList from the
string in \var{definition}, parses it, and creates the list of
intervals accordingly.

There is also a copy constructor, an assignment operator, and a
destructor.

\begin{example}
int contains(const Interval& \var{i1}) const;
\end{example}

The \code{contains} method returns 0 if no part of \var{i1} is in the
IntervalList, 1 if \var{i1} is completely contained in the IntervalList,
and -1 if \var{i1} is partially contained (has a non-null intersection).

\begin{example}
IntervalList& operator|=(const Interval& \var{src});
IntervalList& operator|=(const IntervalList& \var{src});
\end{example}

The \code{|=} operators sets the IntervalList to the union of itself and
the Interval, or the IntervalList, \var{src}.

\begin{example}
IntervalList operator&(const IntervalList& \var{arg}) const;
\end{example}

The binary \code{\&} operator returns the intersection of its arguments,
which are not changed.

\begin{example}
IntervalList& subtract(const Interval& \var{i1});
IntervalList& operator-=(const Interval& \var{i1});
\end{example}

Subtract the Interval \var{i1} from the list.  That is, any intersection
is removed from the set.  Both the \code{subtract} and \code{-=} forms
are equivalent.

\begin{example}
IntervalList& operator-=(const IntervalList &\var{arg});
\end{example}

This one subtracts the argument \var{arg} from the list (removes any
intersection).

\begin{example}
int empty() const;
\end{example}

Return TRUE (1) for an empty IntervalList, otherwise FALSE (0).

\node IntervalList iterators
\subsection{IntervalList iterator classes.}

There are two iterator classes associated with IntervalList,
IntervalListIter and CIntervalListIter.  The only difference is that
the latter iterator can be used with const IntervalList objects and
returns pointers to const Interval objects; the former requires a
non-const IntervalIList and returns pointers to Interval.

These objects obey the standard iterator interface; the \code{next()}
or \code{++} function returns a pointer to the next contained Interval;
\code{reset} goes back to the beginning.

\node Clock and TimeVal
\section{Classes for interacting with the system clock}

These classes provide simple means of interacting with the operating
system's clock -- sleeping until a specified time, timing events, etc.
They may be replaced with something more general.

Class TimeVal represents a time interval to microsecond precision.
There are two constructors:

\begin{example}
TimeVal();
TimeVal(double \var{seconds});
\end{example}

The first represents a time interval of zero.  In the second case, the
\var{seconds} argument is rounded to the nearest microsecond.

These classes rely on features found in BSD-based Unix systems and newer
System V Unix systems.  Older System V systems tend not to provide the
ability to sleep for a time specified more accurately than a second.

\begin{example}
operator double() const;
\end{example}

This returns the interval value as a double.

\begin{example}
TimeVal operator +(const TimeVal& \var{arg}) const;
TimeVal operator -(const TimeVal& \var{arg}) const;
TimeVal& operator +=(const TimeVal& \var{arg});
TimeVal& operator -=(const TimeVal& \var{arg});
\end{example}

These operators do simple addition and subtraction of TimeVals.

\begin{example}
int operator >(const TimeVal& \var{arg}) const;
int operator <(const TimeVal& \var{arg}) const;
\end{example}

These operators do simple comparisons of TimeVals.

Class Clock provides a simple interface to the system clock for
measurement of actual elapsed time.  It has an internal TimeVal
field that represents the starting time of a time interval.

\begin{example}
Clock();
\end{example}

The constructor creates a Clock with starting time equal to the
time at which the constructor is executed.

\begin{example}
void reset();
\end{example}

This method resets the start time to ``now''.

\begin{example}
TimeVal elapsedTime() const;
\end{example}

This method returns the elapsed time since the last \code{reset} or
the call to the constructor.

\begin{example}
int sleepUntil(const TimeVal& \var{howLong}) const;
\end{example}

This method causes the process to sleep until \var{howLong} after the
start time.
