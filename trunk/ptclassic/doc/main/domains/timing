.\" $Id$
.H1 "Timing Relation Between Domains
.pp
\*(PT can support an effectively unlimited number of different
domains since adding a new domain does not affect any existing
implementation of other domains as well as kernels.
The domain interface should take care of timing relations between
the outer and inner domains. Timing management is the most 
challenging task in the design of
.c Wormhole s
and their interconnection mechanism.  Our approach is to
classify the domains\** into two groups : \fItimed\fR, and
\fIuntimed\fR. In the \fItimed\fR domain, the scheduler
of the domain requires the global timing relations among data packets
over the domain.  On the other hand, the \fIuntimed\fR domain
requires only the local ordering information of data packets.
.(f
\**refer to the "\fBAlmagest\fR" for more information on the
domains supported by \fBPtolemy\fR.
.)f
Thus, the resulting taxonomy is :
.sp
.nf
\fItimed\fR : DE, THOR, etc
\fIuntimed\fR : SDF, DDF, CAPSIM, MQ, etc
.fi
.sp
.pp
The
.c Scheduler
of a domain keeps a property called \fIcurrentTime\fR for timing
management.  For the timed domain, the \fIcurrentTime\fR indicates the
global time.  As the scheduler proceeds, the \fIcurrentTime\fR also
increases.  Hence, the stopping condition for the timed domain is
usually given by "stop time".  On the other hand, the untimed domain
does not have the concept of time.  If an untimed domain resides in a
.c Wormhole ,
then the \fIcurrentTime\fR of the domain is simply the copy of the
\fIcurrentTime\fR of the outer domain.
There are four combinations of timed and untimed domains.  For each
combination, we will show how to do timing management with \fIcurrentTime\fR.
.H2 "Untimed Domain in Untimed Domain
.pp
The first combination is the simplest in timing management : 
an untimed domain contains another untimed domain.
For example, a DDF domain may contain a SDF domain.  If a system has only
a small part of non-deterministic behavior and others of
deterministic behaviour, the entire application is a DDF domain.
But by defining the deterministic parts as
SDF domains and applying the compile-time scheduling for them, 
we can improve the runtime performance of the system.
Since the outer domain does not care the \fIcurrentTime\fR 
of the inner domain,
we are free to manage the \fIcurrentTIme\fR of the inner domain.
In this case, the \fIcurrentTime\fR of the inner domain is just
copied from that of the outer domain.  
During the execution of the
wormhole, the \fIcurrentTime\fR is not changed at all.  
The stopping condition of the inner domain is given by the number of
"iteration" of the schedule.  Refer to the individual domain 
documentation (e.g. \fBSDF Domain, DDF Domain\fR, etc) to see
what is the definition of one "iteration".  The meaning of one
"iteration" is very domain specific.
Then, the stopping condition of the inner domain is "one iteration".
.H2 "Untimed Domain in Timed Domain
.pp
The second possibility is that a timed domain contains an untimed domain.
If a DE domain contains a SDF domain, it falls into this category.
In this case, the \fIcurrentTime\fR of the inner untimed domain
is synchronized with the \fIcurrentTime\fR of the outer timed domain
which is the global time of the outer domain, at the beginning of the
execution of the 
.c Wormhole .  
Like the first case, the \fIcurrentTime\fR
of the inner domain is not increased during the execution.
It gives an illusion to the outer domain that the untimed domain takes
zero time for execution.  Since the inner domain has no notion of
time, it seems not only awkward but infeasible to assign any 
execution delay to the inner domain.  Instead, we can simulate
the execution delay of the inner domain by attaching a
.c Delay\ Star
in the outer domain next to the 
.c Wormhole .
The decoupling of the delay and the functionality of a 
block in a timed domain
is the basic technique we use in the timed domain like DE.
The stopping condition of the inner domain is again "one iteration".
.H2 "Timed Domain in Timed Domain
.pp
The third combination is most complicated : a timed domain contains
another timed domain.  A DE domain containing a THOR domain will be
an example.  First of all, since both domains have their global clocks, 
we have to synchronize both domains.  Therefore, the inner domain
has a 
.c State 
called \fItimeScale\fR which is the ratio between the time unit of
inner domain and that of the outer domain.  If the state is undefined,
the \fItimeScale\fR is $1.0$ by default (no scaling).  
At the beginning of the execution of the 
.c Wormhole ,
the \fIcurrentTime\fR of the outer domain is scaled by the \fItimeScale\fR
of the inner domain and copied to the \fIcurrentTime\fR of the
inner domain.  The \fIcurrentTime\fR of the inner domain
proceeds as the
.c Wormhole
is executed until the stopping condition is met.  After the execution 
finishes, the \fIcurrentTime\fR of the inner domain is scaled
by the inverse of the \fItimeScale\fR and assigned to the output data
packets.
A user can change the value of the
scale factor by defining a 
.c FloatState
(\fItimeScale\fR) in the outermost galaxy of the timed domain.
In the interpreter command, the following line does it :
.(c
(state timeScale float "10.0")
.)c
.pp
Decision of the stopping condition of the inner domain is the most
tricky part of the domain interface.  Suppose that the
.c Wormhole
has two inputs ($input sub 1$, $input sub 2$) and two outputs
($output sub 1$, $output sub 2$).  If $input sub 1$ receives an
event (data packet), the
.c Wormhole
starts execution.  The complication arises from the observation
that if $input sub 2$ receives an event sometime later but before
the previous event does not generate outputs, this event will
affect the previous execution.  For example, if 
$input sub 2$ is a reset input of a system, the reset event will
affect the previous execution if it is not completed.
Therefore, we can process the inner system at a given event
until the next event arrives.  Unfortunately it is generally
not possible to predict when the next event will arrive.
One possible solution is to process the
.c Wormhole
for one time unit at each invocation.  In case of THOR domain, one
time unit is well defined so that this approach is acceptable.
However, there is no notion of time unit in the DE domain since
the time is 
.c float
type.  Also, the approach is too conservative implying a lot of overhead.
Even though there will be no event during the next $100$ time units,
the 
.c Wormhole 
should be invoked $100$ times to march one time unit
at each invocation.  
.pp
Another approach is to process the 
.c Wormhole
until the next earliest event in the outer domain. 
When the
.c Wormhole
is to be executed, we check the expected next global time by examining
the next earliest event in the outer domain.  The stopping condition
of the inner timed domain is set with the stop time equal to the
expected next global time.  As long as the
.c Wormhole
does not generate any event during execution, the expected next global
time becomes the actual next global time.  If the inner domain generates
any output events, however, 
they will be the next earliest events
in the outer domain.  There is a pathological example which
breaks this approach.
Suppose that the inner domain generates output events through
$output sub 1$ earlier than through $output sub 2$.  Moreover, the
output event through $output sub 1$ is routed back to $input sub 2$ of the
.c Wormhole .
Then, we meet the original problem if this feedback event should have
affected the
output event through $output sub 2$ of the previous execution.
Since the output event through $output sub 2$ is already produced in the
previous execution, there is no way to correct the event.
.pp
Therefore, we propose the following solution.
At the beginning of the execution,
we set the stop time of the
.c Wormhole
with the expected next global time.  We proceed the inner
.c Scheduler
until the \fIcurrentTime\fR reaches the stop time, or until
the inner domain generates any output, whenever earlier.
If the
.c Wormhole
generates an output, the output becomes the next earliest event
in the outer domain.  Therefore, our scheme is nothing but to
process the
.c Wormhole
until the actual (not expected) next global time in the outer domain.
This proves the correctness of our solution.
According to the scheme, the
.c Wormhole
may finish the execution even before the current event is completely
processed.  The 
.c Wormhole
should be invoked again right before the global clock of the
outer domain is increased as long as the
.c Wormhole
contains any events.  In other words, once the
.c Wormhole
is invoked, the global clocks of the inner and the outer domain
march in parallel.  The 
.c Wormhole
forms a special class of
.c Star s
in a timed domain, called "process star".  The first invocation
of a process star is triggered by external events to the star.
But the further invocations are without external events until the
star completes the execution.
.H2 "Timed Domain in Untimed Domain
.pp
The last possible combination is that of a timed domain in an
untimed domain.  Even though the untimed domain has no notion of
time, it needs to control the inner timed domain by setting the
stopping condition.  For that purpose, an untimed domain
keeps a property called \fIschedulePeriod\fR.  
The \fIcurrentTime\fR of the untimed domain is increased by the
\fIschedulePeriod\fR after each iteration.
A user can control the value of the \fIschedulePeriod\fR by defining a 
.c FloatState
(\fIschedulePeriod\fR) in the outermost galaxy of the untimed domain.
In the interpreter command, the following line is enough :
.(c
(state schedulePeriod float "10.0")
.)c
If the state is not defined, the \fIschedulePeriod\fR of the untimed
domain is set by a large number ($10000$) by default.
Presumably, the \fIschedulePeriod\fR has no physical significance
since the untimed domain contains no meaning of time.  The sole
purpose of the state is to define the stopping condition of the
timed domain.  A user should make sure that the 
.c Wormhole
does the necessary task before it reaches the stopping condition.
The common approach is to set the stop time large enough so that
the timed domain is deadlocked (meaning that there is no
active events in the timed system) before the stop time.  Then, the
timed domain acts as a functional block like a conventional 
.c Star
in the untimed domain.  Note that in this case, the inner timed
domain must not stop after it generates the output events unlike the
third case.  It is not proven yet how useful this combination is
in real applications.
.pp
There is a special case where the above discussion is not
applicable.  Suppose that the untimed 
.c Universe 
is a SDF domain.
We can interpret the SDF domain as a time driven domain where
the time interval between data packets is fixed, so hidden safely
in the system representation.  A SDF application as a digital
signal processing system falls into this category.
Then, the SDF domain looks like a timed domain!.  The
\fIschedulePeriod\fR has its physical significance in this case.
Then, user has to supply a meaningful value for that.
The \fIschedulePeriod\fR of the SDF system represents the repetition
period of the SDF schedule, and during one iteration, there may
arrive more than one data packets at the
.c Wormhole .
The time-interval of the data packets becomes the ratio of the
\fIschedulePeriod\fR and the number of arrived data packets during one
iteration.  It is this time-interval not \fIschedulePeriod\fR
that determines the stop time of the inner timed domain.
This combination of a SDF domain and a timed domain has 
abundant applications. 
.H2 "Summary
.pp
We have discussed four combinations of the domains.
If a
.c Wormhole
contains another
.c Wormhole ,
we can apply the basic rule developed in this section
to each domain interface.  For example, a timed domain
contains a 
.c Wormhole
of an untimed domain which itself contains a timed
.c Wormhole .
Since the timed domain inside an untimed domain loses the physical
meaning of times, the innermost timed domain is nothing to do with
the outer timed domain in timing management.  Still the untimed
domain takes zero time in the sense of the outer global clock.
An exceptional case is when
the untimed domain is the SDF domain for time-driven application
(e.g. DSP application).  By controlling the \fIschedulePeriod\fR
of the SDF domain, we can synchronize the innermost timed
domain and the outer timed domain.
