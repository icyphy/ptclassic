.\" $Id$
.H1 "The Wormhole Class"
.pp
.IE "wormhole design"
A wormhole for a domain is much like star belonging to that domain,
but it can contain pointers to a subsystem that operates in a different
domain.  The interface to that other domain is through a "universal
event horizon".
.IE "universal event horizon"
The wormhole design, therefore, does not depend on the domain
it contains, but only on the domain in which it is used as a block.
It must look like a star in that outer domain.
.pp
The base
.c Wormhole
class is derived from class
.c Runnable ,
just like the base class
.c Universe .
Every member of the
.c Runnable
class has a pointer to a component
.c Galaxy
and a
.c Scheduler .
Like a
.c Universe ,
a 
.c Wormhole
can perform the scheduling actions on the component
.c Galaxy.
A
.c Wormhole
is different from a
.c Universe
in that it is not a stand-alone object.  Instead, it is triggered
from the outer domain to initiate the scheduling.
.pp
Each domain has a derived
.c Wormhole
class.
For example, the SDF domain has  class
.c SDFWormhole .
This domain-specific
.c Wormhole
is derived from not only the base
.c Wormhole
class but also from the domain-specific star class,
.c SDFStar .
This multiple inheritance realizes the inherent nature of the
.c Wormhole .
First, the
.c Wormhole
behaves exactly like a
.c Star
from the outer domain (SDF) since it is derived from 
.c SDFStar .
Second, internally it can encapsulate an entire foreign domain
with a separate 
.c Galaxy
and a separate
.c Scheduler .
.pp
The 
.c Scheduler 
executes a star by calling its \fIgo()\fR method.
Before the execution of a star
data packets (
.c Particles )
are delivered to the 
.c Star
via \fIgrabData()\fR method of the input ports.
.IE "grabData()"
After its execution, the 
.c Star
sends particles to other stars
via the \fIsendData()\fR method of the output ports.
.IE "sendData()"
Thus, the
.c Scheduler
calls a sequence of methods to execute a star:
\fIgrabData()\fR on the input ports, \fIgo()\fR on the 
.c Star ,
and \fIsendData()\fR on the output ports.
Since the scheduler
can not distinguish a wormhole
from a star,
it follows the same sequence of calls to fire the wormhole.
In this case \fIgrabData()\fR and \fIsendData()\fR operate
via the event horizon.
The design of these methods will be discussed in the 
next section.
.pp
The main part of the domain interface is performed in the
\fIgo()\fR method of the
.c Wormhole .
As an example, the \fIgo()\fR method of the
.c SDFWormhole\ class
is defined as follows.
.(c
void SDFWormhole :: go() {
	// set the currentTime of the inner domain.
	scheduler->setCurrentTime(arrivalTime);

	// run
	run();
}
.)c
After getting the input data packets (\fIgrabData()\fR),
the
.c Wormhole
first synchronize the inner domain with the outer domain.
The \fIcurrentTime\fR of the inner 
.IE "currentTime, scheduler"
scheduler is set to equal the arrival time of the data packets
.c (arrivalTime) .
Since the SDF domain is untimed, decision on the arrival time of the
data packets is not trivial, as explained above.
The next step is to call the \fIrun()\fR method of the base
.c Wormhole\ class .
Here is a part of the definition\** of the base 
.c Wormhole\ class .
.(f
\** We omit the members that are not relevant to the domain interface such
as constructor and print methods.
.)f
.(c
	//////////////////////////////
	// Wormhole
	//////////////////////////////
	
class Wormhole : public Runnable {
public:
	void setup() { initSched(); 
		       scheduler->stopBeforeDeadlocked = FALSE ;}

	void run() { if (!checkReady()) return;
		     setStopTime();
		     Runnable :: run(); 
		     sumUp();}

	// redefine setStopTime()
	void setStopTime() { scheduler->resetStopTime(getStopTime()) ;}

protected :
	// get the stopping condition for the inner domain.
	// SHOULD be redefined in the derived class.
	virtual float getStopTime();

	// arrange things after run if necessary
	virtual void sumUp() {}

private :
	// check ready
	int checkReady();
};
.)c
The \fIrun()\fR method of the
.c Wormhole
class consists of four method calls.
The first one, \fIcheckReady()\fR, checks the readiness of the input data.
Suppose the wormhole is a
DE wormhole,
and the inner domain is an SDF domain.  If there is an input event to the
wormhole, then the wormhole
is runnable\** from the point of view of the DE domain, and the \fIgo()\fR
method is called.
.IE "runnable"
.(f
\**The decision of runnability of a wormhole is indistinguishable
from those of other stars.  For example, an
.c SDFWormhole
is runnable when all input ports have sufficient data packets.
.)f
However, the inner SDF domain may not be fired before all input 
.c PortHole s
have enough particles.  In this case, the \fIcheckReady()\fR method
will return FALSE to terminate the execution.
This method is discussed in more detail below.
.pp
When all input data packets are ready, we can initiate the
inner scheduler
by calling the \fIrun()\fR method of the
.c Runnable
class which is the base class of the
.c Wormhole .
Before initiating the inner scheduler,
we should specify its stopping condition
using the \fIsetStopTime()\fR method of the wormhole,
which invokes the \fIresetStopTime()\fR method of the scheduler.
How to set the value of the stop time is discussed above.
.pp
In the initialization stage of the outer
galaxy,
the \fIstart()\fR method is called.  The \fIstart()\fR method of a
wormhole calls the \fIsetup()\fR method of the base
.c Wormhole
class (see for instance the source code
for \fISDFWormhole :: start()\fR in ~ptolemy/src/domains/sdf/kernel).
In the \fIsetup()\fR method, the inner domain is not only initialized
but also any compile-time scheduling for the inner domain is performed.
Also, the flag \fIstopBeforeDeadlocked\fR is set FALSE by default.
The flag will be set TRUE by the inner scheduler
when the inner domain suspends execution before
being deadlocked (meaning that one or more stars
in the domain is runnable).
.IE "deadlock"
.IE "stopBeforeDeadlocked"
