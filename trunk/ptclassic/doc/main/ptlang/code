.\" $Id$
.H1 "Writing C++ code"
.pp
C++ code segments are an important part of any star definition.
They can appear in the
.c start ,
.c go ,
.c wrapup ,
.c constructor ,
.c destructor ,
.c code ,
and
.c method
directives in the \*(PT preprocessor.
These directives all include a body of arbitrary C++ code, enclosed
by curly braces, ``{'' and ``}''.
In all but the
.c code
directive, the C++ code between braces
defines the body of a method
.IE method
of the star class.  This method can access any member of the class,
.IE member
including portholes (for input and output), states, and members
defined with the
.c public ,
.c protected ,
and
.c private
directives.
.H2 "Reading inputs and writing outputs"
.pp
The precise mechanism for references to input and output portholes
depends somewhat on the domain.
We will explain here how such references are used in the SDF domain.
For information about other domains, please see the domain document in
the Almagest.
.H3 "PortHoles and Particles"
.pp
In the SDF domain, normal
inputs and outputs become members of type
.c InSDFPort
and
.c OutSDFPort
after the preprocessor is finished.
.IE InSDFPort
.IE OutSDFPort
These are derived from base class
.c PortHole .
.IE PortHole
For example, given the following directive in the
.c defstar
of an SDF star,
.(c
	input {
		name {in}
		type {float}
	}
.)c
a member of type
.c InSDFPort
will become part of the star.
.pp
We are not usually interested in directly accessing these porthole classes,
but rather wish to read or write data through the portholes.
All data passing through a porthole is derived
from base class
.c Particle .
.IE Particle
Each particle contains data of the type specified in the
.c type
subdirective of the
.c input
or
.c output
directive.
Currently this can be float, int, or complex.
.pp
The operator ``%'' operating on an SDF porthole returns a reference
to a particle.
Consider the following example:
.(c
go {
	Particle& currentSample = in%0;
	Particle& pastSample = in%1;
	...
}
.)c
The right-hand argument to the ``%'' operator specifies the delay
of the access.  A zero always means the most recent particle.
A one means the particle arriving just before the most recent particle.
The same rules apply to outputs.  Given an output named ``out'',
the same particles that are read from ``in'' can be written to
``out'' in the same order as follows:
.(c
go {
	...
	out%1 = pastSample;
	out%0 = currentSample;
}
.)c
This works because
.c out%n
returns a \fIreference\fR to a particle, and hence
can accept an assignment.
The assignment operator for the class
.c Particle
is overloaded to make a copy of the data field of the particle.
.pp
Operating directly on class
.c Particle ,
as in the above examples, is useful for writing stars that accept
ANYTYPE of input.  The operations need not concern themselves
with the type of data contained by the particle.
But it is far more common to operate numerically on the data
carried by a particle.
This can be done using a cast to a compatible type.
For example, since ``in'' above is of type
.c float ,
its data can be accessed as follows:
.(c
go {
	Particle& currentSample = in%0;
	float value = float(currentSample);
	...
}
.)c
or more concisely,
.(c
go {
	float value = float(in%0);
	...
}
.)c
The expression
.c float(in%0)
can be used anywhere that a float can be used.
.pp
To write data to an output porthole, note that the right-hand
side of the assignment operator should be of type
.c Particle ,
as shown in the above example.
An operator ``<<'' is defined for particle classes to make
this more convenient.
Consider the following example:
.(c
go {
	float t;
	t = \fIsome value to be sent to the output\fP
	out%0 << t;
}
.)c
The right-hand side of the ``<<'' operator need not be of class
.c Particle ,
but can rather be any compatible type.
Automated type conversion is discussed below.
.H3 "SDF PortHole parameters"
.pp
In the above example, where
.c in%1
was referenced,
some special action is required to tell \*(PT that past input
particles are to be saved.
Special action is also required to tell the SDF scheduler how
many particles will be consumed at each input and produced
at each output when a star fires.  This information can be
provided through a call to
.c setSDFParams
in the
.c start
method.
.IE setSDFParams
.IE "SDF parameters"
.IE "past particles"
.IE "consuming multiple particles"
.IE "producing multiple particles"
This has the syntax
.(c
start {
	\fIname\fP.setSDFParams(\fImultiplicity, past\fP)
}
.)c
where \fIname\fP is the name of the input or output porthole,
\fImultiplicity\fP is the number of particles consumed or produced,
and \fIpast\fP is the number of past samples accessed.
For the above example, \fIpast\fP would have to be at least one.
.H3 "Multiple PortHoles"
.pp
.IE "multiple portholes"
Sometimes a star should be defined with
.i n
input portholes or
.i n
output portholes, where
.i n
is variable.
This is supported by the class
.c MultiPortHole
.IE MultiPortHole
and its derived classes.
An object of this class is a sequential list of
.c PortHole s.
For SDF, we have the specialized derived class
.c MultiInSDFPort
(which contains
.c InSDFPorts )
and
.c MultiOutSDFPort
(which contains
.c OutSDFPorts ).
.pp
Defining a multiple porthole is easy, as illustrated below:
.(c
defstar {
	...
	inmulti {
		name {\fIinput_name\fP}
		type {\fIinput_type\fP}
	}
	outmulti {
		name {\fIoutput_name\fP}
		type {\fIoutput_type\fP}
	}
}
.)c
.IE inmulti
.IE outmulti
.pp
To successively access individual portholes in a
.c MultiPortHole ,
the
.c MPHIter
iterator class should be used.
.IE iterators
.IE MPHIter
.IE "MuliPortHole iterator"
Consider the following example:
.(c
defstar {
	name {Fork}
	domain {SDF}
	desc { Copies input particles to each output. }
	input {
		name{input}
		type{ANYTYPE}
	}
	outmulti {
		name{output}
		type{= input}
	}
	go {
		MPHIter nextp(output);
		PortHole* p;
		while ((p = nextp++) != 0)
			(*p)%0 = input%0;
	}
}
.)c
A single input porthole supplies a particle that gets copied
to any number of output portholes.
The
.c type
of the
.c output
.c MultiPortHole
is inherited from the type of the input.
The first line of the
.c go
method creates an
.c MPHIter
iterator called
.c nextp ,
initialized to point to portholes in
.c output .
The ``++'' operator on the iterator returns a pointer to the next porthole
in the list, until there are no more portholes, at which time it
returns zero.
So the
.c while
construct steps through all output portholes, copying the input
particle data to each one.
.pp
Consider another example, which sums any number of inputs:
.(c
defstar {
	name {FloatSum}
	domain {SDF}
	desc { Output the sum of the inputs, as a floating value.  }
	inmulti {
		name {input}
		type {float}
	}
	output {
		name {output}
		type {float}
	}
	go {
		MPHIter nexti(input);
		PortHole *p;
		double sum = 0.0;
		while ((p = nexti++) != 0)
			sum += float((*p)%0);
		output%0 << sum;
	}
}
.)c
Again, an
.c MPHIter
iterator named
.c nexti
is created and used to access the inputs.
.pp
Upon occation, the
.c numberPorts()
method of the porthole, which
returns the number of ports, is useful.
.H3 "Type conversion"
.pp
.IE "Particle types"
.IE types
As currently defined, each type of
.c Particle
has a cast defined to other types of particles.
For instance, a float particle can be cast to an int,
in which case the integer part is taken.
Or a complex particle can be cast to float, in which
case the magnitude is taken.
This gives considerable flexibility in defining code that
operates on ANYTYPE.
For instance, since ANYTYPE of particle can be cast to float,
a plotting star can accept ANYTYPE of input, and internally
the star only has to cast the input to float.
Of course, if the input is complex, some information is lost.
Each particle also has a
.c print()
method, so a star that writes particles to a file can
also accept ANYTYPE.
.H2 "States"
.pp
.IE "state"
.IE "attributes"
A state is defined by the
.c defstate
directive.
The star can use a state to store data values, remembering
them from one invocation to another.  They differ from ordinary
members of the star, which are defined using the
.c public ,
.c protected ,
and
.c private
directives, in that they have a name, and can be accessed from
outside the star in systematic ways.  For instance, the graphical
interface Pigi permits the user to set any state with the A_SETTABLE
attribute to some value prior to a run, using the \fIedit-params\fR command.
The interpreter provides similar functionality through the
.c setstate
command.
The state attributes are set in the
.c defstate
directive.
A state may be modified by the star code during a run.
The attribute A_NONCONSTANT is used
.IE A_SETTABLE
.IE A_NONCONSTANT
as a pragma to mark a state as one that gets modified during
a run.
There is currently no mechanism for checking the correctness of these
attributes.
.pp
All states are derived from the base class
.c State ,
defined in the \*(PT kernel.
The derived state classes currently defined in the kernel are
.c FloatState ,
.c IntState ,
.c ComplexState ,
.c StringState ,
.c FloatArrayState ,
and
.c IntArrayState .
.pp
A state can be used in a star method
just like the corresponding predefined data types.
As an example, suppose the star definition contains the following directive:
.(c
defstate {
	name { myState }
	type { float }
	default { 1.0 }
	descriptor { Gain parameter. }
}
.)c
This will define a member of class
.c FloatState
with default value 1.0.
.IE FloatState
No attributes are defined, so A_CONSTANT and A_SETTABLE, the default
attributes, are assumed.
To use the value of a state, it should be cast to type
.c double ,
either explicitly by the programmer or implicitly by the context.
For example, the value of this state can be accessed in the
.c go
method as follows
.(c
go {
	output%0 << myState * (float)(input%0);
}
.)c
The references to input and output are explained above.
The reference to
.c myState
works because an unambiguous cast to
.c double
is defined in
.c FloatState
class, and it is automatically invoked by the C++ compiler.
(Similarly, a cast to
.c int
is defined for
.c IntState ,
to
.c Complex
from
.c ComplexState ,
.IE ComplexState
and to
.c char*
for
.c Stringstate ).
.IE IntState
.IE StringState
.pp
Note that the type
.c Complex
.IE "Complex type"
is not a fundamental part of C++.
We have used a subset of the
.c Complex
class defined by the Free Software Foundation,
and included on the standard distribution tape with the Gnu software.
Using the
.c ComplexState
class will automatically ensure the inclusion of the appropriate header
files.
A member of the
.c Complex
class can be initialized and operated upon any number of ways.
For details, see the file ~ptolemy/src/kernel/ComplexSubset.h.
.pp
.b WARNING:
were the compiler perfect, it would never be necessary to use
explicit casts with
.c State s.
But because of a compiler bug in the Gnu C++ compiler
(g++ version 1.37.1), if you attempt to cast a
.c FloatState
to type
.c float ,
either explicitly by writing
.(c
output%0 << float(myFloatState);
.)c
or implicitly by writing
.(c
float x = myFloatState;
.)c
the compiler will erroneously assign zero.  This bug is fixed
in the alpha version of g++ 1.37.2, but this version hasn't been
released yet.  Until it is, for safety
.i always
write an explicit cast to
.c double
when a
.c FloatState
is used in an expression.  For example:
.(c
go {
	output% << (double(myState) + 0.5) * float(input%0);
}
.)c
Similarly, an
.c IntState
should be cast explicitly to
.c int ,
a
.c ComplexState
to
.c Complex ,
and
.c StringState
to
.c char* .
.pp
A state may be updated by ordinary assignment in C++, as in the following
lines
.(c
	double t;
	t = \fIsome value\fP;
	myState = t;
.)c
This works because the
.c FloatState
class definition has overloaded the assignment operator (``='')
to set its value from a double.
Similarly, an
.c IntState
can be set from an
.c int
and a
.c StringState
can be set from a
.c char* .
Be careful, in the latter case, to be sure that the memory pointed
to by the
.c char*
is persistent.
.H2 "Array States"
.pp
The
.c ArrayState
.IE ArrayState
.c class es
(
.c FloatArrayState ,
.c IntArrayState
and
.c ComplexArrayState )
.IE FloatArrayState
.IE IntArrayState
.IE ComplexArrayState
are used to store arrays of data.
For example,
.(c
defstate {
	name { taps }
	type { FloatArray }
	default { "0.0 0.0 0.0 0.0" }
	descriptor { An array of length four. }
}
.)c
defines an array of type
.c double
with dimension four, with each element initialized to zero.
Quotes must surround the initial values.
Alternatively, you can specify a file name with a prefix 
.c "<".
If you have a file named "foo" that contains the default values for
an array state,
you can write,
.(c
	default { "< foo" }
.)c
The format of the file is also a  sequence of data separated by spaces
(or newlines, tabs, or commas).
File input can be combined with direct data input as in
.(c
	default { "<foo 2.0" }
	default { "0.5 <foo <bar" }
.)c
.pp
A "repeat" notation is also supported for
.c ArrayState
objects: the two value strings
.(c
	default { "1.0 [5]" }
	default { "1.0 1.0 1.0 1.0 1.0" }
.)c
are equivalent.
.pp
The number of elements in an
.c ArrayState
can be determined by calling its
.c size()
method.
The size is not specified explicitly, but is calculated by scanning
the default value.
.pp
As an example of how to access the elements of an
.c ArrayState ,
suppose
.c fState
is a
.c FloatState
and
.c aState
is a
.c FloatArrayState .
The accesses like those in the following lines are routine:
.(c
sState = aState[1] + 0.5;
aState[1] = (double)sState * 10.0;
aState[0] = sState * aState[2];
.)c
.pp
For a more complete example of the use of 
.c FloatArrayState ,
consider the class 
.c FIR
defined below.
Note that this is a simplified version of the SDF
.c FIR
star that does not permit interpolation or decimation.
.(c
defstar {
	name {FIR}
	domain {SDF}
	desc {
A Finite Impulse Response (FIR) filter.
	}
	version {$Revision$ $Date$}
	author { E. A. Lee }
	input {
		name {signalIn}
		type {float}
	}
	output {
		name {signalOut}
		type {float}
	}
	defstate {
		name {taps}
		type {floatarray}
		default {
	"-.040609 -.001628 .17853 .37665 .37665 .17853 -.001628 -.040609"
		}
		desc { Filter tap values. }
	}
	start {
		// tell the PortHole the maximum delay we will use
		signalIn.setSDFParams(1, taps.size() - 1);
	}
	go {
		double out = 0.0;
		for (int i = 0; i < taps.size(); i++)
			out += taps[i] * float(signalIn%i);
		signalOut%0 << out;
	}
}
.)c
.pp
Notice the
.c start
method; this is necessary to allocate a buffer in the input
.c PortHole
large enough to hold the particles that are accessed in the
.c go()
method.
Notice the use of the
.c size()
method of the
.c FloatArrayState.
.pp
We now illustrate an interpreter session using the above
.c FIR
.c Star .
Assume there is a galaxy called
.c SinGen
that generates a sine wave.
you can use it with the
.c FIR
.c star,
as in:
.(c
PTOLEMY: (galaxy foop SinGen)
PTOLEMY: (star fir FIR)
PTOLEMY: (star printer Printer)
PTOLEMY: (connect (foop output)(fir signalIn))
PTOLEMY: (connect (fir signalOut)(printer input))
PTOLEMY: (show fir)
Star: Universe.mainGalaxy.fir
	...
States in the star fir:
Universe.mainGalaxy.fir.taps type: FloatArray
 initial value: -.040609 -.001628 .17853 .37665 .37665 .17853 -.001628 -.040609
 current value:
0 -0.040609
1 -0.001628
2 .17853
3 .37665
4 .37665
5 .17853
6 -0.001628
7 -0.040609
.)c
Then you can re-define taps by reading them from a file "foo", which
contains the data:
.(c
1.1
-2.2
3.3
-4.4
.)c
The resulting interpreter commands are:
.(c
PTOLEMY: (setstate fir taps "<foo 5.5")
PTOLEMY: (show fir)
Star: Universe.mainGalaxy.fir
	...
States in the star fir:
Universe.mainGalaxy.fir.taps type: FloatArray
 initial value: <foo 5.5
 current value:
0 1.1
1 -2.2
2 3.3
3 -4.4
4 5.5
PTOLEMY:
.)c
This illustrates that \fIboth\fR the contents and the size of a
.c FloatArrayState
are changed by a
.c setstate
command.  Also, notice that file values may be combined with
string values; when
.(c
< filename
.)c
occurs in an
.i initial-value ,
it is processed exactly as if the whole file were substituted at
that point.
.H2 "Programming examples"
.pp
The following star has no inputs, just an output.
It generates a linearly increasing or decreasing sequence
of float particles on its output:
.(c
defstar {
	name { FloatRamp }
	domain { SDF }
	desc {
Generates a ramp signal, starting at "value" (default 0)
with step size "step" (default 1).
	}
	output {
		name { output }
		type { float }
	}
	defstate {
		name { step }
		type { float }
		default { 1.0 }
		desc { Increment from one sample to the next. }
	}
	defstate {
		name { value }
		type { float }
		default { 0.0 }
		desc { Initial (or latest) value output by Ramp. }
		attributes { A_SETTABLE|A_NONCONSTANT }
	}
	go {
		double t = value;
		output%0 << t;
		t += step;
		value = t;
	}
}
.)c
The state
.c value
is initialized to define the value of the first output.
Each time the star
.c go()
method fires, the
.c value
state is updated to store the next output value.
.pp
The next example multiplies its input by a constant:
.(c
defstar {
	name { FloatGain }
	domain { SDF }
	desc { Amplifier: output is input times "gain" (default 1.0). }
	input {
		name { input }
		type { float }
	}
	output {
		name { output }
		type { float }
	}
	defstate {
		name { gain }
		type { float }
		default { "1.0" }
		desc { Gain of the star. }
	}
	go {
		output%0 << double(gain) * (float)(input%0);
	}
}
.)c
.pp
The following example illustrates multiple inputs,
ANYTYPE inputs, and the use of the
.c print()
method
of the
.c Particle
class.
.(c
defstar {
	name { Printer }
	domain { SDF }
	desc {
Prints out one sample from each input port per line
If "fileName" is not equal to "cout" (the default), it
specifies the filename to write to.
	}
	explanation {
This star prints its input, which may be any supported type.
There may be multiple inputs: all inputs are printed together on
the same line, separated by tabs.
	}
	inmulti {
		name { input }
		type { ANYTYPE }
	}
	defstate {
		name { fileName }
		type { string }
		default { "cout" }
		desc { Filename for output. }
	}
	protected {
		UserOutput output;
	}
	start {
		output.fileName(fileName);
	}

	go {
		MPHIter nexti(input);
		PortHole* p;
		while ((p = nexti++) != 0)
		 	output << ((*p)%0).print() << "\t";
		output << "\n";
	}
}
.)c
This star is \fIpolymorphic\fR
.IE polymorphism
since it can operate on any type of input.
Note that the default value of the output filename is ``cout'',
which causes the output to go to the standard output.
