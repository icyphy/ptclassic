.\" $Id$
.VR 0.$Revision$ $Date$
.TI "Appendix:  Packets in Ptolemy"
.AU
Joseph Buck
.AE
.IE "packets"
.H1 "Design Criteria for the Packet Interface
.pp
The Ptolemy packet interface is designed to provide a mechanism that
allows stars to transmit packets that are arbitrary objects to other
stars.  The design was constrained by the following criteria:
.IE "packet design criteria"
.bu
Existing stars (stars that were written
before the packet interface was added) that handle ANYTYPE work
with packet particles without change.
.bu
Packet portholes should be able to send different types of packets
during the same simulation (just as a real network does).
.bu
The design should be efficient: we should not repeatedly be required
to copy large packets.  This suggests using a reference-count mechanism
as is used in many C++ classes (for example, string classes).
.bu
At the same time, it should be possible to safely modify large packets
without excessive memory allocation and deallocation.
.bu
It should be easy for users to define their own packet types, and
no change to the kernel should be required to transmit the new packet
types.
.lp
To accomplish this goal, three classes were designed:
.bu
The
.c  PacketData
.IE "class PacketData"
class is the base class from which all other packet datatypes
are derived.  A user who wishes to define an application-specific
packet type creates a new class that is derived from
.c PacketData .
.bu
The
.c Packet
.IE "class Packet"
class is an envelope; it "holds" an object derived from class
.c PacketData .
.c Packet
objects may be copied or duplicated; when this
happens, the contents are not copied (several
.c Packet
objects share the same
.c PacketData
object); at any time, the
.c PacketData
object's reference count says how many
.c Packet
objects refer to it.  When the last reference is removed, the contents
are deleted.
.bu
The
.c PacketSample
.IE "class PacketSample"
class is a type of
.c Particle
(like
.c IntSample ,
.c FloatSample ,
etc); it contains a
.c Packet .
Most users will never see this class directly;
if a
.c PortHole
is declared to be of type ``packet'' it will use this type of
.c Particle .
.pp
Class
.c Particle
contains two member functions for packet support:
.c getPacket ,
to receive a packet, and the "<<" operator with a
.c Packet
as the right argument, to load a packet into a particle.  These functions
return errors in the base class; they are overridden in the
.c PacketSample
class with functions that "do the right thing".
.H1 "Defining A New PacketData Class"
.IE "user-defined packets"
.pp
The designer of a new type of packet does so by defining a new
class that is derived from class
.c PacketData .
Certain virtual functions
defined in that class must be overriden; others may optionally be
overriden.  Here is an example of a user-defined packet type:
.IE "vector packet"
.(c
// This is a simple vector packet body.  It stores
// an array of integer values of arbitrary length.
// The length is specified by the constructor.

#include "Packet.h"

class IntVecData : public PacketData {
private:
	int len;

	init(int length,int *srcData) {
		len = length;
		data = new int[len];
		for (int i = 0; i < len; i++)
			data[i] = *srcData++;
	}

public:
	// the pointer is public for simplicity
	int *data;

	int length() const { return len;}

	// functions for type-checking
	const char* dataType() const { return "IntVecData";}

	// isA responds TRUE if given the name of the class or
	// of any baseclass.
	int isA(const char* typ) const {
		if (strcmp(typ,"IntVecData") == 0) return TRUE;
		else return PacketData::isA(typ);
	}

	// constructor: makes an uninitialized array
	IntVecData(int length) : len(length) {
		data = new int[length];
	}

	// constructor: makes an initialized array from a int array
	IntVecData(int length,int *srcData) { init(length,srcData);}

	// copy constructor
	IntVecData(const IntVecData& src) { init(src.len,src.data);}

	// clone: make a duplicate object
	PacketData* clone() const { return new IntVecData(*this);}

	// destructor
	~IntVecData() {
		delete data;
	}
};
.)c
.pp
This packet body can contain a vector of integers of arbitrary length.
Some functions in the class are arbitrary and the user may define them
in whatever way is most convenient; however, there are some requirements.
.pp
The class must redefine class
.c PacketData 's
.c dataType()
function.
This function returns a string identifying the packet type.  This string
should be identical to the name of the class.  In addition, the
.c isA()
function must be defined.
The
.c isA
Function
responds with TRUE (1) if given the name of the class or of any baseclass;
it returns FALSE (0) otherwise.  This mechanism permits stars to handle
any of a whole group of packet types, even for classes that are defined
after the star is written.
.pp
Because of the regular structure of
.c isA
function bodies, macros are provided to generate them.  The
.c ISA_INLINE
macro expands to an inline definition of the function; for example,
.(c
	ISA_INLINE(IntVecData,PacketData)
.)c
could have been written above instead of the definition of
.c isA
to generate exactly the same code.  Alternatively, to put the function
body in a .cc file, one can write
.(c
		int isA(const char*) const;
.)c
in the class body and put
.(c
ISA_FUNC(IntVecData,PacketData)
.)c
in the .cc file.
.pp
The class must define a copy constructor, unless the default
copy constructor generated by the compiler, which does memberwise copying,
will do the job.
.pp
The class must redefine class
.c PacketData 's
.c  clone()
function.  Given that the copy constructor is defined, the form shown
in the example, where a new object is created with the
.c new
operator and the copy constructor, will suffice.
.pp
In addition, the user may optionally define type conversion and printing
functions if they make sense.  If a star that produces packets is connected
to a star that expects integers (or floating values, or complex values),
the appropriate type conversion function is called.  The base class,
.c PacketData ,
defines the virtual conversion functions
.c asInt() ,
.c asFloat() ,
and
.c asComplex()
and the printing function
.c print()
\- see the Packet.h file for their exact types.  The base class conversion
functions assert a run-time error, and the default print function returns
a
.c StringList
saying
.(l
<\fItype\fR>: no print method
.)l
where
.i type
is whatever is returned by
.c dataType() .
.pp
By redefining these functions, you can make it legal to connect a star
that generates packets to a star that expects integer,
floating, or complex particles, or you can connect to a Printer or Xgraph
star (for Xgraph to work, you must define the
.c asFloat
function; for Printer to work, you must define the
.c print
function).
.H1 "Use of the Packet class"
.IE "class Packet"
.pp
The
.c Packet
class serves as an envelope to hold objects of class
.c PacketData
or derived classes. 
.pp
The constructor (which takes as argument a reference to
.c PacketData ),
copy constructor, and assignment operator for
.c Packet
manipulate the reference counts of the
.c PacketData
object inside the
.c Packet
objects.  Assignment simply copies a pointer and increments the
reference count.  Whenever the destructor for a
.c Packet
is called, the reference count of the contents is decremented; if
it reaches zero, the contained
.c PacketData
object is deleted.  Because of this deletion, a
.c PacketData
must never be put inside a
.c Packet
unless it was created with the
.c new
operator.  Once a
.c PacketData
object is put into a
.c Packet
it should never be deleted; it will ``live'' as long as
there is at least one
.c Packet
that contains it and will then be deleted automatically.
.pp
The
.c dataType()
member function of
.c Packet
returns the datatype of the contained
.c PacketData
object; the functions
.c asInt() ,
.c asFloat() ,
.c asComplex() ,
and
.c print()
are also ``passed through'' in a similar way to the contained object.
.pp
Two functions are provided for convenience to make type checking simpler:
.c typeCheck
and
.c typeError .
A simple example illustrates their use:
.(c
	if (!packet.typeCheck("IntVecData")) {
		Error::abortRun(*this,packet.typeError("IntVecData"));
		return;
	}
.)c
.c typeCheck
calls
.c isA
on the packet contents and returns the result, so an error will be
reported if the packet contents are not IntVecData and are not
derived from IntVecData.  Since the above code segment is so common in
stars; a macro is included in Packet.h to generate it; the macro
.(c
	TYPE_CHECK(packet,"IntVecData");
.)c
expands to essentially the same code as above and is shorter to type.
.c typeError
generates an appropriate error message:
.pp
Expected packet type '\fIarg\fR', got '\fItype\fR'
.pp
To access the data, two functions are provided:
.c getData()
and
.c writableCopy() .
The
.c getData
function
returns a pointer to the contained
.c PacketData -derived
object.
.i "The data pointed to by this pointer must not be modified" ,
since other
.c Packet
objects in the program may also contain it.  If you convert its type,
always make sure that the converted type is a pointer to const
(see the programming example for UnPackInt below).  This will
ensure that the compiler will complain if you do anything illegal.
.pp
The
.c writableCopy
function also returns a pointer to the contained object, but with a difference.
If the object's reference count is one, the packet is zeroed (set to
the null packet) and the contents are returned.  If the reference
count is more than one, a
.i clone
of the contents is made (by calling its
.c clone()
function) and that is returned; again the packet is zeroed (to
avoid the making of additional clones later on).
.pp
In some cases, a star writer will need to keep a received
.c PacketData
object around between executions.  One way to accomplish this is
for the star to have a member of type
.c Packet ,
and to use this member object to hold the packet data between
executions.
.H1 "Use of the PacketSample class"
.IE "class PacketSample"
.pp
In normal star code that uses packets, the user does not see directly
that he or she is using class PacketSample.  However, if a
.c PortHole
is declared to be of type `packet',
then the
.c Particle
objects used by that
.c PortHole
will be of type
.c PacketSample .
The only functions specific to class
.c PacketSample
that are visible to the user are virtual functions that override
functions provided by class
.c Particle .
.pp
Many of
.c Particle 's
functions are redefined to cause a run-time error; for example, it
is illegal to send an integer, floating, or complex number to the
particle with the `<<' operator.  The conversion operators (conversion
to type int, float, or Complex) return errors by default, but can
be made legal by redefining the
.c asInt ,
.c asFloat ,
or
.c asComplex
member functions for a specific packet type.
.pp
The principal operations on
.c PacketSample
objects are `<<' with an argument of type
.c Packet ,
to load a packet into the particle, and
.c getPacket(Packet&) ,
to transfer packet contents from the particle into a user-supplied
packet.
.c getPacket
removes the packet contents from the particle.
.(f
The reason for this
``aggressive reclamation'' policy (both here and in other places)
is to minimize the number of no-longer-needed
packets in the system and to prevent unnecessary clones from being
generated by
.c writableCopy()
by eliminating references to
.c PacketData
objects as soon as possible.
.)f
For cases where the destructive behavior of
.c getPacket
cannot be tolerated, an alternate interface,
.c accessPacket(Packet&) ,
is provided.  It does not remove the packet contents from the particle.
Promiscuous use of
.c accessPacket
in systems where large-sized packets may be present can cause the
amount of virtual memory occupied to grow (though all packet will
be deleted eventually).
.H1 "Use of Packets in Stars"
.pp
Here are a couple of simple examples of stars that produce and
consume packets.  For more advanced samples, look in the Ptolemy
distribution for stars that produce or consume packets.
.IE "packet programming example"
.(c
defstar {
	name { PackInt }
	domain { SDF }
	desc { Accept integer inputs and produce IntVecData packets.}
	defstate {
		name { length }
		type { int }
		default { 10 }
		desc { number of values per packet }
	}
	input {
		name { input }
		type { int }
	}
	output {
		name { output }
		type { packet }
	}
	ccinclude { "Packet.h", "IntVecData.h" }
	start {
		input.setSDFParams(int(length),int(length-1));
	}
	go {
		int l = length;
		IntVecData * pd = new IntVecData(l);
		// Fill in packet.  input%0 is newest, must reverse
		for (int i = 0; i < l; i++)
			pd->data[l-i-1] = int(input%i);
		Packet pkt(*pd);
		output%0 << pkt;
	}
}
.)c
.pp
Since this is an SDF star, it must produce and consume a constant
number of tokens on each step, so the packet length must be fixed
(though it is controllable with a state).  Notice that the output
porthole is declared to be of type packet.  Notice also the
.c ccinclude
statement; we must include the file Packet.h in all packet-manipulating
stars, and we must also include the definition of the specific
packet type we wish to use.
.pp
The code itself is fairly straightforward -- an
.c IntVecData
object is created with 
.c new ,
it is filled in with data, put into a
.c Packet
envelope, and sent.  Resist the temptation to declare the
.c IntVecData
object as a local variable; it won't work.
.pp
And here's a star to do the inverse operation:
.(c
defstar {
	name { UnPackInt }
	domain { SDF }
	desc {
Accept IntVecData packets and produce integers.  The first 'length'
values from each packet are produced.
	}
	defstate {
		name { length }
		type { int }
		default { 10 }
		desc { number of values output per packet }
	}
	input {
		name { input }
		type { packet }
	}
	output {
		name { output }
		type { int }
	}
	ccinclude { "Packet.h", "IntVecData.h" }
	start {
		output.setSDFParams(int(length),int(length-1));
	}
	go {
		Packet pkt;
		(input%0).getPacket(pkt);
		if (!pkt.typeCheck("IntVecData")) {
			Error::abortRun(*this,pkt.typeError("IntVecData"));
			return;
		}
		const IntVecData * pd = (const IntVecData *)pkt.myData();
		if (pd.length() < int(length)) {
			Error::abortRun(*this,"Received packet is too short");
			return;
		}
		for (i = 0; i < int(length); i++) {
			output%(int(length)-i-1) << pd->data[i];
		}
	}
}
.pp
Because the domain is SDF, we must always produce the same number of
outputs regardless of the size of the packets.  The simple approach
taken here is to require at least a certain amount of data or else
die.
.pp
The operations here are to declare an envelope, get the data from the
particle into the envelope with
.c getPacket ,
check the type, and then access the contents.  Notice the cast operation;
this is needed because
.c myData
returns a const pointer to class
.c PacketData .
It is important that we converted the pointer to
.c "const IntVecData *"
and not
.c "IntVecData *"
because we have no right to modify the packet through this pointer.
Most C++ compilers will not warn by default about ``casting away const''; we
recommend turning on compiler warnings when compiling code that
uses packets to avoid getting into trouble (for
.i g++ ,
say
.c \-Wcast-qual ;
for
.i cfront -derived
compilers, say
.c \+w ).
.pp
If we wished to modify the packet and then send the result as an output,
we would call
.c writableCopy
instead of
.c myData ,
modify the object, then send it on its way as in the previous star.
.)c
