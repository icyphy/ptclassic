# Tcl script for generating Ptolemy star definitions from Esterel programs.
#
# Author: Edward A. Lee
# Version: $Id$
#
# Copyright (c) 1990-%Q% The Regents of the University of California.
# All rights reserved.
# 
# Permission is hereby granted, without written agreement and without
# license or royalty fees, to use, copy, modify, and distribute this
# software and its documentation for any purpose, provided that the
# above copyright notice and the following two paragraphs appear in all
# copies of this software.
# 
# IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY
# FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
# ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF
# THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.
# 
# THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE
# PROVIDED HEREUNDER IS ON AN "AS IS" BASIS, AND THE UNIVERSITY OF
# CALIFORNIA HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,
# ENHANCEMENTS, OR MODIFICATIONS.
# 
# 						PT_COPYRIGHT_VERSION_2
# 						COPYRIGHTENDKEY
# See the file $PTOLEMY/copyright for copyright notice,
# limitation of liability, and disclaimer of warranty provisions.

if {$argc < 2} {
    puts "Usage: esterel2pl domain file(s) [options]"
    exit 1
}

# Parse the argument list
set domain [lindex $argv 0]
set strlfiles ""
for {set i 1} {$i < $argc} {incr i} {
    set arg [lindex $argv $i]
    switch -regexp $arg {
	-B {
	    incr i
	    if {$i < $argc} {set base [lindex $argv 1]}
	}
	.*\.strl {
	    lappend strlfiles $arg
	}
	.*\.c {
	    lappend cfiles $arg
	}
	.*\.cc {
	    lappend ccfiles $arg
	}
	.*\.h {
	    lappend hfiles $arg
	}
	default {
	    lappend options $arg
	}
    }
    # Set base name, if not already set
    if {![info exists base]} {
	if {[llength $strlfiles] == 1} {
	    set l [string first .strl [lindex $strlfiles 0]]
	    set base [string range [lindex $strlfiles 0] 0 [expr $l-1]]
	}
    }
    # If no basename was specified, use "esterel"
    if {![info exists base]} {
	set base esterel
    }   
}

# Check for supported domains, and set flags for quick testing
set de 0
set sdf 0
switch -exact $domain {
    DE {set de 1}
    SDF {set sdf 1}
    default {
	puts "Sorry, domain $domain is not currently supported"
	exit 1
    }
}

puts "Creating Ptolemy star \"$base\" for the $domain domain"

# Check to see whether the .lc file needs to be created
# First compute the latest update time of all the .strl files
set time 0
foreach file $strlfiles {
    if {[file readable $file]} {
	set ftime [file mtime $file]
	if {$ftime > $time} {set time $ftime}
    }
}
if {(![file readable ${base}.lc] ||
     ([file mtime ${base}.lc] < $time))} {
	 if {[info exists options]} {
	     puts "esterel -Klc -B $base $strlfiles $options"
	     exec esterel -Klc -B $base $strlfiles $options
	 } {
	     puts "esterel -Klc -B $base $strlfiles"
	     exec esterel -Klc -B $base $strlfiles
	 }	     
}
if {![file readable ${base}.lc]} {
    error "Can't create ${base}.lc intermediate form file"
    exit 1
}
set fid [open ${base}.lc]

# Read the .lc file for inputs, outputs, sensors, etc.
#
while {[gets $fid line] != -1} {
    set splitline [split $line]
    switch -exact [lindex $splitline 1] {
	input: {
	    # FIXME: Are there other options?
	    switch -exact [lindex $splitline 4] {
		pure: {
		    lappend pure_inputs [lindex $splitline 2]
		}
		single: {
		    lappend value_inputs [lindex $splitline 2]
		}
	    }
	}
	sensor: {
	    lappend sensor_inputs [lindex $splitline 2]
	}
	output: {
	    # FIXME: I'm not sure what the other possibilities in this field mean.
	    # "single" and "multiple" seem to be common.
	    switch -exact [lindex $splitline 4] {
		pure: {
		    lappend pure_outputs [lindex $splitline 2]
		}
		single: {
		    lappend value_outputs [lindex $splitline 2]
		}
	    }
	}
    }
}
close $fid

# Create the .pl file for writing
#
if {[catch {open ${domain}${base}.pl w} ofid] != 0} {
    error "Cannot open file for writing: ${domain}${base}.pl"
    exit 1
}

puts $ofid "defstar {
  name { $base }
  domain { $domain }
  desc { Star generated by esterel2pl }"

# Define the inputs and outputs of the Ptolemy star.
# For dataflow domains, pure inputs are of type int.
# For DE, however, pure inputs are of anytype.
if {$de} {set puretype anytype} \
	 {set puretype int}
	 
if {[info exists pure_inputs]} {
    foreach input $pure_inputs {
	puts $ofid "  input { name { $input } type { $puretype } }"
    }
}
if {[info exists sensor_inputs]} {
    foreach input $sensor_inputs {
	puts $ofid "  input { name { $input } type { int } }"
    }
}
if {[info exists value_inputs]} {
    foreach input $value_inputs {
	puts $ofid "  input { name { $input } type { int } }"
    }
}
if {[info exists pure_outputs]} {
    foreach output $pure_outputs {
	puts $ofid "  output { name { $output } type { int } }"
    }
}
if {[info exists value_outputs]} {
    foreach output $value_outputs {
	puts $ofid "  output { name { $output } type { int } }"
    }
}

# global definitions
puts $ofid "  code {
    static ${domain}${base} *esterelStar = NULL;"
    
    if {$de} {puts $ofid "    static double now = 0.0;"}

if {[info exists pure_outputs]} {
    foreach output $pure_outputs {
	puts $ofid "    extern \"C\" void"
	puts $ofid "    ${base}_O_$output () {"
	if {$de} {
	    puts $ofid "        (esterelStar->${output}).put(now) << 1;"
	} {
	    puts $ofid "        (esterelStar->${output})%0 << 1;"
	}
	puts $ofid "    }"
    }
}

if {[info exists value_outputs]} {
    foreach output $value_outputs {
	puts $ofid "    extern \"C\" void"
	puts $ofid "    ${base}_O_$output (int val) {"
	if {$de} {
	    puts $ofid "        (esterelStar->${output}).put(now) << val;"
	} {
	    puts $ofid "        (esterelStar->${output})%0 << val;"
	}
	puts $ofid "    }"
    }
}

if {[info exists sensor_inputs]} {
    foreach input $sensor_inputs {
	puts $ofid "    extern \"C\" int"
	puts $ofid "    ${base}_S_$input () {"
	puts $ofid "        return (esterelStar->${input})%0;"
	puts $ofid "    }"
    }
}

puts $ofid "    extern \"C\" {\n#include \"${base}.c\"\n    }"

if {[info exists hfiles]} {
    foreach file $hfiles {
	puts $ofid "#include \"${file}\""
    }
}

if {[info exists ccfiles]} {
    foreach file $ccfiles {
	puts $ofid "#include \"${file}\""
    }
}

if {[info exists cfiles]} {
    foreach file $cfiles {
	puts $ofid "    extern \"C\" {\n#include \"${file}\"\n    }"
    }
}

# End of "code" section
puts $ofid "  }"

# "begin" section
puts $ofid "  begin {
    esterelStar = this;
  }"

# "go" section
puts $ofid "  go {"
if {$de} {puts $ofid "    now = arrivalTime;"}

if {[info exists pure_inputs]} {
    foreach input $pure_inputs {
    	if {$de} {
	    puts $ofid "    if (${input}.dataNew) {"
	    puts $ofid "        ${input}.get();"
	    puts $ofid "        ${base}_I_${input}();"
	    puts $ofid "    }"
	} {
	    puts $ofid "    if (${input}%0) {"
	    puts $ofid "        ${base}_I_${input}();"
	    puts $ofid "    }"
	}
    }
}

if {[info exists value_inputs]} {
    foreach input $value_inputs {
        if {$de} {
            puts $ofid "    if (${input}.dataNew) {"
            puts $ofid "        ${base}_I_${input}(${input}.get());"
            puts $ofid "    }"
	} {
	    puts $ofid "    ${base}_I_${input}(${input}%0);"
	}
    }
}

# Invoke an Esterel tick
puts $ofid "    ${base}();"

# End of "go" section
puts $ofid "  }"

puts $ofid "}"
close $ofid
