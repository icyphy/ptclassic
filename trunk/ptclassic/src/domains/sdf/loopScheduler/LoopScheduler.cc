static const char file_id[] = "LoopScheduler.cc";
/******************************************************************
Version identification:
$Id$

 Copyright (c) 1990 The Regents of the University of California.
                       All Rights Reserved.

 Programmer:  Shuvra Bhattacharyya, Soonhoi Ha (4/92)
 Date of creation: 5/9/91

Loop scheduler

*******************************************************************/
#ifdef __GNUG__
#pragma implementation
#endif

#include "LoopScheduler.h"
#include "DecomGal.h"
#include "Target.h"
#include "Error.h"
#include "streamCompat.h"


////////////////////////////
// Loop Scheduler methods //
////////////////////////////

//
// Main routine for LoopScheduler
//
int LoopScheduler::computeSchedule(Galaxy& g)
{
	LOG_DEL; delete cgal;

	// log file stuff.
	const char* file = logFile;
	ostream* logstrm = 0;
	if (file && *file) {
		if (strcmp(file,"cerr") == 0 || strcmp(file,"stderr") == 0)
			logstrm = &cerr;
		else {
			int fd = creat(expandPathName(file), 0666);
			if (fd < 0) {
			    Error::warn(g, "Can't open log file ",file);
			} else {
				LOG_NEW; logstrm = new ofstream(fd);
			}
		}
	}

	// Step 1. Shuvra's decomposition idea.
	//	   After removing the arcs with enough delays.

	LOG_NEW; DecomGal* dGal = new DecomGal(g, logstrm);
	cgal = dGal;

	dGal->simplify();	// remove arcs with enough delays.
	dGal->decompose();	// decomposition step.

	// Step 2. Joe's clustering algorithm.
	// It now deals correctly with feed-forward delays, so we
	// do not need to apply it twice as before.

	dGal->cluster();

	// if the clusterGal is not uni-rate, do this
	if (dGal->uniformRate() == FALSE) {
		dGal->loopAll();
		dGal->mergePass();
	}

	//
	// Step3. generate top-level schedule.  Subschedules are
	// generated by simRunStar methods for bag clusters.
	
	if (SDFScheduler::computeSchedule(*dGal)) {
		if (logstrm) {
			*logstrm << "Schedule:\n" << displaySchedule();
			logstrm->flush();
			LOG_DEL; delete logstrm;
		}
		return TRUE;
	} else {
		return FALSE;
	}
}

StringList LoopScheduler::displaySchedule() {
	StringList sch;
	SDFSchedIter next(mySchedule);
	SDFCluster* c;
	while ((c = (SDFCluster*) next++) != 0) {
		sch += ((SDFCluster*) c)->displaySchedule(0);
	}
	return sch;
}

void LoopScheduler::compileRun() {
	Target& targ = target();
	SDFSchedIter next(mySchedule);
	SDFCluster* c;
	while ((c = (SDFCluster*) next++) != 0) {
		c->genCode(targ,0);
	}
}
