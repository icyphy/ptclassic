#ifndef lint
static char SccsId[]="$Id$";
#endif /*lint*/
/*
Copyright (c) 1990-%Q% The Regents of the University of California.
All rights reserved.

Permission is hereby granted, without written agreement and without
license or royalty fees, to use, copy, modify, and distribute this
software and its documentation for any purpose, provided that the
above copyright notice and the following two paragraphs appear in all
copies of this software.

IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY
FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF
THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF
SUCH DAMAGE.

THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE
PROVIDED HEREUNDER IS ON AN "AS IS" BASIS, AND THE UNIVERSITY OF
CALIFORNIA HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,
ENHANCEMENTS, OR MODIFICATIONS.

						PT_COPYRIGHT_VERSION_2
						COPYRIGHTENDKEY
*/
#include "copyright.h"
#include "port.h"
#include "utility.h"
#include "errtrap.h"
#include "oct.h"
#include "oh.h"
#include "list.h"
#include "tap_int.h"

struct boxId {
    octId id;
    struct octBox box;
};

static void freeElement();
static lsList buildList();
static void fixAspectRatio();
static void placeObjects();
static int getRowDim();

/*LINTLIBRARY*/

/*
*	tapLayoutPalette -- lay out objects neatly in a palette
*
*   Takes the objects generated by `*genPtr' (often a user defined
*   generator) and arranges them in rows, separated vertically and
*   horizontally by at least `pad', attempting to achieve an aspect
*   ratio of approximately `widthOverHeight'.  The end of a row can be
*   forced at a particular place by having the generator return an
*   object without a valid bounding box (this could be a non-geometric
*   object or even a non-existent object, if a user defined generator
*   is used). When the generator is exhausted, the objects are moved
*   and the function returns.  The array of objects is alwaysplaced
*   with its upper-left corner at the containing facet's origin.
*/

void tapLayoutPalette(genPtr, pad, widthOverHeight)
octGenerator *genPtr;	/* generator for objects */
octCoord pad;		/* minimum inter-object spacing (in oct units) */
double widthOverHeight;	/* desired aspect ratio */
{
    lsList bBoxList;	/* list of object ids and bounding boxes */
    lsList buildList();
    void fixAspectRatio(), placeObjects(), freeElement();

    TAP_START("tapLayoutPalette");

    bBoxList = buildList(genPtr);
    fixAspectRatio(bBoxList, pad, widthOverHeight);
    placeObjects(bBoxList, pad);
    lsDestroy(bBoxList, freeElement);

    TAP_END();
}

static void freeElement(boxPtr)
struct boxId *boxPtr;
{
    FREE(boxPtr);
}

static lsList buildList(genPtr)
octGenerator *genPtr;	/* generator for objects */
{
    lsList bBoxList;
    octObject obj;
    octStatus stat;
    struct boxId *boxPtr;

    bBoxList = lsCreate();
    while ((stat = octGenerate(genPtr, &obj)) == OCT_OK) {
	boxPtr = ALLOC(struct boxId, 1);
	boxPtr->id = obj.objectId;
	if (octBB(&obj, &boxPtr->box) != OCT_OK) {
	    boxPtr->id = oct_null_id;
	}
	lsNewEnd(bBoxList, (lsGeneric) boxPtr, LS_NH);
    }
    OCT_ASSERT(stat);
    return(bBoxList);
}

static void fixAspectRatio(bBoxList, pad, widthOverHeight)
lsList bBoxList;	/* list of object ids and bounding boxes */
octCoord pad;		/* minimum inter-object spacing (in oct units) */
double widthOverHeight;	/* desired aspect ratio */
{
    octCoord rowWidth, rowHeight, totWidth, totHeight, desiredWidth;
    lsGen boxGen;
    lsGeneric dummy;
    struct boxId *boxPtr;
    int rowCount;

    totWidth = 0;
    totHeight = -pad;
    boxGen = lsStart(bBoxList);
    while (getRowDim(boxGen, &rowWidth, &rowHeight, pad)) {
	totWidth = MAX(totWidth, rowWidth);
	totHeight += rowHeight + pad;
    }
    lsFinish(boxGen);

    desiredWidth = sqrt(widthOverHeight * totWidth * totHeight);

    if (desiredWidth >= totWidth) {
	/* can't improve it without merging rows */
	return;
    }

    boxGen = lsStart(bBoxList);
    rowWidth = -pad;
    rowCount = 0;
    while (lsNext(boxGen, &dummy, LS_NH) == LS_OK) {
	boxPtr = (struct boxId *) dummy;
	if (octIdIsNull(boxPtr->id)) {
	    rowWidth = -pad;
	    rowCount = 0;
	} else {
	    rowWidth += boxPtr->box.upperRight.x-boxPtr->box.lowerLeft.x + pad;
	    if (rowCount++ && rowWidth > desiredWidth) {
		(void) lsPrev(boxGen, &dummy, LS_NH);
		boxPtr = ALLOC(struct boxId, 1);
		boxPtr->id = oct_null_id;
		lsInBefore(boxGen, (lsGeneric) boxPtr, LS_NH);
		(void) lsPrev(boxGen, &dummy, LS_NH);
		rowWidth = -pad;
		rowCount = 0;
	    }
	}
    }
    lsFinish(boxGen);
}

static void placeObjects(bBoxList, pad)
lsList bBoxList;	/* list of object ids and bounding boxes */
octCoord pad;		/* minimum inter-object spacing (in oct units) */
{
    octCoord rowWidth, rowHeight, curX, curY;
    lsGen scanGen, modifyGen;
    lsGeneric dummy;
    struct boxId *boxPtr;
    struct octTransform transform;
    octObject obj;

    curX = curY = 0;
    transform.transformType = OCT_NO_TRANSFORM;
    scanGen = lsStart(bBoxList);
    modifyGen = lsStart(bBoxList);

    while (getRowDim(scanGen, &rowWidth, &rowHeight, pad)) {
	while (lsNext(modifyGen, &dummy, LS_NH) == LS_OK &&
		(boxPtr = (struct boxId *) dummy, !octIdIsNull(boxPtr->id))) {
	    transform.translation.x = curX - boxPtr->box.lowerLeft.x;
	    transform.translation.y = curY -
			(rowHeight +
			 boxPtr->box.lowerLeft.y + boxPtr->box.upperRight.y)/2;
	    OCT_ASSERT(ohGetById(&obj, boxPtr->id));
	    OCT_ASSERT(octTransformAndModifyGeo(&obj, &transform));

	    curX += boxPtr->box.upperRight.x - boxPtr->box.lowerLeft.x + pad;
	}

	curX = 0;
	curY -= rowHeight + pad;
    }
    lsFinish(scanGen);
    lsFinish(modifyGen);
}

static int getRowDim(boxGen, widthPtr, heightPtr, pad)
lsGen boxGen;		/* steps through the bounding boxes */
octCoord *widthPtr;	/* for returning width of row */
octCoord *heightPtr;	/* for returning height of row */
octCoord pad;		/* minimum inter-object spacing (in oct units) */
{
    lsGeneric dummy;
    struct boxId *boxPtr;
    int genActive = 0;

    *widthPtr = -pad;
    *heightPtr = 0;

    while (lsNext(boxGen, &dummy, LS_NH) == LS_OK) {
	genActive = 1;
	boxPtr = (struct boxId *) dummy;
	if (octIdIsNull(boxPtr->id)) break;
	*widthPtr += boxPtr->box.upperRight.x - boxPtr->box.lowerLeft.x + pad;
	*heightPtr = MAX(*heightPtr,
			 boxPtr->box.upperRight.y - boxPtr->box.lowerLeft.y);
    }

    return(genActive);
}
