##########################################################################
# Version: $Id$
# Author: Edward A. Lee, John Reekie
#
# @Copyright (c) 1996-%Q% The Regents of the University of California.
# All rights reserved.
# 
# Permission is hereby granted, without written agreement and without
# license or royalty fees, to use, copy, modify, and distribute this
# software and its documentation for any purpose, provided that the
# above copyright notice and the following two paragraphs appear in all
# copies of this software.
# 
# IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY
# FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
# ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF
# THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.
# 
# THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE
# PROVIDED HEREUNDER IS ON AN "AS IS" BASIS, AND THE UNIVERSITY OF
# CALIFORNIA HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,
# ENHANCEMENTS, OR MODIFICATIONS.
# 
# 						PT_COPYRIGHT_VERSION_2
# 						COPYRIGHTENDKEY
##########################################################################


##########################################################################
#### Digraph
#
# The _Digraph_ model is a standard directed graph.  It extends the
# _AbstractGraph_ superclass with concrete methods for a number
# of common algorithms on directed graphs.
#
# Here are some examples of its use; see <a 
# href="AbstractGraph">AbstractGraph</a> for examples of
# the basics of graph construction. First, create a graph
# that looks like this:
# <pre>
#   d----+
#        v
#   a--->b&lt;==>c
#   |         ^
#   +---------+
# </pre>
# <tcl><pre>
#     catch {delete object $graph}
#     set graph [::tycho::Digraph [::tycho::autoName graph]]
#     $graph read string {
#         vertex a
#         vertex b
#         vertex c
#         vertex d
#         edge a b
#         edge b c
#         edge a c
#         edge c b
#         edge d b
#     }
#     $graph describe
# </tcl></pre>
#
# Get the children of a vertex:
# <pre><tcl>
#     $graph children a
# </tcl></pre>
#
# Get the parents of a vertex:
# <pre><tcl>
#     $graph parents b
# </tcl></pre>
#
# Test if the graph is acyclic:
# <pre><tcl>
#     $graph acyclic
# </tcl></pre>
#
# Get the roots of the graph:
# <pre><tcl>
#     $graph roots
# </tcl></pre>
#
# Get the topological sort of the graph:
# <pre><tcl>
#     $graph topologicalSort
# </tcl></pre>
#
# Get a depth-sort of the graph:
# <pre><tcl>
#     $graph depthSort
# </tcl></pre>
#
# Get the graph in a grid layout (Not working!):
# <pre><tcl>
#     $graph gridLayout
# </tcl></pre>
#
class ::tycho::Digraph {
    inherit ::tycho::AbstractGraph
    
    constructor {args} {}
    destructor {}

    #################################################################
    ####                     public methods                      ####

    # Test if the graph is acyclic
    method acyclic {}

    # Get the children of a vertex
    method children {vertex}

    # Remove a vertex _and_ adjacent edges from the graph
    method delete {vertex}

    # Add an edge and attributes to the graph
    method edge {vertex1 vertex2 args}

    # Return all attributes of an edge
    method edgeattrs {vertex1 vertex2}

    # Get an attribute or attributes of an edge
    method edgecget {vertex1 vertex2 attribute}

    # Configure the edge with one or more attributes
    method edgeconfigure {vertex1 vertex2 args}

    # Remove an edge from the graph
    method edgedelete {vertex1 vertex2}

    # Return edges matching a pair of connection patterns
    method edges {{pattern1 *} {pattern2 *}}

    # Get the "leaves" of the graph
    method leaves {}

    # Get the parents of a vertex
    method parents {vertex}

    # "Repair" a graph by deleting improperly-connected edges
    method repair {}

    # Get the roots of the graph
    method roots {}

    # Get the edges within a subgraph
    method subgraphEdges {args}

    # Get the input edges to a subgraph
    method subgraphInputs {args}

    # Get the output edges from a subgraph
    method subgraphOutputs {args}

    #################################################################
    ####                   protected methods                     ####

    # Edges cannot be nested
    protected method _edge {context args} {
    	_nesterror edge $context [list $vertex1 $vertex2]
    }
    
    # Evaluate code in this object's context
    protected method evalInSpecificContext {args} {eval $args}
}

########################################################################
#### constructor
#
body ::tycho::Digraph::constructor {args} {
    # Define the "edge" link
    defineLinkType edge \
	    -description ""

    # Evaluate options
    eval configure $args
}

########################################################################
#### acyclic
#
# Test if the graph is acyclic. This is a based on Tarjan's
# algorithm for strongly-connected components (simplified a lot!).
# See Sedgewick.
#
body ::tycho::Digraph::acyclic {} {
    # Don't traverse if we don't have to
    if { [::info exists _cache(acyclic)] } {
	return $_cache(acyclic)
    }

    # The mark for each vertex is initialized to 0
    foreach v [array names _vertices] {
	set _cache($v,visited) 0
    }

    # Initialize the traversal stack with the roots of the graph
    set stack [roots]
    
    # Initialize the vertex counter
    set count 0

    # A larger number than the counter can reach
    set N [expr [llength [vertices]] + 1]

    # Keep processing vertices until there are none left
    while { $stack != "" } {
	# Read the vertex on the top of the stack
	set current [lindex $stack end]

	switch -exact $_cache($current,visited) {
	    "0" {
		# The vertex has not been seen, so mark it but leave
		# it on the stack
		incr count
		set _cache($current,visited) $count
		
		# Check the children
		foreach child [children $current] {
		    if { ! $_cache($child,visited) } {
			# If not seen, put it on the stack
			lappend stack $child
		    } else {
			# If its index is lower, we have a cycle
			if { $_cache($child,visited) <= $count } {
			    set _cache(acyclic) 0
			    return 0
			}
		    }
		}
	    }
	    $N {
		# This vertex has already been processed, by some other
		# path through the graph. Remove it from the stack.
		set stack [lreplace $stack end end]
	    }
	    default {
		# This vertex is still on the stack. Remove
		# it from the stack and mark it as "done."
		set stack [lreplace $stack end end]
		set _cache($current,visited) $N
	    }
	}
    }
    
    # If we get to here, we have no cycles
    set _cache(acyclic) 1
    return 1
}

########################################################################
#### children
#
# Return the children of a vertex. An error will result
# if the vertex does not exist.
#
body ::tycho::Digraph::children {vertex} {
    return $_adjacency($vertex,children) 
}

########################################################################
#### delete
#
# Delete a vertex and all connected edges from the graph, and
# return the inverse command.
#
body ::tycho::Digraph::delete {vertex} {
    _verify vertex {} $vertex

    # Start inverse command
    set inverse [list sequence]

    # Delete outward edges
    foreach {src tgt} [edges $vertex *] {
	lappend inverse [edgedelete $src $tgt]
    }
    # Delete inward edges
    foreach {src tgt} [edges * $vertex] {
	lappend inverse [edgedelete $src $tgt]
    }
    # Delete the vertex. (NB: This must follow the edge deletion.)
    lappend inverse [vertexdelete $vertex]

    # Return the inverse command
    return $inverse
}

########################################################################
#### edge
#
# Add a new edge to the graph, and return the inverse command.
# By default, this method just adds a link between the
# two named edges.  Flag an error if the edge
# already exists, but not if any of the connected vertices do not exist. 
#
body ::tycho::Digraph::edge {vertex1 vertex2 args} {
    _verifynot edge {} [list $vertex1 $vertex2] [list $vertex1 $vertex2]
    
    # Record the edge
    set inverse [_addlink edge {} [list $vertex1 $vertex2] {} $args]

    # Add links to the adjacency matrix
    _adjacencyadd $vertex1 $vertex2
    
    # Clear any cached structural information
    catch {unset _cache}

    # Return the inverse command
    return $inverse
}

########################################################################
#### edgeattrs
#
# Return a list containing the attributes of the edge as a flat
# attribute-value list. An error will result if the edge does
# not exist.
#
body ::tycho::Digraph::edgeattrs {vertex1 vertex2} {
    _verify edge {} [list $vertex1 $vertex2]
    _attributes edge {} [list $vertex1 $vertex2]
}

########################################################################
#### edgecget
#
# Get an attribute of an edge. An error will occur if the edge does not
# exist or the attribute does not exist.
#
body ::tycho::Digraph::edgecget {vertex1 vertex2 attribute} {
    _verify edge {} [list $vertex1 $vertex2]
    _cget edge {} [list $vertex1 $vertex2] $attribute
}

########################################################################
#### edgeconfigure
#
# Configure the edge and return the inverse command. An error will
# occur if the edge does not exist. The argument list
# is a flat list of attribute-value pairs.
#
body ::tycho::Digraph::edgeconfigure {vertex1 vertex2 args} {
    _verify edge {} [list $vertex1 $vertex2]
    _configure edge {} [list $vertex1 $vertex2] $args
}

########################################################################
#### edgedelete
#
# Remove an edge from the graph, and return the inverse command. This
# default method works for simple directed graphs.
#
body ::tycho::Digraph::edgedelete {vertex1 vertex2} {
    _verify edge {} [list $vertex1 $vertex2]

    # Delete it from the adjacency list
    _adjacencydelete $vertex1 $vertex2

    # Clear any cached structural information
    catch {unset _cache}

    # Delete the data and return the inverse command
    _delete edge {} [list $vertex1 $vertex2]
}

########################################################################
#### edges
#
# Return a list containing the edges of the graph with source and target
# vertex names that match the given patterns. The result is a flat list
# of source-target pairs. If no arguments are supplied, return all edges.
# To test for the presence of a single edge, provide its source and 
# target vertices as the arguments and compare the result with the empty
# list.
#
body ::tycho::Digraph::edges {{pattern1 *} {pattern2 *}} {
    set result {}
    foreach info \
	    [array names _info [list edge {} [list $pattern1 $pattern2]]] {
	eval lappend result [lindex $info 2]
    }
    return $result
}

########################################################################
#### leaves
#
# Return the "leaves" of the graph.
#
body ::tycho::Digraph::leaves {} {
    _graphleaves
}

########################################################################
#### parents
#
# Return the parents of a vertex. An error will result
# if the vertex does not exist.
#
body ::tycho::Digraph::parents {vertex} {
    return $_adjacency($vertex,parents) 
}

########################################################################
#### repair
#
# "Repair" a graph by deleting improperly-connected edges. This method
# provides a default implementation that will remove invalid edges in 
# most properly-written subclasses; however, subclasses may
# choose to override it for efficiency, because it doesn't work
# with the subclass, or to perform additional repairs. This
# method should be called after building a graph if it is not certain
# that the graph is correctly constructed.
# This method cannot be recorded or published.
#
body ::tycho::Digraph::repair {} {
    foreach {src tgt} [$this edges] {
	if { ! [::info exists _vertices($src)] \
                || ! [::info exists _vertices($tgt)] } {
            # Delete it from the adjacency list
            _adjacencydelete $src $tgt

            # Clear any cached structural information
            catch {unset _cache}

            # Delete the data and return the inverse command
            _delete edge {} [list $src $tgt]
	}
    }
    # Return null so record{} or publish{} will complain.
    return ""
}

########################################################################
#### roots
#
# Return the roots of the graph.
#
body ::tycho::Digraph::roots {} {
    _graphroots
}

########################################################################
#### subgraphEdges
#
# Return the edges within a sub-graph. The arguments are the vertices
# of the subgraph. The returned list of edges are source-target pairs
# (not a flat list as in some other methods). This is to make graph
# editors more generic.
#
body ::tycho::Digraph::subgraphEdges {args} {
    set result {}
    foreach u $args {
        foreach v $args {
            foreach info [array names _info [list edge {} [list $u $v]]] {
                lappend result [lindex $info 2]
            }
        }
    }
    return $result
}

########################################################################
#### subgraphInputs
#
# Return the input edges to a sub-graph. The arguments are the vertices
# of the subgraph. The returned list of edges are source-target pairs
# (not a flat list as in some other methods). This is to make graph
# editors more generic.
#
body ::tycho::Digraph::subgraphInputs {args} {
    set result {}
    set vertices [array names _vertices]
    foreach v $args {
        foreach info [array names _info [list edge {} [list * $v]]] {
            set edge [lindex $info 2]
            if { [lsearch -exact $args [lindex $edge 0]] < 0 } {
                lappend result $edge
            }
        }
    }
    return $result
}

########################################################################
#### subgraphOutputs
#
# Return the output edges from a sub-graph. The arguments are the vertices
# of the subgraph. The returned list of edges are source-target pairs
# (not a flat list as in some other methods). This is to make graph
# editors more generic.
#
body ::tycho::Digraph::subgraphOutputs {args} {
    set result {}
    set vertices [array names _vertices]
    foreach v $args {
        foreach info [array names _info [list edge {} [list $v *]]] {
            set edge [lindex $info 2]
            if { [lsearch -exact $args [lindex $edge 1]] < 0 } {
                lappend result $edge
            }
        }
    }
    return $result
}
