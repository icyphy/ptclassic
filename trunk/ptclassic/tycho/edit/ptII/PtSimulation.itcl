# The superclass of all simulation controllers.
#
# @Author: John Reekie
#
# @Version: $Id$
#
# @Copyright (c) 1996-1998 The Regents of the University of California.
# All rights reserved.
#
# Permission is hereby granted, without written agreement and without
# license or royalty fees, to use, copy, modify, and distribute this
# software and its documentation for any purpose, provided that the above
# copyright notice and the following two paragraphs appear in all copies
# of this software.
#
# IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY
# FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
# ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF
# THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.
#
# THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE
# PROVIDED HEREUNDER IS ON AN "AS IS" BASIS, AND THE UNIVERSITY OF
# CALIFORNIA HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,
# ENHANCEMENTS, OR MODIFICATIONS.
# 
#                                        PT_COPYRIGHT_VERSION_2
#                                        COPYRIGHTENDKEY
#######################################################################


#######################################################################
#### PtSimulation
#
# A <i>PtSimulation</i> object controls and communicates with a
# running Ptolemy II simulation. It is a subclass of the Tycho
# Model class, in order that multiple views can monitor the
# simulation.
#
# The simulation object
# represents a "live" simulation, and is distinct from the
# graph object that represents the static structure of the
# simulation. We say that the simulation object "performs"
# the graph.
#
# Most of the implementations of the methods in here are garbage,
# and will be fixed when we get a proper interface to Ptolemy II.
#
class ::tycho::PtSimulation {
    inherit ::tycho::Model

    constructor {args} {}
    destructor {}
    
    ###################################################################
    ####                            options                        ####
    
    # The name of the simulation for messages and the like
    public variable simulationName ""

    # The debug flag
    public variable debug 1

    # The graph model
    public variable graph

    # The domain library
    public variable domainLibrary

     ###################################################################
    ####                         public methods                    ####

    # Add a new actor to the graph
    method addActor {name uniqueName}

    # Get the names of all actors
    method actors {} {
	return [array names _actors]
    }

    # Connect an edge
    method connect {edgename source out target in}

    # Construct a simulation
    method constructSimulation {}

    # Get the actor with the given name
    method getActor {name} {
	return $_actors($name)
    }

    # Get the domain
    method getDomain {} {
	return $_domain
    }

     # Get the director
    method getDirector {} {
	return $_director
    }

    # Get the director name
    method getDirectorName {} {
        return $_directorName
    }

    # Respond to changes in the graph
    method notify {method args}

    # Pause the simulation
    method pause {}

    # Accept and remember the graph describing the simulation
    method perform {graph}

    # Get a relation by name
    method getRelation {name} {
	return $_relations($name)
    }

    # Get the names of all relations
    method relations {} {
	return [array names _relations]
    }

    # Resume the simulation
    method resume {}

    # Set the director
    method setDirector {director}

   # Set the director name
    method setDirectorName {name} {
        set _directorName $name
    }

    # Set the domain
    method setDomain {domain} {
	set _domain $domain
    }

    # Start the simulation
    method start {}

    # Start the simulation server
    method startServer {}

    # Stop the simulation
    method stop {}

    ###################################################################
    ####                      public procs                         ####

    ###################################################################
    ####                   protected methods                       ####

    # Print a debug message
    protected method debug {msg} {
	if $debug {
	    puts "$this: $msg"
	}
    }

    # Generate simulation from the current graph
    protected method _construct {}

    # Send a script to the simulation
    protected method _send {script}

    ###################################################################
    ####                   protected variables                     ####

    # The graph we are performing
    protected variable _graph

    ###################################################################
    ####                     private variables                     ####

    # The map from names to actors
    private variable _actors

    # The top-level actor
    private variable _toplevelActor ""

    # The manager
    private variable _manager ""

    # The domain
    private variable _domain ""

    # The director
    private variable _director ""

     # The directorName
    private variable _directorName ""

    # The director
    private variable _javaDirector ""

    # The map from names to relations
    private variable _relations

    ### FIXME
    public method getToplevelActor {} {
	return $_toplevelActor
    }
    public method getManager {} {
	return $_manager 
    }
}

#######################################################################
#### constructor
#
body ::tycho::PtSimulation::constructor {args} {
    # Initialize args
    eval configure $args

    set ptversion [java::call ptolemy.schematic.DomainLibrary \
	    getPtolemyVersion]
    # puts "Ptolemy II version $ptversion"
    
    set _toplevelActor [java::new ptolemy.actor.TypedCompositeActor]
    $_toplevelActor setName System
    debug "Toplevel actor: $_toplevelActor"

    set _manager [java::new ptolemy.actor.Manager]
    $_toplevelActor setManager $_manager
    debug "Manager: $_manager"

    $_toplevelActor setManager $_manager

    ### FIXME
    ###set _domain SDF
}

    ###################################################################
    ###################################################################
    ####                      public methods                       ####

########################################################################
#### addActor
#
# Add a new actor to the graph
#
body ::tycho::PtSimulation::addActor {name uniqueName} {
    # Get the actor
    set actor [$domainLibrary createActor $_domain $_toplevelActor \
	    $name $uniqueName]
    if { $actor != "" } {
	puts "$actor: [$actor toString]"
	set _actors($uniqueName) $actor
    }
}

########################################################################
#### connect
#
# Connect one port to another
#
body ::tycho::PtSimulation::connect {edgename source out target in} {
    puts "connect $edgename $source $out $target $in"

    set outPort [$_actors($source) getPort $out]
    set inPort [$_actors($target) getPort $in]
    puts "[$outPort getFullName] ($outPort) -> [$inPort getFullName] ($inPort)"

    set _relations($edgename) \
            [$_toplevelActor connect $outPort $inPort $edgename]
    puts "Got relation $_relations($edgename)"
}

########################################################################
#### constructSimulation
#
# Construct a new simulation
#
body ::tycho::PtSimulation::constructSimulation {} {
    puts ::tycho::PtSimulation::constructSimulation

    puts "Vertices = [array names _actors]"

    # Generate the stars from vertices
    foreach v [$graph vertices] {
        # Is it a junction or a vertex? Currently, we can
        # tell only by looking at the name, but this is
        # obviously lame...
        # FIXME
        if [string match {junction*} $v] {
            # do nothing

        } else {
            # Otherwise assume it represents a star.

	    # See if it already exists
	    if [info exists _actors($v)] {
		puts "$v exists ($_actors($v))"
	    } else {
		puts "$v does not exist! Aborting."
		return
	    }

	    set STUFF {
		# Get the class name.
		set type ptolemy.domains.ct.lib.CT[$graph attrget $v -class]

		# Create the star
		global $v
		debug "set $v \[java::new $type \$system $type\]"
		set result [set $v [java::new $type $system $v]]
		debug " -> $result"

		# Set its parameters. Get the star master.
		set m [split [$graph attrget $v -master] #]
		set libname [lindex $m 0]
		set starname [split [lindex $m 1] "."]
		set library [::tycho::model dereference \
			[::tycho::model locate $libname]]
            
		# Get the attributes of the star and set them
		foreach attr [$library match attribute $starname] {
		    set val [$graph attrget $v -$attr]

		    # Now try and set it
		    debug "\$[set v] setParam [string trim $attr -] $val"
		    set result [[set $v] setParam [string trim $attr -] $val]
		    debug " -> $result"
		}
	    }   
	}
    }

    # Generate the edges
    foreach e [$graph edges] {
        # If the edge is already done, forget it
        if [info exists done($e)] {
            continue
        }

        # Get the names etc
        set from [$graph attrget $e -from]
        set fromname [join $from .]
        set to [$graph attrget $e -to]
        set toname [join $to .]
        debug "$from -> $to"

        # If the input port is a junction, then it's part
        # of a complex net, and we ignore it for now
        if [string match {junction*} $from] {
            continue
        }

        # If, however, the output port is a junction, it must
        # be the first edge in set of junctions and edges
        # that form a relation. Create a new net, then traverse
        # the edges and junctions and link all connected ports.
        if [string match {junction*} $to] {
            # Create the relation
            set rname $to
            debug "set $rname \[\$system newRelation $rname\]"
            set result [set $rname [$system newRelation $rname]]
            debug " -> $result"

            # Link the first edge (the only input!)
            set fromvertex [lindex $from 0]
            set fromport [lindex $from 1]
	    set fromport [lindex [split $fromport -] 0]

            debug "set $fromname \[\$[set fromvertex] getPort $fromport\]"
            set result [set $fromname [[set $fromvertex] \
                    getPort $fromport]]
            debug " -> $result"

            debug "\$\{[set fromname]\} link \$[set rname]"
            set result [[set $fromname] link [set $rname]]
            debug " -> $result"

            # Find edges
            set es {}
            set js [list $to]
            while { $js != "" } {
                set j [lindex $js 0]
                set js [lreplace $js 0 0]
                foreach e [$graph edges $j] {
                    # If the end is a junction, add to the list
                    set q [$graph attrget $e -from]
                    set r [$graph attrget $e -to]
                    if [string match {junction*} $r] {
                        lappend js $r
                    } else {
                        # Any other edges are output edges
                        lappend es $e
                    }
                }
            }

            # Link each output edge from the relation to its port
            foreach e $es {
                set to [$graph attrget $e -to]
                set toname [join $to .]
                set tovertex [lindex $to 0]
                set toport [lindex $to 1]
		set toport [lindex [split $toport -] 0]

                debug "set $toname \[\$[set tovertex] getPort $toport\]"
                set result [set $toname [[set $tovertex] \
                        getPort $toport]]
                debug " -> $result"

                debug "\$\{[set toname]\} link \$[set rname]"
                set result [[set $toname] link [set $rname]]
                debug " -> $result"
            }
            continue
        }
 
        # Otherwise, we are creating a simple link
        set fromvertex [lindex $from 0]
        set fromport [lindex $from 1]
	set fromport [lindex [split $fromport -] 0]

        set tovertex [lindex $to 0]
        set toport [lindex $to 1]
	set toport [lindex [split $toport -] 0]

        # Get the actual ports
        debug "set from \[$_actors($fromvertex) getPort $fromport\]"
        set result [set from \
            [$_actors($fromvertex) getPort $fromport]]
        debug " -> $result"

        debug "set to \[$_actors($tovertex) getPort $toport\]"
        set result [set to [$_actors($tovertex) getPort $toport]]
        debug " -> $result"

        # Make the connection, dude
        debug "set $e \[ \
            $_toplevelActor connect $from $to \
            $e\]"
        set result [set $e [ \
            $_toplevelActor connect $from $to \
            $e]]
        debug " -> $result"
    }
}

########################################################################
#### notify
#
# Handle data change notification from the graph.
#
body ::tycho::PtSimulation::notify {method args} {
    # FIXME
    # puts "$this notify $method"
}

########################################################################
#### perform
#
# Accept a graph describing the simulation and construct the
# run-time simulation. Subscribe to the graph, so that any changes
# to it (from, for example, the user interface) update the
# simulation.
#
body ::tycho::PtSimulation::perform {graph} {
    if [info exists graph] {
        # Unsubscribe from the graph
        $graph subscribe data $this

        # FIXME: unlink from it as well?
    }
    set graph $graph

    # Subscribe to the graph
    $graph subscribe data $this

    # Generate the initial simulation run-time
    _construct
}

#######################################################################
#### pause
#
# Pause the simulation.
#
body ::tycho::PtSimulation::pause {} {
    debug "Pause"
    $_manager pause 
}

#######################################################################
#### resume
#
# Resume the simulation.
#
body ::tycho::PtSimulation::resume {} {
    debug "Resume"
    $_manager resume
}

#######################################################################
#### setDirector
#
# Set the director of the simulation
#
body ::tycho::PtSimulation::setDirector {director} {
    puts "::tycho::PtSimulation::setDirector $director"

    if ![ string match {java*} $director] {
	error "Bad director!!!"
    }

    set _director $director

    set JUNK {
	set dir [$domainLibrary getDirector $_domain $director]
	set class [$dir getAttribute "class"]
	set _javaDirector [java::new $class [lindex [split $class] end]]

	puts "Got director [$_javaDirector toString]"
	puts "[$_toplevelActor getName] ($_toplevelActor) \
		setDirector [$_javaDirector getName] ($_javaDirector)"
    }
    $_toplevelActor setDirector $_director
}

#######################################################################
#### start
#
# Start the simulation.
#
body ::tycho::PtSimulation::start {} {
    debug "Start"
    $_manager startRun
}

#######################################################################
#### startServer
#
# Start the simulation server.
#
body ::tycho::PtSimulation::startServer {} {
    configure -offline 0
}

#######################################################################
#### stop
#
# Stop the simulation.
#
body ::tycho::PtSimulation::stop {} {
    debug "Stop"
    $_manager finish
}


    ###################################################################
    ###################################################################
    ####                    protected methods                      ####

########################################################################
#### _construct
#
# Construct a simulation from the current graph. Subclasses must
# override (for now, at least).
#
body ::tycho::PtSimulation::_construct {} {
    ;#
}
