##########################################################################
# The abstract superclass of all picts.
#
# @Version: $Id$
# @Author: H. John Reekie
#
# @Copyright (c) 1996 The Regents of the University of California.
# All rights reserved.
#
# Permission is hereby granted, without written agreement and without
# license or royalty fees, to use, copy, modify, and distribute this
# software and its documentation for any purpose, provided that the above
# copyright notice and the following two paragraphs appear in all copies
# of this software.
# 
# IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY
# FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
# ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF
# THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.
# 
# THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE
# PROVIDED HEREUNDER IS ON AN "AS IS" BASIS, AND THE UNIVERSITY OF
# CALIFORNIA HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,
# ENHANCEMENTS, OR MODIFICATIONS.
#                                                         COPYRIGHTENDKEY
##########################################################################


#######################################################################
#### Picture
#
# The abstract superclass of all picts. This class provides much of the
# default functionality of all pictures.
#
class ::tycho::Picture {

    constructor {} {}
    destructor {}


    ###################################################################
    ####                            options                        ####

    # Tags associated with this picture.
    private variable prevTags ""  ;# Hack so "tag set" works... _FIXME_
    public variable tags {}


    ###################################################################
    ####                         public methods                    ####

    # Return the ``active'' picture above this one.
    method active {} {}

    # Test if a picture is an ancestor of this one.
    method ancestor {pict} {}

    # Manipulate annotations of this picture
    method annotation {name args} {}
    
    # Read an aspect
    method aspect {aspect} {}
    
    # Read multiple aspets
    method aspects {args} {}
    
    # Set or get the picture's behavior
    method behavior {args} {}
    
    # Get a configuration option
    method cget {option} {}
    
    # Start interaction sequence
    method click {x y} {}
    
    # Set or get configuration options
    method configure {args} {}
    
    # Manipulate picture components
    method component {mode args} {}
    
    # Set or get picture coordinates
    method coords {args} {}

    # Deform a picture
    method deform {mode x y args} {}
    
    # Continue an interaction sequence by dragging
    method drag {x y} {}
    
    # Manipulate event tags. DO NOT USE.
    method etag {mode args} {abstractMethod Picture etag}

    # I forget what this is for
    method extend {args} {}
    
    # Attach grab handles
    method grapple {args} {}
    
    # Manipulate hierarchy tags. DO NOT USE.
    method htag {mode args} {abstractMethod Picture htag}

    # Set or get the picture's mark. DO NOT USE.
    method mark {args} {}

    # Move a picture. This can be used with sequences.
    method move {mode x y args} {}
    
    # Move an aspect of a picture to abslute coordinates
    method moveto {aspect x y} {}
    
    # Get the normal to an aspect
    method normal {aspect} {}
    
    # Set or get the parent of the picture. DO NOT USE.
    method parent {args} {}

    # Set or get the rectangular region occupied by the picture    
    method region {args} {abstractMethod Picture region}
    
    # Terminate an interactrion sequence
    method release {} {}
    
    # Move an aspect of a picture to specified coordinates
    method reshape {args} {}
    
    # Scale a picture
    method scale {xscale args} {}
    
    # Set or get the shape class of the picture
    method shape {args} {}
    
    # Manipulate picture tags
    method tag {mode args} {}
    
    # Apply a transformation to the picture
    method transform {mode args} {}
    
    # Query the picture for some information about itself
    method query {option args} {}


    ###################################################################
    ####                   protected methods                       ####

    # Built-in version of configure{}
    protected method _configure \
 	    {?option? ?value option value...?} @itcl-builtin-configure

    # Built-in version of cget{}
    protected method _cget {option} @itcl-builtin-cget


    ###################################################################
    ####                   protected variables                     ####

    # Internal event tags.
    protected variable etags {}

    # Internal hierarchy tags.
    protected variable htags {}

    # The behavior of this picture under interaction
    protected variable behavior "move"

    # The canvas on which this picture is drawn
    protected variable canvas ""

    # The array of named picture components.
    protected variable component

    # The current mark.
    protected variable mark 0

    # The parent of this picture in the picture hierarchy
    protected variable parent ""

    # The shape of this picture
    protected variable shape ""

    # The object that implements the shape of this picture
    protected variable shapeobject ""

    # The slate on which this picture is drawn
    protected variable slate  ""

    # The tag representing this object
    protected variable thistag {}

    # An array for miscellaneous temporary variables
    protected variable temp


    ###################################################################
    ####                   private variables                       ####

    # An array for "annotations" on this picture
    private variable annotations

    # An array for class-wide scripts to respond to "query" operations
    private common classanswers

    # An array for object-level scripts to respond to "query" operations
    private variable objectanswers


    ###################################################################
    ####                       answer scripts                      ####

    # The items contained by the picture. Not for general use.
    set classanswers(items) {
	1 {$canvas find withtag $thistag}
    }

    # The slate on which this picture lives.
    set classanswers(slate) {
	1 {set slate}
    }

    # The tag that represents this picture on the slate.
    set classanswers(tag) {
	1 {set thistag}
    }

    # The canvas on which this picture lives. Not for general use.
    set classanswers(canvas) {
	1 {set canvas}
    }

    # The _internal_ region bounded by the object. Must be a rectangle.
    set classanswers(internal) {
	1 {rectShrink [$canvas bbox $thistag] 4}
    }

    # The "shape" of the picture, as a canvas type.
    set classanswers(canvasshape) {
	1 {$canvas type $component(primary)}
    }

    # The Shape object of the picture. Not for general use.
    set classanswers(shapeobject) {
	1 {
	    if { $shape == "" } {
		set shapeobject \
			[info context]::[::tycho::Noshape \
			#auto -target $this]
	    } elseif { $shapeobject == "" } {
		set shapeobject \
			[info context]::[::tycho::[capitalize $shape] \
			#auto -target $this]
	    }
	    return $shapeobject
	}
    }

    # Create a grey "ghost" for interactive manipulation
    set classanswers(ghost) {
	1 {
	    $canvas create \
		    [$canvas type $component(primary)] \
		    [$this coords] \
		    {-outline grey -fill ""}
	}
    }

    # Create a blue "highlight" for interactive manipulation.
    # Not for general use. NOTE: this item is not "part" of the
    # highlighted picture, and will not be moved if the picture is
    # moved. It is for transient use only.
    set classanswers(highlight) {
	1 {
	    eval $canvas create rectangle \
		    [rectStretch [$this region] 2] \
		    {-outline blue -width 4 -fill ""}
	}
    }



    ###################################################################
    ## EXPERIMENTAL

    ## constraints
    #
    # An associative array mapping aspects to constraints. A constraint
    # is stored as a triple (picture, operation, options). See the
    # propagate{} method for more information.
    #
    protected variable constraints

    method attach    {aspects picture operation args} {}
    method detach    {aspects picture} {}
    method propagate {mode x y aspect} {}

    method sc {} {
	foreach c [array names constraints] {
	    puts "$c |-> $constraints($c)"
	}
    }
}


#######################################################################
#### tags
#
# Tags associated with this picture. These tags are maintained
# separately from those used internally by the slate and picture
# classes to create and manipulate the picture hierarchy.
#
# The utility method tags{} provides a simpler way of adding
# tags to a picture's tag list than manipulating the option variable.
#
configbody ::tycho::Picture::tags {
    $this tag set $tags
    set prevTags $tags
}


#######################################################################
#### constructor
#
# Set the slate and canvas variables, and the initial value
# of the picture hierarchy tags.
#
# There are no optional arguments because this class cannot be
# instantiated.
#
body ::tycho::Picture::constructor {} {
    # Initialise the hierarchy tags
    set thistag [::info namespace tail $this]
    set htags   [list $thistag]
}


#######################################################################
#### destructor
#
body ::tycho::Picture::destructor {} {
    # Find the tags on this picture and deregister them
    foreach t $tags {
	@scope [$slate info class] "$slate deregisterTag $t $this"
    }

    # Delete the shape object if there is one
    if { $shapeobject != "" } {
	delete object $shapeobject
    }
}


#######################################################################
#### annotation
#
# Return the ``active'' picture above this one.
#
body ::tycho::Picture::active {} {
    if { $parent == "" || $mark != "" } {
	return $this
    } else {
	return [$parent active]
    }
}


#######################################################################
#### ancestor
#
# Test if a picture is an ancestor of this one.
#
body ::tycho::Picture::ancestor {pict} {
    return [lmember $htags $pict]
}


#######################################################################
#### annotation
#
# Set or get the value of an annotation. Annotations are a simple
# mechanism to allow clients to attach information to individual
# pictures. With a single argument, return the current value of the
# given annotation; with two arguments, set the annotation to the
# second argument.
# Once created, an annotation cannot be deleted, but merely set
# to null.
#
body ::tycho::Picture::annotation {name args} {
    if { $args == "" } {
	return $annotations($name)
    } else {
	set annotations(name) [lindex $args 0]
    }
}


#######################################################################
#### aspect aspect
#
# Return the value of a single aspect. The valid aspects depend
# on the current setting of the picture's _shape_ option.
#
body ::tycho::Picture::aspect {aspect} {
    # Call the aspect{} method of the shape delegate.
    [query shapeobject] aspect $aspect
}


#######################################################################
#### aspects {aspect}+
#
# Return the value of one or more aspects. The valid aspects depend
# on the current setting of the picture's _shape_ option.
#
body ::tycho::Picture::aspects {args} {
    # Call the aspect{} method of the shape delegate.
    eval [query shapeobject] aspects $args
}


#######################################################################
#### attach aspect picture operation {option}
#
# Attach a constraint to a picture. The mechanism is very simple: each
# aspect in the list will be added to the constraints array, for later
# use by propagate. For correct operation under move, the "body" aspect
# should always be specified in the aspect list.
#
# When a picture is moved or deformed, the changed aspects (or "body"
# for a move) are used to index into the constraint array. For each
# picture found, _operation_ is applied to it, with the list of _options_
# appended to the call. The form of _operation_ and _options_ is as for
# the _behavior_ method.
#
body ::tycho::Picture::attach {aspects picture operation args} {
    foreach aspect $aspects {
	# Create a name for aspects with complex names
	set aspect [join $aspect "-"]

	# Add the constraint
	if { [::info exists constraints($aspect)] } {
	    lappend constraints($aspect) [list $picture $operation $args]
	} else {
	    set constraints($aspect) [list [list $picture $operation $args]]
	}
    }
}


#######################################################################
#### behavior
#### behavior mode args
#
# Set or query the behavior of a picture under interaction. The
# _mode_ variable is the method that will be called by each of the
# click{}, drag{}, and release{} methods; remaining arguments will
# be passed to the method called by click{} only.
#
# The default behavior is "move." Most pictures will support "deform,"
# and others might support "transform" and "extend." Pictures
# will only respond ot these additional behaviors if they have
# a shape (see the shape{} method).
#
# Each of the interaction commands calls the behavior method with
# a different mode. For example, is behavior is set to
# <pre>
#     deform ne -ghost
# </pre>
# then the call
# <pre>
#     click 100 100
# </pre>
# will be translated into the call
# <pre>
#     move click 100 100 ne -ghost
# </pre>
# If the behavior is set to "ignore", then the picture will
# not respond to interaction commands at all, but will not
# complain either. If set to "", then the picture will
# respond to interaction commands by generating an error message.
#
body ::tycho::Picture::behavior {{mode {}} args} {
    if { $args == "" } {
	return $behavior
    } else {
	set behavior $args
    }
}


#######################################################################
#### cget option
#
# Query a configuration option. This method overrides the
# default cget{} in order to make access to configuration
# options of a shape transparent. See configure{} for comments.
#
body ::tycho::Picture::cget {option} {
    if { [catch {_cget $option} result] } {
	if { $shapeobject != "" } {
	    set result [$shapeobject cget $option]
	}
    }
    return $result
}


#######################################################################
#### click
#
# Start an interaction sequence on this picture. See the behavior{}
# method.
#
# <b>Note</b>: Do not override.
#
body ::tycho::Picture::click {x y} {
    if { $behavior == "none" } {
	error "Picture $this has no behavior"
    }

    if { $behavior != "ignore" } {
	eval $this [lindex $behavior 0] click $x $y [lrange $behavior 1 end]
    }

    set temp(prevX) $x
    set temp(prevY) $y
}


#######################################################################
#### component
#
# _Abstract method_.
# Manipulate picture components. The exact argument formats
# available depend on the sub-classes method, but will include
# at least the following:
#
# <ul>
# <li><b>create</b> _name_ _type_ _args_: Create a new component
# named _name_. _type_ indicates the kind of componentl _args_ contain
# subclass-specific information. More than one component with the
# given name can be created.
#
# <li><b>delete</b> _name_: Delete components named _name_.
#
# <li><b>exists</b> _name_: Return true if there are any components
# named _name_.
#
# <li><b>get</b> _name_: Return all components named _name_.
#
# </ul>
#
body ::tycho::Picture::component {mode args} {
    abstractMethod Picture component
}
   

#######################################################################
#### coords
#
# _Abstract method_.
# Read or set the co-ordinates of a picture. This default method
# provides a reasonable behavior for simple scaling, although
# many subclasses will want to override this method for more
# sophisticated or more accurate behavior.
#
# With no arguments, the method looks for a component named
# "primary"; if it finds one, it returns its coordinates. If not,
# it returns a rectangle that _approximates_ the region occupied
# by the picture.
#
# With arguments: if there is a component called "primary" and it
# has rectangular coordinates, scale all items in the
# picture so that the primary component will have the given
# coordinates. If the primary component is not rectangular, then
# set its coordinates to the given coordinates and scale all
# other components based on the region occupied by the primary
# component before and after setting the coordinates. (This is
# a situation in which a sub-class really should override this
# method.)
#
# If there is no primary component, scale all items so that
# the region occupied after scaling will be the given coordinates.
# (This requres that the coordinates define a rectangle.)
#
body ::tycho::Picture::coords {args} {
    abstractMethod Picture coords
}


#######################################################################
#### configure {option value}+
#
# Set or query configuration options. This method overrides the
# default configure{} in order to make access to configuration
# options of a shape transparent.
#
# <b>Note</b>: There's one catch: configuration options of a shape show up
# only after the shape has been accessed. However, attempting to
# set a configuration option not valid for the picture will
# automatically access the shape.
#
# _FIXME_: This code cannot distinguish between an error caused
# by an incorrect option name and a bad option value, and thus
# may give misleading error messages.
#
body ::tycho::Picture::configure {args} {
    if { $args == "" } {
 	# We've been asked for the configuration values. Get the
 	# configuration values of this object and its shape
 	# object and append them together.

 	set result [_configure]
 	if { $shapeobject != "" } {
 	    set result [concat $result [$shapeobject configure]]
 	}
 	return $result

    } elseif { [llength $args] == 1 } {
 	if { [catch {_configure [lindex $args 0]} result] } {
 	    if { $shapeobject != "" } {
 		set result [$shapeobject configure [lindex $args 0]]
 	    }
 	}
 	return $result

    } else {
 	# To set a configuration option, we first have to figure
 	# out whether each option belongs to this object or not.
 	# There are probably several ways of doing this: I have
 	# done it by trying to do a cget{}.

 	foreach {option value} $args {
 	    if { ! [catch {_cget $option}] } {
 		_configure $option $value
 	    } elseif {$shapeobject != "" } {
 		$shapeobject configure $option $value
 	    }
 	}
    }
}


#######################################################################
#### deform "direct"  x y {aspect}+
#### deform "click"   x y {aspect}+ [-ghost]
#### deform "drag"    x y
#### deform "release" x y
#
# Deform a picture. By default, this method delegates to the
# picture's _shapeobject_ instance variable, as determined by the
# _shape_ option variable. See the various Shape objects for a
# a description of the different modes.
#
# The shape object is tested for null before doing anything, and one
# is created if it doesn't exist. This avoids creating shape objects
# that will never be used.
#
body ::tycho::Picture::deform {mode x y args} {

    # Call the deform{} method of the shape delegate.
    eval [query shapeobject] deform $mode $x $y $args
}


#######################################################################
#### detach aspect picture
#
# Remove a constraint. The constraint is specified by its aspects
# and a picture. It is the caller's responsibility to ensure that
# aspects and pictures when detaching correspond to those used when
# attaching.
#
body ::tycho::Picture::detach {aspects picture} {
    foreach aspect $aspects {
	set aspect [join $aspect "-"]

	if { ! [::info exists constraints($aspect)] } {
	    error "Invalid constraint ($picture, $aspect) in $this"
	}

	set result {}
	foreach triple $constraints($aspect) {
	    if { [lindex $triple 0] != $picture } {
		lappend result $triple
	    }
	}
	if { $result == {} } {
	    unset constraints($aspect)
	} else {
	    set constraints($aspect) $result
	}
    }
}


#######################################################################
#### drag
#
# Continue an interaction sequence on this picture. See the behavior{}
# method.
#
# <b>Note</b>: Do not override.
#
body ::tycho::Picture::drag {x y} {
    if { $behavior != "ignore" } {
	$this [lindex $behavior 0] drag \
		[expr $x - $temp(prevX)] [expr $y - $temp(prevY)]
    }

    set temp(prevX) $x
    set temp(prevY) $y
}


## extend args
#
# Extend a picture. The need for and meaning of additional
# arguments depends on the picture's shape class. If the shape class
# doesn't support the extend{} operation then an error will be
# signalled.
#
body ::tycho::Picture::extend {args} {
    # Call the extend{} method of the shape delegate.
    eval [query shapeobject] extend $args
}


#######################################################################
#### grapple args
#
# Attach grapples to a picture.
#
body ::tycho::Picture::grapple {args} {
    eval [query shapeobject] grapple $args
}


#######################################################################
#### mark
#
# Set or get the mark of a picture.
# A picture is "marked" if it is able to respond to user
# interaction. This variable is tied on intimately with the
# tagging mechanisms, so don't use it!
#
# _FIXME_: Can this option be eliminated by just using
# absence/presence of certain tag types?
#
body ::tycho::Picture::mark {args} {
    if { $args == "" } {
	return $mark
    } else {
	set mark [lindex $args 0]
    }
}


#######################################################################
#### move "direct"  x y
#### move "click"   x y [-ghost]
#### move "drag"    x y
#### move "release" x y
#
# Move a picture. This method has several sub-commands, selected
# by the first argument.
#
# <ul>
# <li><b>direct</b> _x_ _y_:
# Move the picture by the specified _x_ and _y_ coordinates.
# This is intended only for ``all-at-once'' moves; for moves that
# can be broken into a series of small moves -- such as dragging
# with the mouse -- use a sequence of click-drag-release moves.
#
# <li><b>click</b> _x_ _y_ [*-ghost*]:
# Signal the start of a click-drag-release action. This
# assumes that a release action has been called since previous
# drag actions. The optional *-ghost* flag indicates that the picture
# is to be moved by dragging a ``ghost'' of the picture.
#
# <li><b>drag</b> _x_ _y_:
# Move the picture or its ghost by the specified amount.
# Drag assumes that click has already been called on the picture,
# and will function unpredictably if not.
#
# <li><b>release</b> _x_ _y_:
# Terminate a click-drag-release sequence. If a ghost is
# being moved, then the picture is moved to its position and the ghost
# is deleted. Note: A release must be used to terminate the click-drag-
# release sequence, even if not ghosting the picture. The _x_ and _y_
# arguments are ignored.
# </ul>
#
# <b>Note</b>: Do not override.
#
body ::tycho::Picture::move {mode x y args} {

    # Switch on the mode keyword
    switch -exact $mode {
	"direct" {
	    # A simple relative move. Move canvas items, and then
	    # propagate constraints.
	    $canvas move $thistag $x $y
	    $this propagate "direct" $x $y "body"
	}
	"click" {
	    getflag ghost args

	    # If the _ghost_ option is set, draw the ghost shape.
	    # If not, clear the *ghost* flag so that later drags
	    # don't get confused.
	    #
	    # If the ghost is not set, propagate constraints.
	    if { $ghost } {
		set temp(ghost) [$this query ghost]

		# Tag each ghost item to make moving easier later
		foreach g $temp(ghost) {
		    $canvas itemconfigure $g -tags "ghost"
		}

		# Remember where I am now.
		set temp(start) \
			[lrange [$canvas coords [lindex $temp(ghost) 0]] 0 1]

	    } else {
		$this propagate "click" $x $y "body"
	    }
	}
	"drag" {
	    # If there's a ghost, move it. Otherwise move the picture.
	    if { [::info exists temp(ghost)] } {
		$canvas move "ghost" $x $y
	    } else {
		$canvas move $thistag $x $y
		$this propagate "drag" $x $y "body"
	    }
	}
	"release" {
	    # If there's a ghost, delete it, move the picture there, which
	    # will in turn perform a one-shot constraint propagation.
	    # If there isn't a ghost, finalize constraint propagation.
	    if { [::info exists temp(ghost)] } {
		assign x y $temp(start)
		assign a b [$canvas coords [lindex $temp(ghost) 0]]

		$this move "direct" [expr $a - $x] [expr $b - $y]

		$canvas delete "ghost"
		unset temp(ghost)
		unset temp(start)

	    } else {
		$this propagate "release" 0 0 "body"
	    }
	}
	default {
	    error "Invalid mode \"$mode\" to $this::mode{}"
	}
    }
}


#######################################################################
#### moveto aspect x y
#
# Move an aspect of a picture to a given coordinate. By
# default, this method delegates to the picture's shape object.
#
body ::tycho::Picture::moveto {aspect x y} {
    # Call the move{} method of the shape delegate.
    [query shapeobject] move $aspect $x $y
}


#######################################################################
#### normal aspect
#
# Return the normal to an aspect. The valid aspects depend
# on the current setting of the picture's _shape_ option.
#
body ::tycho::Picture::normal {aspect} {
    # Call the normal{} method of the shape delegate.
    [query shapeobject] normal $aspect
}


#######################################################################
#### parent
#
# Set or clear the parent of the picture. This is not intended
# for general use: instead, use the component{} method.
#
body ::tycho::Picture::parent {args} {
    if { $args == "" } {
	return $parent
    }

    # If the current parent is not null, then remove its tags
    # from this picture.
    #
    # FIXME: Does this need -force?
    if { $parent != "" } {
	eval $this etag delete [$parent etag get]
	eval $this htag delete [$parent htag get]
    }

    # Set the new parent. If it is not null, then add its tags to
    # this picture.
    #
    # FIXME: Does this need -force?
    set parent [lindex $args 0]
    if { $parent != "" } {
	eval $this etag add [$parent etag get]
	eval $this htag add [$parent htag get]
    }
}


#######################################################################
#### propagate mode x y aspects
#
# Propagate a constraint. This method is called by the various
# moving and deforming methods. The _mode_ argument is the same mode
# as used by interaction commands -- that is, "click," "drag," or
# "release" -- or the "direct" mode for simple moves and deforms.
#
# Every constraint associated with every aspect in _aspects_ is looked
# up in the constraints array. For each of these constraints, the associated
# operation is called on the associated picture, with mode _mode_ and
# coordinates _x_ and _y_.
#
# <b>Note</b>: Constraint propagation bypasses the behavior interface, so
# the behavior of a picture moved or deformed under constraints is not
# affected by its behavior configuration variable.
#
# _FIXME_: A more efficient way of caching constraints for propagation
# for use in click-drag-release sequences is needed.
#
# _FIXME_: Constraints cannot be circular. I need to think about exactly
# how much circularity is needed, before deciding on the best way
# to deal with it.
#
body ::tycho::Picture::propagate {mode x y aspects} {

    # First get all the constraints, and remove duplicates.
    # Note that only the picture name is considered, so the
    # same picture cannot (usefully) have more than one operation.
    set cons {}
    foreach aspect $aspects {
	set aspect [join $aspect "-"]

	if { [::info exists constraints($aspect)] } {
	    set cons [concat $cons $constraints($aspect)]
	}
    }
    set cons [lnubKeyed $cons]

    # Apply the operation to each picture.
    switch -exact $mode {
	"direct" {
	    foreach triple $cons {
		assign picture operation options $triple
		eval $picture $operation "direct" $x $y $options
	    }
	}
	"click" {
	    foreach triple $cons {
		assign picture operation options $triple
		eval $picture $operation "click" $x $y $options
	    }
	}
	"drag" {
	    foreach triple $cons {
		assign picture operation $triple
		eval $picture $operation "drag" $x $y
	    }
	}
	"release" {
	    foreach triple $cons {
		assign picture operation $triple
		eval $picture $operation "release" 0 0
	    }
	}
    }
}


#######################################################################
#### query option
#### query "set" option script
#
# Query a picture for some information about itself. If the
# picture does not find the answer in its own array of answers,
# it asks its shape object.
#
# To add a script to an object for future queries, use the
# "set" option. To make the script apply to all objects of
# the same class (unless overridden by individual objects),
# specify the -class flag. To make the script execute in the
# object's local scope, specify the -local flag. (The advantage
# of local execution is that $this will be expanded when the
# query is made; the disadvantage is that you might overwrite
# private variables.
#
# <b>Note</b>: Do not override.
#
body ::tycho::Picture::query {option args} {
    switch -exact $option {
	"classanswers" {
	    return [array get classanswers]
	}
	"objectanswers" {
	    return [array get objectanswers]
	}
	"set" {
	    # Set an answer script. The -local flag makes it execute
	    # locally, the -class flag makes it apply to all objects
	    # of this class (unless individual objects override it).
	    getflag local args
	    getflag class args

	    set option [lindex $args 0]
	    set script [lindex $args 1]

	    if { $class } {
		set classanswers($option)  [list $local $script]
	    } else {
		set objectanswers($option) [list $local $script]
	    }
	}
	default {
	    # See if there's an object answer; if not, try for a class
	    # answer; if none there, try the shape object
	    if { [::info exists objectanswers($option)] } {
		set answer $objectanswers($option)
	    } elseif { [::info exists classanswers($option)] } {
		set answer $classanswers($option)
	    } else {
		return [eval [query shapeobject] query $option $args]
	    }

	    # Execute the answer script with args appended, either here
	    # or at the global scope
	    if { [lindex $answer 0] } {
		eval [lindex $answer 1] $args
	    } else {
		uplevel \#0 [lindex $answer 1] $args
	    }
	}
    }
}


#######################################################################
#### region
#
# _Abstract method_.
# Read or set the region of a picture. 
# With no arguments, the method looks for a component named
# "primary"; if it finds a rectangular one, it returns its
# coordinates. If not it returns a rectangle that _approximates_
# the region occupied by the picture.
#
# With arguments: if there is a component called "primary" and it
# has rectangular coordinates, scale all items in the
# picture so that the primary component will have the given
# coordinates. If there is no primary component or it is not
# rectangular, then scale the picture but use the approximate
# region instead of the primary component.
#
body ::tycho::Picture::region {args} {
    abstractMethod Picture region
}


#######################################################################
#### reshape aspect x y
#### reshape aspect value
#
# Reshape a picture. By default, this method delegates to the
# picture's _shapeobject_ instance variable, as determined by the
# _shape_ option variable. The effect of this function depends on
# the current setting of the picture's *-shape* option.
#
body ::tycho::Picture::reshape {args} {
    # Call the reshape{} method of the shape delegate.
    eval [query shapeobject] reshape $args
}


#######################################################################
#### release
#
# Terminate an interaction sequence on this picture. See the behavior{}
# method.
#
# <b>Note</b>: Do not override.
#
body ::tycho::Picture::release {} {
    if { $behavior != "ignore" } {
	$this [lindex $behavior 0] release 0 0
    }
}


#######################################################################
#### scale scale
#### scale xscale yscale
#### scale x y scale
#### scale x y xscale yscale
#
# Scale a picture. Argument formats are:
#
# <ul>
# <li>_scale_: Scale uniformly in both directions about the picture's
#      center.
# <li>_xscale_ _yscale_: Scale about the picture's center.
# <li>_x_ _y_ _scale_: Scale uniformly in both directions about _x_ and 
#      _y_.
# <li>_xscale_ _yscale_: Scale about _x_ and _y_.
# </ul>
#
body ::tycho::Picture::scale {xscale args} {
    # Extract arguments
    switch -exact [llength $args] {
	0 {
	    set yscale $xscale
	    assign x y [$this aspect center]
	}
	1 {
	    set yscale [lindex $args 0]
	    assign x y [$this aspect center]
	}
	2 {
	    set x $xscale
	    assign y xscale $args
	    set yscale $xscale
	}
	3 {
	    set x $xscale
	    assign y xscale yscale $args
	}
    }

    # Get new coordinates
    set result {}
    set coords [$this coords]
    foreach {a b} $coords {
	set a [expr $x + $xscale * ($a - $x)]
	set b [expr $y + $yscale * ($b - $y)]
	lappend result $a $b
    }

    # Apply scaling
    eval $this coords $result
}


#######################################################################
#### shape
#
# Get or set the shape class of this picture. This must be the
# name of a class in the Shape hierarchy in lower-case.
#
# The actual shape object is not created until needed -- this is
# mainly to reduce picture creation cost.
#
# If this option is null (the default), then the picture won't
# respond to shape-related commands. Whenever this option is
# changed, the current shape object is deleted.
#
body ::tycho::Picture::shape {args} {
    if { $args == "" } {
	return $shape
    } else {
	if { $shapeobject != "" } {
	    delete object $shapeobject
	    set shapeobject ""
	}
	set shape [lindex $args 0]
    }
}


#######################################################################
#### tag add {tag}+
#### tag delete {tag}+
#### tag get
#### tag set {tag}+
#
# Manipulate tags. This is a better interface than configure{} for
# this purpose. Argument formats are:
#
# <ul>
# <li><b>add</b> _tag_ ... _tag_: Add tags.
# <li><b>delete</b> _tag_ ... _tag_: Delete tags.
# <li><b>get</b>: Get tags.
# <li><b>set</b> _tag_ ... _tag_: Set tags.
# </ul>
#
# <b>Note</b>: Do not override.
#
body ::tycho::Picture::tag {mode args} {
    switch -exact $mode {
	"add" {
	    set tags [lunion $tags $args]

	    # If the picture is not marked, see if there are any
	    # bindings for these tags and if there are, mark it.
	    if { $mark == "" } {
		foreach t $args {
		    if { [$canvas bind $t] != "" } {
			set mark 1
			break
		    }
		}
	    }

	    # If the picture is marked, add the new tags to the event
	    # tags.
	    if { $mark != "" } {
		eval $this etag "add" $tags -force
	    }

	    # Tell the slate about the new tags,
	    foreach t $args {
		@scope [$slate info class] "$slate registerTag $t $this"
	    }
	}
	"delete" {
	    set tags [lsubtract $tags $args]

	    # If the picture is marked, then it is possible that deleting
	    # a tag will make it unmarked. So, for the tags that remain,
	    # test if there are any bindings. If none of them have bindings,
	    # then the picture can be unmarked and its event tags set to
	    # the event tags of its parent.
	    set unmark 1
	    foreach t $tags {
		if { [$itk_component(canvas) bind $t] != "" } {
		    set unmark 0
		    break
		}
	    }
	    if { $unmark } {
		set mark ""

		if { $parent != "" } {
		    eval $this etag set [$parent etag get] -force
		} else {
		    $this etag set {} -force
		}
	    }

	    # If the picture is still marked, set its event tags to
	    # its user tags.
	    if { $mark != "" } {
		eval $this etag "set" $tags -force
	    }

	    # Tell the slate about the removed tags.
	    foreach t $args {
		@scope [$slate info class] "$slate deregisterTag $t $this"
	    }
	}
	"get" {
	    return $tags
	}
	"set" {
	    # This code figures out the new tags and the obsolete
	    # "dead" tags and calls tag add and tag delete. This
	    # is currently a hack to deal with the fact that this
	    # can get called by the configuration code for the
	    # -tags option.
	    #
	    # FIXME. Now this won't work if called from somehere else!!!
	    set newtags [lsubtract $args $prevTags]
	    if { $tags != "" } {
		set deadtags [lsubtract $prevTags $args]
	    } else {
		set deadtags {}
	    }

	    set tags $args

	    if { $newtags != "" } {
		$this tag "add" $newtags
	    }
	    if { $deadtags != "" } {
		$this tag "delete" $deadtags
	    }
	}
	default {
	    error "Picture::tag: Invalid mode $mode"
	}
    }
}


#######################################################################
#### transform mode args
#
# Transform a picture. The transformation available depend on the
# picture's shape.
#
body ::tycho::Picture::transform {mode args} {
    # Call the transform{} method of the shape delegate.
    eval [query shapeobject] transform $mode $args
}




# _FIXME_: move these somewhere else...
proc lsearchKeyed {list key} {
    set index 0
    foreach i $list {
	if { [lindex $i 0] == $key } {
	    return $index
	}
	incr index
    }
    return -1
}

proc ldeleteKeyed {list key} {
    set i [lsearchKeyed $list $key]

    if { $i != -1 } {
	return [lreplace $list $i $i]
    }

    return $list
}

proc lnubKeyed {list} {
    set result {}
    foreach i $list {
	if { [lsearchKeyed $result [lindex $i 0]] == -1 } {
	    lappend result $i
	}
    }
    return $result
}
