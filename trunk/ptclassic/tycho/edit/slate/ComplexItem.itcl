##########################################################################
# Version: $Id$
# Author: H. John Reekie
#
# Copyright (c) %Q% The Regents of the University of California.
# All rights reserved.
# 
# Permission is hereby granted, without written agreement and without
# license or royalty fees, to use, copy, modify, and distribute this
# software and its documentation for any purpose, provided that the above
# copyright notice and the following two paragraphs appear in all copies
# of this software.
# 
# IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY
# FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
# ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF
# THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.
# 
# THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE
# PROVIDED HEREUNDER IS ON AN "AS IS" BASIS, AND THE UNIVERSITY OF
# CALIFORNIA HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,
# ENHANCEMENTS, OR MODIFICATIONS.
#                                                         COPYRIGHTENDKEY
##########################################################################


## Picture
#
# The top-level picture class. This is an abstract class.
#
class ::tycho::Picture {


    ###################################################################
    ####                            options                        ####

    ## tags
    #
    # Tags associated with this picture. These tags are maintained
    # separately from those used internally by the slate and picture
    # classes to create and manipulate the picture hierarchy.
    #
    # The utility method tags{} provides a simpler way of adding
    # tags to a picture's tag list than manipulating the option variable.
    #
    private variable prevTags ""  ;# Hack so "tag set" works... FIXME
    public variable tags {} {
	$this tag set $tags
	set prevTags $tags
    }




    ###################################################################
    ## Constructor and destructor

    ## constructor
    #
    # Set the slate and canvas variables, and the initial value
    # of the picture hierarchy tags.
    #
    # There are no optional args because this class cannot be
    # instantiated.
    #
    constructor {} {
	# Initialise the hierarchy tags
	set thistag [lindex [split $this "::"] end]
	set _htags  [list $thistag]
    }


    ## destructor
    #
    destructor {
	# Find the tags on this picture and deregister them
	foreach t $tags {
	    $slate deregisterTag $t $this
	}

	# Delete the shape object if there is one
	if { $shapeobject != "" } {
	    delete object $shapeobject
	}
    }


    ###################################################################
    ####                         public methods                    ####

    method annotation {name args}      {}
    method aspect     {aspect}         {}
    method aspects    {args}           {}
    method behavior   {args}           {}
    method bbox       {}               {}
    method cget       {option}         {}
    method click      {x y}            {}
    method configure  {args}           {}
    method component  {mode args}      {abstractMethod Picture component}
    method coords     {args}           {abstractMethod Picture coords}
    method deform     {mode x y args}  {}
    method drag       {x y}            {}
    method extend     {args}           {}
    method grapple    {args}           {}
    method mark       {args}           {}
    method move       {mode x y args}  {}
    method moveto     {aspect x y}     {}
    method normal     {aspect}         {}
    method parent     {args}           {}
    method region     {args}           {abstractMethod Picture region}
    method release    {}               {}
    method reshape    {args}           {}
    method scale      {xscale args}    {}
    method shape      {args}           {}
    method tag        {mode args}      {}
    method transform  {mode args}      {}
    method query      {option args}    {}


    ###################################################################
    ####              public methods but slate use ONLY            ####

    # Manipulate event tags
    method _etag {mode args} {abstractMethod Picture _etag}

    # Manipulate hierarchy tags
    method _htag {mode args} {abstractMethod Picture _htag}

    # Return the ``active'' picture above this one.
    method active {} {
	if { $parent == "" || $mark != "" } {
	    return $this
	} else {
	    return [$parent active]
	}
    }

    # Test if a picture is an ancestor of this one.
    method ancestor {pict} {
	return [lmember $_htags $pict]
    }


    ###################################################################
    ####                   protected methods                       ####

    # Built-in version of configure{}
    protected method _configure \
 	    {?option? ?value option value...?} @itcl-builtin-configure

    # Built-in version of cget{}
    protected method _cget {option} @itcl-builtin-cget


    ###################################################################
    ####                   protected variables                     ####

    # Internal event tags.
    protected variable _etags {}

    # Internal hierarchy tags.
    protected variable _htags {}

    # The behavior of this picture under interaction
    protected variable behavior "move"

    # The canvas on which this picture is drawn
    protected variable canvas ""

    # The array of named picture components.
    protected variable component

    # The current mark.
    protected variable mark 0

    # The parent of this picture in the picture hierarchy
    protected variable parent ""

    # The shape of this picture
    protected variable shape ""

    # The object that implements the shape of this picture
    protected variable shapeobject ""

    # The slate on which this picture is drawn
    protected variable slate  ""

    # The tag representing this object
    protected variable thistag {}

    # An array for miscellaneous temporary variables
    protected variable temp


    ###################################################################
    ####                   private variables                       ####

    # An array for "annotations" on this picture
    private variable annotations

    # An array for class-wide scripts to respond to "query" operations
    private common classanswers

    # An array for object-level scripts to respond to "query" operations
    private variable objectanswers


    ###################################################################
    ####                       answer scripts                      ####

    # The items contained by the picture. Not for general use.
    set classanswers(items) {
	1 {$canvas find withtag $thistag}
    }

    # The slate on which this picture lives.
    set classanswers(slate) {
	1 {set slate}
    }

    # The tag that represents this picture on the slate.
    set classanswers(tag) {
	1 {set thistag}
    }

    # The canvas on which this picture lives. Not for general use.
    set classanswers(canvas) {
	1 {set canvas}
    }

    # The _internal_ region bounded by the object. Must be a rectangle.
    set classanswers(internal) {
	1 {rectShrink [$canvas bbox $thistag] 4}
    }

    # The "shape" of the picture, as a canvas type.
    set classanswers(canvasshape) {
	1 {$canvas type $component(primary)}
    }

    # The Shape object of the picture. Not for general use.
    set classanswers(shapeobject) {
	1 {
	    if { $shape == "" } {
		set shapeobject \
			[info context]::[::tycho::Noshape \
			#auto -target $this]
	    } elseif { $shapeobject == "" } {
		set shapeobject \
			[info context]::[::tycho::[capitalize $shape] \
			#auto -target $this]
	    }
	    return $shapeobject
	}
    }

    # Create a grey "ghost" for interactive manipulation
    set classanswers(ghost) {
	1 {
	    $canvas create \
		    [$canvas type $component(primary)] \
		    [$this coords] \
		    {-outline grey -fill ""}
	}
    }

    # Create a blue "highlight" for interactive manipulation.
    # Not for general use. NOTE: this item is not "part" of the
    # highlighted picture, and will not be moved if the picture is
    # moved. It is for transient use only.
    set classanswers(highlight) {
	1 {
	    eval $canvas create rectangle \
		    [rectStretch [$this region] 2] \
		    {-outline blue -width 4 -fill ""}
	}
    }



    ###################################################################
    ## EXPERIMENTAL

    ## constraints
    #
    # An associative array mapping aspects to constraints. A constraint
    # is stored as a triple (picture, operation, options). See the
    # propagate{} method for more information.
    #
    protected variable constraints

    method attach    {aspects picture operation args} {}
    method detach    {aspects picture} {}
    method propagate {mode x y aspect} {}

    method sc {} {
	foreach c [array names constraints] {
	    puts "$c |-> $constraints($c)"
	}
    }
}




## annotation name [value]
#
# Get or set value of an annotation. Annotations are a simple
# mechanism to allow clients to atatch information to individual
# pictures.
#
# Once created, an annotation cannot be deleted, but merely set
# to null.
#
body ::tycho::Picture::annotation {name args} {
    if { $args == "" } {
	return $annotations($name)
    } else {
	set annotations(name) [lindex $args 0]
    }
}


## aspect aspect
#
# Return the value of a single aspect. The valid aspects depend
# on the current setting of the picture's _shape_ option.
#
body ::tycho::Picture::aspect {aspect} {

    # Call the aspect{} method of the shape delegate.
    [query shapeobject] aspect $aspect
}


## aspects {aspect}+
#
# Return the value of one or more aspects. The valid aspects depend
# on the current setting of the picture's _shape_ option.
#
body ::tycho::Picture::aspects {args} {

    # Call the aspect{} method of the shape delegate.
    eval [query shapeobject] aspects $args
}


## attach aspect picture operation {option}
#
# Attach a constraint to a picture. The mechanism is very simple: each
# aspect in the list will be added to the constraints array, for later
# use by propagate. For correct operation under move, the "body" aspect
# should always be specified in the aspect list.
#
# When a picture is moved or deformed, the changed aspects (or "body"
# for a move) are used to index into the constraint array. For each
# picture found, _operation_ is applied to it, with the list of _options_
# appended to the call. The form of _operation_ and _options_ is as for
# the _behavior_ method.
#
body ::tycho::Picture::attach {aspects picture operation args} {
    foreach aspect $aspects {
	# Create a name for aspects with complex names
	set aspect [join $aspect "-"]

	# Add the constraint
	if { [info exists constraints($aspect)] } {
	    lappend constraints($aspect) [list $picture $operation $args]
	} else {
	    set constraints($aspect) [list [list $picture $operation $args]]
	}
    }
}


## bbox
#
# Get the bounding box of the picture
#
body ::tycho::Picture::bbox {} {
    eval $canvas bbox $thistag
}


## behavior
## behavior mode args
#
# Set or query the behavior of a picture under interaction. The
# _mode_ variable is the method that will be called by each of the
# click{}, drag{}, and release{} methods; remainain arguments will
# be passed to the method called by click{} only.
#
# The default behavior is "move." Most pictures will support "deform,"
# and others might support "transform" and "extend." Pictures
# will only respond ot these additional behaviors if they have
# a shape (see the shape{} method).
#
# Each of the interaction commands calls the behavior method with
# a different mode. For example, is behavior is set to
#
#     deform ne -ghost
#
# then the call
#
#     click 100 100
#
# will be translated into the call
#
#     move click 100 100 ne -ghost
#
# If the behavior is set to "ignore", then the picture will
# not respond to interaction commands at all, but will not
# complain either. If set to "", then the picture will
# respond to interaction commands by generating an error message.
#
body ::tycho::Picture::behavior {args} {
    if { $args == "" } {
	return $behavior
    } else {
	set behavior $args
    }
}


## cget option
#
# Query a configuration option. This method overrides the
# default cget{} in order to make access to configuration
# options of a shape transparent. See configure{} for comments.
#
body ::tycho::Picture::cget {option} {
    if { [catch {_cget $option} result] } {
	if { $shapeobject != "" } {
	    set result [$shapeobject cget $option]
	}
    }
    return $result
}


## click
#
# Start an interaction sequence on this picture. See the behavior{}
# method.
#
# NOTE: DO NOT OVERRIDE
#
body ::tycho::Picture::click {x y} {
    if { $behavior == "none" } {
	error "Picture $this has no behavior"
    }

    if { $behavior != "ignore" } {
	eval $this [lindex $behavior 0] click $x $y [lrange $behavior 1 end]
    }

    set temp(prevX) $x
    set temp(prevY) $y
}


## configure {option value}+
#
# Set or query configuration options. This method overrides the
# default configure{} in order to make access to configuration
# options of a shape transparent.
#
# Note: There's one catch: configuration options of a shape show up
# only after the shape has been accessed. However, attempting to
# set a configuration option not valid for the picture will
# automatically access the shape.
#
# FIXME: This code cannot distinguish between an error caused
# by an incorrect option name and a bad option value, and thus
# may give misleading error messages.
#
body ::tycho::Picture::configure {args} {
    if { $args == "" } {
 	# We've been asked for the configuration values. Get the
 	# configuration values of this object and its shape
 	# object and append them together.

 	set result [_configure]
 	if { $shapeobject != "" } {
 	    set result [concat $result [$shapeobject configure]]
 	}
 	return $result

    } elseif { [llength $args] == 1 } {
 	if { [catch {_configure [lindex $args 0]} result] } {
 	    if { $shapeobject != "" } {
 		set result [$shapeobject configure [lindex $args 0]]
 	    }
 	}
 	return $result

    } else {
 	# To set a configuration option, we first have to figure
 	# out whether each option belongs to this object or not.
 	# There are probably several ways of doing this: I have
 	# done it by trying to do a cget{}.

 	foreach {option value} $args {
 	    if { ! [catch {_cget $option}] } {
 		_configure $option $value
 	    } elseif {$shapeobject != "" } {
 		$shapeobject configure $option $value
 	    }
 	}
    }
}


## deform "direct"  x y {aspect}+
## deform "click"   x y {aspect}+ [-ghost]
## deform "drag"    x y
## deform "release" x y
#
# Deform a picture. By default, this method delegates to the
# picture's _shapeobject_ instance variable, as determined by the
# _shape_ option variable. See the various Shape objects for a
# a description of the different modes.
#
# The shape object is tested for null before doing anything, and one
# is created if it doesn't exist. This avoids creating shape objects
# that will never be used.
#
body ::tycho::Picture::deform {mode x y args} {

    # Call the deform{} method of the shape delegate.
    eval [query shapeobject] deform $mode $x $y $args
}


## detach aspect picture
#
# Remove a constraint. The constraint is specified by its aspects
# and a picture. It is the caller's responsibility to ensure that
# aspects and pictures when detaching correspond to those used when
# attaching.
#
body ::tycho::Picture::detach {aspects picture} {
    foreach aspect $aspects {
	set aspect [join $aspect "-"]

	if { ! [info exists constraints($aspect)] } {
	    error "Invalid constraint ($picture, $aspect) in $this"
	}

	set result {}
	foreach triple $constraints($aspect) {
	    if { [lindex $triple 0] != $picture } {
		lappend result $triple
	    }
	}
	if { $result == {} } {
	    unset constraints($aspect)
	} else {
	    set constraints($aspect) $result
	}
    }
}


## drag
#
# Continue an interaction sequence on this picture. See the behavior{}
# method.
#
# NOTE: DO NOT OVERRIDE
#
body ::tycho::Picture::drag {x y} {
    if { $behavior != "ignore" } {
	$this [lindex $behavior 0] drag \
		[expr $x - $temp(prevX)] [expr $y - $temp(prevY)]
    }

    set temp(prevX) $x
    set temp(prevY) $y
}


## extend args
#
# Extend a picture. The need for and meaning of additional
# arguments depends on the picture's shape class. If the shape class
# doesn't support the extend{} operation then an error will be
# signalled.
#
body ::tycho::Picture::extend {args} {

    # Call the extend{} method of the shape delegate.
    eval [query shapeobject] extend $args
}


## grapple args
#
# Attach grapples to a picture.
#
body ::tycho::Picture::grapple {args} {
    eval [query shapeobject] grapple $args
}


## mark
## mark value
#
# A picture is "marked" if it is able to respond to user
# interaction. This variable is tied on intimately with the
# tagging mechanisms, so don't use it!
#
# FIXME: Can this option be eliminated by just using
# absence/presence of certain tag types?
#
body ::tycho::Picture::mark {args} {
    if { $args == "" } {
	return $mark
    } else {
	set mark [lindex $args 0]
    }
}


## move "direct"  x y
## move "click"   x y [-ghost]
## move "drag"    x y
## move "release" x y
#
# Move a picture. This method has several sub-commands, selected
# by the first argument.
#
# -- direct: Move the picture by the specified x and y coordinates.
#    This is intended only for ``all-at-once'' moves; for moves that
#    can be broken into a series of small moves -- such as dragging
#    with the mouse -- use a sequence of click-drag-release moves.
#
# -- click: Signal the start of a click-drag-release action. This
#    assumes that a release action has been called since previous
#    drag actions. The optional -ghost flag indicates that the picture
#    is to be moved by dragging a ``ghost'' of the picture.
#
# -- drag: Move the picture or its ghost by the specified amount.
#    Drag assumes that click has already been called on the picture,
#    and will function unpredictably if not.
#
# -- release: Terminate a click-drag-release sequence. If a ghost is
#    being moved, then the picture is moved to its position and the ghost
#    is deleted. Note: A release must be used to terminate the click-drag-
#    release sequence, even if not ghosting the picture. The x and y
#    arguments are ignored.
#
# Note: DO NOT OVERRIDE.
#
body ::tycho::Picture::move {mode x y args} {

    # Switch on the mode keyword
    switch -exact $mode {
	"direct" {
	    # A simple relative move. Move canvas items, and then
	    # propagate constraints.
	    $canvas move $thistag $x $y
	    $this propagate "direct" $x $y "body"
	}
	"click" {
	    getflag ghost args

	    # If the _ghost_ option is set, draw the ghost shape.
	    # If not, clear the *ghost* flag so that later drags
	    # don't get confused.
	    #
	    # If the ghost is not set, propagate constraints.
	    if { $ghost } {
		set temp(ghost) [$this query ghost]

		# Tag each ghost item to make moving easier later
		foreach g $temp(ghost) {
		    $canvas itemconfigure $g -tags "ghost"
		}

		# Remember where I am now.
		set temp(start) \
			[lrange [$canvas coords [lindex $temp(ghost) 0]] 0 1]

	    } else {
		$this propagate "click" $x $y "body"
	    }
	}
	"drag" {
	    # If there's a ghost, move it. Otherwise move the picture.
	    if { [info exists temp(ghost)] } {
		$canvas move "ghost" $x $y
	    } else {
		$canvas move $thistag $x $y
		$this propagate "drag" $x $y "body"
	    }
	}
	"release" {
	    # If there's a ghost, delete it, move the picture there, which
	    # will in turn perform a one-shot constraint propagation.
	    # If there isn't a ghost, finalize constraint propagation.
	    if { [info exists temp(ghost)] } {
		assign x y $temp(start)
		assign a b [$canvas coords [lindex $temp(ghost) 0]]

		$this move "direct" [expr $a - $x] [expr $b - $y]

		$canvas delete "ghost"
		unset temp(ghost)
		unset temp(start)

	    } else {
		$this propagate "release" 0 0 "body"
	    }
	}
	default {
	    error "Invalid mode \"$mode\" to $this::mode{}"
	}
    }
}


## moveto aspect x y
#
# Move an aspect of a picture to a given coordinate. By
# default, this method delegates to the picture's shape object.
#
body ::tycho::Picture::moveto {aspect x y} {

    # Call the move{} method of the shape delegate.
    [query shapeobject] move $aspect $x $y
}


## normal aspect
#
# Return the normal to an aspect. The valid aspects depend
# on the current setting of the picture's _shape_ option.
#
body ::tycho::Picture::normal {aspect} {

    # Call the normal{} method of the shape delegate.
    [query shapeobject] normal $aspect
}


## parent
## parent p
#
# Set or clear the parent of the picture. This is not intended
# for general use: instead, use the component{} method.
#
body ::tycho::Picture::parent {args} {
    if { $args == "" } {
	return $parent
    }

    # If the current parent is not null, then remove its tags
    # from this picture.
    #
    # FIXME: Does this need -force?
    if { $parent != "" } {
	eval $this _etag delete [$parent _etag get]
	eval $this _htag delete [$parent _htag get]
    }

    # Set the new parent. If it is not null, then add its tags to
    # this picture.
    #
    # FIXME: Does this need -force?
    set parent [lindex $args 0]
    if { $parent != "" } {
	eval $this _etag add [$parent _etag get]
	eval $this _htag add [$parent _htag get]
    }
}


## propagate mode x y aspects
#
# Propagate a constraint. This method is called by the various
# moving and deforming methods. The _mode_ argument is the same mode
# as used by interaction commands -- that is, "click," "drag," or
# "release" -- or the "direct" mode for simple moves and deforms.
#
# Every constraint associated with every aspect in _aspects_ is looked
# up in the constraints array. For each of these constraints, the associated
# operation is called on the associated picture, with mode _mode_ and
# coordinates _x_ and _y_.
#
# NOTE: Constraint propagation bypasses the behavior interface, so
# the behavior of a picture moved or deformed under constraints is not
# affected by its behavior configuration variable...
#
# FIXME: A more efficient way of caching constraints for propagation
# for use in click-drag-release sequences is needed.
#
# FIXME: Constraints cannot be circular. I need to think about exactly
# how much circularity is needed, before deciding on the best way
# to deal with it.
#
body ::tycho::Picture::propagate {mode x y aspects} {

    # First get all the constraints, and remove duplicates.
    # Note that only the picture name is considered, so the
    # same picture cannot (usefully) have more than one operation.
    set cons {}
    foreach aspect $aspects {
	set aspect [join $aspect "-"]

	if { [info exists constraints($aspect)] } {
	    set cons [concat $cons $constraints($aspect)]
	}
    }
    set cons [lnubKeyed $cons]

    # Apply the operation to each picture.
    switch -exact $mode {
	"direct" {
	    foreach triple $cons {
		assign picture operation options $triple
		eval $picture $operation "direct" $x $y $options
	    }
	}
	"click" {
	    foreach triple $cons {
		assign picture operation options $triple
		eval $picture $operation "click" $x $y $options
	    }
	}
	"drag" {
	    foreach triple $cons {
		assign picture operation $triple
		eval $picture $operation "drag" $x $y
	    }
	}
	"release" {
	    foreach triple $cons {
		assign picture operation $triple
		eval $picture $operation "release" 0 0
	    }
	}
    }
}


## query option
## query "set" option script
#
# Query a picture for some information about itself. If the
# picture does not find the answer in its own array of answers,
# it asks its shape object.
#
# To add a script to an object for future queries, use the
# "add" option. To make the script apply to all objects of
# the same class (unless overridden by individual objects),
# specify the -class flag. To make the script execute in the
# object's local scope, specify the -local flag. (The advantage
# of local execution as that $this will be expanded when the
# query is made; the disadvantage is that you might overwrite
# private variables.
#
# NOTE: DO NOT OVERRIDE
#
body ::tycho::Picture::query {option args} {
    switch -exact $option {
	"classanswers" {
	    return [array get classanswers]
	}
	"objectanswers" {
	    return [array get objectanswers]
	}
	"set" {
	    # Set an answer script. The -local flag makes it execute
	    # locally, the -class flag makes it apply to all objects
	    # of this class (unless individual objects override it).
	    getflag local args
	    getflag class args

	    set option [lindex $args 0]
	    set script [lindex $args 1]

	    if { $class } {
		set classanswers($option)  [list $local $script]
	    } else {
		set objectanswers($option) [list $local $script]
	    }
	}
	default {
	    # See if there's an object answer; if not, try for a class
	    # answer; if none there, try the shape object
	    if { [info exists objectanswers($option)] } {
		set answer $objectanswers($option)
	    } elseif { [info exists classanswers($option)] } {
		set answer $classanswers($option)
	    } else {
		return [eval [query shapeobject] query $option $args]
	    }

	    # Execute the answer script with args appended, either here
	    # or at the global scope
	    if { [lindex $answer 0] } {
		eval [lindex $answer 1] $args
	    } else {
		uplevel \#0 [lindex $answer 1] $args
	    }
	}
    }
}


## reshape aspect x y
## reshape aspect value
#
# Reshape a picture. By default, this method delegates to the
# picture's _shapeobject_ instance variable, as determined by the
# _shape_ option variable. The effect of this function depends on
# the current setting of the picture's -shape option.
#
body ::tycho::Picture::reshape {args} {

    # Call the reshape{} method of the shape delegate.
    eval [query shapeobject] reshape $args
}


## release
#
# Terminate an interaction sequence on this picture. See the behavior{}
# method.
#
# NOTE: DO NOT OVERRIDE
#
body ::tycho::Picture::release {} {
    if { $behavior != "ignore" } {
	$this [lindex $behavior 0] release 0 0
    }
}


## scale scale
## scale xscale yscale
## scale x y scale
## scale x y xscale yscale
#
# Scale a picture. The scale operation works on the picture's
# coordinates, not on its representation.
#
# If only *scale* is specified, the picture is scaled uniformly
# in both axes. If no coordinates are specified, the picture
# is scaled about its center.
#
body ::tycho::Picture::scale {xscale args} {
    # Extract arguments
    switch -exact [llength $args] {
	0 {
	    set yscale $xscale
	    assign x y [$this aspect center]
	}
	1 {
	    set yscale [lindex $args 0]
	    assign x y [$this aspect center]
	}
	2 {
	    set x $xscale
	    assign y xscale $args
	    set yscale $xscale
	}
	3 {
	    set x $xscale
	    assign y xscale yscale $args
	}
    }

    # Get new coordinates
    set result {}
    set coords [$this coords]
    foreach {a b} $coords {
	set a [expr $x + $xscale * ($a - $x)]
	set b [expr $y + $yscale * ($b - $y)]
	lappend result $a $b
    }

    # Apply scaling
    eval $this coords $result
}


## shape
#
# Get or set the shape class of this picture. This must be the
# name of a class in the Shape hierarchy in lower-case.
#
# The actual shape object is not created until needed -- this is
# mainly to reduce picture creation cost.
#
# If this option is null (the default), then the picture won't
# respond to shape-related commands. Whenever this option is
# changed, the current shape object is deleted.
#
body ::tycho::Picture::shape {args} {
    if { $args == "" } {
	return $shape
    } else {
	if { $shapeobject != "" } {
	    delete object $shapeobject
	    set shapeobject ""
	}
	set shape [lindex $args 0]
    }
}


## tag add {tag}+
## tag delete {tag}+
## tag get
## tag set {tag}+
## tag prim
#
# Manipulate tags. This is a better interface than configure{} for
# this purpose.
#
# DO NOT OVERRIDE.
#
body ::tycho::Picture::tag {mode args} {
    switch -exact $mode {
	"add" {
	    set tags [lunion $tags $args]

	    # If the picture is not marked, see if there are any
	    # bindings for these tags and if there are, mark it.
	    if { $mark == "" } {
		foreach t $args {
		    if { [$canvas bind $t] != "" } {
			set mark 1
			break
		    }
		}
	    }

	    # If the picture is marked, add the new tags to the event
	    # tags.
	    if { $mark != "" } {
		eval $this _etag "add" $tags -force
	    }

	    # Tell the slate about the new tags,
	    foreach t $args {
		$slate registerTag $t $this
	    }
	}
	"delete" {
	    set tags [lsubtract $tags $args]

	    # If the picture is marked, then it is possible that deleting
	    # a tag will make it unmarked. So, for the tags that remain,
	    # test if there are any bindings. If none of them have bindings,
	    # then the picture can be unmarked and its event tags set to
	    # the event tags of its parent.
	    set unmark 1
	    foreach t $tags {
		if { [$itk_component(canvas) bind $t] != "" } {
		    set unmark 0
		    break
		}
	    }
	    if { $unmark } {
		set mark ""

		if { $parent != "" } {
		    eval $this _etag set [$parent _etag get] -force
		} else {
		    $this _etag set {} -force
		}
	    }

	    # If the picture is still marked, set its event tags to
	    # its user tags.
	    if { $mark != "" } {
		eval $this _etag "set" $tags -force
	    }

	    # Tell the slate about the removed tags.
	    foreach t $args {
		$slate deregisterTag $t $this
	    }
	}
	"get" {
	    return $tags
	}
	"set" {
	    # This code figures out the new tags and the obsolete
	    # "dead" tags and calls tag add and tag delete. This
	    # is currently a hack to deal with the fact that this
	    # can get called by the configuration code for the
	    # -tags option.
	    #
	    # FIXME. Now this won't work if called from somehere else!!!
	    set newtags [lsubtract $args $prevTags]
	    if { $tags != "" } {
		set deadtags [lsubtract $prevTags $args]
	    } else {
		set deadtags {}
	    }

	    set tags $args

	    if { $newtags != "" } {
		$this tag "add" $newtags
	    }
	    if { $deadtags != "" } {
		$this tag "delete" $deadtags
	    }
	}
	default {
	    error "Picture::tag: Invalid mode $mode"
	}
    }
}


## transform mode args
#
# Transform a picture. The transformation available depend on the
# picture's shape.
#
body ::tycho::Picture::transform {mode args} {

    # Call the transform{} method of the shape delegate.
    eval [query shapeobject] transform $mode $args
}




# FIXME: move these somewhere else...
proc lsearchKeyed {list key} {
    set index 0
    foreach i $list {
	if { [lindex $i 0] == $key } {
	    return $index
	}
	incr index
    }
    return -1
}

proc ldeleteKeyed {list key} {
    set i [lsearchKeyed $list $key]

    if { $i != -1 } {
	return [lreplace $list $i $i]
    }

    return $list
}

proc lnubKeyed {list} {
    set result {}
    foreach i $list {
	if { [lsearchKeyed $result [lindex $i 0]] == -1 } {
	    lappend result $i
	}
    }
    return $result
}
