#########################################################################
# @Version: $Id$
# @Author: H. John Reekie
#
# @Copyright (c) 1996-1997 The Regents of the University of California.
# All rights reserved.
#  
# Permission is	hereby granted,	without	written	agreement and without
# license or royalty fees, to use, copy, modify, and distribute	this
# software and its documentation for any purpose, provided that	the above
# copyright notice and the following two paragraphs appear in all copies
# of this software.
# 
# IN NO	EVENT SHALL THE	UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY
# FOR DIRECT, INDIRECT,	SPECIAL, INCIDENTAL, OR	CONSEQUENTIAL DAMAGES
# ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF
# THE UNIVERSITY OF CALIFORNIA HAS BEEN	ADVISED	OF THE POSSIBILITY OF
# SUCH DAMAGE.
# 
# THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES	OF
# MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.	THE SOFTWARE
# PROVIDED HEREUNDER IS	ON AN "AS IS" BASIS, AND THE UNIVERSITY	OF
# CALIFORNIA HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT,	UPDATES,
# ENHANCEMENTS,	OR MODIFICATIONS.
#							  COPYRIGHTENDKEY
##########################################################################


# Explicitly load the superclass. I don't really know why this is
# needed, but the common arrays get upset otherwise.
namespace ::tycho {
    if { [::info classes ComplexItem] == "" } {
	uplevel #0 {source $tychoslate/ComplexItem.itcl}
    }
}


########################################################################
## Connectible
#
# <i>Connectible</i> is an abstract class for items that can have
# things connected to them with terminals.
# The appearance of its terminals if given by configuration options. 
# For a specific application, you may prefer to write a subclass
# dedicated to the application.
# 
# <p><b>Options</b>:
# 
# <ul>
# <li><b>-inputs</b>.  The positions of the input connections.  This is a 
# flat list of <i>x</i> and <i>y</i> coordinates, as percentages of the 
# icon size and with the origin at the top left of the icon.  By default, 
# this is <code>{0 50}</code>, meaning that there is a single input 
# halfway up the left edge of the icon.  If a single integer is given when 
# setting this option, the option is set to a list such that that number 
# of inputs are evely spaced along the left edge of the icon.  For 
# example, setting <code>-inputs 2</code> will result in the 
# <code>-inputs</code> being set to <code>{0 25 0 75}</code>.
# 
# <li><b>-intype</b>.  A list containing the item type to use to draw the 
# input terminals, followed by options of the item.  The item must accept 
# exactly two coordinates.  The default is <code>{Terminal -type 
# input}</code>.
# 
# <li><b>-outputs</b>.  The positions of the output connections.  This is 
# must the same as the <code>inputs</code> option, except that output 
# terminals are by default placed at the right-hand side of the node icon.
# 
# <li><b>-outtype</b>.  A list containing the item type to use to draw the 
# output terminals, followed by options of the item.  The default is 
# <code>{Terminal -type output}</code>.
# 
# </ul>
# 
# <p><b>Components</b>
#
# <ul>
# <li><b>inports</b>:
# The input ports.
# <li><b>outports</b>:
# The output ports.
# </ul>
#
# <p><b>Enhancements</b>: In an earlier version of the Slate,
# Connectible items had primary and secondary "directions," so that
# you could flip the node about the vertical and horizontal axes.
# 
# <p><b>Caveats</b>: (none)
# 
# <p><b>Example</b>: See <a href="IconFrame.html">IconFrame.html</a>
# and <a href="IconRect.html">IconRect.html</a>
#
# <a href="../internals/howtoread.html">Reading <i>ComplexItem</i> documentation</a>.
#
# <b>Note</b>: This is an experimental class.
#
class ::tycho::Connectible {
    inherit ::tycho::ComplexItem

    ###################################################################
    ####                         public procs                      ####

    # Update the *-inputs* option
    proc _inputs {id canvas slate inputs}
    
    # Update the *-intype* option
    proc _intype {id canvas slate intype}
    
    # Update the *-outputs* option
    proc _outputs {id canvas slate outputs}
    
    # Update the *-outtype* option
    proc _outtype {id canvas slate outtype}

    # Get an aspect
    proc aspect {id canvas slate args}
    
    # Access a component
    proc component {id canvas slate {name {}}}

    # Get the region of the icon
    proc region {id canvas slate args}

    ###################################################################
    ####                          protected procs                  ####

    # Update the inputs and output because of change in coordinates
    protected proc coords {id canvas slate x0 y0 x1 y1}
    
    ###################################################################
    ####                         protected variables               ####

    # All methods are looked up through a table
    common methodtable

    # All options have a default value
    common optiondefault

    # The "direction" of the input ports
    common indirn

    # The "direction" of the output ports
    common outdirn

    ###################################################################
    ####                           private procs                   ####

    proc redrawinputs  {id canvas slate positions}
    proc redrawoutputs {id canvas slate positions}

    ###################################################################
    ####                       class initialization                ####

    #### Set method table
    array set methodtable [array get ::tycho::ComplexItem::methodtable]

    set methodtable(_inputs)     ::tycho::Connectible::_inputs
    set methodtable(_intype)     ::tycho::Connectible::_intype
    set methodtable(_outputs)    ::tycho::Connectible::_outputs
    set methodtable(_outtype)    ::tycho::Connectible::_outtype

    set methodtable(aspect)      ::tycho::Connectible::aspect
    set methodtable(component)   ::tycho::Connectible::component
    set methodtable(region)      ::tycho::Connectible::region

    #### Set option defaults
    array set optiondefault [array get ::tycho::ComplexItem::optiondefault]

    set optiondefault(-inputs)   1
    set optiondefault(-intype)   {Terminal -type input}
    set optiondefault(-outputs)  1
    set optiondefault(-outtype)  {Terminal -type output}
}

##########################################################################
#### -inputs option configuration
#
# The option representing the positions of the input connections.
# Each of these is a list of connection positions, in % and relative
# to the top-left corner of the picture's outline. Each position
# is a pair, with each number the percentage distance along
# the horizontal and vertical axis respectively. For example,
# a single point in the center of the left edge is *{0 50}*;
# two points along the bottom edge could be *{25 100 75 100}*.
#
# By default, there is one input on the left edge and one output
# on the right edge.
#
# Setting this configuration option supports a handy shortcut:
# A single number sets the list to evenly spaced positions
# along the left (input) or right (output) edges. For example,
# the option *-inputs 2* to the constructor will result in
# the -inputs variable being set to *{0 25 0 75}*.
#
body ::tycho::Connectible::_inputs {id canvas slate inputs} {
    # Set up coordinates
    ::tycho::assign x0 y0 x1 y1 [$canvas coords $primary($id)]
    set xscale [expr ($x1-$x0)/100.0]
    set yscale [expr ($y1-$y0)/100.0]
    set positions {}

    # If the argument is an integer, generate evenly-spaced points
    # along the left axis.
    if { [llength $inputs] == 1 && [string match {[0-9]*} $inputs] } {
	set option(inputs$id) {}
	set variable(indirn$id) {}

	# If it's zero, then delete ports and we're done
	if { $inputs == 0 } {
	    if { [::info exists component(inports$id)] } {
		foreach p $component(inports$id) {
		    $slate delete $p
		}
	    }
	    return
	}
	foreach y [::tycho::spread $inputs 0 100 -indented] {
	    lappend option(inputs$id) 0 $y
	    lappend variable(indirn$id) -1 0
	    lappend positions $x0 [expr $y0 + $yscale * $y]
	}
    } else {
	# The argument has the correct format
	set option(inputs$id) $inputs
	set variable(indirn$id) {}
	foreach {x y} $inputs {
	    if { $x == 0 } {
		lappend variable(indirn$id) -1 0
		lappend positions $x0 [expr $y0 + $yscale * $y]
	    } elseif { $x == 100 } {
		lappend variable(indirn$id) 1 0
		lappend positions $x1 [expr $y0 + $yscale * $y]
	    } elseif { $y == 0 } {
		lappend variable(indirn$id) 0 -1
		lappend positions [expr $x0 + $xscale * $x] $y0
	    } elseif { $y == 100 } {
		lappend variable(indirn$id) 0 1
		lappend positions [expr $x0 + $xscale * $x] $y1
	    } else {
		error "Invalid coordinates $x $y"
	    }
	}
    }
    # Now move/draw the terminals
    redrawinputs $id $canvas $slate $positions
}

##########################################################################
#### -intype option configuration
#
body ::tycho::Connectible::_intype {id canvas slate intype} {
    set option(intype$id) $intype
    foreach p $component(inports$id) {
	$slate delete $p
    }
    set component(inports$id) {}

    _inputs $id $canvas $option(inputs$id)
}

##########################################################################
#### -outputs option configuration
#
# See _inputs{} for comments.
#
body ::tycho::Connectible::_outputs {id canvas slate outputs} {
    # Set up coordinates
    ::tycho::assign x0 y0 x1 y1 [$canvas coords $primary($id)]
    set xscale [expr ($x1-$x0)/100.0]
    set yscale [expr ($y1-$y0)/100.0]
    set positions {}
    
    # If the argument is an integer, generate evenly-spaced points
    # along the right axis.
    if {  [llength $outputs] == 1 && [string match {[0-9]*} $outputs] } {
	set option(outputs$id) {}
	set variable(outdirn$id) {}

	# If it's zero, then delete ports and we're done
	if { $outputs == 0 } {
	    if { [::info exists component(outports$id)] } {
		foreach p $component(outports$id) {
		    $slate delete $p
		}
	    }
	    return
	}
	foreach y [::tycho::spread $outputs 0 100 -indented] {
	    lappend option(outputs$id) 100 $y
	    lappend variable(outdirn$id) 1 0
	    lappend positions $x1 [expr $y0 + $yscale * $y]
	}
    } else {
	# The argument has the correct format
	set option(outputs$id) $outputs
	set variable(outdirn$id) {}
	foreach {x y} $outputs {
	    if { $x == 0 } {
		lappend variable(outdirn$id) -1 0
		lappend positions $x0 [expr $y0 + $yscale * $y]
	    } elseif { $x == 100 } {
		lappend variable(outdirn$id) 1 0
		lappend positions $x1 [expr $y0 + $yscale * $y]
	    } elseif { $y == 0 } {
		lappend variable(outdirn$id) 0 -1
		lappend positions [expr $x0 + $xscale * $x] $y0
	    } elseif { $y == 100 } {
		lappend variable(outdirn$id) 0 1
		lappend positions [expr $x0 + $xscale * $x] $y1
	    } else {
		error "Invalid coordinates $x $y"
	    }
	}
    }
    # Now move/draw the terminals
    redrawoutputs $id $canvas $slate $positions
}

##########################################################################
#### -outtype option configuration
#
body ::tycho::Connectible::_outtype {id canvas slate outtype} {
    set option(outtype$id) $outtype
    foreach p $component(outports$id) {
	$slate delete $p
    }
    set component(outports$id) {}
    _outputs $id $canvas $option(outputs$id)
}

##########################################################################
#### aspect
#
# Return aspects of a node. Aspects are of the form *input-*_n_
# or $output-*_n_.
#
# FIXME: Make more efficient.
#
# FIXME: Do we really need this? Terminal positions can be found
# more easily by using component and then calling aspects on those.
# Plus it doesn't assume that the ports have an aspect called
# "terminal."
#
body ::tycho::Connectible::aspect {id canvas slate args} {
    set result {}

    # If there are no args, return a list of aspect names
    if { $args == "" } {
	foreach n [interval 0 [expr [llength $component(inports$id)] - 1]] {
	    lappend result input-$n
	}
	foreach n [interval 0 [expr [llength $$component(outports$id)] - 1]] {
	    lappend result output-$n
	}
	return $result
    }
    
    # If there are args, return the aspect coordinates
    foreach aspect $args {
	set splut [split $aspect "-"]
	switch -exact [lindex $splut 0] {
	    "input" {
		set result [concat $result \
			[$slate aspect \
			[lindex $component(inports$id) [lindex $splut 1]] "terminal"]]
	    }
	    "output" {
		set result [concat $result \
			[$slate aspect \
			[lindex $component(outports$id) [lindex $splut 1]] "terminal"]]
	    }
	    default {
		error "unknown aspect $aspect"
	    }
	}
    }
    return $result
}

##########################################################################
#### component
#
# Return a component of a node. Component names are of the form *input-*_n_
# or $output-*_n_.
#
body ::tycho::Connectible::component {id canvas slate {name {}}} {
    # If there is no component argument, return a list of components
    if { $name == "" } {
	return [aspect $id $canvas]
    }
    
    # Otherwise, get the specified component
    set splut [split $name "-"]
    switch -exact [lindex $splut 0] {
	"input" {
	    return [lindex $component(inports$id) [lindex $splut 1]]
	}
	"output" {
	    return [lindex $component(outports$id) [lindex $splut 1]]
	}
	default {
	    error "unknown component $name"
	}
    }
}

##########################################################################
#### coords
#
# Move the inputs and outputs to match the coordinates of the
# primary component
#
body ::tycho::Connectible::coords {id canvas slate x0 y0 x1 y1} {
    set xscale [expr ($x1-$x0)/100.0]
    set yscale [expr ($y1-$y0)/100.0]

    # Move inputs
    set positions {}
    foreach {x y} $option(inputs$id) {
	if { $x == 0 } {
	    lappend positions $x0 [expr $y0 + $yscale * $y]
	} elseif { $x == 100 } {
	    lappend positions $x1 [expr $y0 + $yscale * $y]
	} elseif { $y == 0 } {
	    lappend positions [expr $x0 + $xscale * $x] $y0
	} elseif { $y == 100 } {
	    lappend positions [expr $x0 + $xscale * $x] $y1
	}  
    }
    redrawinputs $id $canvas $slate $positions

    # Move outputs
    set positions {}
    foreach {x y} $option(outputs$id) {
	if { $x == 0 } {
	    lappend positions $x0 [expr $y0 + $yscale * $y]
	} elseif { $x == 100 } {
	    lappend positions $x1 [expr $y0 + $yscale * $y]
	} elseif { $y == 0 } {
	    lappend positions [expr $x0 + $xscale * $x] $y0
	} elseif { $y == 100 } {
	    lappend positions [expr $x0 + $xscale * $x] $y1
	}  
    }
    redrawoutputs $id $canvas $slate $positions
}

##########################################################################
#### region
#
# Get the region of the primary.
#
body ::tycho::Connectible::region {id canvas slate args} {
    eval $slate region $primary($id) $args
}

##########################################################################
#### redrawinputs
#
body ::tycho::Connectible::redrawinputs {id canvas slate positions} {
    if { ! [::info exists component(inports$id)] } {
	set component(inports$id) {}
    }
    set tags [$canvas gettags $id]
    foreach {x y} $positions {a b} \
	    $variable(indirn$id) \
	    p $component(inports$id) {
	if { $p == "" } {
	    lappend component(inports$id) [eval $slate createrootchild $id \
		    [lindex $option(intype$id) 0] \
		    $x $y \
		    [lrange $option(intype$id) 1 end] \
		    -direction [list [list $a $b]] \
		    -tags input]
	} else {
	    $slate coords $p $x $y
	    # Should be able to optimise this out
	    $slate itemconfigure $p \
		    -direction [list $a $b]
	}
    }
}

##########################################################################
#### redrawoutputs
#
body ::tycho::Connectible::redrawoutputs {id canvas slate positions} {
    if { ! [::info exists component(outports$id)] } {
	set component(outports$id) {}
    }
    set tags [$canvas gettags $id]
    foreach {x y} $positions \
	    {a b} $variable(outdirn$id) \
	    p $component(outports$id) {
	if { $p == "" } {
	    lappend component(outports$id) [eval $slate createrootchild $id \
		    [lindex $option(outtype$id) 0] \
		    $x $y \
		    [lrange $option(outtype$id) 1 end] \
		    -direction [list [list $a $b]] \
		    -tags output]
	} else {
	    $slate coords $p $x $y
	    # Should be able to optimise this out
	    $slate itemconfigure $p \
		    -direction [list $a $b]
	}
    }    
}
