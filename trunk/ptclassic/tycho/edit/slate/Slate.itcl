##########################################################################
# A canvas mega-widget for manipulating hierarchical picture objects.
#
# @Version: $Id$
# @Author: H. John Reekie
#
# @Copyright (c) 1996 The Regents of the University of California.
# All rights reserved.
# 
# Permission is hereby granted, without written agreement and without
# license or royalty fees, to use, copy, modify, and distribute this
# software and its documentation for any purpose, provided that the above
# copyright notice and the following two paragraphs appear in all copies
# of this software.
# 
# IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY
# FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
# ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF
# THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.
# 
# THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE
# PROVIDED HEREUNDER IS ON AN "AS IS" BASIS, AND THE UNIVERSITY OF
# CALIFORNIA HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,
# ENHANCEMENTS, OR MODIFICATIONS.
#                                                         COPYRIGHTENDKEY
##########################################################################


#######################################################################
## slate pathName args
#
# Create a slate. This procedure creates a new widget, as
# recommended on the itk web pages. In addition to creating
# a new slate, this procedure changes the binding tags so
# that events on the canvas are intercepted by the slate.
#
proc ::tycho::slate {pathName args} {
    # Create the widget
    uplevel ::tycho::Slate $pathName $args

    # Muck about with the binding tags in order to make events
    # on the canvas appear to be on the mega-widget. The default
    # bindtags for the slate (say ".s") are:
    #
    #    itk-delete-.s .s Slate . all
    #
    # and for the canvas are:
    #
    #    itk-destroy-.s.canvas .s.canvas Canvas . all
    #
    # The following code changes the binding tags to:
    #
    #    itk-delete-.s Slate . all
    #
    # and:
    #
    #    itk-destroy-.s.canvas .s Canvas . all
    #
    # What this does is: a) make scripts bound to the _slate_ (.s)
    # be matched when an event occurs on the _canvas_; b) removes
    # the slate from its own binding tags so that scripts bound to
    # events like Enter, Leave, Configure don't get executed
    # twice twice.
    #
    # I don't what the itk-delete-.s and itk-destroy-.s.canvas
    # tags are for.
    set slatetags  [bindtags $pathName]
    set canvastags [bindtags [$pathName component canvas]]

    bindtags [$pathName component canvas] \
	    [lreplace $canvastags 1 1 [lindex $slatetags 1]]
    bindtags $pathName [lreplace $slatetags 1 1]

    return $pathName
}



#######################################################################
#### Slate
#
# A canvas mega-widget for manipulating hierarchical picture objects.
# A "picture," or "pict," is a collection of canvas items, that together
# form a more complex graphic than a single canvas item. All
# methods of the Slate can manipulate either canvas items or
# "pictures" more-or-less transparently.
#
# This is a total re-write of the earlier design. In this new design,
# pictures are not represented by [incr Tcl] objects, but by an
# associative array containing just enough information to allow
# hierarchical picture construction and object-oriented-like
# picture manipulation.
#
# The key here is a hierarchical naming scheme, as used in Tk
# widgets. If a picture is named say .foo, then it might have
# a component named say .foo.bar; unlike Tk widgets, .foo.bar
# does not necessarily denote a unique item, but could denote
# a number of canvas items. Canvas items and 'pictures' are more
# intergrated in this design: .foo.bar could itself have a
# component named, say, .foo.bar.fred.
#
# The Slate will soon have all the same fancy interaction mechanisms
# as the Slate, at which time it will be renamed Slate.
#
class ::tycho::Slate {
    inherit itk::Widget

    constructor {args} {}
    destructor {}

    ###################################################################
    ####                         public methods                    ####

    # Add a tag to picts using a search spec
    method addtag {tag searchSpec args}

    # Get the bounding box of one or more picts or items
    method bbox {args}

    # Bind a command to an item, picture, or tag
    method bind {id args} {
	eval $canvas bind $id $args
    }

    # Call a "method" on a picture
    method call {picture method args}

    # Convert a screen x coordinate into a canvas x coordinate
    method canvasx {screenx {gridspacing {}}}

    # Convert a screen y coordinate into a canvas y coordinate
    method canvasy {screeny {gridspacing {}}}

    # Set or get the coordinates of an item or pict
    method coords {id args}

    # Create a new item or pict
    method create {type args}

    # Delete characters
    method dchars {id first {last {}}} {
	eval $canvas dchars $id $first $last
    }

    # Delete items or picts
    method delete {args}

    # Delete a tag from items
    method dtag {id {tagToDelete {}}}

    # Find picts according to a search spec
    method find {searchSpec args}

    # Focus on an item
    method focus {{id {}}} {
	eval $canvas $id
    }

    # Get the tags of an item or pict
    method gettags {id}

    # Set the insertion cursor
    method icursor {id index} {
	 $canvas $id $index
    }

    # Return the numerical value of a symbolic index
    method index {id index} {
	 $canvas $id $index
    }

    # Insert text at the insertion cursor
    method insert {id beforeThis string} {
	 $canvas $id $beforeThis $string
    }

    # Interact with pictures
    method interact {mode pict args}

    # Get a configuration option of an item or pict
    method itemcget {id option}

    # Configure an item or pict
    method itemconfigure {id args}

    # Lower an item or pict
    method lower {id {belowThis {}}}

    # Move items or picts
    method move {id xAmount yAmount}

    # Manipulate pictures
    method picture {mode args}

    # Generate postscript
    method postscript {args}

    # Raise an item or pict
    method raise {id {aboveThis {}}}

    # Set or get the rectangular "region" of the picture
    method region {id args}

    # Scale a picture
    method scale {id xOrigin yOrigin xScale yScale}

    # Scanning on a picture
    method scan {option args} {
	eval $canvas scan $option $args
    }

    # Manipulate the selection
    method select {option {id {}} {index {}}} {
	eval $canvas select $option $id $index
    }

    # Return the picture type
    method type {id}

    # Set the horizontal view for scrolling
    method xview {args}

    # Set the vertical view for scrolling
    method yview {args}


    ###################################################################
    ####                   protected variables                     ####

    # The canvas on which I draw
    protected variable canvas


    ###################################################################
    ####                     private methods                       ####
    
    # Give a picture a new parent
    private method adopt {parent id}

    # Test id a picture is an ancestor of another
    private method ancestor {ancestor descendent}

    # Return the children of an item or picture
    private method children {id}

    # Return the ancestors of an item or picture
    private method ancestors {id}

    # Return the items only under this item or picture
    private method items {id}

    # Make a picture have no parent
    private method orphan {id}

    # Return the "owner" of an item -- the parent if there is one,
    # else the item.
    private method owner {id}

    # Return the parent of an item or picture
    private method parent {id}

    # Return the root of an item or picture
    private method root {id}

    # Add a tag to items and pictures
    private method tagadd {tag args}


    ###################################################################
    ####                    private variables                      ####

    # Unique IDs and tags are created using this counter
    private variable secretcounter 0

    # Every picture remembers its parent
    private variable parent

    # Each pict has a "type"
    private variable picttype

    # Each tag belongs to one or more picts
    private variable tagged

    # Storage for temporary variables
    private variable temp


    ### TEMPORARY ###

    method parray {name} {
	puts [::array get $name]
    }
}


#######################################################################
#### constructor
#
# Do not call the constructor of the Slate directly: _always_
# use the procedure ::tycho::slate{}.
#
body ::tycho::Slate::constructor {args} {

    # Create the canvas and pack it
    itk_component add canvas {
	# Create at the global scope to avoid calls to unknown{}
	uplevel #0 canvas $itk_interior.canvas
    } {
	keep -background -cursor -relief \
		-height -width -borderwidth \
		-xscrollcommand -yscrollcommand \
		-scrollregion
    }
    pack $itk_component(canvas) -fill both -expand yes

    # Keep a pointer to the canvas to save typing
    set canvas $itk_component(canvas)

    # Initialise some things
    set slatetags() {{}}

    # Initialise options
    eval itk_initialize $args
}


#######################################################################
#### addtag
#
# Add a tag to specified pictures. Uses find to get all relevent
# pictures and items, and then tags them; optimized for some
# special cases.
#
body ::tycho::Slate::addtag {add mode args} {
    switch -exact $mode {
	"withtag" {
	    set tag [lindex $args 0]

	    if { $tag == "all" || $tag == "current" } {
		eval $this tagadd $add [eval $this find withtag $tag]

	    } elseif { [string match {[0-9]*} $add] } {
		# Hey, this is just an item ID
		$canvas addtag $tag withtag $add

	    } elseif { [string match {_*} $add] } {
		# Hey, this is just a picture ID
		$canvas addtag $tag withtag $add

		if { ! [::info exists tagged($add)] } {
		    set tagged($add) [list $tag]
		} elseif { ! [lmember $tagged($add) $tag] } {
		    lappend tagged($add) $tag
		}
	    } else {
		# Oo, it really is a tag..
		$canvas addtag $add withtag $tag
		if { [::info exists tagged($tag)] } {
		    if { ! [::info exists tagged($add)] } {
			set tagged($add) $tagged($tag)
		    } else {
			set tagged($add) [lunion $tagged($add) $tagged($tag)]
		    }
		}
	    }
	}
	default {
	    eval $this tagadd $add [eval $this find $mode $args]
	}
    }
}

#######################################################################
#### bbox
#
body ::tycho::Slate::bbox {args} {
    eval $canvas bbox $args
}

#######################################################################
#### call
# Call a "method" on a picture. This just looks up the method in
# the global "virtual function table" and calls it.
#
body ::tycho::Slate::call {id method args} {
    global $picttype($id)
    eval [set $picttype($id)($method)] $id $canvas $args
}

#######################################################################
#### canvasx
#
body ::tycho::Slate::canvasx {screenx {gridspacing {}}} {
    eval $canvas canvasx $screenx $gridspacing
}

#######################################################################
#### canvasy
#
body ::tycho::Slate::canvasy {screeny {gridspacing {}}} {
    eval $canvas canvasy $screeny $gridspacing
}

#######################################################################
#### coords
#
body ::tycho::Slate::coords {id args} {

    # If this is not a picture, just call the canvas
    if { ! [string match {_*} $id] } {
	return [eval $canvas coords $id $args]
    }

    # Call the picture's coords method
    global $picttype($id)
    eval [set $picttype($id)(coords)] $id $canvas $args
}

#######################################################################
#### create
# Create a canvas item or a picture. If the _type_ arg starts
# with a lower-case letter, create an item; if not, create a
# picture.
#
body ::tycho::Slate::create {type args} {
    if { [string match {[a-z]*} $type] } {
	# Create a canvas item; tags determine nesting (if any)
	eval $canvas create $type $args

    } else {
	# Create a picture. Tags determine nesting.

	# Get the unique id
	set id _$secretcounter
	incr secretcounter

	# Remember the picture-type mapping
	set picttype($id) $type

	# Add the picture id tag to the tags. If there's a parent
	# then remember it.
	set indx [lsearch -exact $args -tags]
	if { $indx != -1 } {
 	    set tags [lsort [lindex $args [expr $indx+1]]]
 	    set args [lreplace $args $indx [expr $indx+1]]

	    # The tags are sorted: the owner tag must be first,
	    # followed by hierarchy tags, then user tags.
	    if { [string match {!*} [lindex $tags 0]] } {
		set parent($id) [string range [lindex $tags 0] 1 end]
		set tags [lreplace $tags 0 0 !$id $id]
	    } else {
		set parent($id) ""
		set tags [concat !$id $id $tags]
	    }
	    # Remember "user" tags
	    set tidx [lsearch -regexp $tags {^[^!_]}]
	    if { $tidx != -1 } {
		foreach t [lrange $tags $tidx end] {
		    lappend tagged($t) $id
		}
	    }
	} else {
	    set parent($id) ""
	    set tags [list !$id $id]
	}

	# Create the picture by calling the construct{} proc. This
	# is OK, since every picture must have a constructor, and also
	# guarantees that auto-loading will work.
	eval ::tycho::$type::construct $id [list $tags] $canvas $args

	# Make sure the name is returned
	return $id
    }
}


#######################################################################
#### delete
#
body ::tycho::Slate::delete {args} {
    foreach id $args {
	if { [string match {[0-9]*} $id] } {
	    # Delete a canvas item
	    $canvas delete $id
	} elseif { [string match {_*} $id] } {
	    # Delete a picture. First call its destruct method
	    global $picttype($id)
	    eval [set $picttype($id)(destruct)] $id $canvas

	    # Then remove all items
	    $canvas delete $id
	} else {
	    # Delete by tag: call myself again for simplicity
	    eval $this delete [$this find withtag $id]
	}
    }
}

#######################################################################
#### dtag
#
body ::tycho::Slate::dtag {id {delete {}}} {
    if { [string match {[0-9]*} $id] } {
	# A canvas item.
	eval $canvas dtag $id $delete
    } elseif { [string match {_*} $id] } {
	# A picture. Make sure _delete exists.
	if { $delete != "" } {
	    set tagged($delete) [ldelete $tagged($delete) $id]
	    $canvas dtag $id $delete
	}
    } else {
	# Doing it by tag..
	if { $delete == "" } {
	    set delete $id
	}
	$canvas dtag $id $delete
	if { [::info exists tagged($delete)] } {
	    set tagged($delete) [lsubtract $tagged($delete) $tagged($id)]
	}
    }
}

#######################################################################
#### find
#
# Find a pict or picts, as given by _searchSpec_. The argument
# formats are the same as for the Tk canvas; however, because of
# hierarchy, the behavior for the different search modes differ
# from each other. As a general rule, the slate does not
# attempt to deal with hierarchy, but blindly returns a set of
# pictures and items -- the caller must eliminate unwanted parents
# or children explicitly (see the <i>picture</i> method).
# The following argument formats are supported:
#
# <ul>
# <li><b>above</b> _id_: Return the picture or item immediately above
# _id_. Currently, this will not work if _id_ is a tag.
#
# <li><b>all</b>: Return every _root_ picture, and every
# item that is not a component of a picture.
#
# <li><b>below</b> _id_: Return the picture or item immediately below
# _id_. Currently, this will not work if _id_ is a tag.
#
# <li><b>closest _x y ?halo? ?start?_: Return the picture or item
# closest to the point _(x,y)_. Currently, this mode is not
# working correctly.
#
# <li><b>enclosed</b> _x0 x1 y0 y1_: Return every picture and
# unparented item enclosed by the given region.
#
# <li><b>overlapping</b> _x0 x1 y0 y1_: Return every picture and
# unparented item that overlaps the given region.
#
# <li><b>withtag</b> _tag_: Return every picture and every item
# with the given tag. (In the case of items, this means items that
# were explicitly tagged, rather than implicitly as a result of being
# a component of a picture with that tag.)
#
# The _tag_ can also be
# ``current,''  in which case either a) the current item is
# returned if that item is not a component; or b) the parent
# of the current item is returned.
#
# </ul>
#
body ::tycho::Slate::find {mode args} {
    switch -exact $mode {
	"above" {
	    # Get the passed item/id as a picture if possible
	    set id [$this owner [lindex $args 0]]
	    
	    # Get the item above it and return its owner
	    set id [$canvas find above $id]
	    if { $id == "" } {
		return ""
	    } else {
		return [$this owner $id]
	    }
	}
	"all" {
	    # Find top-level picts
	    set picts {}
	    foreach p [array names parent] {
		if { $parent($p) == "" } {
		    lappend picts $p
		}
	    }

	    # Tag top-level items
	    $canvas addtag temp all
	    foreach id $picts {
		$canvas dtag $id temp
	    }
	    set items [$canvas find withtag temp]
	    $canvas dtag temp

	    # Return picts and items
	    return [concat $picts $items]
	}
	"below" {
	    # Get the passed item/id as a picture if possible
	    set id [$this owner [lindex $args 0]]
	    
	    # Get the item below it and return its owner
	    set id [$canvas find below $id]
	    if { $id == "" } {
		return ""
	    } else {
		return [$this owner $id]
	    }
	}
	"closest" {
	    set x [lindex $args 0]
	    set y [lindex $args 1]

	    set item [lindex [$canvas find closest $x $y] 0]

	    return [$this owner $item]
	}
	"enclosed" {
	    # Find enclosed items
	    set items [eval $canvas find enclosed $args]

	    # For each, find out whether the owner is also fully
	    # enclosed by looking at its region. If it is, include
	    # it in the result list, and process its parent.
	    set result {}
	    set slate [canvasslate $canvas]
	    while { $items != "" } {
		set item [lindex $items 0]
		set pict [$this owner $item]
		if { [string match {[0-9]*} $pict] } {
		    # It's a top-level item, so include it
		    lappend result $item
		    set items [lreplace $items 0 0]
		} else {
		    if { [rectInside [$slate region $pict] $args] } {
			set result [lsetadd $result $pict]
			while { $parent($pict) != "" } {
			    set pict $parent($pict)
			    if { [rectInside [$slate region $pict] $args] } {
				set result [lsetadd $result $pict]
			    } else {
				break
			    }
			}
		    }
		    set items [lsubtract $items [$canvas find withtag $pict]]
		}
	    }
	    return $result
	}
	"overlapping" {
	    # Find overlapping items
	    set items [eval $canvas find overlapping $args]

	    # Find the set of owners
	    set picts {}
	    foreach i $items {
		set picts [lsetadd $picts [$this owner $i]]
	    }

	    # For each owner, include all ancestors
	    foreach p $picts {
		if { [string match {_*} $p] } {
		    set picts [lunion $picts [$this ancestors $p]]
		}
	    }
	    return $picts
	}
	"withtag" {
	    set tag [lindex $args 0]

	    if { $tag == "all" } {
		return [$this find all]

	    } elseif { $tag == "current" } {
		set current [$canvas find withtag current]
		if { $current == "" } {
		    return {}
		}

		set par [$this parent $current]
		if { $par == "" } {
		    return $current
		} else {
		    return $par
		}
	    } elseif { [string match {[0-9]*} $tag] \
		    || [string match {_*} $tag] } {
		# Hey, this is really just a picture or item ID
		return $tag

	    } else {
		# Get unparented items with this tag
		$canvas addtag temp withtag $tag
		if { [::info exists tagged($tag)] } {
		    set picts $tagged($tag)
		} else {
		    set picts {}
		}
		foreach id $picts {
		    $canvas dtag $id temp
		}
		set items [$canvas find withtag temp]
		$canvas dtag temp

		# Return picts and items
		return [concat $picts $items]
	    }
	}
    }
}

#######################################################################
#### gettags
#
body ::tycho::Slate::gettags {id} {
    # If a picture, get the primary
    if { [string match {_*} $id] } {
	set id [@scope ::tycho::Picture [list set primary($id)]]
    }
    $canvas gettags $id
}

#######################################################################
#### interact "create" class [options]
#### interact "click" id x y [options]
#### interact "drag" id x y
#### interact "release" id
#
body ::tycho::Slate::interact {mode id args} {
    switch -exact $mode {
	"create" {
	    # Create an interactor
	    set interactor [::info context]::[eval ::tycho::$id #auto \
		    [::info namespace tail $this] $canvas $args]

	    # Return it
	    return $interactor
	}
	"click" {
	    # Remember where we started
	    set x [lindex $args 0]
	    set y [lindex $args 1]

	    set temp($id.prevX) $x
	    set temp($id.prevY) $y

	    # If the -ghost option is specified, create the ghost
	    if { [lsearch -exact $args -ghost] != -1 } {
		global $picttype($id)
		set temp($id.ghost) \
			[[set $picttype($id)(ghost)] $id $canvas]

		set temp($id.start) [$this coords $temp($id.ghost)]
	    }
	}
	"drag" {
	    set x [lindex $args 0]
	    set y [lindex $args 1]

	    # If there's a ghost, move it. else move the picture.
	    if { [::info exists temp($id.ghost)] } {
		set movethis $temp($id.ghost)
	    } else {
		set movethis $id
	    }

	    # Move is a delta operation.
	    $this move $movethis \
		    [expr $x - $temp($id.prevX)] \
		    [expr $y - $temp($id.prevY)]

	    # Remember the new position
	    set temp($id.prevX) $x
	    set temp($id.prevY) $y
	}
	"release" {
	    # If there's a ghost, move the picture to its position and then
	    # delete it
	    if { [::info exists temp($id.ghost)] } {
		assign x y $temp($id.start)
		assign a b [$this coords $temp($id.ghost)]

		$this move $id [expr $a - $x] [expr $b - $y]
		$this delete $temp($id.ghost)

		unset temp($id.ghost)
		unset temp($id.start)
	    }

	    # Clean up
	    unset temp($id.prevX)
	    unset temp($id.prevY)
	}
    }
}

##########################################################################
#### itemcget
#
# Read a configuration option
#
body ::tycho::Slate::itemcget {id option} {
    if { ! [string match {_*} $id] } {
	# If this is not a picture, just call the canvas
	return [$canvas itemcget $id $option]

    } elseif { ! [string compare $option -tags] } {
	# Return the tags of this picture using the primary
	return [$canvas gettags \
		[@scope ::tycho::$picttype($id) [list set primary($id)]]]

    } elseif { [@scope ::tycho::$picttype($id) \
	    [list ::info exists [string trimleft $option -]($id)]] } {
	# Read the value directly from the class
	return [@scope ::tycho::$picttype($id) \
		[list set [string trimleft $option -]($id)]]
    } else {
	error "Invalid option $option"
    }
}

#######################################################################
#### itemconfigure
#
# Set a configuration option. There is a special caveat related
# to tags: they must not be altered directly with this method,
# but can only be changed indirectly using the picture{} method.
#
# Note also that dtag{}, gettags{}, and addtag{} are faster (and safer)
# ways of manipulating tags and should be used in preference to
# itemcget{} and itemconfigure{}.
#
body ::tycho::Slate::itemconfigure {id args} {

    # If this is an item, just call the canvas
    if { ! [string match {_*} $id] } {
	return [eval $canvas itemconfigure $id $args]
    }

    if { [llength $args] == 0 } {
	# We've been asked for all configuration values. FIXME.
	return {}
    } elseif { [llength $args] == 1 } {
	set option [lindex $args 0]
	set value [$this itemcget $id $option]
	return [list $option {} {} {} $value]  ;# default value is bogus
    } else {
	foreach {option value} $args {
	    if { ! [string compare $option -tags] } {
		# Set the tags of the picture. Figure out the differences.
		set tags [$canvas gettags \
			[@scope ::tycho::$picttype($id) \
			[list set primary($id)]]]

		
		set new [lsubtract $value $tags]
		set old [lsubtract $tags $value]

		# Delete old tags, add new tags
		foreach t $old {
		    $canvas dtag $id $t
		    set tagged($t) [ldelete $tagged($t) $t]
		}
		foreach t $new {
		    $canvas addtag $t withtag $id
		    lappend tagged($t) $id
		}
	    } else {
		# Call the proc on the class to set the option
#		::tycho::$picttype($id)::[string trimleft $option -] \
#			$id $canvas $value

		global $picttype($id)
		[set $picttype($id)([string trimleft $option -])] \
			$id $canvas $value

		[set $picttype($id)(update)] $id $canvas
		
	    }
	}
    }
}

#######################################################################
#### lower
#
body ::tycho::Slate::lower {id {belowThis {}}} {
    eval $canvas lower $id $belowThis
}

#######################################################################
#### move
#
body ::tycho::Slate::move {id xAmount yAmount} {
     $canvas move $id $xAmount $yAmount
}

#######################################################################
#### picture
# Manipulate pictures. This is a "safe" interface to some of the
# picture manipulation methods used within the slate.
#
body ::tycho::Slate::picture {mode args} {
    switch -exact $mode {
	"adopt" {
	    eval $this adopt $args
	}
	"ancestor" {
	    eval $this ancestor $args
	}
	"ancestors" {
	    eval $this ancestors $args
	}
	"children" {
	    eval $this children $args
	}
	"items" {
	    eval $this items $args
	}
	"orphan" {
	    eval $this orphan $args
	}
	"owner" {
	    eval $this owner $args
	}
	"parent" {
	    eval $this parent $args
	}
	"root" {
	    eval $this root $args
	}
    }
}

#######################################################################
#### postscript
#
body ::tycho::Slate::postscript {args} {
    eval $canvas postscript $args
}

#######################################################################
#### raise
#
body ::tycho::Slate::raise {id {aboveThis {}}} {
    eval $canvas raise $id $aboveThis
}

#######################################################################
#### region
#
body ::tycho::Slate::region {id args} {
    # If there are no arguments, just read the region.
    if { $args == "" } {
	# For a canvas item, use the coords if it's a 4-list, else
	# use the bounding box shrunk by 2 in each direction
	if { ! [string match {_*} $id] } {
	    set region [$canvas coords $id]
	    if { [llength $region] == 4 } {
		return $region
	    } else {
		return [rectShrink [$canvas bbox $id] 2]
	    }
	} else {
	    # For a picture, use the primary component if there is one.
	    # If not, use the bounding box.
	    if { [@scope ::tycho::$picttype($id) \
		    [list ::info exists primary($id)]] } {
		set region [$canvas coords \
			[@scope ::tycho::$picttype($id) \
			[list set primary($id)]]]

		if { [llength $region] == 4 } {
		    return $region
		}
	    }
	    return [rectShrink [$this bbox $id] 2]
	}
    }

    # Set the region -- FIXME!
}

#######################################################################
#### scale
#
body ::tycho::Slate::scale {id xOrigin yOrigin xScale yScale} {
    # If this is not a picture, just call the canvas
    if { ! [string match {_*} $id] } {
	$canvas scale $id $xOrigin $yOrigin $xScale $yScale
	return
    } else {
	# Get new coordinates
	set newcoords {}
	set coords [$canvas coords \
		[@scope ::tycho::$picttype($id) [list set primary($id)]]]
	foreach {a b} $coords {
	    set a [expr $xOrigin + $xScale * ($a - $xOrigin)]
	    set b [expr $yOrigin + $yScale * ($b - $yOrigin)]
	    lappend newcoords $a $b
	}

	# Apply scaling
	eval $this coords $id $newcoords
    }
}

#######################################################################
#### type
#
body ::tycho::Slate::type {id} {
    if { [string match {[0-9]*} $id] } {
	$canvas type $id
    } else {
	return $picttype($id)
    }
}

#######################################################################
#### xview
#
body ::tycho::Slate::xview {args} {
    eval $canvas xview $args
}

#######################################################################
#### yview
#
body ::tycho::Slate::yview {args} {
    eval $canvas yview $args
}

#######################################################################
#### type
#
body ::tycho::Slate::type {id} {
    if { [string match {[0-9]*} $id] } {
	$canvas type $id
    } else {
	return $picttype($id)
    }
}


#######################################################################
#### canvasslate
#
# Get the slate name given the canvas name
#
proc canvasslate {canvas} {
    return [join [linit [split $canvas .]] .]
}


    ###################################################################
    ###################################################################
    ####                      private methods                      ####


#######################################################################
#### adopt
#
# Give a picture a new parent
#
body ::tycho::Slate::adopt {parent id} {
    # If we have a parent, then orphan it first
    if { [$this parent $id] != "" } {
	$this orphan $id
    }

    # If this is a picture, remove the owner tags
    if { ! [string match {[0-9]*} $id] } {
	$canvas dtag !$id
    }

    # Add the parent's tags, but without the parent owner tag
    foreach tag [ldelete [$this tags $parent] !$parent] {
	$canvas addtag $tag withtag $id
    }
}

#######################################################################
#### ancestor
#
# Test if a picture is an ancestor of another
#
body ::tycho::Slate::ancestor {ancestor descendent} {
    return [lmember [$this itemcget $descendent -tags] $ancestor]
}

#######################################################################
#### ancestors
#
# Return the ancestors of an item or picture
#
body ::tycho::Slate::ancestors {id} {
    if { [string match {[0-9]*} $id] } {
	# A canvas item: find the owner and call again
	return [$this ancestors [$this owner $id]]
    } else {
	set picts [list $id]
	while { $parent($id) != "" } {
	    lappend $picts $parent($id)
	    set id $parent($id)
	}
	return $picts
    }
}

#######################################################################
#### children
#
# Return the children of an item or picture
#
body ::tycho::Slate::children {id} {
    if { [string match {[0-9]*} $id] } {
	return {}
    }
    set children {}
    foreach {child par} [array get parent] {
	if { $par == $id } {
	    lappend children $child
	}
    }
    return $children
}

#######################################################################
#### items
#
# Return the items only under this item or picture
# Note that this includes the primary -- is this good or bad?
#
body ::tycho::Slate::items {id} {
    if { [string match {[0-9]*} $id] } {
	return [list $id]
    } else {
	return [$canvas find withtag !$id]
    }
}

#######################################################################
#### orphan
#
# Make a picture have no parent
#
body ::tycho::Slate::orphan {id} {
    # Remove parent tags
    foreach tag [$this tags [$this parent $id]] {
	$canvas dtag $tag
    }
    
    # If this is a picture, add the owner tag
    if { ! [string match {[0-9]*} $id] } {
	$canvas addtag !$id withtag $id
    }
}

#######################################################################
#### owner
#
# Return the "owner" of an item -- the parent if there is one,
# else the item.
#
body ::tycho::Slate::owner {id} {
    if { ! [string match {[0-9]*} $id] } {
	return $id
    }
    set tags [$canvas gettags $id]
    set indx [lsearch $tags {!*}]
    if { $indx != -1 } {
	return [string range [lindex $tags $indx] 1 end]
    } else {
	return $id
    }
}

#######################################################################
#### parent
#
# Return the parent of an item or picture
#
body ::tycho::Slate::parent {id} {
    if { [string match {[0-9]*} $id] } {
	# A canvas item: find the owner
	set tags [$canvas gettags $id]
	set indx [lsearch $tags {!*}]
	if { $indx != -1 } {
	    return [string range [lindex $tags $indx] 1 end]
	} else {
	    return {}
	}
    } else {
	return $parent($id)
    }
}

#######################################################################
#### root
#
# Return the root of an item or picture
#
body ::tycho::Slate::root {id} {
    if { [string match {[0-9]*} $id] } {
	set nid [$this parent $id]
	if { $nid == "" } {
	    return $id
	} else {
	    set id $nid
	}
    }
    while { $parent($id) != "" } {
	set id $parent($id)
    }
    return $id
}

#######################################################################
#### tagadd
#
# Add a tag to items and pictures
#
body ::tycho::Slate::tagadd {tag args} {
    foreach id $args {
	# Add the tag to canvas items
	$canvas addtag $tag withtag $id

	# If a picture, remember the tag
	if { [string match {_*} $id] } {
	    if { ! [::info exists tagged($tag)] } {
		set tagged($tag) [list $id]
	    } elseif { ! [lmember $tagged($tag) $id] } {
		lappend tagged($tag) $id
	    }
	}
    }
}
