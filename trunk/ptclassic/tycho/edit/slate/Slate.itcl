##########################################################################
# @Version: $Id$
# @Author: H. John Reekie
#
# @Copyright (c) %Q% The Regents of the University of California.
# All rights reserved.
# 
# Permission is hereby granted, without written agreement and without
# license or royalty fees, to use, copy, modify, and distribute this
# software and its documentation for any purpose, provided that the above
# copyright notice and the following two paragraphs appear in all copies
# of this software.
# 
# IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY
# FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
# ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF
# THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.
# 
# THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE
# PROVIDED HEREUNDER IS ON AN "AS IS" BASIS, AND THE UNIVERSITY OF
# CALIFORNIA HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,
# ENHANCEMENTS, OR MODIFICATIONS.
#                                                         COPYRIGHTENDKEY
##########################################################################


#######################################################################
## slate pathName args
#
# Create a slate. This procedure creates a new widget, as
# recommended on the itk web pages. In addition to creating
# a new slate, this procedure changes the binding tags so
# that events on the canvas are intercepted by the slate.
#
proc ::tycho::slate {pathName args} {
    # Create the widget
    uplevel ::tycho::Slate $pathName $args

    # Muck about with the binding tags in order to make events
    # on the canvas appear to be on the mega-widget. The default
    # bindtags for the slate (say ".s") are:
    #
    #    itk-delete-.s .s Slate . all
    #
    # and for the canvas are:
    #
    #    itk-destroy-.s.canvas .s.canvas Canvas . all
    #
    # The following code changes the binding tags to:
    #
    #    itk-delete-.s Slate . all
    #
    # and:
    #
    #    itk-destroy-.s.canvas .s Canvas . all
    #
    # What this does is: a) make scripts bound to the _slate_ (.s)
    # be matched when an event occurs on the _canvas_; b) removes
    # the slate from its own binding tags so that scripts bound to
    # events like Enter, Leave, Configure don't get executed
    # twice twice.
    #
    # I don't what the itk-delete-.s and itk-destroy-.s.canvas
    # tags are for.
    set slatetags  [bindtags $pathName]
    set canvastags [bindtags [$pathName component canvas]]

    bindtags [$pathName component canvas] \
	    [lreplace $canvastags 1 1 [lindex $slatetags 1]]
    bindtags $pathName [lreplace $slatetags 1 1]

    return $pathName
}



#######################################################################
#### Slate
#
# A canvas mega-widget. The Slate is the primary interface to the
# Visual Language Toolkit, which supports hierarchical canvas items,
# moving and dragging, reusable interactions mechansism, constraints,
# and things generally useful for building visual language editors.
# It can also be used to quickly build customized widgets and
# graphical displays.
#
# In addition to the Slate class itself, there are a number of
# other classes that work with the slate to implement its full
# functionality. These classes are grouped into several categories,
# according to their function in the slate:
#
# <dl>
# <dt><a href="index.html"><b>kernel</b></a>
# <dd>The kernel classes, including this one (Slate) and the core
# classes that implement hierarchical pictures (Picture, Primitive,
# and Composite).
#
# <dt><a href="../../../pictures/doc/codeDoc/index.html"><b>pictures</b></a> 
# <dd>A set of key picture classes, including things like
# rectangles, lines, and polygons, ``3D'' rectangles and polygons,
# and ``smart'' objects like self-routing lines.
#
# <dt><a href="../../../shapes/doc/codeDoc/index.html"><b>shapes</b></a> 
# <dd>A class hierarchy that manages picture ``shapes.'' Shape
# object are what gives pictures knowledge of key coordinates
# such as wher their corners or or the location of a point on
# a circumference), and the ability to reshape themselves.
#
# <dt><a href="../../../interactors/doc/codeDoc/index.html">
#       <b>interactors</b></a> 
# <dd>A class hierarchy that manages user interaction with pictures
# on the slate. Interactors provide a pwoerful mechanism
# for capturing and reusing standard patterns of interaction.
# </dl>
#
# To create a slate, do not call the constructor directly, but call
# the procedure <code>::tycho::slate</code>:
#
# <tcl><pre>
#     ::tycho::slate .s
#     pack .s -fill both -expand on
#     wm deiconify .
# </pre></tcl>
#
# <b>A note on performance</b>
#
# Currently, all of the slate classes are written in [incr Tcl],
# which makes it run like a flea in molasses.
# Sooner or later, some or all of the code will be rewritten
# in ``something else.'' When that happens,
# the picture classes will no longer be directly accessible. To
# assist future compatibility, use the slate interface to the
# picture classes whereever possible instead of calling the
# picture classes directly.
#
# <b>A note on canvas items</b>
#
# The slate is in the process of being modified to accept canvas
# items IDs as well as object identifiers. This complicates most
# methods, but is necessary to make the slate an acceptable
# alternative in situations where the overhead of itcl objects
# is not worth the gains in flexibility.
#
class ::tycho::Slate {
    inherit itk::Widget

    constructor {args} {}
    destructor {}


    ###################################################################
    ####                         public methods                    ####

    # Add a tag to picts using a search spec
    method addtag {tag searchSpec args} {}

    # Get the bounding box of one or more picts or items
    method bbox {args} {}

    # Bind a command to an item, picture, or tag
    method bind {tagOrID args} {}

    # Set or get the coordinates of an item or pict
    method coords {pict args} {}

    # Create a new item or pict
    method create  {class args} {}

    # Delete items or picts
    method delete {args} {}

    # Find picts according to a search spec
    method find {searchSpec args} {}

    # Get the tags of an item or pict
    method gettags {pict} {}

    # Configure an item or pict
    method itemconfigure {pict args} {}

    # Get a configuration option of an item or pict
    method itemcget {pict option} {}

    # Lower an item or pict
    method lower {tagOrID args} {}

    # Move items or picts
    method move {tagOrID x y} {}

    # Generate postscript
    method postscript {args} {eval $canvas postscript $args}

    # Raise an item or pict
    method raise {tagOrID args} {}

    # Return the ``root'' pictures of a list of pictures
    method roots {picts} {}

    # Set the horizontal view for scrolling
    method xview {args} {eval $canvas xview $args}

    # Set the vertical view for scrolling
    method yview {args} {eval $canvas yview $args}


    ###################################################################
    ####                   protected variables                     ####

    # The canvas on which I draw
    protected variable canvas

    # Use instead of ``$this'' if you just want the namespace tail
    protected variable myself ""

    # The mapping from primary canvas tags to the pictures
    private variable pictdict

    # The mapping from tags to pictures
    private variable tagdict


    ###################################################################
    ####                     private methods                       ####
    
    # Tell the slate a picture no longer has a given tag
    private method deregisterTag {tag pict} {}
    
    # Tell the slate that a picture has a given tag
    private method registerTag {tag pict} {}

    # Break protection and call a private or protected method
    private method breakin {cmd} {
    	@scope [[lindex $cmd 0] info class] $cmd
    }
}


#######################################################################
#### constructor
#
# Do not call the constructor of the canvas directly: _always_
# use the procedure ::tycho::slate{}.
#
body ::tycho::Slate::constructor {args} {

    # Create the canvas and pack it
    itk_component add canvas {
	canvas $itk_interior.canvas
    } {
	keep -background -cursor -relief \
		-height -width -borderwidth \
		-xscrollcommand -yscrollcommand \
		-scrollregion
    }
    pack $itk_component(canvas) -fill both -expand yes

    # Keep a pointer to the canvas to save typing
    set canvas $itk_component(canvas)

    # Set up the "myself" variable for later use in create{}.
    set myself [::info namespace tail $this]

    # Initialise options
    eval itk_initialize $args
}


#######################################################################
#### addtag tag all
#### addtag tag withtag     tag
#### addtag tag overlapping x0 x1 y0 y1
#### addtag tag enclosed    x0 x1 y0 y1
#
# Add a tag to picts. Apart from _tag_, the arguments are exactly
# the same as for find{}: the picts selected by _searchSpec_ have
# _tag_ appended to their tags list.
#
# _FIXME_: Doesn't work with canvas item IDs
#
body ::tycho::Slate::addtag {tag searchSpec args} {
    foreach i [eval $this find $searchSpec $args] {
	$i addtag $tag
    }
}


#######################################################################
#### bbox
#
# Return the bounding box of any number of items or picts, as a four-list.
# Each argument can be an item, a pict, or a tag. If there are no pictures
# matching the tags, return the null string -- the caller must check for
# this condition. (This behavior matches
# that of the canvas).
#
# _FIXME_: Doesn't work with "current" tag
#
body ::tycho::Slate::bbox {args} {
    set tags  {}
    foreach p $args {
	if { $p == "all" } {
	    return [$canvas bbox all]
	} elseif { [isNumber $p] } {
	    lappend tags $p
	} elseif { [isObject $p] } {
	    lappend tags [::info namespace tail $p]
	} else {
	    # _FIXME_: Remove redundant pictures (children)
	    foreach q $tagdict($p) {
		lappend tags [::info namespace tail $q]
	    }
	}
    }
    return [eval $canvas bbox $tags]
}


#######################################################################
#### bind
#
# Bind a command to an item, picture, or tag. The command accepts the 
# following argument formats:
#
# <ul>
# <li>_tagOrID_: Return the events for which _tagOrID_ has a binding.
# <li>_tagOrID_ _event_: Return the binding on _tagOrID_ for _event_.
# <li>_tagOrID_ _event_ _command_: Bind _command_ to the _tagOrID_
# for _event_
# </ul>
#
# <b>Note</b>: Bindings on hierarchical picture are complicated, but
# there's a reasonably well-developed theory behind it. This needs to be 
# explained more here.
#
# <b>Caveat</b>: The bind{} command is not properly developed yet. There are
# some interactions with canvas bindings, multiple bindings on the
# same tag/object, and hierarchical pictures that need to be
# explored and clarified.
#
# <b>Caveat</b>: The canvas items are not properly integrated. Right now,
# I'm not certain exactly what does and doesn't work, as tagging in the
# presence of the visual hierarchy is rather complicated.
#
# _FIXME_: Doesn't work properly if resetting bindings (event tags
# not reset).
#
# _FIXME_: This code is very slow (25 ms on denon): can it be
# improved?
#
# _FIXME_: Doesn't work with "current" tag
#
body ::tycho::Slate::bind {tagOrID {event 0} {command 0}} {
    # Deal with canvas items first
    # _FIXME_: Can this be better integrated?
    if { [string match {[0-9]*} $tagOrID] } {
	return [eval $canvas bind $tagOrID $event $command]
    }

    # Separate into object and tag parts.
    if { [isObject $tagOrID] } {
	set obj $tagOrID
	set tag [::info namespace tail $obj]
    } else {
	set obj ""
	set tag $tagOrID
    }

    # With just one arg, return the event and command
    if { $event == 0 } {
	return [$canvas bind $tag]
    }

    # With two args, return the bound commands
    if { $command == 0 } {
	return [$canvas bind $tag $event]
    }

    # From here on, treat four cases separately, according to whether
    # a) the binding is to a tag or an object, and b) whether the
    # command is blank (i.e. deleting a binding) or not.
    #
    if { $obj != "" && $command != 0 } {
	# Bind to an object. This means the picture is "self-bound."
	# If the picture is not marked, then mark it and set the event
	# tags to _$tag. If it is marked but doesn't have that
	
	# event tag, then add it.
	if { ! [$obj mark] } {
	    $obj mark 1
	    $obj etag set [list _$tag] -force
	} elseif { ! [lmember [$obj etag get] _$tag] } {
	    $obj etag add _$tag -force
	}

	# Bind the command to the event tag.
	$canvas bind _$tag $event $command


    } elseif { $obj != "" && $command == 0 } {
	# Remove a binding from an object. First remove the binding
	# for the specified sequence. Then, check if the event tag
	# has any other bindings; if not, remove it from the event
	# bindings.
	$canvas bind _$tag $event {}

	if { [$canvas bind _$tag] == "" } {
	    $obj etag delete _$tag -force

	    # If that was the last event tag, then the picture is
	    # no longer able to respond to events. So unmark it.
	    if { [$obj etag get] == "" } {
		$obj mark 0
	    }
	}

    } elseif { $obj == "" && $command != 0 } {
	# Bind to an tag. There are potentially a whole bunch
	# of pictures, so get the list of them.
	#
	if { [::info exists tagdict($tag)] } {
	    set pictures $tagdict($tag)
	} else {
	    set pictures {}
	}

	# For each picture, test if it is marked. If not, then mark it
	# and set its event tags to its user tags. (If it is already
	# marked, then all user tags will already have been propagated
	# to its active components, so there is no need to do anything.)
	foreach p $pictures {
	    if { ! [$p mark] } {
		$p mark 1
		$p etag set [$p cget -tags] -force
	    }
	}

	# Bind the command to the event and tag.
	$canvas bind $tag $event $command

    } elseif { $obj == "" && $command == 0 } {
	# Remove a binding from a tag. Firstly, find the pictures.
	$canvas bind $tag $event {}

	if { [::info exists tagdict($tagOrID)] } {
	    set pictures $tagdict($tagOrID)
	} else {
	    set pictures {}
	}

	# Now we have to check whether a picture needs to be
	# unmarked: check the bindings for each of its event
	# tags, and, if they are all empty, then there are no
	# bindings on that picture any more and the picture
	# must be unmarked and its event tags either cleared
	# (if the picture has no parent) or set to its parent's
	# event tags.
	foreach p $pictures {
	    set unmark 1
	    foreach t [$p etag get] {
		if { [$canvas bind $t] != "" } {
		    set unmark 0
		    break
		}
	    }
	    if { $unmark } {
		$p mark 0
		if { [$p parent] != "" } {
		    eval $p etag set [[$p parent] etag get] -force
		} else {
		    $p etag set {} -force
		}
	    }
	}
    }
}


#######################################################################
#### coords pict args
#
# Get or set the coordinates of an item or pict.
#
# <b>Note</b>: Unlike the canvas version, the first argument cannot
# be an arbitrary tag.
#
body ::tycho::Slate::coords {pict args} {
    if { [string match {[0-9]*} $pict] } {
	eval $canvas coords $pict $args
    } else {
	eval $pict coords $args
    }
}


#######################################################################
#### create class args
#
# Create a new pict of type _class_. If _class_ starts with
# a lower-case letter, then it is assumed to be the type
# of a canvas item; if not, it is assumed to be the type
# of a slate pict. In either case, _args_ is the coordinates
# and options used to create the picture.
#
body ::tycho::Slate::create {class args} {
    if { [string match {[a-z]*} $class] } {
	# Create a canvas item
	eval $canvas create $class $args

    } else {
	# Create a slate pict
	set pict [::info context]::[eval ::tycho::$class #auto \
		$myself $canvas $args]

	# The "primary" tag of the picture will be the last
	# part of its name. Get the tag and add an entry to
	# the pictdict so we can get the picture name later on.
	set pictdict([::info namespace tail $pict]) $pict

	# Return it
	return $pict
    }
}


#######################################################################
#### delete picts
#
# Delete one or more picts. If picts is the string "all" then
# delete all objects from the canvas, _including_ all
# interactors.
#
# _FIXME_: Doesn't work with "current" tag -- why would you do this anyway?
#
body ::tycho::Slate::delete {args} {
    # Expand tags to get list of pictures
    set picts {}
    foreach p $args {
	if { $p == "all" } {
	    set picts [$this find all]
	    break
	} elseif { [string match {[0-9]*} $p] } {
	    # Canvas item: just delete now
	    $canvas delete $p
	} elseif { ! [isObject $p] } {
	    set picts [concat $picts \
		    [$this roots [$this find withtag $p]]]
	} else {
	    lappend picts $p
	}
    }

    # Now delete each picture individually
    # 
    foreach p $picts {
	::delete object $p
	::unset pictdict([::info namespace tail $p])
    }
}


#######################################################################
#### deregisterTag
#
# Tell the slate a picture no longer has a given tag. For use by the
# Picture class only -- this is a private method, but the Picture
# class uses @scope to break protection. Think of it as a C++ ``friend.''
#
body ::tycho::Slate::deregisterTag {tag pict} {
    set tagdict($tag) [ldelete $tagdict($tag) $pict]
	
    if { $tagdict($tag) == "" } {
	unset tagdict($tag)
    }
}


#######################################################################
#### find all
#### find withtag     tag
#### find overlapping x0 x1 y0 y1
#### find enclosed    x0 x1 y0 y1
#
# Find a pict or picts, as given by _searchSpec_. The following argument
# formats are supported:
#
# <ul>
# <li><b>all</b>: Return every picture on the slate.
# <li><b>withtag</b> _tag_: Return every picture -- active or not --
# with the given tag.
# <li><b>overlapping</b> _x0 x1 y0 y1_: Return every _active_ picture
# that overlaps the given region.
# <li><b>enclosed</b> _x0 x1 y0 y1_: Return every _active_ picture
# enclosed by the given region.
# </ul>
#
# find{} will return pictures at multiple levels of the hierarchy
# if that's what it finds. To remove component pictures, use the method
# roots{}. In some cases, the top-level will need to be removed -- this can
# easily be done with ldelete{}.
#
# <b>Caveat</b>: This doesn't know anything about canvas items.
#
body ::tycho::Slate::find {searchSpec args} {
    set result {}
    switch -exact $searchSpec {
	"all" {
	    # Finding all picts requires returning the contents of the
	    # tag->picture dictionary.
	    set result {}
	    foreach t [array names pictdict] {
		lappend result $pictdict($t)
	    }
	    set result [eval concat $result]
	}

	"withtag" {
	    # Finding picts with a given tag depends on whether the tag
	    # is "current" or not. If it's current, then I have to query
	    # the canvas to find the current pict, since the current tag
	    # is dynamically altered by the canvas itself. If there
	    # is one, then return the active picture of that pict.
	    #
	    # If the tag is anything else, then just look up the tag
	    # dictionary to find pictures with that tag.
	    if { $args == "current" } {
		set current [$canvas find withtag current]
		if { $current != "" } {
		    set result [$pictdict([lindex \
			    [$canvas gettags $current] 0]) \
			    active]
		}
	    } else {
		if { [::info exists tagdict([lindex $args 0])] } {
		    set result $tagdict([lindex $args 0])
		} else {
		    set result {}
		}
	    }
	}

	"overlapping" {
	    # Finding overlapping picts is fairly simple. First, use the
	    # canvas to get overlapping canvas items. For each item, add
	    # its picture to the result list, but avoid duplicates,
	    set canvasItems [eval $canvas find overlapping $args]
	    foreach i $canvasItems {
		set p [$pictdict([lindex \
			    [$canvas gettags $i] 0]) \
			    active]
		if { ! [lmember $result $p] } {
		    lappend result $p
		}
	    }
	}

	"enclosed" {
	    # Finding enclosed picts is more difficult. For each canvas
	    # item, find the corresponding picture, and add it to
	    # the result list only if all of its elements are in the
	    # enclosed canvas items.
	    #
	    # This is not really quite what I want: I really want the
	    # subset test to include only the active picts in the picture...
	    #
	    # _FIXME_: This is broken.
	    set canvasItems [eval $canvas \
		    find overlapping $args]

	    foreach i $canvasItems {
		set p [$pictdict([lindex \
			    [$canvas gettags $i] 0]) \
			    active]
		if { ! [lmember $result $p] } {
		    if { [lsubset [$canvas find withtag $p] \
			    $canvasItems] } {
			lappend result $p
		    }
		}
	    }
	}
    }
    return $result
}


#######################################################################
#### gettags pict
#
# Get the tags of an item or a pict.
#
# <b>Note</b>: Unlike the canvas version, the first argument cannot
# be an arbitrary tag
#
body ::tycho::Slate::gettags {pict} {
    if { [string match {[0-9]*} pict] } {
	$canvas gettags $pict
    } else {
	$pict tag get
    }
}


#######################################################################
#### itemcget
#
body ::tycho::Slate::itemcget {pict option} {
    if { [string match {[0-9]*} $pict] } {
	eval $canvas itemcget $pict $option
    } else {
	eval $pict cget $option
    }
}


#######################################################################
#### itemconfigure
#
body ::tycho::Slate::itemconfigure {pict args} {
    if { [string match {[0-9]*} $pict] } {
	eval $canvas itemconfigure $pict $args
    } else {
	eval $pict configure $args
    }
}


#######################################################################
#### lower
#
# Lower the specified picture or item to the bottom of, or below
# a specified picture or tag in the display list.
#
body ::tycho::Slate::lower {tagOrID {belowThis b}} {
    eval $canvas lower $tagOrID $b
}


#######################################################################
#### move tagOrID x y
#
# Move one or more picts the specified amount. The first argument
# can either be a tag or a picture.
#
# _FIXME_: Constraint propagation with multiple items will be broken
#
# _FIXME_: Doesn't work with canvas items
#
body ::tycho::Slate::move {tagOrID x y} {

    if { [isObject $tagOrID] } {
	set pictures $tagOrID
    } elseif {$tagOrID == "all" } {
    	set pictures [$this roots [$this find all]]
    } else {
	set pictures [$this roots [$this find withtag $tagOrID]]
    }

    foreach p $pictures {
	eval $p move "direct" $x $y
    }
}


#######################################################################
#### raise
#
# Raise the specified pict or item to the top of, or above
# a specified picture or tag in the display list.
#
body ::tycho::Slate::raise {tagOrID {aboveThis a}} {
    eval $canvas raise $tagOrID $a
}


#######################################################################
#### registerTag
#
# Tell the slate a picture no longer has a given tag. For use by the
# Picture class only -- this is a private method, but the Picture
# class uses @scope to break protection. Think of it as a C++ ``friend.''
#
body ::tycho::Slate::registerTag {tag pict} {
    if { ! [::info exists tagdict($tag)] } {
	set tagdict($tag) [list $pict]
    } else {
	lappend tagdict($tag) $pict
    }
}


#######################################################################
#### roots
#
# Give a list of pictures, return only the root pictures in that list.
# This is useful in various kinds of `find' operations.
#
body ::tycho::Slate::roots {picts} {
    set result {}
    foreach p $picts {
	set ok 1
	foreach q [ldelete $picts $p] {
	    if { [$p ancestor $q] } {
		set ok 0
		break
	    }
	}
	if { $ok } {
	    lappend result $p
	}
    }
    return $result
}
