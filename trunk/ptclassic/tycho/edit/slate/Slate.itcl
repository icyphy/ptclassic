##########################################################################
# Version: $Id$
# Author: H. John Reekie
#
# Copyright (c) %Q% The Regents of the University of California.
# All rights reserved.
# 
# Permission is hereby granted, without written agreement and without
# license or royalty fees, to use, copy, modify, and distribute this
# software and its documentation for any purpose, provided that the above
# copyright notice and the following two paragraphs appear in all copies
# of this software.
# 
# IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY
# FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
# ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF
# THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.
# 
# THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE
# PROVIDED HEREUNDER IS ON AN "AS IS" BASIS, AND THE UNIVERSITY OF
# CALIFORNIA HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,
# ENHANCEMENTS, OR MODIFICATIONS.
#                                                         COPYRIGHTENDKEY
##########################################################################


## README
#
# This is the primary interface to the Slate widget, and the whole
# of the Visual Language Toolkit. Sooner or later, large parts of
# the VL Toolkit will be recoded in "something else." When that happens,
# the picture classes will no longer be directly accessible. To
# ensure future compatibility, use the slate interface to the
# picture classes _only_. There will be, of course, some speed
# penalty, but not that much considering what you have to pay anyway...
#
# This is, of course, also the reason why some of the methods on
# the slate seem just like useless wrappers around picture methods --
# the picture methods will cease to exist one day.
#

## README TOO
#
# The slate is in the process of being modified to accept canvas
# items IDs as well as object identifiers. This complicates most
# methods, but is necessary to make the slate an acceptable
# alternative in situations where the overhead of itcl objects
# is not worth the gains in flexibility.
#

## slate pathName args
#
# A procedure to create a new widget, as recommended on the
# itk web pages. This turns out to be useful to have anyway,
# since we need to muck about with the binding order for the
# widget, and itk doesn't seem to like having $this referenced
# in the constructor...
#
proc ::tycho::slate {pathName args} {
    #
    # Create the widget
    #
    uplevel ::tycho::Slate $pathName $args

    #
    # Now muck about with the bindings in order to
    # make events on the canvas appear to be on the mega-widget.
    # This simply sets the bindtags for the canvas to be the
    # the same as those for the megawidget, effectively removing
    # the canvas itself from the event chain. It has the side-effect
    # of causing some events to occur twice, but so far this appears
    # to happen only with Enter and Leave events.
    #
    bindtags [$pathName component canvas] [concat \
	    [list lhead [bindtags [$pathName component canvas]]] \
	    [ltail [bindtags $pathName]]]

    return $pathName
}



#######################################################################
#### Slate
#
# A canvas mega-widget. The slate supports complex
# canvas items, moving and dragging, connection between objects,
# and constraints.
#
class ::tycho::Slate {
    inherit itk::Widget

    constructor {args} {}
    destructor {}


    ###################################################################
    ## Methods dealing with pictures

    method addtag   {tag searchSpec args} {}
    method bbox     {args}                {}
    method bind     {tagOrID args}        {}
    method coords   {pict args}           {}
    method create   {class args}          {}
    method delete   {args}                {}
    method deform   {x y args}            {}
    method find     {searchSpec args}     {}
    method gettags  {pict}                {}
    method lower    {tagOrID args}        {}
    method move     {tagOrID x y}         {}
    method raise    {tagOrID args}        {}
    method roots    {picts}               {}


    ###################################################################
    ## Thin wrappers around canvas operations

    method postscript {args} {
	eval $itk_component(canvas) postscript $args
    }

    method xview {args} {
	eval $itk_component(canvas) xview $args
    }

    method yview {args} {
	eval $itk_component(canvas) yview $args
    }



    ###################################################################
    ## Restricted access

    ## myself
    #
    # An alternative to "this", which doesn't put a :: in front...
    #
    protected variable myself ""


    ## slatePictures
    #
    # A list of all pictures created on the slate. This may need to be
    # modified in future to record only top-level pictures (?).
    #
#    private variable slatePictures {}


    ## itemdict
    #
    # The mapping from canvas items to pictures.
    #
#    private variable itemdict


    ## pictdict
    #
    # The mapping from the primary canvas tag to the corresponding
    # picture.
    #
    private variable pictdict


    ## tagdict
    #
    # The mapping from tags to pictures.
    #
    private variable tagdict


    ## registerItem  pict item
    ## registerItems pict items
    #
    # Register a picture with one or more items. For use by the
    # Primitive class only.
    #
    # -- pict: The picture object to set as the owner of the items.
    # -- item: A single canvas item.
    # -- items: A list of canvas items.
    #
#     method registerItem {pict item} {
# 	set itemdict($item) $pict
#     }

#     method registerItems {pict items} {
# 	foreach i $items {
# 	    set itemdict($i) $pict
# 	}
#     }


    ## deregisterItem  item
    ## deregisterItems items
    #
    # Cancel the registration of a picture with an item.
    # For use by the Primitive class only.
    #
    # -- item: A single canvas item.
    # -- items: A list of canvas items.
    #
#     method deregisterItem {item} {
# 	unset itemdict($item)
#     }

#     method deregisterItems {items} {
# 	foreach i $items {
# 	    unset itemdict($i)
# 	}
#     }


    ## registerTag tag pict
    #
    # Register a tag as belonging to a picture. For use by the
    # Picture class only.
    #
    # -- tag: The tag we're adding.
    # -- pict: A picture to tag.
    #
    method registerTag {tag pict} {
	if { ! [info exists tagdict($tag)] } {
	    set tagdict($tag) [list $pict]
	} else {
	    lappend tagdict($tag) $pict
	}
    }


    ## deregisterTag tag pict
    #
    # Cancel the registration of tags to pictures.
    # For use by the Picture class only.
    #
    # -- tag: The tag we're adding.
    # -- pict: A picture to tag.
    #
    method deregisterTag {tag pict} {
	set tagdict($tag) [ldelete $tagdict($tag) $pict]
	
	if { $tagdict($tag) == "" } {
	    unset tagdict($tag)
	}
    }
}


## addtag tag all
## addtag tag withtag     tag
## addtag tag overlapping x0 x1 y0 y1
## addtag tag enclosed    x0 x1 y0 y1
#
# Add a tag to picts. The searchSpec and args is the same
# as for the find{} method.
#
# FIXME: Doesn't work with canvas item IDs
#
body ::tycho::Slate::addtag {tag searchSpec args} {
    foreach i [eval $this find $searchSpec $args] {
	$i addtag $tag
    }
}


## bbox {pictOrTag}+
#
# Return the bounding box of any number of picts. Each argument
# can be a picture ID or a tag.
#
# Returns the bounding box as a four-list. If there are no pictures
# matching the tags, return the null string. (This behavior matches
# that of the canvas). The caller must therefore check the result if
# calling this method with tags.
#
# FIXME: Doesn't work with "current" tag
#
body ::tycho::Slate::bbox {args} {
    set picts {}
    foreach p $args {
	if { $p == "all" } {
	    set picts $slatePictures
	    break
	} elseif { [isNumber $p] } {
	    lappend picts $p
	} elseif { [isObject $p] } {
	    lappend picts $p
	} else {
	    # FIXME: Remove redundant pictures (children)
	    lappend picts $tagdict($p)
	}
    }
    
    # Flatten the picture list. If empty, return null string
    set picts [eval concat $picts]
    if { $picts == "" } {
	return ""
    } else {
	return [eval $itk_component(canvas) bbox $picts]
    }
}


## bind tagOrID [event [command]]
#
# Bind a command to an object or to all objects with a given tag.
#
# -- tagOrID: A valid pict ID, canvas item ID, or any string
#    that represents a possible tag.
#
# -- event: If present, is the mouse event to be queried or to which
#    a command is bound. If not present, then this method returns
#    events for which there are bindings.
#
# -- command: If present, the command to bind to the object or tag.
#    If not present, then return the binding(s) for the object or tag.
#
# Caveat: The bind command is not properly developed yet. There are
# some interactions with canvas bindings, multiple bindings on the
# same tag/object, and hierarchical pictures that need to be
# explored and clarified.
#
# FIXME: Doesn't work properly if resetting bindings (event tags
# not reset).
#
# FIXME: This code is very slow (25 ms on denon): can it be
# improved?
#
# FIXME: Doesn't work with "current" tag
#
body ::tycho::Slate::bind {tagOrID {event void} {command void}} {
puts "Slate::bind $tagOrID $event $command"

    # Deal with canvas items first
    # FIXME: Can this be better integrated?
    if { [string match {[0-9]*} $tagOrID] } {
	return [eval $itk_component(canvas) bind $tagOrID $event $command]
    }

    # Separate into object and tag parts.
    if { [isObject $tagOrID] } {
	set obj $tagOrID
	set tag [lindex [split $obj ":"] end]
    } else {
	set obj ""
	set tag $tagOrID
    }

    # With just one arg, return the event and command
    if { $event == void } {
	return [$itk_component(canvas) bind $tag]
    }

    # With two args, return the bound commands
    if { $command == void } {
	return [$itk_component(canvas) bind $tag $event]
    }

    # From here on, treat four cases separately, according to whether
    # a) the binding is to a tag or an object, and b) whether the
    # command is blank (i.e. deleting a binding) or not.
    #
    if { $obj != "" && $command != void } {
puts "Bind to an object"
	# Bind to an object. This means the picture is "self-bound."
	# If the picture is not marked, then mark it and set the event
	# tags to _$tag. If it is marked but doesn't have that
	# event tag, then add it.
	if { [$obj cget -mark] == void } {
	    $obj configure -mark 1
	    $obj _etag set [list _$tag] -force
	} elseif { ! [lmember [$obj _etag get] _$tag] } {
	    $obj _etag add _$tag -force
	}

	# Bind the command to the event tag.
	$itk_component(canvas) bind _$tag $event $command


    } elseif { $obj != "" && $command == void } {
puts "Unbind from an object"
	# Remove a binding from an object. First remove the binding
	# for the specified sequence. Then, check if the event tag
	# has any other bindings; if not, remove it from the event
	# bindings.
	$itk_component(canvas) bind _$tag $event {}

	if { [$itk_component(canvas) bind _$tag] == "" } {
	    $obj _etag delete _$tag -force

	    # If that was the last event tag, then the picture is
	    # no longer able to respond to events. So unmark it.
	    if { [$obj _etag get] == "" } {
		$obj configure -mark ""
	    }
	}

    } elseif { $obj == "" && $command != void } {
	# Bind to an tag. There are potentially a whole bunch
	# of pictures, so get the list of them.
	#
	if { [info exists tagdict($tag)] } {
	    set pictures $tagdict($tag)
	} else {
	    set pictures {}
	}

	# For each picture, test if it is marked. If not, then mark it
	# and set its event tags to its user tags. (If it is already
	# marked, then all user tags will already have been propagated
	# to its active components, so there is no need to do anything.)
	foreach p $pictures {
	    if { [$p cget -mark] == "" } {
		$p configure -mark 1
		$p _etag set [$p cget -tags] -force
	    }
	}

	# Bind the command to the event and tag.
	$itk_component(canvas) bind $tag $event $command

    } elseif { $obj == "" && $command == void } {
	# Remove a binding from a tag. Firstly, find the pictures.
	$itk_component(canvas) bind $tag $event {}

	if { [info exists tagdict($tagOrID)] } {
	    set pictures $tagdict($tagOrID)
	} else {
	    set pictures {}
	}

	# Now we have to check whether a picture needs to be
	# unmarked: check the bindings for each of its event
	# tags, and, if they are all empty, then there are no
	# bindings on that picture any more and the picture
	# must be unmarked and its event tags either cleared
	# (if the picture has no parent) or set to its parent's
	# event tags.
	foreach p $pictures {
	    set unmark 1
	    foreach t [$p _etag get] {
		if { [$itk_component(canvas) bind $t] != "" } {
		    set unmark 0
		    break
		}
	    }
	    if { $unmark } {
		$p configure -mark ""
		if { [$p parent] != "" } {
		    eval $p _etag set [[$p parent] _etag get] -force
		} else {
		    $p _etag set {} -force
		}
	    }
	}
    }
}


## constructor
#
body ::tycho::Slate::constructor {args} {

    # Create the canvas and pack it
    itk_component add canvas {
	canvas $itk_interior.canvas
    } {
	keep -background -cursor -relief \
		-height -width -borderwidth \
		-xscrollcommand -yscrollcommand \
		-scrollregion
    }
    pack $itk_component(canvas) -fill both -expand yes

    # Set up the "myself" variable for later use in create{}.
    set myself [string trimleft $this ":"]

    # Initialise options
    eval itk_initialize $args
}


## coords pict args
#
# Get or set the coordinates of an item or pict.
#
# NOTE: Unlike the canvas version, the first argument cannot
# be an arbitrary tag
#
body ::tycho::Slate::coords {pict args} {
    if { [string match {[0-9]*} $pict] } {
	eval $itk_component(canvas) coords $pict $args
    } else {
	eval $pict coords $args
    }
}


## create class args
#
# Create a new picture of type _class_. If _class_ starts with
# a lower-case letter, then it is assumed to be the type
# of a canvas item; if not, it is assumed to be the type
# of a slate pict. In either case, _args_ is the coordinates
# and options used to create the picture.
#
body ::tycho::Slate::create {class args} {
    if { [string match {[a-z]*} $class] } {
	# Create a canvas item
	eval $itk_component(canvas) create $class $args

    } else {
	# Create a slate pict
	set pict [info context]::[eval ::tycho::$class #auto \
		$myself $itk_component(canvas) $args]

	# The "primary" tag of the picture will be the last
	# part of its name. Get the tag and add an entry to
	# the pictdict to we can get the picture name later on.
	set pictdict([lindex [split $pict ":"] end]) $pict

	# Return it
	return $pict
    }
}


## delete picts
#
# Delete one or more picts. If picts is the string "all" then
# delete all objects from the canvas, _including_ all
# interactors.
#
# FIXME: Doesn't work with canvas item IDs
# FIXME: Doesn't work with "current" tag
#
body ::tycho::Slate::delete {args} {
    # Expand tags to get list of pictures
    set picts {}
    foreach p $args {
	if { $p == "all" } {
	    set picts [$this find all]
	    break
	} elseif { ! [isObject $p] } {
	    set picts [concat $picts \
		    [$this roots [$this find withtag $p]]]
	} else {
	    lappend picts $p
	}
    }

    # Now delete each picture individually
    # 
    foreach p $picts {
	::delete object $p
	::unset pictdict([lindex [split $p ":"] end])
    }
}


## find all
## find withtag     tag
## find overlapping x0 x1 y0 y1
## find enclosed    x0 x1 y0 y1
#
# Find an pict or picts given by the searchSpec. The picts returned are
# always the top-most active pict: lower-level picts are not returned
# if it makes sense for a higher-level one to be returned.
#
# Note that find{} will return pictures at multiple levels of the hierarchy
# is that's what it finds! To remove component pictures, use the method
# roots{}. In some cases, the top-elvel will need to be removed -- this can
# easily be done with ldelete{}.
#
# FIXME: Doesn't work with canvas item IDs
# FIXME: BROKEN!
#
body ::tycho::Slate::find {searchSpec args} {
    set result {}
    switch -exact $searchSpec {
	"all" {
	    # Finding all picts requires returning the contents of the
	    # tag->picture dictionary.
	    set result {}
	    foreach t [array names pictdict] {
		lappend result $pictdict($t)
	    }
	    set result [eval concat $result]
	}

	"withtag" {
	    # Finding picts with a given tag depends on whether the tag
	    # is "current" or not. If it's current, then I have to query
	    # the canvas to find the current pict, since the current tag
	    # is dynamically altered by the canvas itself. If there
	    # is one, then return the active picture of that pict.
	    #
	    # If the tag is anything else, then just look up the tag
	    # dictionary to find pictures with that tag.
	    if { $args == "current" } {
		set current [$itk_component(canvas) find withtag current]
		if { $current != "" } {
		    set result [$pictdict([lindex \
			    [$itk_component(canvas) gettags $current] 0]) \
			    active]
		}
	    } else {
		if { [info exists tagdict([lindex $args 0])] } {
		    set result $tagdict([lindex $args 0])
		} else {
		    set result {}
		}
	    }
	}

	"overlapping" {
	    #
	    # Finding overlapping picts is fairly simple. First, use the
	    # canvas to get overlapping canvas items. For each item, add
	    # its picture to the result list, but avoid duplicates,
	    #
	    set canvasItems [eval $itk_component(canvas) \
		    find overlapping $args]

	    foreach i $canvasItems {
		set p [$pictdict([lindex \
			    [$itk_component(canvas) gettags $i] 0]) \
			    active]
		if { ! [lmember $result $p] } {
		    lappend result $p
		}
	    }
	}

	"enclosed" {
	    #
	    # Finding enclosed picts is more difficult. For each canvas
	    # item, find the corresponding picture, and add it to
	    # the result list only if all of its elements are in the
	    # enclosed canvas items.
	    #
	    # This is not really quite what I want: I really want the
	    # subset test to include only the active picts in the picture...
	    #
	    # FIXME: This is broken.
	    #
	    set canvasItems [eval $itk_component(canvas) \
		    find overlapping $args]

	    foreach i $canvasItems {
		set p [$pictdict([lindex \
			    [$itk_component(canvas) gettags $i] 0]) \
			    active]
		if { ! [lmember $result $p] } {
		    if { [lsubset [$itk_component(canvas) find withtag $p] \
			    $canvasItems] } {
			lappend result $p
		    }
		}
	    }
	}
    }
    return $result
}


## gettags pict
#
# Get the tags of an item or a pict.
#
# NOTE: Unlike the canvas version, the first argument cannot
# be an arbitrary tag
#
body ::tycho::Slate::gettags {pict} {
    if { [string match {[0-9]*} pict] } {
	$itk_component(canvas) gettags $pict
    } else {
	$pict tag get
    }
}


## lower tagOrID {belowThis}
#
# Lower the specified picture or item picture to the bottom, or below
# a specified picture or tag in the display list.
#
# -- tagOrID: The item to lower. This can be a slate picture,
#    a raw canvas item, or a tag.
#
# -- belowThis: If specified, the item or tag above which the picture
#    is raised.
#
body ::tycho::Slate::lower {tagOrID args} {
    eval $itk_component(canvas) lower $tagOrID $args
}


## move tagOrID x y
#
# Move one or more picts the specified amount. The first argument
# can either be a tag or a picture.
#
# NOTE: To access the "modal" move commands (click, drag, release),
# the pictures must be called directly.
#
# FIXME: Constraint propagation with multiple items will be broken...
#
# FIXME: Doesn't work with canvas item IDs
# FIXME: Doesn't work with "current" tag
# FIXME: Doesn't work with "all" tag
#
body ::tycho::Slate::move {tagOrID x y} {

    if { [isObject $tagOrID] } {
	set pictures $tagOrID
    } else {
	set pictures [$this roots [$this find withtag $tagOrID]]
    }

    foreach p $pictures {
	eval $p move "direct" $x $y
    }
}


## raise tagOrID {aboveThis}
#
# Raise the specified picture or item picture to the top, or above
# a specified picture or tag in the display list.
#
# -- item: The item to raise. This can be a slate picture,
#    a raw canvas item, or a tag.
#
# -- aboveThis: If specified, the item or tag above which the picture
#    is raised.
#
body ::tycho::Slate::raise {tagOrID args} {
    eval $itk_component(canvas) raise $tagOrID $args
}


## roots {pict}+
#
# Give a list of pictures, return only the root pictures in that list.
# This is useful in various kinds of `find' operations.
#
body ::tycho::Slate::roots {picts} {
    set result {}
    foreach p $picts {
	set ok 1
	foreach q [ldelete $picts $p] {
	    if { [$p ancestor $q] } {
		set ok 0
		break
	    }
	}
	if { $ok } {
	    lappend result $p
	}
    }
    return $result
}
