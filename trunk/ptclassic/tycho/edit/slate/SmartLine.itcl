#########################################################################
# @Version: $Id$
# @Author: H. John Reekie
#
# @Copyright (c) 1996-%Q% The Regents of the University of California.
# All rights reserved.
# 
# Permission is hereby granted, without written agreement and without
# license or royalty fees, to use, copy, modify, and distribute this
# software and its documentation for any purpose, provided that the
# above copyright notice and the following two paragraphs appear in all
# copies of this software.
# 
# IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY
# FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
# ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF
# THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.
# 
# THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE
# PROVIDED HEREUNDER IS ON AN "AS IS" BASIS, AND THE UNIVERSITY OF
# CALIFORNIA HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,
# ENHANCEMENTS, OR MODIFICATIONS.
# 
# 						PT_COPYRIGHT_VERSION_2
# 						COPYRIGHTENDKEY
##########################################################################


# Explicitly load the superclass. I don't really know why this is
# needed, but the common arrays get upset otherwise.
namespace ::tycho {
    if { [::info classes ComplexItem] == "" } {
	uplevel #0 {source $tychoslate/ComplexItem.itcl}
    }
}

##########################################################################
## SmartLine
#
# A line item that understands how to place itself given its start and end
# points and their directions. The directions are specified as compass
# directions: "n", "s", "e", or "w". Although there are presently
# no facilities for user adjustment of line placement, this class
# has been designed to support this extension.
#
# When a line is drawn, it is first rotated so that its start is in
# the "east" direction. Lines with the end pointing "north" are
# flipped about the horizontal axis so that there are three types
# of line (going by the direction of the end point): "east," "west,"
# and "south." Each of these has a number of different shapes, depending
# on the relative positions of the start and end points; each shape
# is represented by a state of a finite-state machine. Each shape is
# such that it can be drawn with no conditionals (and is therefore
# as efficient as possible to generate). Transitions
# between states occur when the _x_ or _y_ coordinates (of the end-point,
# relative to the start point) meets some condition that requires
# a different line shape. If _x_ or _y_ changes, the line may go through
# several states before reaching an acceptable one -- this makes the
# transitions simple to code. When a new line is created, it starts in
# state 0, and may pass through several states before settling on an
# acceptable line shape.
#
# <p><b>Options</b>:
#
# <ul>
# <li><b>-alpha</b>:
# The minimum distance from an end-point of a line
# to the first vertex.
#
# <li><b>-arrow</b>:
# The location of the arrow-head on the line: can be
# one of <i>none</i>, <i>first</i>, <i>last</i>, or <i>both</i>. 
# <i>none</i> by default.
#
# <li><b>-beta</b>:
# The preferred distance between vertices that "wrap" back
# in the opposite direction.
#
# <li><b>-end</b>:
# The direction of the line end-point. Can be one of the
# four major compass points: <i>n</i>, <i>s</i>, <i>e</i>, or <i>w</i>. It is
# <i>e</i> by default.
#
# <li><b>-fill</b>:
# The color of the line. Black by default.
#
# <li><b>-smooth</b>:
# The flag controlling whether the line is
# drawn with curves instead of straight segments. Off by default.
#
# <li><b>-start</b>:
# The direction of the line start-point. Can be one of the
# four major compass points: <i>n</i>, <i>s</i>, <i>e</i>, or <i>w</i>. It is
# <i>e</i> by default.
#
# <li><b>-state</b>:
# The current "state" of the line. This is provided to make it possible to
# duplicate lines, since a line between two given points may be drawn
# in different ways.
#
# <li><b>-width</b>:
# The width of the line.
#
# </ul>
#
# <p><b>Components</b>
#
# <ul>
# <li><b>segments</b>:
# The visible line.
# </ul>
#
# <b>Bugs</b>: (none)
# 
# <b>Enhancements</b>
#
# SmartLine needs to support "manual" 
# dragging of line segments and vertices.
#
#  <P><b>Example</b>
#
#  <P>Create a smart line and an object for moving it around
# (this is an example of how to implement a simple kind of
# constraint using interactors and the slate -- some support
# for this will be built into the interactors in the near future):
# <tcl quiet><pre>
#   source $tycho/editors/slate/doc/internals/newslate.itcl
#   proc mv {mode id x y args} {
#       global d l slate
#       $slate move$mode $d $x $y
#       $slate reshape$mode $l $x $y end
#   }
#   $follower configure &#92
#           -clickprefix "mv click" &#92
#           -dragprefix "mv drag" &#92
#           -releaseprefix "mv release"
#   set l [$slate create SmartLine 150 120 200 200 -arrow last]
#   set d [$slate create Solid 200 200 210 190 220 200 210 210 &#92
#   		-color green -tags moveable]
# </pre></tcl>
#
# Move the diamond around to see the different line shapes.
# Change the direction of the end of the line: "w":
# <tcl quiet><pre>
#   eval $slate reshapeto $l [$slate aspect $d vertex-2] end
#   $slate itemconfigure $l -end w
# </pre></tcl>
#
# Change the direction of the end of the line: "s":
# <tcl quiet><pre>
#   eval $slate reshapeto $l [$slate aspect $d vertex-1] end
#   $slate itemconfigure $l -end s
# </pre></tcl>
#
# Change the direction of the end of the line: "n":
# <tcl quiet><pre>
#   eval $slate reshapeto $l [$slate aspect $d vertex-3] end
#   $slate itemconfigure $l -end n
# </pre></tcl>
#
# Change the direction of the end of the line: "e":
# <tcl quiet><pre>
#   eval $slate reshapeto $l [$slate aspect $d vertex-0] end
#   $slate itemconfigure $l -end e
# </pre></tcl>
#
class ::tycho::SmartLine {
    inherit ::tycho::ComplexItem

    ###################################################################
    ####                         public procs                      ####

    # Update the *-alpha* option
    proc _alpha {id canvas slate alpha}

    # Update the *-arrow* option
    proc _arrow {id canvas slate arrow}

    # Update the *-beta* option
    proc _beta {id canvas slate beta}

    # Update the *-end* option
    proc _end {id canvas slate end}

    # Update the *-fill* option
    proc _fill {id canvas slate fill}

    # Update the *-smooth* option
    proc _smooth {id canvas slate smooth}

    # Update the *-start* option
    proc _start {id canvas slate start}

    # Update the *-state* option
    proc _state {id canvas slate start}

    # Update the *-width* option
    proc _width {id canvas slate width}

    # Create a new item
    proc construct {id canvas slate tags x0 y0 x1 y1 args}

    # Set or get the lines's coordinates
    proc coords {id canvas slate args}

    ###################################################################
    ####                         protected variables               ####

    # SmartLines are shaped like... lines
    protected common shape "line"

    ###################################################################
    ####                         private variables                 ####

    # The virtual "method" table
    private common methodtable

    # Default values of this item's options
    private common optiondefault

    ###################################################################
    ####                        private procs                      ####

    # Figure out the next state
    proc nextstate {id type state x y}

    # Redraw the line
    proc redraw {id canvas slate}

    # Auto-route an "east" line
    proc route_e {id state x y}

    # Auto-route a "west" line
    proc route_w {id state x y}

    # Auto-route a "south" line
    proc route_s {id state x y}

    ###################################################################
    ####                      private variables                    ####

    # An array saying how to rotate a line endpoint
    private common rotate
    array set rotate {
	n-n e n-s w n-e s n-w n
	s-n w s-s e s-e n s-w s
	e-n n e-s s e-e e e-w w
	w-n s w-s n w-e w w-w e
    }

    # An array saying how to normalize a line
    private common normalize
    array set normalize {
	n {[expr -($y)] $x}
	s {$y [expr -($x)]}
	e {$x $y}
	w {[expr -$x] $y}
    }

    # An array saying how to "un-normalize" a line
    private common unnormalize
    array set unnormalize {
	n {$y [expr -($x)]}
	s {[expr -($y)] $x}
	e {$x $y}
	w {[expr -$x] $y}
    }

    # An array of next states. Each entry is a list of expression-
    # nextstate pairs. The expression is evaluated inside the
    # nextstate{} method, and if satisfied, the state is changed
    private common transitions
    array set transitions {
	"e,0" {
	    {$x < $a} "7"
	    {$y < 0}  "1"
	    {$y > 0}  "2"
	}
	"e,1" {
	    {$x < 2*$a} "3"
	    {$y >= 0}   "0"
	}
	"e,2" {
	    {$x < 2*$a} "4"
	    {$y <= 0}   "0"
	}
	"e,3" {
	    {$x >  2*$a} "1"
	    {$y > -2*$b} "5"
	}
	"e,4" {
	    {$x > 2*$a} "2"
	    {$y < 2*$b} "6"
	}   
	"e,5" {
	    {$x >  2*($a-$b)} "7"
	    {$y < -2*$b}      "3"
	    {$y > 0}          "9"
	}
	"e,6" {
	    {$x > 2*($a-$b)}  "8"
	    {$y > 2*$b}       "4"
	    {$y < 0}          "10"
	}
	"e,7" {
	    {$x <  2*($a-$b)} "5"
	    {$x >  2*$a}      "1"
	    {$y < -2*$b}      "3"
	    {$y > 0}          "11"
	}
	"e,8" {
	    {$x < 2*($a-$b)} "6"
	    {$x > 2*$a}      "2"
	    {$y > 2*$b}      "4"
	    {$y < 0}         "11"
	}
	"e,9" {
	    {$x > 2*($a-$b)} "11"
	    {$y < 0}         "5"
	    {$y > 2*$b}      "4"
	}
	"e,10" {
	    {$x >  2*($a-$b)} "12"
	    {$y < -2*$b}      "3"
	    {$y > 0}          "6"
	}
	"e,11" {
	    {$x <  2*($a-$b)} "9"
	    {$x >  2*$a}      "2"
	    {$y >  2*$b}      "4"
	    {$y <  0}         "7"
	}
	"e,12" {
	    {$x <  2*($a-$b)} "10"
	    {$x >  2*$a}      "1"
	    {$y < -2*$b}      "3"
	    {$y >  0}         "8"
	}
	"w,0" {
	    {$x < 0}  "2"
	    {$y < $b} "10"
	}
	"w,1" {
	    {$x < 0}   "3"
	    {$y > -$b} "11"
	}
	"w,2" {
	    {$x > 0}  "0"
	    {$y < $b} "4"
	}
	"w,3" {
	    {$x > 0}   "1"
	    {$y > -$b} "5"
	}
	"w,4" {
	    {$x > -2*$a} "6"
	    {$y < -$b}   "3"
	    {$y > $b}    "2"
	}
	"w,5" {
	    {$x > -2*$a} "7"
	    {$y < -$b}   "3"
	    {$y > $b}    "2"
	}
	"w,6" {
	    {$x < -2*$a} "4"
	    {$x > 0}     "8"
	    {$y < 0}     "7"
	}
	"w,7" {
	    {$x < -2*$a} "5"
	    {$x > 0}     "9"
	    {$y > 0}     "6"
	}
	"w,8" {
	    {$x < 0}    "6"
	    {$x > 2*$a} "10"
	    {$y < 0}    "9"
	}
	"w,9" {
	    {$x < 0}    "7"
	    {$x > 2*$a} "11"
	    {$y > 0}    "8"
	}
	"w,10" {
	    {$x < 2*$a} "8"
	    {$y < -$b}  "1"
	    {$y > $b}   "0"
	}
	"w,11" {
	    {$x < 2*$a} "9"
	    {$y < -$b}  "1"
	    {$y > $b}   "0"
	}
	"s,0" {
	    {$x < $a} "5"
	    {$y < $a} "1"
	}
	"s,1" {
	    {$x < $a+$b} "2"
	    {$y > $a}    "0"
	}
	"s,2" {
	    {$x < $a-$b} "3"
	    {$x > $a+$b} "1"
	    {$y > $a-$b} "6"
	}
	"s,3" {
	    {$x > $a-$b} "2"
	    {$y > $a-$b} "4"
	}
	"s,4" {
	    {$x > $a-$b} "6"
	    {$y < $a-$b} "3"
	    {$y > $a+$b} "5"
	}
	"s,5" {
	    {$x > $a}    "0"
	    {$y < $a+$b} "4"
	}
	"s,6" {
	    {$x < $a-$b} "4"
	    {$x > $a+$b} "1"
	    {$y < $a-$b} "2"
	    {$y > $a && $x > $a} "0"
	    {$y > $a+$b} "5"
	}
    }

    ###################################################################
    ####                       class initialization                ####

    #### Set method table
    array set methodtable [array get ::tycho::ComplexItem::methodtable]

    set methodtable(_alpha)	::tycho::SmartLine::_alpha
    set methodtable(_arrow)	::tycho::SmartLine::_arrow
    set methodtable(_beta)	::tycho::SmartLine::_beta
    set methodtable(_end)	::tycho::SmartLine::_end
    set methodtable(_fill)      ::tycho::SmartLine::_fill
    set methodtable(_smooth)	::tycho::SmartLine::_smooth
    set methodtable(_start)	::tycho::SmartLine::_start

    set methodtable(construct)  ::tycho::SmartLine::construct
    set methodtable(coords)     ::tycho::SmartLine::coords

    #### Set option defaults
    array set optiondefault [array get ::tycho::ComplexItem::optiondefault]

    set optiondefault(-alpha)	  12
    set optiondefault(-arrow)     last
    set optiondefault(-beta)	  30
    set optiondefault(-end)	  "e"
    set optiondefault(-fill)	  black
    set optiondefault(-smooth)    off
    set optiondefault(-start) 	  "e"
    set optiondefault(-state) 	  0
    set optiondefault(-width) 	  1
}


##########################################################################
## -alpha option configuration
#
body ::tycho::SmartLine::_alpha {id canvas slate alpha} {
    set option(alpha$id) $alpha
    redraw $id $canvas $slate
}

##########################################################################
## -arrow option configuration
#
body ::tycho::SmartLine::_arrow {id canvas slate arrow} {
    set option(arrow$id) $arrow
    $canvas itemconfigure $component(segments$id) -arrow $arrow
}

##########################################################################
## -beta option configuration
#
body ::tycho::SmartLine::_beta {id canvas slate beta} {
    set option(beta$id) $beta
    redraw $id $canvas $slate
}

##########################################################################
## -end option configuration
#
body ::tycho::SmartLine::_end {id canvas slate end} {
    set option(end$id) $end
    redraw $id $canvas $slate
}

##########################################################################
## -fill option configuration
#
body ::tycho::SmartLine::_fill {id canvas slate fill} {
    set option(fill$id) $fill
    $canvas itemconfigure $component(segments$id) -fill $fill
}

##########################################################################
## -smooth option configuration
#
body ::tycho::SmartLine::_smooth {id canvas slate smooth} {
    set option(smooth$id) $smooth
    $canvas itemconfigure $component(segments$id) -smooth $smooth
}

##########################################################################
## -start option configuration
#
body ::tycho::SmartLine::_start {id canvas slate start} {
    set option(start$id) $start
    redraw $id $canvas $slate
}

##########################################################################
## -state option configuration
#
body ::tycho::SmartLine::_state {id canvas slate state} {
    set option(state$id) $state
    redraw $id $canvas $slate
}

##########################################################################
## -width option configuration
#
body ::tycho::SmartLine::_width {id canvas slate width} {
    set option(width$id) $width
    $canvas itemconfigure $primary($id) -width $option(width$id)
}

##########################################################################
#### construct
#
body ::tycho::SmartLine::construct {id canvas slate tags x0 y0 x1 y1 args} {
    # Initialize the options
    foreach {opt val} [concat [array get optiondefault] $args] {
	set option([string trimleft $opt -]$id) $val
    }

    # Create the primary component for the outline coordinates.
    # This is a transparent line.
    set primary($id) [$canvas create line $x0 $y0 $x1 $y1 \
	    -fill "" -tags $tags]

    # Create the "segments" component which is the visible line.
    set component(segments$id) [$canvas create line $x0 $y0 $x1 $y1 \
	    -fill $option(fill$id) -arrow $option(arrow$id) -tags $tags \
	    -width $option(width$id)]

    # Call redraw to do the work
    redraw $id $canvas $slate
}

##########################################################################
#### coords
#
# Set or read the SmartLine's coordinates
#
body ::tycho::SmartLine::coords {id canvas slate args} {
    # No args: just return coordinates
    if { $args == "" } {
	return [$canvas coords $primary($id)]
    }

    # Move the primary
    set coords $args
    eval $canvas coords $primary($id) $coords

    # Call redraw to do the work
    redraw $id $canvas $slate
}


##################################################################
##################################################################
####                       private procs                      ####

##########################################################################
#### redraw
#
# Redraw the line.
#
body ::tycho::SmartLine::redraw {id canvas slate} {
    set flipped 0
    
    # Get the coordinates
    ::tycho::assign x0 y0 x1 y1 [$canvas coords $primary($id)]

    # "Normalize" the line
    set x [expr $x1-$x0]
    set y [expr $y1-$y0]

    set type $rotate($option(start$id)-$option(end$id))
    ::tycho::assign x y [eval list $normalize($option(start$id))]

    # Swap north-south if needed
    if { $type == "n" } {
	set flipped 1
	set type "s"
	set y [expr -$y]
    }

    # Get the relative coordinates
    set option(state$id) [nextstate $id $type $option(state$id) $x $y]
    set coords [route_$type $id $option(state$id) $x $y]

    # Swap north-south again if needed
    if { $flipped } {
	set temp $coords
	set coords {}
	foreach {x y} $temp {
	    lappend coords $x [expr -$y]
	}
	set type "n"
    }

    # Rotate back to correct orientation
    set temp $coords
    set coords {}
    foreach {x y} $temp {
	eval lappend coords "$unnormalize($option(start$id))"
    }

    # Redraw the line
    eval $canvas coords $component(segments$id) $coords

    # Move to correct coordinates
    $canvas move $component(segments$id) $x0 $y0
}

##########################################################################
#### route_e
#
# Route an "east" line given its state and the
# relative positions of its end points.
#
body ::tycho::SmartLine::route_e {id state x y} {
    set a $option(alpha$id)
    set b $option(beta$id)
    
    switch -exact $state {
	"0" {
	    return [list 0 0 $x $y]
	}
	"1" -
	"2" {
	    set xi [expr $x / 2]
	    return [list 0 0 $xi 0 $xi $y $x $y]
	}
	"3" -
	"4" {
	    set x0 [expr $a]
	    set x1 [expr $x-$a]
	    set yi [expr $y / 2]
	}
	"5" {
	    set x0 [expr $a]
	    set x1 [expr $x-$a]
	    set yi [expr $y-$b]
	}
	"6" {
	    set x0 [expr $a]
	    set x1 [expr $x-$a]
	    set yi [expr $y+$b]
	}
	"7" {
	    set x0 [expr $x-$a+2*$b]
	    set x1 [expr $x-$a]
	    set yi [expr $y-$b]
	}
	"8" {
	    set x0 [expr $x-$a+2*$b]
	    set x1 [expr $x-$a]
	    set yi [expr $y+$b]
	}
	"9" {
	    set x0 [expr $a]
	    set x1 [expr $x-$a]
	    set yi [expr -$b]
	}
	"10" {
	    set x0 [expr $a]
	    set x1 [expr $x-$a]
	    set yi [expr $b]
	}
	"11" {
	    set x0 [expr $a]
	    set x1 [expr $a-2*$b]
	    set yi [expr -$b]
	}
	"12" {
	    set x0 [expr $a]
	    set x1 [expr $a-2*$b]
	    set yi [expr $b]
	}
    }
    return [list 0 0 $x0 0 $x0 $yi $x1 $yi $x1 $y $x $y]
}

##########################################################################
#### route_w
#
# Route a "west" line given its state and the
# relative positions of its end points.
#
body ::tycho::SmartLine::route_w {id state x y} {
    set a $option(alpha$id)
    set b $option(beta$id)
    
    switch -exact $state {
	"0" -
	"8" -
	"1" -
	"9" {
	    set xi [expr $x+$a]
	    return [list 0 0 $xi 0 $xi $y $x $y]
	}
	"2" -
	"6" -
	"3" -
	"7" {
	    set xi [expr $a]
	    return [list 0 0 $xi 0 $xi $y $x $y]
	}
	"4" {
	    set x0 [expr $a]
	    set x1 [expr $x+$a]
	    set yi [expr $b]
	}
	"5" {
	    set x0 [expr $a]
	    set x1 [expr $x+$a]
	    set yi [expr -$b]
	}
	"10" {
	    set x0 [expr $a]
	    set x1 [expr $x+$a]
	    set yi [expr $y-$b]
	}
	"11" {
	    set x0 [expr $a]
	    set x1 [expr $x+$a]
	    set yi [expr $y+$b]
	}
    }
    return [list 0 0 $x0 0 $x0 $yi $x1 $yi $x1 $y $x $y]
}

##########################################################################
#### route_s
#
# Route a "south" line given its state and the
# relative positions of its end points.
#
body ::tycho::SmartLine::route_s {id state x y} {
    set a $option(alpha$id)
    set b $option(beta$id)
    
    switch -exact $state {
	"0" {
	    return [list 0 0 $x 0 $x $y]
	}
	"1" -
	"3" {
	    set xi [expr $a]
	    set yi [expr $y-$a]
	}
	"2" {
	    set xi [expr $x+$b]
	    set yi [expr $y-$a]
	}
	"4" {
	    set xi [expr $a]
	    set yi [expr -$b]
	}
	"5" {
	    set xi [expr $a]
	    set yi [expr $y-$a]
	}
	"6" {
	    set xi [expr $x+$b]
	    set yi [expr -$b]
	}
    }
    return [list 0 0 $xi 0 $xi $yi $x $yi $x $y]
}

##########################################################################
#### nextstate
#
# Given a line "type" and its current state, return the best state
# for it to be in. This method works through the state table until
# it finds a state for which none of the transition conditions
# are satisfied. 
#
body ::tycho::SmartLine::nextstate {id type state x y} {
    # Line parameters used by transition expressions
    set a $option(alpha$id)
    set b $option(beta$id)

    # Check that the state option has not been set incorrectly
    if { ! [::info exists transitions($type,$state)] } {
	set option(state$id) 0
	set state 0
    }

    # We jump out of the while loop when no transitions are satisfied
    while { 1 } {
	set laststate $state
	# Try each transition expression
	foreach {condition nextstate} $transitions($type,$state) {
	    if { [eval expr $condition] } {
		# The condition is satisfied, so change state and move on
		set state $nextstate
		break
	    }
	}
	# If we haven't changed state, then we're done
	if { $state == $laststate } {
	    break
	}
    }
    return $state
}
