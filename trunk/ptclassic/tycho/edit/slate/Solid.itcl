##########################################################################
# @Version: $Id$
# @Author: H. John Reekie
#
# @Copyright (c)	%Q% The Regents of the University of California.
# All rights reserved.
# 
# Permission is	hereby granted,	without	written	agreement and without
# license or royalty fees, to use, copy, modify, and distribute	this
# software and its documentation for any purpose, provided that	the above
# copyright notice and the following two paragraphs appear in all copies
# of this software.
# 
# IN NO	EVENT SHALL THE	UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY
# FOR DIRECT, INDIRECT,	SPECIAL, INCIDENTAL, OR	CONSEQUENTIAL DAMAGES
# ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF
# THE UNIVERSITY OF CALIFORNIA HAS BEEN	ADVISED	OF THE POSSIBILITY OF
# SUCH DAMAGE.
# 
# THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES	OF
# MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.	THE SOFTWARE
# PROVIDED HEREUNDER IS	ON AN "AS IS" BASIS, AND THE UNIVERSITY	OF
# CALIFORNIA HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT,	UPDATES,
# ENHANCEMENTS,	OR MODIFICATIONS.
#							  COPYRIGHTENDKEY
##########################################################################


# Set up the "function table." Explicitly load the superclass
# to avoid a bizarre problem with variable scoping.
#
uplevel #0 {
    if { [::info classes ::tycho::Picture] == "" } {
	source $tychoslate/kernel/Picture.itcl
    }

    array set Solid [array get Picture]

    set Solid(borderwidth) ::tycho::Solid::borderwidth
    set Solid(color)       ::tycho::Solid::color
    set Solid(construct)   ::tycho::Solid::construct
    set Solid(coords)      ::tycho::Solid::coords
    set Solid(ghost)       ::tycho::Solid::ghost
    set Solid(relief)      ::tycho::Solid::relief
}


## Solid
#
# A 3D polygon. This accepts all "standard" relief options: flat,
# raised, sunken, ridge, and groove. Because
# of some funnies with Tk's coordinates, the last two don't work too
# well with sharp angles (< 25 or so), but with moderate angles
# they look fine.
#
class ::tycho::Solid {
    inherit ::tycho::Picture

    proc construct {id tags canvas args}

    ###################################################################
    ####                            options                        ####

    # The width of the relief border
    common borderwidth

    # The color of the frame
    common color

    # The relief: raised, sunken, groove, ridge, or flat
    common relief

    ###################################################################
    ####                         public procs                      ####

    proc borderwidth {id canvas bw}
    proc color       {id canvas co}
    proc coords      {id canvas args}
    proc ghost       {id canvas}
    proc relief      {id canvas re}

    ###################################################################
    ####                         protected variables               ####

    common lit
    common notlit
    common shaded
    common notshaded
    common surface

    common colorObject

    ###################################################################
    ####                        private procs                      ####

    private proc adjust {id canvas name shade coords} {}

}

##########################################################################
## adjust name shade coords
#
# Adjust a list of polygons to a new set of coordinates
#
body ::tycho::Solid::adjust {id canvas name shade coords} {

    # Move the components to their new locations.
    set polys [set [set name]($id)]
    set count [min [llength $polys] [llength $coords]]
    set usepolys  [ltake $polys $count]
    set usecoords [ltake $coords $count]
    foreach p $usepolys c $usecoords {
	eval $canvas coords $p $c
    }

    # If there weren't enough polygons, create some more. Lower the
    # new components to the same level as the primary component.
    if { [llength $coords] > $count } {
	set tags [[canvasslate $canvas] gettags $id]
	set moreneeded [ldrop $coords $count]
	foreach c $moreneeded {
	    set p [eval $canvas create polygon $c \
		    -fill $shade \
		    -tags [list $tags]]
	    lappend [set name]($id) $p
	    $canvas lower $p $primary($id)
	}
    } elseif { [llength $coords] < $count } {
	# If there were too many polygons, delete the leftovers
	set leftovers [ldrop $polys $count]
	set [set name]($id) [ltake $polys $count]
	# FIXME: replace with eval $canvas delete $leftovers and TEST
	foreach p $leftovers {
	    $canvas delete $p
	}
    }
}

##########################################################################
## borderwidth
#
# Update the -borderwidth configuration option. Just cause a redraw
# by calling the coords{} method with the current coordinates.
#
# This could be made a lot faster by duplicating code.
#
body ::tycho::Solid::borderwidth {id canvas bw} {
    eval $this coords [$canvas coords primary($id)]
}


##########################################################################
## color
#
# Set the color configuration option.
#
body ::tycho::Solid::color {id canvas co} {
    set color($id) $co
    set colorObject($id) [::tycho::Shades::new $color($id)]

    # FIXME: quick and dirty
    relief $id $canvas $relief($id)
    $canvas itemconfigure $surface($id) -fill [$colorObject($id) matt]
}


##########################################################################
## construct
#
body ::tycho::Solid::construct {id tags canvas args} {
    getalloptions options args

    # Initialize the options
    set defaultoptions {-color background -borderwidth 2 -relief raised}

    foreach {option value} [concat $defaultoptions $options] {
	set [string trimleft $option -]($id) $value
    }

    # This object is used to get the shades of color
    set colorObject($id) [::tycho::Shades::new $color($id)]
 
    # Create the primary component for the outline coordinates
    set primary($id) [eval $canvas create polygon $args \
	    [list -tags $tags -fill ""]]

    # Create the surface component with null size
    set surface($id) [$canvas create polygon 0 0 0 0 0 0 \
	    -fill [$colorObject($id) matt] -tags $tags]

    # Create the borders using the coords{} method. Set the list and
    # shaded components to null to save work in coords{}.
    set lit($id)    {}
    set shaded($id) {}

    eval coords $id $canvas $args
}


##########################################################################
## coords
## coords {coord}+
#
# Query or set the coordinates of the object. This procedure ensures
# that the last two points are the same as the first two.
#
body ::tycho::Solid::coords {id canvas args} {
    # No args: just return coordinates
     if { $args == "" } {
	set coords [$canvas coords $primary($id)]
	return $coords
    }

    # Make sure that end point is same as start point
    if { [lindex $args 0] != [lindex $args [expr [llength $args] - 2]] \
	    || [lindex $args 1] != [lindex $args end] } {
	lappend args [lindex $args 0]
	lappend args [lindex $args 1]
    }

    # Move the primary.
    set coords $args
    eval $canvas coords $primary($id) $coords

    # Get the coordinates of the borders and the surface component
    assign inside litC shadedC \
	    [polyBorders 45 -135 $coords $borderwidth($id)]

    # Adjust the positions of the border polygons, creating and
    # deleting them as necessary.
    adjust $id $canvas "lit"    [$colorObject($id) light] $litC
    adjust $id $canvas "shaded" [$colorObject($id) dark]  $shadedC

    # If the relief is "groove" or "ridge," adjust the inner borders
    # as well. Note that _inside_ is over-written with new values.
    if { $relief($id) == "ridge" || $relief($id) == "groove" } {
	assign inside notlitC notshadedC \
		[polyBorders 45 -135 $inside $borderwidth($id)]

	adjust $id $canvas "notshaded" [$colorObject($id) light] $notshadedC
	adjust $id $canvas "notlit"    [$colorObject($id) dark]  $notlitC
    }

    # Change the co-ordinates of the surface component, if it exists.
    if { [::info exists surface($id)] } {
	eval $canvas coords $surface($id) $inside
    }
}


##########################################################################
## fill
#
# Update the fill configuration option. Just cause a redraw
# by calling the coords{} method with the current coordinates.
#
# This could be made a lot faster by duplicating code.
#
#body ::tycho::Solid::fill {args} {
#    eval $this coords [$canvas coords $component(primary)]
#}


##########################################################################
## ghost
#
# Create and return a "ghost" of the picture.
#
body ::tycho::Solid::ghost {id canvas} {
    eval $canvas create polygon [$canvas coords $primary($id)] \
	    -outline grey {-fill {}}
}

##########################################################################
## relief
#
# Update the -relief configuration option.
#
body ::tycho::Solid::relief {id canvas re} {
    set relief($id) $re
    set slate [join [linit [split $canvas .]] .]

    if { $relief($id) == "ridge" || $relief($id) == "groove" } {

	set light [$colorObject($id) light]
	set dark  [$colorObject($id) dark]

	if { $relief($id) == "groove" } {
	    set light $dark
	    set dark [$colorObject($id) light]
	}

	# Change the color of the lit and shaded components
	foreach i $lit($id) {
	    $canvas itemconfigure $i -fill $light
	}
	foreach i $shaded($id) {
	    $canvas itemconfigure $i -fill $dark
	}

	# If the relief has changed to ridge or groove, then we
	# have to create the inside border polygons, and move
	# the surface if it exists.
	if { ! [info exists notlit($id)] } {

	    set coords [$canvas coords $primary($id)]

	    assign inside junk1 junk2 \
		    [polyBorders 45 -135 $coords $borderwidth($id)]
	    assign inside notlitC notshadedC \
		    [polyBorders 45 -135 $inside $borderwidth($id)]

	    set notlit($id)    {}
	    set notshaded($id) {}

	    adjust $id $canvas "notshaded" $light $notshadedC
	    adjust $id $canvas "notlit"    $dark  $notlitC

	    if { [::info exists surface($id)] } {
		eval $canvas coords $surface($id) $inside
	    }
	} else {
	    foreach i $notshaded($id) {
		$canvas itemconfigure $i -fill $light
	    }
	    foreach i $notlit($id) {
		$canvas itemconfigure $i -fill $dark
	    }
	}
    } else {
	set light [$colorObject($id) light]
	set dark  [$colorObject($id) dark]

	if { $relief($id) == "sunken" } {
	    set light $dark
	    set dark [$colorObject($id) light]
	} elseif { $relief($id) == "flat" } {
	    set light [$colorObject($id) matt]
	    set dark $light
	}

	# Change the color of the various components
	foreach i $lit($id) {
	    $canvas itemconfigure $i -fill $light
	}
	foreach i $shaded($id) {
	    $canvas itemconfigure $i -fill $dark
	}

	# If the relief has changed _from_ ridge or groove, then we
	# delete the inside border polygons and move the surface.
	if { [::info exists notlit($id)] } {
	
	    eval $canvas delete $notlit($id) $notshaded($id)
	    unset notlit($id)
	    unset notshaded($id)

	    if { [::info exists surface($id)] } {
		set coords [$canvas coords $primary($id)]
		assign inside junk1 junk2 \
			[polyBorders 45 -135 $coords $borderwidth($id)]
		eval $canvas coords $surface($id) $inside
	    }
	}
    }
}

##########################################################################
## transform mode args
#
# Transformation on a solid has to be overridden to make sure that
# the "direction" in which the coordinates run remains correct.
# Without this overriding, the solid will change relief from
# "raised" to "sunken," or vice versa.
#
#body ::tycho::Solid::transform {mode args} {
#    if { $mode == "flip" || $mode == "flop" } {
#	eval $this coords [lineReverse [$this coords]]
#    }
#    eval [$this shape] transform $mode $args
#}
