# Definition of a C context-sensitive editor.
#
# @Author: Edward A. Lee
#
# @Version: $Id$
#
# @Copyright (c) 1995-%Q% The Regents of the University of California.
# All rights reserved.
# 
# Permission is hereby granted, without written agreement and without
# license or royalty fees, to use, copy, modify, and distribute this
# software and its documentation for any purpose, provided that the
# above copyright notice and the following two paragraphs appear in all
# copies of this software.
# 
# IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY
# FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
# ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF
# THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.
# 
# THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE
# PROVIDED HEREUNDER IS ON AN "AS IS" BASIS, AND THE UNIVERSITY OF
# CALIFORNIA HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,
# ENHANCEMENTS, OR MODIFICATIONS.
# 
# 						PT_COPYRIGHT_VERSION_2
# 						COPYRIGHTENDKEY
#######################################################################

#######################################################################
# FIXME: To do
#
# - This editor only handles indenting and comments.  Needs much more.
# 


#######################################################################
#### EditC
# This class defines a text widget with an emacs-like editor with some
# context-specific features for editing C files. It editor
# automatically indents a line in response to a Tab character, and
# provides a command for indenting a region (the selection). To enter a
# literal Tab, enter the sequence <Control-q><Tab>. This editor also
# colors comments and the strings "FIXME" and "NOTE", and provides a
# method for commenting out a region.
#
class ::tycho::EditC {
    inherit ::tycho::EditProgram

    constructor {args} {}
    destructor {}

    ##########################################################################
    ####                         public methods                           ####

    # If the selection has no embedded comments, then comment it out.
    method commentSelection {}

    # Compile the C file and load it into Tcl.
    method evaluate {}

    # Open a window with help on the C editor.
    method help {}

    # Tag and color the C code in a region.
    method parseNow {start stop}

    # Return a list of tags to use when checking the spelling.
    method spellCheckTags {} {return {ccomment}}

    # If the selection is exactly a comment, remove the comment symbols.
    method uncommentSelection {}
}

###################################################################
#
body ::tycho::EditC::constructor {args} {

    eval itk_initialize $args
    
    # C does not have line-oriented comments, so there is no fill prefix.
    set fillPrefix ""
}

#####################################################################
#### commentSelection
# Check to see whether the selection has any embedded comments. If it
# does, issue an error message. If it does not, then comment out the
# selection.
#
body ::tycho::EditC::commentSelection {} {
    if {[set txt [getSelection]] != {}} {

	if [regexp {\/\*|\*\/} $txt] {
	    error "Selection contains embedded comment characters"
	}
	$itk_component(text) mark set insert \
		[$itk_component(text) index sel.first]
	deleteRange sel.first sel.last
	set start [$itk_component(text) index insert]
	insertString insert "/*\n"
	insertString insert $txt
	insertString insert "*/\n"
	$itk_component(text) tag add sel $start insert
	markModified
	parseRegion sel.first sel.last
    }
}

#####################################################################
#### evaluate
# Save the buffer if necessary, compile it and load it back into
# Tcl.  If necessary, add a initialization procedure so that the 
# Tcl load command will work.  If there is no makefile present in the
# current directory, then create a makefile with a name based on the
# current file.
#
body ::tycho::EditC::evaluate {} {
    global env tycho
    saveQuery
    set dirname [file dirname $file]
    set basename [file rootname [file tail $file]]

    ###
    # Append a initialization procedure
    # See the tcl load command man page for details
    set initProcName "[string toupper\
            [string range $basename 0 0]][string tolower\
            [string range $basename 1 end]]_Init"

    set end [$itk_component(text) search -forwards -regexp -- \
	    $initProcName 0.0 end]
    if {$end == ""} {
	# The initialization procedure was not found.
	# Ask the user if they want to append one, if they do, append it
	# and don't load, so the user can stick in the body and re-evaluate.
	set nm [::tycho::autoName .editCYNC]
	::tycho::YesNoCancel $nm \
		-text "The file $file does not have a Tcl initialization \
		procedure named \"$initProcName\".\nIf you choose to add\
		the initialization procedure, then be sure to reedit\
		the file and insert calls to register your commands and\
		reevaluate the file.\nAdd\
		the initializaiont procedure now?"
	
	set response [::tycho::Dialog::wait $nm]
    	switch $response {
	    -1 {return}
	    0 {}
	    1 {
		# Add a initialization procedure to the end of the file
		set fd [open $file a]
                # Check to see if we need to add #include <tcl.h>
                set end [$itk_component(text) search -forwards -regexp -- \
                        {#include [<"](tcl|tk|itcl).h[">]} 0.0 end]
                if {$end == ""} {
                    puts $fd "#ifndef _TCL\n#include <tcl.h>"
                    puts $fd "#endif"
                }

		puts $fd "/* Tcl initialization procedure added for\
			the Tcl load command\n */"
		puts $fd "int ${initProcName}\(Tcl_Interp *interp)\n\{"
		puts $fd "    /* A sample Tcl command registration. */"
		puts $fd "    /* Tcl_CreateCommand(interp, \"$basename\",\
			Tcl_${basename}Cmd,"
		puts $fd "                         (ClientData) NULL,\
			(Tcl_CmdDeleteProc*) NULL);"
                puts $fd "     */"
                puts $fd "    return TCL_OK;\n\}"
		close $fd
		reload
                putStatus "Successfully added initialization procedure"
		return
	    }
	}
    }

    
    ###
    # Figure out which makefile to run
    if {[file exists [file join $dirname makefile]] || \
	    [file exists [file join $dirname Makefile]]} {
	# There is a makefile or a Makefile, so just call make
        putStatus "makefile or Makefile present, so we just call make,\
                when complete, be sure to close the Exec window to continue."
        set win [::tycho::autoName .ceval]
	::tycho::Exec $win -command make -dir $dirname
        $win centerOnScreen
        ::tycho::Dialog::wait $win
        putStatus ""
    } else {
        set makefile [file join $dirname $basename.mk]
	if ![file exists $makefile] {
	    # Create a makefile by reading in from the template and 
            # substituting %basename% for the value of $basename
	    # FIXME: templateMakefile should probably be a preference.
	    set templateMakefile \
		    [file join $tycho editors textedit templates Cmakefile.mk]
            set fdin [open $templateMakefile r]
            set fdout [open $makefile w]
            while {[gets $fdin linein] >= 0} {
                regsub -all {%basename%} $linein $basename lineout
                puts $fdout $lineout
            }
            close $fdout
            close $fdin
	}
	if [info exists env(PTARCH)] {
	    set PTARCH $env(PTARCH)
	} else {
	    error "Sorry, the PTARCH environment variable is not set"
	}
	if {![file exists [file join $tycho obj.$PTARCH tcl.mk]] || \
		![file exists [file join $tycho obj.$PTARCH java.mk]]} {
            putStatus "About to make tcl.mk and java.mk, when complete, be\
                    sure to close the Exec window to continue."
            set win [::tycho::autoName .ceval]
	    ::tycho::Exec $win -command [ list make config_tclexts] \
                    -dir $tycho
            $win centerOnScreen
            ::tycho::Dialog::wait $win
            putStatus ""
	}
	# We need to wait until tcl.mk and java.mk exist
        putStatus "About to make shared object, when complete, be sure to \
                close the Exec window to continue."
        set win [::tycho::autoName .ceval]
        ::tycho::Exec $win \
                -command \
                "make -f $basename.mk $basename[info sharedlibextension]" \
                -dir $dirname
        $win centerOnScreen
        ::tycho::Dialog::wait $win
        putStatus ""
    }
    # We need to wait until the shared object exists
    # Have to use the absolute pathname here, or loading will fail
    if [catch {uplevel #0 \
	    load [file join $dirname $basename[info sharedlibextension]]} \
            errMsg] {
        error "Failed to load\
                [file join $dirname $basename[info sharedlibextension]]:\n\
                $errMsg"
    }
    putStatus "Loaded $basename[info sharedlibextension]"
}

###################################################################
#### help
# Open a window with help on the current widget.
#
body ::tycho::EditC::help {} {
    global ::TYCHO
    ::tycho::File::openContext \
	    [file join $TYCHO editors textedit doc usersGuides \
	    EditCHelp.html]
}

#####################################################################
#### parseNow
# Tag and color C-style comments in the text plus the strings "NOTE"
# and "FIXME". Note that if a comment begins in the specified range but
# ends outside the range, the entire comment is parsed.
#
body ::tycho::EditC::parseNow {start stop} {

    set text $itk_component(text)

    $text tag remove ccomment $start $stop

    # The base class identifies line-oriented comments, which do not
    # exist in C.  Therefore, we need to completely redefine this procedure.
    set ind $start
    set count 0
    while {[set ret [$text search -exact \
	    {/*} $ind $stop]] != {}} {
	# Found the start of a comment.  Look for the end.
	set endcmt [$text search -exact {*/} $ret end]
	if {$endcmt != {}} {

	    # Found the end of a comment.  Tag it.
	    $text tag add ccomment $ret "$endcmt + 2 chars"
	    
	    set ind $endcmt
	} else {
	    set ind [$text index "$ret +2 chars"]
	}
	# The following appears to be needed to prevent infinite loops.
	if [$text compare $ind >= end] {break}
    }

    # Now tag all occurrences of "FIXME" and "NOTE" within the range
    # that got processed.
    set ind $start
    while {[set ind [$text search -count cnt -regexp \
	    {FIXME|NOTE} $ind $stop]] != {}} {

	$text tag add fixme $ind "$ind + $cnt chars"
	    
	set ind [$text index "$ind + $cnt chars"]
	# The following appears to be needed to prevent infinite loops.
	if [$text compare $ind >= end] {break}
    }

    # Set the visual characteristics of the tagged text
    $text tag configure ccomment -foreground \
	    [preference get commentColor]
    $text tag configure fixme -foreground \
	    [preference get fixmeColor]
}

#####################################################################
#### uncommentSelection
# Remove comment characters from the two ends of the selection.
# If the comment characters are by themselves on a line, remove
# the line altogether.
#
body ::tycho::EditC::uncommentSelection {} {
    if {[set txt [getSelection]] != {}} {

	if {[regexp -indices "^\[ \t\]*\/\\*\n*" $txt leading] && \
		[regexp -indices "\\*\/\[ \t\]*\n*\[ \t\]*\$" $txt trailing]} {
	    
	    set newtxt [string range $txt \
		    [expr [lindex $leading 1]+1] \
		    [expr [lindex $trailing 0]-1]]
	    
	    $itk_component(text) mark set insert \
		    [$itk_component(text) index sel.first]
	    deleteRange sel.first sel.last
	    set start [$itk_component(text) index insert]
	    insertString insert $newtxt
	    $itk_component(text) tag add sel $start insert
	    markModified
	    parseRegion sel.first sel.last
	} {
	    error "Selection is not a comment"
	}
    }
}
