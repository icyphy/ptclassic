# Definition of an HTML context-sensitive editor.
#
# @Author: Edward A. Lee
#
# @Version: $Id$
#
# @Copyright (c) 1995-%Q% The Regents of the University of California.
# All rights reserved.
# 
# Permission is hereby granted, without written agreement and without
# license or royalty fees, to use, copy, modify, and distribute this
# software and its documentation for any purpose, provided that the
# above copyright notice and the following two paragraphs appear in all
# copies of this software.
# 
# IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY
# FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
# ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF
# THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.
# 
# THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE
# PROVIDED HEREUNDER IS ON AN "AS IS" BASIS, AND THE UNIVERSITY OF
# CALIFORNIA HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,
# ENHANCEMENTS, OR MODIFICATIONS.
# 
# 						PT_COPYRIGHT_VERSION_2
# 						COPYRIGHTENDKEY
#######################################################################


#######################################################################
#### EditHTML
# This class defines a text widget with an emacs-like editor with some
# context-specific features for editing HTML files. It tags and colors
# HTML statements enclosed by angle brackets, and makes hyperlinks live.
# It also provides a command for checking hyperlinks.
#
class ::tycho::EditHTML {
    inherit ::tycho::Edit

    constructor {args} {}
    destructor {}

    ##########################################################################
    ####                            options                               ####

    # The color of commands.
    itk_option define -commandcolor commandColor CommandColor black {
	$itk_component(text) tag configure command \
		-foreground $itk_option(-commandcolor)
    }

    # The color of pointer.
    itk_option define -pointercolor pointerColor PointerColor black {
	$itk_component(text) tag configure pointer \
		-foreground $itk_option(-pointercolor)
    }

    # The color of dests.
    itk_option define -destcolor destColor DestColor black {
	$itk_component(text) tag configure dest \
		-foreground $itk_option(-destcolor)
    }

    ##########################################################################
    ####                         public methods                           ####

    # Check hyperlinks for validity.
    method checkLinks {}

    # Execute the HTML and display.
    method evaluate {}

    # Get the blank HTML template for a file and insert it into the window
    method fileTemplate {}

    # Open a help window.
    method help {}

    # Jump to the link under the "current" mark, if any.
    method jump {}

    # Color the HTML statements in a region.
    method parseNow {start stop}

    # Find a name definition.
    method seeFragment {point}

    # Returns a list of tags to use when checking the spelling.
    method spellCheckTags {} {return {text}}

    ####################################################################
    ####                  protected methods and variables           ####

    # Fix the link between start and end, which has error indicated by err.
    protected method fixLink {link start end err}

    # Initialize the menu/status/tool bars
    protected method initialize {{menubar {}} {statusbar {}} {toolbar {}}}

    # Given an HTML anchor, return the filename and point within the file.
    protected method parseLink {dest}

    # Access the "edithtml" preferences
    protected method preference {mode args}
}

###################################################################
#
body ::tycho::EditHTML::constructor {args} {
    eval itk_initialize $args

    # Subscribe to the preference set
    preference subscribeoptions $this \
	    -commandcolor commandColor \
	    -pointercolor pointerColor \
	    -destcolor destColor
}

#####################################################################
#### checkLinks
# Check hyperlinks for validity.
#
body ::tycho::EditHTML::checkLinks {} {
    # Clear marks from previous checking
    $itk_component(text) tag delete badlink

    # Have to parse first, since we use the tags.
    # Note that cannot allow the parsing to be deferred.
    parseNow 1.0 end
    set next 1.0
    set even 0
    set ok 1
    while {[set point [$itk_component(text) tag nextrange pointer $next]] \
	    != {}} {
	set start [lindex $point 0]
	set end [lindex $point 1]
	set next $end
	set dest [$itk_component(text) get $start $end]
	set ret [parseLink $dest]
	if {$ret == {}} {
	    set ok 0
	    if {[fixLink $dest $start $end {Malformed hyperlink}] == {}} {
		break
	    }
	} {
	    set filename [lindex $ret 0]
	    set name [lindex $ret 1]
	    set nameexp "<\[ \t\]*a\[ \t\]+name\[ \t\]*=\[ \t\]*\"?$name\"?>"
	    if {$filename != {}} {
		if {![file exists $filename]} {
		    set ok 0
		    if {[fixLink $dest $start $end {Non-existant file}] == {}} {
			break
		    }
		    continue
		} elseif {![file readable $filename]} {
		    set ok 0
		    if {[fixLink $dest $start $end {Non-readable file}] == {}} {
			break
		    }
		    continue
		}
		if {$name != {}} {
		    # Check that name exists in the remote file.
		    set fid [open $filename]
		    set contents [read $fid]
		    close $fid
		    if {![regexp -nocase $nameexp $contents]} {
			set ok 0
			if {[fixLink $dest $start $end {Bad name after #}] \
				== {}} {
			    break
			}
		    }
		}
	    } elseif {$name != {}} {
		# Check that name exists in the local file
		if {[$itk_component(text) search -nocase -regexp $nameexp 1.0] \
			== {}} {
		    set ok 0
		    if {[fixLink $dest $start $end {Bad name after #}] == {}} {
			break
		    }
		}
	    }
	}
    }
    if {$ok} {
	safeEval ::tycho::inform "Hyperlinks appear to be OK"
    } {
	safeEval ::tycho::inform "Done checking hyperlinks"
    }
}

#####################################################################
#### evaluate
# Evaluate the contents of the text window as HTML commands.
#
body ::tycho::EditHTML::evaluate {} {
    $itk_component(text) evaluate
}

#####################################################################
#### fileTemplate
# Insert the blank html template into the file.
#
body ::tycho::EditHTML::fileTemplate {} {
    global TYCHO

    # The location of the template file.  Non-UCB users might want
    # to edit this file for their own use.
    set filename $TYCHO/editors/textedit/templates/HTMLTemplate.html

    if {$filename != "" && $filename != "NoName"} {
	if {[file exists $filename]} {
	    if {[file readable $filename]} {
		# Read in the template file and stuff it into editor
		set fd [open $filename r]
		set data [read $fd]
		close $fd
		insertData $data
                markModified
	    } {
		safeEval ::tycho::warn "File is not readable: $filename"
	    }
	} {
	    safeEval ::tycho::warn "File does not exist: $filename"
	}
    }
}

###################################################################
#### help
# Open a window with help on the current widget.
#
body ::tycho::EditHTML::help {} {
    global ::TYCHO
    ::tycho::File::openContext \
	    [file join $TYCHO editors textedit doc usersGuides \
	    EditHTMLHelp.html]
}

#####################################################################
#### jump
# Jump to the link under the "current" mark, if any.
#
body ::tycho::EditHTML::jump {} {
    set dest [getTaggedText pointer]
    if {$dest != {}} {
	set ret [parseLink $dest]
	if {$ret != {}} {
	    set filename [lindex $ret 0]
	    set name [lindex $ret 1]
	    if {$filename == {}} {
		seeFragment $name
	    } {
		hyperJump $filename $name
	    }
	}
    }    
}

#####################################################################
#### parseNow
# Tag and color HTML commands in the specified range.
#
body ::tycho::EditHTML::parseNow {start stop} {

    set text $itk_component(text)

    # Remove tags first, if necessary
    $text tag remove command $start $stop
    $text tag remove text $start $stop
    $text tag remove pointer $start $stop
    $text tag remove dest $start $stop
    
    # Scan the text for HTML commands.
    set upto $start
    while {[set ret \
	    [$text search -count length -regexp {\<[^>]+\>} \
	    $upto $stop]] != {}} {
	$text tag add text $upto $ret
	$text tag add command $ret "$ret + $length char"
	# The following appears to be needed to prevent infinite loops.
	if [$text compare $upto >= end] {break}
	set upto [$text index "$ret + $length char"]
    }
    $text tag add text $upto $stop
    
    # Set the visual characteristics of the tagged commands
    $text tag configure command -foreground \
	    [preference get commandColor]

    # Scan the text for hypertext pointers.
    set upto $start
    while {[set upto \
	    [$text search -count length -nocase \
	    -regexp {\<a[ \t]+href[ \t]*=[ \t]*[^>]+\>} \
	    $upto $stop]] != {}} {
	$text tag add pointer $upto "$upto + $length char"
	set upto [$text index "$upto + $length char"]
	# The following appears to be needed to prevent infinite loops.
	if [$text compare $upto >= end] {break}
    }
    
    # Set the visual characteristics of the tagged commands
    $text tag configure pointer -foreground \
	    [preference get pointerColor]

    # for testing
    # $text tag configure text -foreground red

    $text tag bind pointer <Double-Button-1> "$this jump"

    # Scan the text for hypertext destinations.
    set upto $start
    while {[set upto \
	    [$text search -count length -nocase \
	    -regexp {\<a[ \t]+name[ \t]*=[ \t]*[^>]+\>} \
	    $upto $stop]] != {}} {
	$text tag add dest $upto "$upto + $length char"
	set upto [$text index "$upto + $length char"]
	# The following appears to be needed to prevent infinite loops.
	if [$text compare $upto >= end] {break}
    }
    
    # Set the visual characteristics of the tagged commands
    $text tag configure dest -foreground \
	    [preference get destColor]
}

#####################################################################
#### seeFragment
# Find a point within the file, center in the
# visible part of the text window, and briefly highlight it.
# The point can have any of three forms:
# <pre>
#    {line <i>linenumber</i>}
#    {range <i>startindex endindex</i>}
#    <i>name</i>
# <pre>
# where in the latter form, <i>name</i> should be a named
# anchor within the HTML file.
#
body ::tycho::EditHTML::seeFragment {point} {
    if {([llength $point] == 2 && [lindex $point 0] == {line}) || \
            ([llength $point] == 3 && [lindex $point 0] == {range})} {
        Edit::seeFragment $point
    } {
        # Edit the pattern to identify the named anchor.
        Edit::seeFragment "name\[ \t\]*=\[ \t\]*\"?$point\"?"
    }
}

#####################################################################
#####################################################################
#####################################################################
####                    protected methods                        ####

#####################################################################
#### fixLink
# Fix the link between start and end, which has error indicated by err.
# The user is queried for a replacement.  The first argument is the
# original text of the bad link.  The second is the start position, the
# third is the end position, and the final argument is a message indicating
# what is wrong with the link.  If the user does not cancel, the link
# will be replaced with an edited value.  Return the replacement string
# if there is one, or the null string if the user cancels.
#
body ::tycho::EditHTML::fixLink {link start end err} {

    $itk_component(text) tag add badlink $start $end
    $itk_component(text) see $start

    # Set up reverse video for the bad match.
    # First lower the priority of the tag so the selection is still visible
    # as normal.
    $itk_component(text) tag raise sel badlink
    $itk_component(text) tag configure badlink \
	    -background [preference get targetColor]

    set nm [::tycho::autoName .entry]
    ::tycho::Query $nm \
	    -bitmap questhead \
	    -text "$err: Make corrections." \
	    -queries [list [list line correction {} $link]] \
	    -entrywidth 80 \
	    -geometry +0+0

    # FIXME: This centers on the screen, which is not what we want.
    # Invoking wm deiconify would work, but "wait" doesn't support this.
    set replacement [lindex [::tycho::Dialog::wait $nm] 1]

    if {$replacement != {} && $replacement != $link} {
	deleteRange $start $end
	insertString $start $replacement
	$itk_component(text) tag add pointer $start \
		"$start +[string length $replacement] chars"
    }
    return $replacement
}

#####################################################################
#### initialize
# Initialize the menu, status, and toolbars associated with this widget.
# The root (view) class sets up the menubar methods in it's initialize
# via the chain command, which should always be the first command in
# this method.
# 
# This method is called by it's displayer when attachView is called (usually
# in ::tycho::view
#
body ::tycho::EditHTML::initialize {{menubar {}} {statusbar {}} {toolbar {}}} {
    chain $menubar $statusbar $toolbar

    if {$menubar != {}} {
        # Add to the format menu commands to comment and uncomment
        # the regions defined by the selection.
        menubar addSeparator Format
        
        menubar command "Recolorize" Format -underline 0 \
                -command "$this parseRegion 1.0 end"
        
        menubar addSeparator Edit
        
        menubar command "Check Links" Edit -underline 6 \
                -command "$this busy $this checkLinks"
        
        menubar addMenu Special -underline 0
        menubar command "File Template" Special -underline 0 \
                -command "$this fileTemplate"
    }
}

#####################################################################
#### parseLink
# Given an HTML anchor, return a two-element list with a fully
# expanded filename (which could be based on the location of the
# current file we are displaying) and a point within the file.
# It is possible for either the filename or the point within the
# file to be an empty string, meaning that they were not specified.
# If the parsing fails, an empty string is returned rather than a
# two-element list.
# FIXME: This will not work unless the parent widget is created
# at the global scope.
#
body ::tycho::EditHTML::parseLink {dest} {
    if [regexp -nocase \
            {\<a[ \t]+href[ \t]*=[ \t]*\"?(file:)?([^>#\"]*)#?([^>\"]*)\"?\>} \
            $dest dummy1 dummy2 filename name] {
        # If the filename is not absolute, use the directory
        # of the current file.  This only works if we are inside
        # a file object.
        if {$filename != {} && ![string match /* $filename] && \
                ![string match "\$*" $filename] && \
                ![string match "~*" $filename]} {
            set filename [file dirname [$this filename]]/$filename
        } else {
            set filename [::tycho::expandPath $filename]
        }
        return [list $filename $name]
    }
    return {}
}

#####################################################################
#### preference
# Access the preferences associated with this widget. This method
# overrides the default method in ::tycho::TWidget to access the
# "edithtml" preferences.
#
body ::tycho::EditHTML::preference {mode args} {
    eval ::tycho::preference $mode "edithtml" $args
}

