# A graphical entry tool for state transition diagrams (STD).
#
# @Author: Bilung Lee
#
# @Version: $Id$
#
# @Copyright (c) 1995-%Q% The Regents of the University of California.
# All rights reserved.
# 
# Permission is hereby granted, without written agreement and without
# license or royalty fees, to use, copy, modify, and distribute this
# software and its documentation for any purpose, provided that the
# above copyright notice and the following two paragraphs appear in all
# copies of this software.
# 
# IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY
# FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
# ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF
# THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.
# 
# THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE
# PROVIDED HEREUNDER IS ON AN "AS IS" BASIS, AND THE UNIVERSITY OF
# CALIFORNIA HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,
# ENHANCEMENTS, OR MODIFICATIONS.
# 
# 						PT_COPYRIGHT_VERSION_2
# 						COPYRIGHTENDKEY
#######################################################################

#######################################################################
#### EditSTD
# A graphical editor for editing the state transition diagrams (STD).
# It recognizes the file extension ".std".
#

class ::tycho::EditSTD {
    inherit ::tycho::EditBubbleAndArc

    ##########################################################################
    ####                      constructor & destructor                    ####
    constructor {args} {}
    destructor {}

    ##########################################################################
    ####                         public methods                           ####

    # Clear the display, discarding the current items.
    method clear {}

    # Clear all previous highlight states.
    method clearHighlightState {}

    method editArc {arc} 
    method editArcDone {arc w}

    # Invoked by the "Edit Item" command in the Edit menu.
    # It invokes the "editState" or "editArc" methods depending on 
    # whether the item is a node or an arc.
    method editItem {item}

    method editState {node} 
    method editStateDone {node w} 

    # getInfo
    method getInfo {} 
 
    # Highlight those states with the name.
    method highlightState {name}
 
    # To set the names of the I/O ports & internal events
    method ioPortNames {}
    method ioPortNamesDone {w}

    # Look inside an item with tag $tag.
    method lookInside {tag}
    
    # Look inside a state with id $node.
    method lookInsideState {node}

    # makeIcon
    method makeIcon {}
    method makeIconOk {w}

    # Modify th options.
    method modifyOptions {}
    method modifyOptionsDone {w}

    # Pop up a file
    method popUpFile {name}

    # The following methods are used only when work with Ptolemy
    method ptkCompile {}

    # Invoked by the "Set Initial State" command in the Edit menu.
    method setInitialState {tag} 

    # Set all options of this machine.
    method setOptions {machine evaluation oneWriter}

    # Set the in, out and internal port names.
    method setPortNames {in out internal}

    # Specify whether or not modifications are allowed in the displayed text.
    method setReadOnly {bool}

    ##########################################################################
    ####                     protected methods                            ####
   
    # Initialize the menu/status/tool bars
    protected method initialize {{menubar {}} {statusbar {}} {toolbar {}}}

    # Insert the specified data into the canvas.
    protected method insertData {data}

    # Return the text to save.
    protected method saveText {}

    # Translate the action of an arc into desired format. 
    protected method transAction {action}

    # Translate the guard of an arc into desired format. 
    protected method transGuard {guard}

    ##########################################################################
    ####                     protected variables                          ####

    # Machine type.
    protected variable machineChoices {Pure}
    protected variable machineType Pure

    # Evaluation type.
    protected variable evaluationChoices {Strict NonStrict}
    protected variable evaluationType Strict

    # One-writer rule checking type.
    protected variable oneWriterChoices {Compile Run None}
    protected variable oneWriterType Compile

    # Previous highlighted state
    protected variable preHighLtStateId ""

    # Names of the I/O ports.  This is an array with two elements:
    # "in" and "out".
    protected variable portNames

    # Store the value used in makeIcon last time.
    protected common makeIconSrcDir [file join \$PTOLEMY src domains fsm demo]
    protected common makeIconPaletteName "user.pal"

    ##########################################################################
    ####                         private methods                          ####
    
    # Initialize the menu bar.
    private method initializeMenubar {menubar}
}

##########################################################################
####  constructor & destructor
#
body ::tycho::EditSTD::constructor {args} {
    interactiveEnable 0

    # Initialize the io portNames array elements.
    set portNames(in)  ""
    set portNames(out) ""
    set portNames(internal) ""

    # Setup menu hot key and mouse binding
    bind $slate <Key-e> "$this editItem selected"
    bind $slate <Double-1> "$this editItem current"
    bind $slate <Key-i> "$this lookInside current"

    # The following initialize options and then invoke any
    # configuration options, assuming there are options specified.
    eval itk_initialize $args 

    interactiveEnable 1
}

    ##########################################################################
    ####                         public methods                           ####

#######################################################################
#### clear
# Clear the display, discarding the current graphics and corresponding
# data structure.
#
body ::tycho::EditSTD::clear {} {
    if [getReadOnly] {bell; return}

#    foreach node [$slate find withtag node] {
#	# destroy the corresponding edit state window if it exists.
#	set w $prefix.stdEditState$node
#	if [winfo exists $w] { destroy $w }
#    }
#    foreach arc [$slate find withtag arc] {
#	# destroy the corresponding edit arc window if it exists.
#	set w $prefix.stdEditArc$arc
#	if [winfo exists $w] { destroy $w }
#    } 

    $slate delete all
    foreach index [array names nodeInfo] {
	unset nodeInfo($index)
    }
    foreach index [array names edgeInfo] {
	unset edgeInfo($index)
    }
}

################################################################
#### clearHighlightState
# Clear all previous highlight states.
#
body ::tycho::EditSTD::clearHighlightState {} {
    foreach id $preHighLtStateId {
        $slate itemconfigure $id -fill white
    }
}

###################################################################
#### editArc and editArcDone
# Edit an arc.
#
body ::tycho::EditSTD::editArc {arc} {
    set w $prefix.stdEditArc$arc
    if [winfo exists $w] {
	wm deiconify $w
	raise $w
    } else {

	set arcLabel [$slate itemcget $edgeInfo($arc,label) -text]
	set src [$slate itemcget $edgeInfo($arc,src) -text]
	set dest [$slate itemcget $edgeInfo($arc,dest) -text]
	set title "Edit $machineType Arc \"$arcLabel\"\nSource state: $src\
		\nDestination state: $dest"

	set labelQuery [list line label {Guard / Action:} $arcLabel]

	if "![info exists edgeInfo($arc,preemptive)]" {
	    set edgeInfo($arc,preemptive) NO
	} 
	set preemptiveQuery [list radio preemptive {Preemptive:} {NO YES}\
		$edgeInfo($arc,preemptive)]

	if "![info exists edgeInfo($arc,entryType)]" {
	    set edgeInfo($arc,entryType) History
	} 
	set entryTypeQuery [list radio entryType {Entry Type:}\
		{History Default} $edgeInfo($arc,entryType)]

	set cmd "$this editArcDone $arc $w"

	::tycho::Query $w -title "STD Edit $machineType Arc" -text $title\
		-queries [list $labelQuery $preemptiveQuery $entryTypeQuery]\
		-okcommand [list catch $cmd]
    }
    
    $w centerOnScreen
}

body ::tycho::EditSTD::editArcDone {arc w} {
    set label [$slate itemcget $edgeInfo($arc,label) -text]
    set newLabel [string trim [$w get label]]
    # Any trailing "/" is also unnessary.
    set newLabel [string trimright $newLabel "/"]
    if {$label != $newLabel} {
	$slate itemconfigure $edgeInfo($arc,label) -text $newLabel
	$this markModified
    }

    set newPreemptive [string trim [$w get preemptive]]
    if {$edgeInfo($arc,preemptive) != $newPreemptive} {
	set edgeInfo($arc,preemptive) $newPreemptive
	$this markModified	
    }

    set newEntryType [string trim [$w get entryType]]
    if {$edgeInfo($arc,entryType) != $newEntryType} {
	set edgeInfo($arc,entryType) $newEntryType
	$this markModified	
    }
}

###################################################################
#### editItem
# Invoked by the "Edit Item" command in the Edit menu.
#
body ::tycho::EditSTD::editItem {item} {
    # The indices in the nodeInfo and edgeInfo arrays
    # are item IDs.
    set id [$slate find withtag $item]
    if {[lsearch -exact [$slate gettags $id] node] >= 0} {
	# id is a node.
	$this editState $id
    } elseif {[lsearch -exact [$slate gettags $id] arc] >= 0} {
	# id is an arc.
	$this editArc $id
    }
}

#########################################################################
#### editState and editStateDone
# Edit a state.
#
body ::tycho::EditSTD::editState {node} {
    
    set w $prefix.stdEditState$node
    if [winfo exists $w] {
	wm deiconify $w
	raise $w
    } else {

	set nodeLabel [$slate itemcget $node -text]
	set title "Edit $machineType State \"$nodeLabel\""
	set labelQuery [list line label {Label:} $nodeLabel]

	set cmd "$this editStateDone $node $w"

	::tycho::Query $w -title "STD Edit $machineType State" \
		-text $title -queries [list $labelQuery]\
		-okcommand [list catch $cmd]

	if "![info exists nodeInfo($node,slave)]" {
	    set nodeInfo($node,slave) ""
	}
	$w line slave {Slave Process:} $nodeInfo($node,slave)

	$w centerOnScreen
    }


}

body ::tycho::EditSTD::editStateDone {node w} {
    set label [$slate itemcget $node -text]
    set newLabel [string trim [$w get label]]

    if {$label != $newLabel} {
	$slate itemconfigure $node -text $newLabel
	$this markModified
    }

    set newSlave [string trim [$w get slave]]
    if {$nodeInfo($node,slave) != $newSlave} {
	set nodeInfo($node,slave) $newSlave
	$this markModified	
    }
}

##############################################################
#### getInfo
body ::tycho::EditSTD::getInfo {} {
    set nodes [$slate find withtag node]
    set arcs [$slate find withtag arc]
    set init_state_id [$slate find withtag init_state]
    if {$init_state_id == ""} {
	set init_state None
    } else {
	set init_state [$slate itemcget $init_state_id -text]
    }

    set w $prefix.getInfo
    catch {destroy $w}
    ::tycho::Message $w -text "Machine type: $machineType\
	    \nEvaluation type: $evaluationType\
            \nOne-writer rule type: $oneWriterType\
	    \n# of nodes: [llength $nodes]\
	    \n# of arcs: [llength $arcs]\
	    \nInitial state: $init_state "
    $w centerOnScreen
}

################################################################
#### highlightState
# Highlight those states with the name.
#
body ::tycho::EditSTD::highlightState {name} {
    set curHighLtStateId ""
    set allNodeId [$slate find withtag node]
    foreach nodeId $allNodeId {
        # Find those node with text "name"
	if {$name == [$slate itemcget $nodeId -text]} {
	    lappend curHighLtStateId $nodeId
	}
    }

    if {$curHighLtStateId != ""} {
        $this clearHighlightState

        foreach id $curHighLtStateId {
            $slate itemconfigure $id -fill skyblue
        }

        set preHighLtStateId $curHighLtStateId
    }
}

################################################################
#### ioPortNames
# Edit the I/O portNames of the STD.
#
body ::tycho::EditSTD::ioPortNames {} {

    set w $prefix.stdIOPortNames
    if [winfo exists $w] {
	wm deiconify $w
	raise $w
    } else {
	set name [file tail [file rootname [filename]]]
	set titleLabel "Edit I/O Port Names of $name"

	set inPortQuery [list line inPort {InPort  names:} $portNames(in)]
	set outPortQuery [list line outPort {OutPort names:} $portNames(out)]
	set internalQuery [list line internalEvents {Internal event names:}\
		    $portNames(internal)]

	::tycho::Query $w -title "STD I/O Port Names"\
		-text $titleLabel \
		-queries [list $inPortQuery $outPortQuery $internalQuery]\
		-okcommand "$this ioPortNamesDone $w"

	$w centerOnScreen
    }
}

###################################################################
#### ioPortNamesDone
# Only used by ioPortNames.
#
body ::tycho::EditSTD::ioPortNamesDone {w} {
    set newInPortNames [$w get inPort]
    if {$portNames(in) != $newInPortNames} {
	set portNames(in) $newInPortNames
	$this markModified
    }

    set newOutPortNames [$w get outPort]
    if {$portNames(out) != $newOutPortNames} {
	set portNames(out) $newOutPortNames
	$this markModified
    }

    set newInternalEvents [$w get internalEvents]
    if {$portNames(internal) != $newInternalEvents} {
	set portNames(internal) $newInternalEvents
	$this markModified
    }	
}

###################################################################
#### lookInside.
# Look inside an item with tag $tag.
#
body ::tycho::EditSTD::lookInside {tag} {
    set id [$slate find withtag $tag]
    if {[lsearch -exact [$slate gettags $id] node] >= 0} {
	# If item is a node (state).
	$this lookInsideState $id
    }
}

###################################################################
#### lookInsideState.
# Look inside a state (node) with id $node.
#
body ::tycho::EditSTD::lookInsideState {node} {
	if "![info exists nodeInfo($node,slave)]" {
	    set nodeInfo($node,slave) ""
	}
	set name $nodeInfo($node,slave)	
	$this popUpFile $name
}


##############################################################
#### makeIcon
# Make a icon for this STD to be put into a VEM palette facet.
body ::tycho::EditSTD::makeIcon {} {

    set w $prefix.stdMakeIcon
    if [winfo exists $w] {
	wm deiconify $w
	raise $w
    } else {
	set srcdirQuery [list line srcdir {Src File Directory:}\
		$makeIconSrcDir]

	set paletteQuery [list line palette {Pathname of Palette:}\
		$makeIconPaletteName]

	::tycho::Query $w -title "stdMakeIcon" -text "Make Icon"\
		-queries [list $srcdirQuery $paletteQuery]\
		-okcommand "$this makeIconOk $w"

	$w centerOnScreen
    }
}

##############################################################
#### makeIconOk
body ::tycho::EditSTD::makeIconOk {w} {
    set name [file tail [file rootname [filename]]]
    set makeIconSrcDir [$w get srcdir]
    set makeIconPaletteName [$w get palette]
    # It doesn't matter in which domain this icon is made.
    ptkSetMkStar $name SDF $makeIconSrcDir $makeIconPaletteName
}

################################################################
#### modifyOptions
# Modify the options, like machineType, evaluationType.
#
body ::tycho::EditSTD::modifyOptions {} {

    set w $prefix.stdmodifyOptions
    if [winfo exists $w] {
	wm deiconify $w
	raise $w
    } else {
	set name [file tail [file rootname [filename]]]
	set titleLabel "Modify options of $name"

	set machineTypeQuery [list radio machineType {Machine Type:}\
		$machineChoices $machineType]

	set evaluationTypeQuery [list radio evaluationType {Evaluation Type:}\
		$evaluationChoices $evaluationType]

	set oneWriterTypeQuery [list radio oneWriterType\
		{One-writer rule type:} $oneWriterChoices $oneWriterType]

	::tycho::Query $w -title "STD modification of options"\
		-text $titleLabel \
		-queries [list $machineTypeQuery $evaluationTypeQuery\
                          $oneWriterTypeQuery]\
		-okcommand "$this modifyOptionsDone $w"

	$w centerOnScreen
    }
}

###################################################################
#### modifyOptionsDone
# Only used by modifyOptions.
#
body ::tycho::EditSTD::modifyOptionsDone {w} {
    set newMachineType [$w get machineType]
    if {$machineType != $newMachineType} {
	set machineType $newMachineType
	$this markModified
    }

    set newEvaluationType [$w get evaluationType]
    if {$evaluationType != $newEvaluationType} {
	set evaluationType $newEvaluationType
	$this markModified
    }

    set newOneWriterType [$w get oneWriterType]
    if {$oneWriterType != $newOneWriterType} {
	set oneWriterType $newOneWriterType
	$this markModified
    }
}

##############################################################
#### popUpFile
body ::tycho::EditSTD::popUpFile {name} {
    if {$name == ""} {
	error "No galaxy for the slave process is specified yet."
    }

    set name [::tycho::expandPath $name]

    if [file exists $name] {
	::tycho::File::openContext $name
    } else {
	error "Specified galaxy for the slave process does not exist."
    }
}

##############################################################
#### ptkCompile
# Compile this STD into Ptolemy using ptcl code.
# This method can used only when invoked from Ptolemy.
# FIXME : Should add some code to check if Ptolemy exists.
body ::tycho::EditSTD::ptkCompile {} {
    if "![file exists [filename]]" {
	error "The specified STD file doesn't exist. "
    }

    # set the name for the FSM galaxy.
    set name [file tail [file rootname [filename]]]

    # Create a galaxy :
    defgalaxy $name {
	domain FSM

	# Setup Target.
	target default-FSM
	# Set Target parameters.
	set inPorts "";
	foreach inName $portNames(in) {
	    append inPorts \"$inName\"     ;#" (emacs highlighting)
	}
	targetparam inputNameMap $inPorts
	set outPorts "";
	foreach outName $portNames(out) {
	    append outPorts \"$outName\"     ;#" (emacs highlighting)
	}
	targetparam outputNameMap $outPorts
	set internalEvents "";
	foreach internalName $portNames(internal) {
	    append internalEvents \"$internalName\"  ;#" (emacs highlighting)
	}
	targetparam internalNameMap $internalEvents

        targetparam machineType $machineType
	targetparam evaluationType $evaluationType
	if {$evaluationType == "Strict" && $oneWriterType == "Run"} {
	    set oneWriterType Compile
	}
        targetparam oneWriterType $oneWriterType
        
        # Setup In/Out Ports
        if {$machineType == "Pure"} {
            star DataIn  DataInInt
            star DataOut DataOutInt
        }
	numports DataIn input [llength $portNames(in)]
	numports DataOut output [llength $portNames(out)]
        set count 1
	foreach inName $portNames(in) {
	    alias $inName DataIn input#$count
	    incr count
	}
        set count 1
	foreach outName $portNames(out) {
	    alias $outName DataOut output#$count
	    incr count
	}
        
	# Step through all the nodes in the canvas.
	# Creating a star for each node : 
	foreach node [$slate find withtag node] {
	    set star$node [$slate itemcget $node -text]
	    star [set star$node] $evaluationType$machineType
	}

	# Set initial state
	set init_state_id [$slate find withtag init_state]
	if {$init_state_id == ""} {
	    error "EditSTD: No initial state is specified. "
	} elseif {[llength $init_state_id] > 1} {
	    error "EditSTD: Only one initial state is allowed. "
	} else {
	    # Setup one initial state :
	    setstate [set star$init_state_id] isInitState YES
	}
    
	# Set the parameters for each star :
	foreach node [$slate find withtag node] {

	    if { ![info exists nodeInfo($node,slave)] } {
		setstate [set star$node] slaveNm ""
		setstate [set star$node] where_is_defined ""
	    } else {
		set slaveNm [file tail $nodeInfo($node,slave)]
		setstate [set star$node] slaveNm $slaveNm
		set dirname [file dirname $nodeInfo($node,slave)]
		setstate [set star$node] where_is_defined $dirname
	    }

	    set conditions ""
	    set actions ""
	    set preemptive ""
	    set entryType ""
	    foreach arc $nodeInfo($node,outEdges) {
                set label [$slate itemcget $edgeInfo($arc,label) -text]
		if {$label==""} {
		    append conditions "{}"
		    append actions "{}"

		} else {
		    set slashIndx [string first "/" $label]
                    if {$slashIndx == -1} {
                        append conditions \{[transGuard $label]\}
                        append actions "{}"
                    } elseif {$slashIndx == 0} {
                        append conditions "{}"
                        append actions \{[transAction\
                            [string range $label 1 end]]\}
                    } else {
                        append conditions \{[transGuard\
                            [string range $label 0 [expr $slashIndx-1]]]\}
                        append actions \{[transAction\
                            [string range $label [expr $slashIndx+1] end]]\}
                    }
		}

		if "![info exists edgeInfo($arc,preemptive)]" {
		    set edgeInfo($arc,preemptive) NO
		}
		if {$edgeInfo($arc,preemptive) == "NO"} {
		    append preemptive "0\ "
		} elseif {$edgeInfo($arc,preemptive) == "YES"}  {
		    append preemptive "1\ "
		} else {
		    error "EditSTD: Unrecognized preemptive! "
		}

		if "![info exists edgeInfo($arc,entryType)]" {
		    set edgeInfo($arc,entryType) History
		}
		if {$edgeInfo($arc,entryType) == "History"} {
		    append entryType "0\ "
		} elseif {$edgeInfo($arc,entryType) == "Default"}  {
		    append entryType "1\ "
		} else {
		    error "EditSTD: Unrecognized entryType! "
		}
	    }
	    setstate [set star$node] conditions $conditions
	    setstate [set star$node] actions $actions
	    setstate [set star$node] preemptive $preemptive
	    setstate [set star$node] entryType $entryType
	} 

	# Do the output connection of each star :
	foreach node [$slate find withtag node] {
	    numports [set star$node] stateOut \
		    [llength $nodeInfo($node,outEdges)]
	    set count 1
	    foreach arc $nodeInfo($node,outEdges) {
		connect [set star$node] stateOut#$count \
			[set star$edgeInfo($arc,dest)] stateIn
		incr count
	    }
	}

    }

    # Done
}

###################################################################
#### setInitialState
# If the specified item is a node, mark it as the initial state
# of the STD.
#
body ::tycho::EditSTD::setInitialState {tag} {
    set item [$slate find withtag $tag]
    if {$item == {}} return
    
    if {[lsearch -exact [$slate gettags $item] node] >= 0} {
	# Item is a node.  See if there is already an initial state.
	set init_state_id [$slate find withtag init_state]
	if {$init_state_id != ""} {
	    $slate itemconfigure $init_state_id -width 1.0
	    $slate dtag init_state
	}
	$slate addtag init_state withtag $item
	$slate itemconfigure $item -width 5.0
	$this markModified
    }
}

#######################################################################
#### setOptions
#
body ::tycho::EditSTD::setOptions {machine evaluation oneWriter} {
    if {[lsearch $machineChoices $machine] == -1} {
	"$machine is an unknown machine type!\
		Possible choices: $machineChoices"
    } else {
	set machineType $machine
    }

    if {[lsearch $evaluationChoices $evaluation] == -1} {
	"$evaluation is an unknown evaluation type!\
		Possible choices: $evaluationChoices"
    } else {
	set evaluationType $evaluation
    }

    if {[lsearch $oneWriterChoices $oneWriter] == -1} {
	"$oneWriter is an unknown one-writer checking type!\
		Possible choices: $oneWriterChoices"
    } else {
	set oneWriterType $oneWriter
    }
}

#######################################################################
#### setPortNames
#
body ::tycho::EditSTD::setPortNames {in out internal} {
    set portNames(in)       $in
    set portNames(out)      $out
    set portNames(internal) $internal
}

#####################################################################
#### setReadOnly
# Specify whether or not modifications are allowed in the displayed text.
# Note that this is independent of whether the associated file is readonly.
# It merely determines whether the buffer can be modified, not whether the
# file can be modified.  To control the file, use <code>toggleReadOnly</code>.
#
body ::tycho::EditSTD::setReadOnly {bool} {
    ::tycho::File::setReadOnly $bool
    if [winfo exists $prefix] {
	if {$bool} {
	    menubar disable {Edit Item}
            menubar disable {Delete}
	} {
	    menubar enable {Edit Item}
            menubar enable {Delete}
	}
    }
}

    ##########################################################################
    ####                     protected methods                            ####

#####################################################################
#### initialize
# Initialize the menu, status, and toolbars associated with this widget.
# The root (view) class sets up the menubar methods in it's initialize
# via the chain command, which should always be the first command in
# this method.
# 
# This method is called by it's displayer when attachView is called (usually
# in ::tycho::view
#
body ::tycho::EditSTD::initialize {{menubar {}} {statusbar {}} {toolbar {}}} {
    chain $menubar $statusbar $toolbar

    if {$menubar != {}} {
        # We have to qualify the call to this supposed-ly private
        # method because Itcl (2.2) has virtual private methods!
        ::tycho::EditSTD::initializeMenubar $menubar
    }
}

#######################################################################
#### insertData
# Append the specified data to the existing display.
#
body ::tycho::EditSTD::insertData {data} {
    if [getReadOnly] {bell; return}
    if {[catch {eval $data} msg]} {
	error "$msg "
    }
}

################################################################
#### saveText
# Save the contents of the canvas widget as text, and return it.
# This method is invoked by the "save" method.
#
body ::tycho::EditSTD::saveText {} {
    # Identification header comment 
    set name [file tail [filename]]
    set text "### State transition diagram : $name\n"

    # First, save the canvas dimensions
    append text "\n### Canvas widget dimensions\n"
    set height [winfo height $slate]
    if {$height == 1} {
        # Canvas has not been mapped yet
        set height [cget -canvasheight]
    }
    append text "\$this configure -canvasheight $height\n"
    set width [winfo width $slate]
    if {$width == 1} {
        # Canvas has not been mapped yet
        set width [cget -canvaswidth]
    }
    append text "\$this configure -canvaswidth $width\n"

    # Machine type
    append text "### Machine type: $machineType\n"
    append text "\$this setOptions [list $machineType $evaluationType\
        $oneWriterType]\n"

    # Set member variables
    append text "\n### Member variables\n"
    # I/O port names
    append text "\$this setPortNames \
         [list $portNames(in) $portNames(out) $portNames(internal)]\n"

    # Step through all the nodes in the canvas.
    append text "\n### Creating the nodes\n"
    foreach node [$slate find withtag node] {
	# Generate code to draw the node as an oval on the canvas.
	append text "set node$node\
		\[\$slate create LabeledOval [$slate coords $node]\
		-outline black -fill white -tags node \
		-text [list [$slate itemcget $node -text]]\]\n"
	append text "set nodeInfo(\$node$node,inEdges) \{\}\n"
	append text "set nodeInfo(\$node$node,outEdges) \{\}\n"

	# Generate code to draw the label.
# 	append text "set nodeInfo(\$node$node,label)\
# 		\[\$slate create text\
# 		[$slate coords $nodeInfo($node,label)] -fill black"
# 	set label [$slate itemcget $node -text]
# 	if {$label != {}} {
# 	    append text " -text \{$label\}"
# 	}
#	append text "\]\n"

        # Slave Process
        if "[info exists nodeInfo($node,slave)]" {
	    append text "# Slave Process:\n"
	    append text "set nodeInfo(\$node$node,slave)\
		    [list $nodeInfo($node,slave)]\n"
	}

	append text "\n"
    }
    
    # See if the initial state is specified.  If so, generate
    # code to set the initial state.
    set init_state_id [$slate find withtag init_state]
    if {[llength $init_state_id] > 1} {
	error "Internel error: more than one initial state!!! "
    } elseif {$init_state_id != ""} {
	append text "### Initial state\n"
	append text "\$slate addtag init_state withtag \$node$init_state_id\n"
	append text "\$slate itemconfigure \$node$init_state_id -width 5.0\n"
    }

    # Step through all the arcs in the canvas.
    append text "\n### Creating the arcs\n"
    foreach arc [$slate find withtag arc] {
	set smooth [$slate itemcget $arc -smooth]
	append text "set arc \[\$slate create line\
		[$slate coords $arc] -arrow last -tags arc -fill black\
		-smooth $smooth\]\n"
	# Set up the corresponding nodeInfo and edgeInfo entries.
	set src $edgeInfo($arc,src)
	append text "set edgeInfo(\$arc,src) \$node$src\n"
	append text "lappend nodeInfo(\$node$src,outEdges) \$arc\n"
	set dest $edgeInfo($arc,dest)
	append text "set edgeInfo(\$arc,dest) \$node$dest\n"
	append text "lappend nodeInfo(\$node$dest,inEdges) \$arc\n"

	# Set up the points of the arc.
	foreach point $edgeInfo($arc,points) {
	    append text "set point \[\$slate create rectangle\
		    [$slate coords $point] -fill \{\} -outline \{\}\]\n"
	    append text "lappend edgeInfo(\$arc,points) \$point\n"
	}
	
	# Set up the "outSlope", "outXneg", "inSlope", and "inXneg"
	# entries.
	append text "set edgeInfo(\$arc,outSlope) $edgeInfo($arc,outSlope)\n"
	append text "set edgeInfo(\$arc,outXneg) $edgeInfo($arc,outXneg)\n"
	append text "set edgeInfo(\$arc,inSlope) $edgeInfo($arc,inSlope)\n"
	append text "set edgeInfo(\$arc,inXneg) $edgeInfo($arc,inXneg)\n"
	
	set mid_xy [$this lineMidpoint $arc]
	set mid_x [lindex $mid_xy 0]
	set mid_y [lindex $mid_xy 1]
	append text "set edgeInfo(\$arc,label)\
		\[\$slate create text\
		[expr $mid_x + $edgeInfo($arc,label_deltax)]\
		[expr $mid_y + $edgeInfo($arc,label_deltay)]\
		-fill black"
	set label [$slate itemcget $edgeInfo($arc,label) -text]
	if {$label != {}} {
	    append text " -text \{$label\}"
	}
	append text "\]\n"

	append text "set edgeInfo(\$arc,label_deltax)\
		$edgeInfo($arc,label_deltax)\n"
	append text "set edgeInfo(\$arc,label_deltay)\
		$edgeInfo($arc,label_deltay)\n"

	# Preemptive.
	if [info exists edgeInfo($arc,preemptive)] {
	    append text "set edgeInfo(\$arc,preemptive)\
		    $edgeInfo($arc,preemptive)\n"
	}
	
	# Entry type. 
	if [info exists edgeInfo($arc,entryType)] {
	    append text "set edgeInfo(\$arc,entryType)\
		    $edgeInfo($arc,entryType)\n"
	}

	append text "\n"
    }
    
    # Done
    append text "### End of File\n"

    return $text
}

################################################################
#### transAction
# Translate the action of an arc into desired format.
# -- Each output symbol is substituted by n, where n is the index 
#    of the symbol in the (output port+internal event) name list.
#
body ::tycho::EditSTD::transAction {action} {
    set length [string length $action]
    set start 0
    set end 0

    set result ""
    while {1} {
	while {$start<$length} {
	    set char [string range $action $start $start]
	    if {$char==" " || $char==","} {
		incr start
	    } else {
		break
	    }
	}

	set end $start
	while {$end<$length} {
	    set char [string range $action $end $end]
	    if {$char==" " || $char==","} {
		break
	    } else {
		incr end
	    }
	}

	if {$start==$length} { break }

	set variable [string range $action $start [expr $end-1]]
	if {[set indx [lsearch $portNames(internal) $variable]]!=-1} {
	    lappend result $indx
	} elseif {[set indx [lsearch $portNames(out) $variable]]!=-1} {
	    lappend result [expr [llength $portNames(internal)]+$indx]
	} else {
	    error "$variable is not an output nor an internal event!" 
	}

	set start $end
    }

    return $result
}

################################################################
#### transGuard
# Translate the guard of an arc into desired format.
# -- Each input symbol is substituted by $input(n), where n is the
#    index of the symbol in the (input port+internal event) name list.
# -- Check if invalid operator exists. <--- Not implement.
#
body ::tycho::EditSTD::transGuard {guard} {
    set validOp "! | & { }" ;# Valid operators or blank
    set invalidOp "> < ="   ;# Invalid operators

    set length [string length $guard]
    set start 0
    set end 0

    set result ""
    while {1} {
	while {$start<$length} {
	    set char [string range $guard $start $start]
	    if {[lsearch $invalidOp $char] != -1} {
		error "$char is invalid operator for $machineType machine!"
	    } elseif {[lsearch $validOp $char] != -1} {
		append result $char
		incr start
	    } else {
		break
	    }
	}

	set end $start
	while {$end<$length} {
	    set char [string range $guard $end $end]
	    if {[lsearch $invalidOp $char] != -1} {
		error "$char is invalid operator for $machineType machine!"
	    } elseif {[lsearch $validOp $char] != -1} {
		break
	    } else {
		incr end
	    }
	}

	if {$start==$length} { break }

	set variable [string range $guard $start [expr $end-1]]
	if {[set indx [lsearch $portNames(internal) $variable]]!=-1} {
	    append result "\$input($indx)"
	} elseif {[set indx [lsearch $portNames(in) $variable]]!=-1} {
	    append result "\$input([expr [llength $portNames(internal)]+$indx])"
	} elseif {[regexp {[0-9*]} $variable]} {
	    append result $variable
	} else {
	    error "$variable is not an input nor an internal event!" 
	}

	set start $end
    }

    return $result
}

#########################################################################
#########################################################################
####                     private methods                             ####

#####################################################################
#### initializeMenubar
# Initialize the menu bar.  Adds entries specific to this class.
#
body ::tycho::EditSTD::initializeMenubar {menubar} {
    # Add items into File menu
    $menubar insert "Look Inside" "Close" \
	    -underline 5 -accelerator "i" -command "$this lookInside selected"
    $menubar insertSeparator "Close"

    # Enable items in Edit menu
    $menubar enable "Edit Item"

    # Change command of items in Edit menu
    $menubar entryconfigure {Edit Item} \
	    -command "$this editItem selected"

    # Add items into Special menu
    $menubar insert "I/O Port Names..." "Smooth Toggle" \
	    -underline 0 -command "$this ioPortNames"
    $menubar insert "Set Initial State" "Smooth Toggle" \
	    -underline 0 -command "$this setInitialState selected"
    $menubar insertSeparator "Smooth Toggle"

    $menubar insert "Make Icon..." "Get Info" -underline 0 \
            -command "$this makeIcon"

    $menubar insert "Options..." "Make Icon..." -underline 0 \
            -command "$this modifyOptions"
}
