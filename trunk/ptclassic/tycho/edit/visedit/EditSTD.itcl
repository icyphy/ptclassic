# A graphical entry tool for state transition diagrams (STD).
#
# @Author: Bilung Lee
#
# @Version: $Id$
#
# @Copyright (c) 1995-%Q% The Regents of the University of California.
# All rights reserved.
# 
# Permission is hereby granted, without written agreement and without
# license or royalty fees, to use, copy, modify, and distribute this
# software and its documentation for any purpose, provided that the
# above copyright notice and the following two paragraphs appear in all
# copies of this software.
# 
# IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY
# FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
# ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF
# THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.
# 
# THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE
# PROVIDED HEREUNDER IS ON AN "AS IS" BASIS, AND THE UNIVERSITY OF
# CALIFORNIA HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,
# ENHANCEMENTS, OR MODIFICATIONS.
# 
# 						PT_COPYRIGHT_VERSION_2
# 						COPYRIGHTENDKEY
#######################################################################

#######################################################################
#### EditSTD
# A graphical editor for editing the state transition diagrams (STD).
# It recognizes the file extension ".std".
#

class ::tycho::EditSTD {
    inherit ::tycho::EditBubbleAndArc

    ##########################################################################
    ####                      constructor & destructor                    ####
    constructor {args} {}
    destructor {}

    ##########################################################################
    ####                         public methods                           ####

    # Clear the display, discarding the current items.
    method clear {}

    method editArc {arc} 
    method editArcDone {arc w}

    # Invoked by the "Edit Item" command in the Edit menu.
    # It invokes the "editState" or "editArc" methods depending on 
    # whether the item is a node or an arc.
    method editItem {item}

    method editState {node} 
    method editStateDone {node w} 

    # getInfo
    method getInfo {} 
 
    # To set the names of the I/O ports & internal events
    method ioPortNames {}
    method ioPortNamesDone {w}

    # Look inside an item with tag $tag.
    method lookInside {tag}
    
    # Look inside a state with id $node.
    method lookInsideState {node}

    # makeIcon
    method makeIcon {}
    method makeIconOk {w}

    # Pop up a file
    method popUpFile {name}

    # The following methods are used only when work with Ptolemy
    method ptkCompile {}

    # Invoked by the "Set Initial State" command in the Edit menu.
    method setInitialState {tag} 

    # Set the machine type.
    method setMachineType {type}

    # Specify whether or not modifications are allowed in the displayed text.
    method setReadOnly {bool}

    ##########################################################################
    ####                     protected methods                            ####

    # Insert the specified data into the canvas.
    protected method insertData {data}

    # Return the text to save.
    protected method saveText {}

    ##########################################################################
    ####                     protected variables                          ####

    # The name of the Tk canvas as a variable, for convenience.
    protected variable canvas

    # Machine type of this state transition diagram.
    protected variable machineType

    # Names of the I/O ports.  This is an array with two elements:
    # "in" and "out".
    protected variable portNames

    # Store the value used in makeIcon last time.
    protected common makeIconSrcDir {[file join $PTOLEMY src domains fsm demo]}
    protected common makeIconPaletteName "user.pal"
}

##########################################################################
####  constructor & destructor
#
body ::tycho::EditSTD::constructor {args} {
    interactiveEnable 0

    # Add items into File menu
    menubar insertMenuItem "Look Inside" "Close" File \
	    -underline 5 -accelerator "i" -command "$this lookInside selected"
    menubar insertMenuSeparator "Close" File

    # Enable items in Edit menu
    menubar enableMenuItem "Edit Item" Edit

    # Renew items in Edit menu
    menubar addMenuItem {Edit Item} Edit -underline 0 \
	    -command "$this editItem selected"

    # Add items into Special menu
    menubar insertMenuItem "I/O Port Names..." "Smooth Toggle" Special \
	    -underline 0 -command "$this ioPortNames"
    menubar insertMenuItem "Set Initial State" "Smooth Toggle" Special \
	    -underline 0 -command "$this setInitialState selected"
    menubar insertMenuSeparator "Smooth Toggle" Special

    menubar insertMenuItem "Make Icon..." "Get Info" Special -underline 0 \
            -command "$this makeIcon"

    # Initialize the variables.
    set canvas [canvasName]

    # Initialize the io portNames array elements.
    set portNames(in)  ""
    set portNames(out) ""
    set portNames(internal) ""

    # Setup menu hot key and mouse binding
    bind $canvas <Key-e> "$this editItem selected"
    bind $canvas <Double-1> "$this editItem current"
    bind $canvas <Key-i> "$this lookInside current"

    # The following initialize options and then invoke any
    # configuration options, assuming there are options specified.
    eval itk_initialize $args 

    # Need to load the startup file here again, otherwise
    # the member variables of this derived class will be lost,
    # such as portNames(in), portNames(out) and portNames(internal).
    $this reload

    # If no machine type is specified yet, initialize it.
    if {![info exists machineType]} {
	set w $prefix.editMachineType
	::tycho::DialogWindow $w -title "Edit the Machine Type"\
		-text "Press button to choose the machine type:"
	$w addButton mixed -text "Mixed"\
		-command "$this setMachineType Mixed; destroy $w"
	$w centerOnScreen
	tkwait window $w
    }

    interactiveEnable 1
}

    ##########################################################################
    ####                         public methods                           ####

#######################################################################
#### clear
# Clear the display, discarding the current graphics and corresponding
# data structure.
#
body ::tycho::EditSTD::clear {} {
    if [getReadOnly] {bell; return}

#    foreach node [$canvas find withtag node] {
#	# destroy the corresponding edit state window if it exists.
#	set w $prefix.stdEditState$node
#	if [winfo exists $w] { destroy $w }
#    }
#    foreach arc [$canvas find withtag arc] {
#	# destroy the corresponding edit arc window if it exists.
#	set w $prefix.stdEditArc$arc
#	if [winfo exists $w] { destroy $w }
#    } 

    $canvas delete all
    foreach index [array names nodeInfo] {
	unset nodeInfo($index)
    }
    foreach index [array names edgeInfo] {
	unset edgeInfo($index)
    }
}

###################################################################
#### editArc and editArcDone
# Edit an arc.
#
body ::tycho::EditSTD::editArc {arc} {
    set w $prefix.stdEditArc$arc
    if [winfo exists $w] {
	wm deiconify $w
	raise $w
    } else {

	set arcLabel [$canvas itemcget $edgeInfo($arc,label) -text]
	set src [$canvas itemcget $nodeInfo($edgeInfo($arc,src),label) -text]
	set dest [$canvas itemcget $nodeInfo($edgeInfo($arc,dest),label) -text]
	set title "Edit $machineType Arc \"$arcLabel\"\nSource state: $src\
		\nDestination state: $dest"

	set labelQuery [list label {Label:} $arcLabel]

	if "![info exists edgeInfo($arc,guard)]" {
	    set edgeInfo($arc,guard) ""
	}
	set guardQuery [list guard {Guard:} $edgeInfo($arc,guard)]

	set cmd "$this editArcDone $arc $w"

	::tycho::EntryQuery $w -title "STD Edit $machineType Arc"\
		-text $title -queries [list $labelQuery $guardQuery]\
		-okcommand [list catch $cmd]

	if {$machineType == "Mixed"} {
	    if "![info exists edgeInfo($arc,preemptive)]" {
		set edgeInfo($arc,preemptive) NO
	    } 
	    $w addRadioQuery preemptive {Preemptive} {NO YES}\
		    $edgeInfo($arc,preemptive)

	    if "![info exists edgeInfo($arc,entryType)]" {
		set edgeInfo($arc,entryType) History
	    } 
	    $w addRadioQuery entryType {Entry Type} {History Default}\
		    $edgeInfo($arc,entryType)

	    foreach outName $portNames(out) {
		if "![info exists edgeInfo($arc,output,$outName)]" {
		    set edgeInfo($arc,output,$outName) 0
		} 
		$w addQuery outputFor$outName "Output for \"${outName}\":"\
			$edgeInfo($arc,output,$outName)
	    }

	    foreach internalName $portNames(internal) {
		if "![info exists edgeInfo($arc,action,$internalName)]" {
		    set edgeInfo($arc,action,$internalName) 0
		} 
		$w addQuery actionFor$internalName "Action for\
			\"$internalName\":" \
			$edgeInfo($arc,action,$internalName)
	    }

	}

	$w centerOnScreen
    }
}

body ::tycho::EditSTD::editArcDone {arc w} {
    set label [$canvas itemcget $edgeInfo($arc,label) -text]
    set newLabel [$w get label]
    if {$label != $newLabel} {
	$canvas itemconfigure $edgeInfo($arc,label) -text $newLabel
	$this markModified
    }

    set newGuard [$w get guard]
    if {$edgeInfo($arc,guard) != $newGuard} {
	set edgeInfo($arc,guard) $newGuard
	$this markModified
    }

    if {$machineType == "Mixed"} {
	set newPreemptive [$w get preemptive]
	if {$edgeInfo($arc,preemptive) != $newPreemptive} {
	    set edgeInfo($arc,preemptive) $newPreemptive
	    $this markModified	
	}

	set newEntryType [$w get entryType]
	if {$edgeInfo($arc,entryType) != $newEntryType} {
	    set edgeInfo($arc,entryType) $newEntryType
	    $this markModified	
	}

	foreach outName $portNames(out) {
	    set newValue [$w get outputFor$outName]
	    if {$edgeInfo($arc,output,$outName) != $newValue} {
		set edgeInfo($arc,output,$outName) $newValue
		$this markModified
	    }
	}

	foreach internalName $portNames(internal) {
	    set newValue [$w get actionFor$internalName]
	    if {$edgeInfo($arc,action,$internalName) != $newValue} {
		set edgeInfo($arc,action,$internalName) $newValue
		$this markModified
	    }
	}

    }
}

###################################################################
#### editItem
# Invoked by the "Edit Item" command in the Edit menu.
#
body ::tycho::EditSTD::editItem {item} {
    # The indices in the nodeInfo and edgeInfo arrays
    # are item IDs.
    set id [$canvas find withtag $item]
    if {[lsearch -exact [$canvas gettags $id] node] >= 0} {
	# id is a node.
	$this editState $id
    } elseif {[lsearch -exact [$canvas gettags $id] arc] >= 0} {
	# id is an arc.
	$this editArc $id
    }
}

#########################################################################
#### editState and editStateDone
# Edit a state.
#
body ::tycho::EditSTD::editState {node} {
    
    set w $prefix.stdEditState$node
    if [winfo exists $w] {
	wm deiconify $w
	raise $w
    } else {

	set nodeLabel [$canvas itemcget $nodeInfo($node,label) -text]
	set title "Edit $machineType State \"$nodeLabel\""
	set labelQuery [list label {Label:} $nodeLabel]

	set cmd "$this editStateDone $node $w"

	::tycho::EntryQuery $w -title "STD Edit $machineType State" \
		-text $title -queries [list $labelQuery]\
		-okcommand [list catch $cmd]

	if {$machineType == "Mixed"} {
	    if "![info exists nodeInfo($node,machine)]" {
		set nodeInfo($node,machine) ""
	    }
	    $w addQuery machine {Internal Machine:} $nodeInfo($node,machine)
	}

	$w centerOnScreen
    }


}

body ::tycho::EditSTD::editStateDone {node w} {

    set label [$canvas itemcget $nodeInfo($node,label) -text]
    set newLabel [$w get label]
    if {$label != $newLabel} {
	$canvas itemconfigure $nodeInfo($node,label) -text $newLabel
	$this markModified
    }

    if {$machineType == "Mixed"} {
	set newMachine [$w get machine]
	if {$nodeInfo($node,machine) != $newMachine} {
	    set nodeInfo($node,machine) $newMachine
	    $this markModified	
	}
    }
}

##############################################################
#### getInfo
body ::tycho::EditSTD::getInfo {} {
    set nodes [$canvas find withtag node]
    set arcs [$canvas find withtag arc]
    set w $prefix.getInfo
    catch {destroy $w}
    ::tycho::Message $w -text "Machine type: $machineType\
	    \n# of nodes  : [llength $nodes]\
	    \n# of arcs   : [llength $arcs]"
    $w centerOnScreen
}

################################################################
#### ioPortNames
# Edit the I/O portNames of the STD.
#
body ::tycho::EditSTD::ioPortNames {} {

    set w $prefix.stdIOPortNames
    if [winfo exists $w] {
	wm deiconify $w
	raise $w
    } else {
	set name [file tail [file rootname $file]]
	set titleLabel "Edit I/O Port Names of $name"

	set inPortQuery [list inPort {InPort  names:} $portNames(in)]
	set outPortQuery [list outPort {OutPort names:} $portNames(out)]
	set internalQuery [list internalEvents {Internal event names:}\
		    $portNames(internal)]

	::tycho::EntryQuery $w -title "STD I/O Port Names"\
		-text $titleLabel \
		-queries [list $inPortQuery $outPortQuery $internalQuery]\
		-okcommand "$this ioPortNamesDone $w"

	$w centerOnScreen
    }
}

###################################################################
#### ioPortNamesDone
# Only used by ioPortNames.
#
body ::tycho::EditSTD::ioPortNamesDone {w} {
    set newInPortNames [$w get inPort]
    if {$portNames(in) != $newInPortNames} {
	set portNames(in) $newInPortNames
	$this markModified
    }

    set newOutPortNames [$w get outPort]
    if {$portNames(out) != $newOutPortNames} {
	set portNames(out) $newOutPortNames
	$this markModified
    }

    set newInternalEvents [$w get internalEvents]
    if {$portNames(internal) != $newInternalEvents} {
	set portNames(internal) $newInternalEvents
	$this markModified
    }	
}

###################################################################
#### lookInside.
# Look inside an item with tag $tag.
#
body ::tycho::EditSTD::lookInside {tag} {
    set id [$canvas find withtag $tag]
    if {[lsearch -exact [$canvas gettags $id] node] >= 0} {
	# If item is a node (state).
	$this lookInsideState $id
    }
}

###################################################################
#### lookInsideState.
# Look inside a state (node) with id $node.
#
body ::tycho::EditSTD::lookInsideState {node} {
	if "![info exists nodeInfo($node,machine)]" {
	    set nodeInfo($node,machine) ""
	}
	set name $nodeInfo($node,machine)	
	$this popUpFile $name
}


##############################################################
#### makeIcon
# Make a icon for this STD to be put into a VEM palette facet.
body ::tycho::EditSTD::makeIcon {} {

    set w $prefix.stdMakeIcon
    if [winfo exists $w] {
	wm deiconify $w
	raise $w
    } else {
	set srcdirQuery [list srcdir {Src File Directory:}\
		$makeIconSrcDir]

	set paletteQuery [list palette {Pathname of Palette:}\
		$makeIconPaletteName]

	::tycho::EntryQuery $w -title "stdMakeIcon" -text "Make Icon"\
		-queries [list $srcdirQuery $paletteQuery]\
		-okcommand "$this makeIconOk $w"

	$w centerOnScreen
    }
}

##############################################################
#### makeIconOk
body ::tycho::EditSTD::makeIconOk {w} {
    set name [file tail [file rootname $file]]
    set makeIconSrcDir [$w get srcdir]
    set makeIconPaletteName [$w get palette]
    # It doesn't matter in which domain this icon is made.
    ptkSetMkStar $name SDF $makeIconSrcDir $makeIconPaletteName
}

##############################################################
#### popUpFile
body ::tycho::EditSTD::popUpFile {name} {
    if {$name == ""} {
	error "No galaxy for the machine is specified yet."
    }

    set name [::tycho::expandPath $name]

    if [file exists $name] {
	if [file isdirectory $name] {
	    # name is a directory, then consider it as a Oct facet.
	    if [catch {ptkOpenFacet $name}] {
		error "Can't open a Oct file for the machine.\
			This needs Ptolemy to exist. "
	    }
	    
	    pvOpenWindow [ptkOpenFacet $name]
	} else {
	    # name is a file, pass it to ::tycho::File::openContext
	    ::tycho::File::openContext $name
	}
    } else {
	error "Specified galaxy for the machine does not exist."
    }
}

##############################################################
#### ptkCompile
# Compile this STD into Ptolemy using ptcl code.
# This method can used only when invoked from Ptolemy.
# FIXME : Should add some code to check if Ptolemy exists.
body ::tycho::EditSTD::ptkCompile {} {

    if "![file exists $file]" {
	error "The specified STD file doesn't exist. "
    }

    # set the name for the FSM galaxy.
    set name [file tail [file rootname $file]]

    # Create a galaxy :
    defgalaxy $name {
	domain FSM

	# Setup Target.
	target default-FSM
	# Set Target parameters.
	set inPorts "";
	foreach inName $portNames(in) {
	    append inPorts \"$inName\"
	}
	targetparam inputNameMap $inPorts
	set outPorts "";
	foreach outName $portNames(out) {
	    append outPorts \"$outName\"
	}
	targetparam outputNameMap $outPorts
	if {$machineType == "Mixed"} {
	    set internalEvents "";
	    foreach internalName $portNames(internal) {
		append internalEvents \"$internalName\"
	    }
	    targetparam internalNameMap $internalEvents
	}
        targetparam machineType $machineType
        
        # Setup In/Out Ports
        star DataInStar DataIn
        star DataOutStar DataOut
	numports DataInStar input [llength $portNames(in)]
	numports DataOutStar output [llength $portNames(out)]
        set count 1
	foreach inName $portNames(in) {
	    alias $inName DataInStar input#$count
	    incr count
	}
        set count 1
	foreach outName $portNames(out) {
	    alias $outName DataOutStar output#$count
	    incr count
	}
        
	# Step through all the nodes in the canvas.
	# Creating a star for each node : 
	foreach node [$canvas find withtag node] {
	    set star$node [$canvas itemcget $nodeInfo($node,label) -text]
	    star [set star$node] $machineType
	}

	# Set initial state
	set init_state_id [$canvas find withtag init_state]
	if {$init_state_id == ""} {
	    error "No initial state is specified. "
	} elseif {[llength $init_state_id] > 1} {
	    error "Only one initial state is allowed. "
	} else {
	    # Setup one initial state :
	    setstate [set star$init_state_id] isInitState YES
	}
    
	# Set the parameters for each star :
	foreach node [$canvas find withtag node] {

	    set conditions ""
	    foreach arc $nodeInfo($node,outEdges) {
		if {![info exists edgeInfo($arc,guard)]} {
		    error "A guard is required in each arc. "
		} else {
		    append conditions \"$edgeInfo($arc,guard)\"
		}
	    }
	    setstate [set star$node] conditions $conditions
	 
	    if {$machineType == "Mixed"} {
		# Mixed machine.
		if { ![info exists nodeInfo($node,machine)] } {
		    setstate [set star$node] inMachNm ""
		    setstate [set star$node] where_is_defined ""
		} else {
		    set inMachNm [file tail $nodeInfo($node,machine)]
		    setstate [set star$node] inMachNm $inMachNm
		    set dirname [file dirname $nodeInfo($node,machine)]
		    setstate [set star$node] where_is_defined $dirname
		}

		set preemptive ""
		set entryType ""
		set actions ""
		foreach arc $nodeInfo($node,outEdges) {
		    if "![info exists edgeInfo($arc,preemptive)]" {
			set edgeInfo($arc,preemptive) NO
		    }
		    if {$edgeInfo($arc,preemptive) == "NO"} {
			append preemptive "0\ "
		    } elseif {$edgeInfo($arc,preemptive) == "YES"}  {
			append preemptive "1\ "
		    } else {
			error "Unrecognized preemptive! "
		    }

		    if "![info exists edgeInfo($arc,entryType)]" {
			set edgeInfo($arc,entryType) History
		    }
		    if {$edgeInfo($arc,entryType) == "History"} {
			append entryType "0\ "
		    } elseif {$edgeInfo($arc,entryType) == "Default"}  {
			append entryType "1\ "
		    } else {
			error "Unrecognized entryType! "
		    }

		    append actions "\{"
		    foreach outName $portNames(out) {
			if "![info exists edgeInfo($arc,output,$outName)]" {
			    set edgeInfo($arc,output,$outName) 0
			}
			append actions \"$edgeInfo($arc,output,$outName)\"
		    }
		    foreach internalName $portNames(internal) {
			if "![info exists edgeInfo($arc,action,$internalName)]" {
			    set edgeInfo($arc,action,$internalName) 0
			}
			append actions \"$edgeInfo($arc,action,$internalName)\"
		    }
		    append actions "\}"
		}
		setstate [set star$node] preemptive $preemptive
		setstate [set star$node] entryType $entryType
		setstate [set star$node] actions $actions

	    } else {
		error "Unrecognized machine type: $machineType. "
	    }
	}

	# Do the output connection of each star :
	foreach node [$canvas find withtag node] {
	    numports [set star$node] stateOut \
		    [llength $nodeInfo($node,outEdges)]
	    set count 1
	    foreach arc $nodeInfo($node,outEdges) {
		connect [set star$node] stateOut#$count \
			[set star$edgeInfo($arc,dest)] stateIn
		incr count
	    }
	}
    }

    # Done
}

###################################################################
#### setInitialState
# If the specified item is a node, mark it as the initial state
# of the STD.
#
body ::tycho::EditSTD::setInitialState {tag} {
    set item [$canvas find withtag $tag]
    if {$item == {}} return
    
    if {[lsearch -exact [$canvas gettags $item] node] >= 0} {
	# Item is a node.  See if there is already an initial state.
	set init_state_id [$canvas find withtag init_state]
	if {$init_state_id != ""} {
	    $canvas itemconfigure $init_state_id -width 1.0
	    $canvas dtag init_state
	}
	$canvas addtag init_state withtag $item
	$canvas itemconfigure $item -width 5.0
	$this markModified
    }
}

#######################################################################
#### setMachineType
#
body ::tycho::EditSTD::setMachineType {type} {
    set machineType $type
}

#####################################################################
#### setReadOnly
# Specify whether or not modifications are allowed in the displayed text.
# Note that this is independent of whether the associated file is readonly.
# It merely determines whether the buffer can be modified, not whether the
# file can be modified.  To control the file, use <code>toggleReadOnly</code>.
#
body ::tycho::EditSTD::setReadOnly {bool} {
    ::tycho::File::setReadOnly $bool
    if [winfo exists $prefix] {
	if {$bool} {
	    menubar disableMenuItem {Edit Item} Edit
            menubar disableMenuItem {Delete} Edit
	} {
	    menubar enableMenuItem {Edit Item} Edit
            menubar enableMenuItem {Delete} Edit
	}
    }
}

    ##########################################################################
    ####                     protected methods                            ####

#######################################################################
#### insertData
# Append the specified data to the existing display.
#
body ::tycho::EditSTD::insertData {data} {
    if [getReadOnly] {bell; return}
    if {[catch {eval $data} msg]} {
	error "$msg "
    }
}

################################################################
#### saveText
# Save the contents of the canvas widget as text, and return it.
# This method is invoked by the "save" method.
#
body ::tycho::EditSTD::saveText {} {
    # Identification header comment 
    set name [file tail $file]
    set text "### State transition diagram : $name\n"

    # Machine type
    append text "### Machine type: $machineType\n"
    append text "set machineType $machineType\n"

    # First, save the canvas dimensions
    append text "\n### Canvas widget dimensions\n"
    set height [winfo height $canvas]
    if {$height == 1} {
        # Canvas has not been mapped yet
        set height [cget -canvasheight]
    }
    append text "\$canvas configure -height $height\n"
    set width [winfo width $canvas]
    if {$width == 1} {
        # Canvas has not been mapped yet
        set width [cget -canvaswidth]
    }
    append text "\$canvas configure -width $width\n"

    # Set member variables
    append text "\n### Member variables\n"
    # I/O port names
    append text "# InPort names\n"
    append text "set portNames(in) \"$portNames(in)\"\n"
    append text "# OutPort names\n"
    append text "set portNames(out) \"$portNames(out)\"\n"
    append text "# Internal event names\n"
    append text "set portNames(internal) \"$portNames(internal)\"\n"

    # Step through all the nodes in the canvas.
    append text "\n### Creating the nodes\n"
    foreach node [$canvas find withtag node] {
	# Generate code to draw the node as an oval on the canvas.
	append text "set node$node\
		\[\$canvas create oval [$canvas coords $node]\
		-outline black -fill white -tags node\]\n"
	append text "set nodeInfo(\$node$node,inEdges) \{\}\n"
	append text "set nodeInfo(\$node$node,outEdges) \{\}\n"

	# Generate code to draw the label.
	append text "set nodeInfo(\$node$node,label)\
		\[\$canvas create text\
		[$canvas coords $nodeInfo($node,label)] -fill black"
	set label [$canvas itemcget $nodeInfo($node,label) -text]
	if {$label != {}} {
	    append text " -text \{$label\}"
	}
	append text "\]\n"

	if {$machineType == "Mixed"} {
	    # Internal machine
	    if "[info exists nodeInfo($node,machine)]" {
		append text "# Internal machine:\n"
		append text "set nodeInfo(\$node$node,machine)\
			[list $nodeInfo($node,machine)]\n"
	    }
	} 

	append text "\n"
    }
    
    # See if the initial state is specified.  If so, generate
    # code to set the initial state.
    set init_state_id [$canvas find withtag init_state]
    if {[llength $init_state_id] > 1} {
	error "Internel error: more than one initial state!!! "
    } elseif {$init_state_id != ""} {
	append text "### Initial state\n"
	append text "\$canvas addtag init_state withtag \$node$init_state_id\n"
	append text "\$canvas itemconfigure \$node$init_state_id -width 5.0\n"
    }

    # Step through all the arcs in the canvas.
    append text "\n### Creating the arcs\n"
    foreach arc [$canvas find withtag arc] {
	set smooth [$canvas itemcget $arc -smooth]
	append text "set arc \[\$canvas create line\
		[$canvas coords $arc] -arrow last -tags arc -fill black\
		-smooth $smooth\]\n"
	# Set up the corresponding nodeInfo and edgeInfo entries.
	set src $edgeInfo($arc,src)
	append text "set edgeInfo(\$arc,src) \$node$src\n"
	append text "lappend nodeInfo(\$node$src,outEdges) \$arc\n"
	set dest $edgeInfo($arc,dest)
	append text "set edgeInfo(\$arc,dest) \$node$dest\n"
	append text "lappend nodeInfo(\$node$dest,inEdges) \$arc\n"

	# Set up the points of the arc.
	foreach point $edgeInfo($arc,points) {
	    append text "set point \[\$canvas create rectangle\
		    [$canvas coords $point] -fill \{\} -outline \{\}\]\n"
	    append text "lappend edgeInfo(\$arc,points) \$point\n"
	}
	
	# Set up the "outSlope", "outXneg", "inSlope", and "inXneg"
	# entries.
	append text "set edgeInfo(\$arc,outSlope) $edgeInfo($arc,outSlope)\n"
	append text "set edgeInfo(\$arc,outXneg) $edgeInfo($arc,outXneg)\n"
	append text "set edgeInfo(\$arc,inSlope) $edgeInfo($arc,inSlope)\n"
	append text "set edgeInfo(\$arc,inXneg) $edgeInfo($arc,inXneg)\n"
	
	set mid_xy [$this lineMidpoint $arc]
	set mid_x [lindex $mid_xy 0]
	set mid_y [lindex $mid_xy 1]
	append text "set edgeInfo(\$arc,label)\
		\[\$canvas create text\
		[expr $mid_x + $edgeInfo($arc,label_deltax)]\
		[expr $mid_y + $edgeInfo($arc,label_deltay)]\
		-fill black"
	set label [$canvas itemcget $edgeInfo($arc,label) -text]
	if {$label != {}} {
	    append text " -text \{$label\}"
	}
	append text "\]\n"

	append text "set edgeInfo(\$arc,label_deltax)\
		$edgeInfo($arc,label_deltax)\n"
	append text "set edgeInfo(\$arc,label_deltay)\
		$edgeInfo($arc,label_deltay)\n"

	# Guard
	if [info exists edgeInfo($arc,guard)] {
	    append text "set edgeInfo(\$arc,guard)\
		    [list $edgeInfo($arc,guard)]\n"
	}

	if {$machineType == "Mixed"} {
	    if [info exists edgeInfo($arc,preemptive)] {
		append text "set edgeInfo(\$arc,preemptive)\
			$edgeInfo($arc,preemptive)\n"
	    }

	    if [info exists edgeInfo($arc,entryType)] {
		append text "set edgeInfo(\$arc,entryType)\
			$edgeInfo($arc,entryType)\n"
	    }

	    foreach outName $portNames(out) {
		if [info exists edgeInfo($arc,output,$outName)] {
		    append text "set edgeInfo(\$arc,output,$outName)\
			    [list $edgeInfo($arc,output,$outName)]\n"
		}
	    }

	    foreach internalName $portNames(internal) {
		if [info exists edgeInfo($arc,action,$internalName)] {
		    append text "set edgeInfo(\$arc,action,$internalName)\
			    [list $edgeInfo($arc,action,$internalName)]\n"
		}
	    }

	}

	append text "\n"
    }
    
    # Done
    append text "### End of File\n"

    return $text
}

