# Definition of a display manager
# 
# @Authors: Farhana Sheikh and Edward A. Lee
#
# @Version: $Id$
# 
# @Copyright (c) 1995-1996 The Regents of the University of California.
# All rights reserved.
#
# Permission is hereby granted, without written agreement and without
# license or royalty fees, to use, copy, modify, and distribute this
# software and its documentation for any purpose, provided that the above
# copyright notice and the following two paragraphs appear in all copies
# of this software.
#
# IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY
# FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
# ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF
# THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.
#
# THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE
# PROVIDED HEREUNDER IS ON AN "AS IS" BASIS, AND THE UNIVERSITY OF
# CALIFORNIA HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,
# ENHANCEMENTS, OR MODIFICATIONS.
# 
#                                        PT_COPYRIGHT_VERSION_2
#                                        COPYRIGHTENDKEY
#######################################################################

#######################################################################
#### view
# This is a shortcut procedure for opening a Displayer/View combination.
# The first argument is the name of a class derived from <code>View</code>,
# an instance of which will be created and placed into a subclass of
# <code>Displayer</code>. Following arguments are configuration options.
# The options include:
# <ul>
# <li><b>-displayer</b>: A class that descended from Displayer, into
# which the view will be placed. Default is "Displayer."
# <li><b>-withdrawn</b>: If set, the window will not be deiconifies
# but will remain withdrawn. This is useful if you want to call
# <code>centerOnScreen</code>, for example.
# <li><b>-prefix</b>: The prefix of the created window name.
# <li><b>-geometry</b>: The window geometry, as for regular Tk
# top-level windows.
# <li><b>-height</b>: The height of the window in pixels.
# <li><b>-title</b>: The title string placed into the window head.
# <li><b>-toolbar</b>: If true, the Displayer will create and display
# a toolbar.
# <li><b>-width</b>: The width of the window in pixels.
# </ul>
# If either the <i>view</i> argument or
# <i>-displayer</i> option does not begin with "::", then "::tycho::"
# is prepended to the classname. Thus, classes in the tycho namespace
# can be specified without specifying the namespace. All other classes
# must be fully specified. Classes in the global namespace should have
# a simple "::" prefix.  The procedure returns the name of the new
# subwindow -- to get the top-level window, use "winfo toplevel".
#
proc ::tycho::view {view args} {
    # Figure out options for displayer
    array set temp $args
    set options {}
    foreach opt {-geometry -height -master -title -toolbar -width} {
	if { [::info exists temp($opt)] } {
	    lappend options $opt $temp($opt)
	    unset temp($opt)
	}
    }

    # Get correct class names
    if ![string match {::*} $view] {
        set view "::tycho::$view"
    }
    if { [::info exists temp(-displayer)] } {
	set displayer $temp(-displayer)
	unset temp(-displayer)
    } else {
	set displayer "::tycho::Displayer"
    }
    if ![string match {::*} $displayer] {
        set displayer "::tycho::$displayer"
    }

    # Get the flag saying whether to withdraw
    if { [::info exists temp(-withdrawn)] } {
	set withdrawn $temp(-withdrawn)
	unset temp(-withdrawn)
    } else {
	set withdrawn 0
    }
    
    # Create the displayer and view, and attach and show the view
    if { [::info exists temp(-prefix)] } {
	set prefix $temp(-prefix)
	unset temp(-prefix)
    } else {
	set prefix .displayer
    }
    set wname [::tycho::autoName $prefix]
    uplevel #0 $displayer $wname $options
    uplevel #0 $view $wname.v [array get temp]
    $wname showView $wname.v

    # Deiconify the displayer and return the view name
    if { ! $withdrawn } {
	wm deiconify $wname
    }
    return $wname.v
}

# ## OLD VERSION
# # proc ::tycho::view {view {viewoptions {}} \
# #         {displayer {Displayer}} {dispoptions {}}} {
# #     if ![string match {::*} $view] {
# #         set view "::tycho::$view"
# #     }
# #     if ![string match {::*} $displayer] {
# #         set displayer "::tycho::$displayer"
# #     }
# #     set wname [::tycho::autoName .displayer]
# #     uplevel #0 $displayer $wname $dispoptions
# #     uplevel #0 $view $wname.v $viewoptions
# #     $wname attachView  $wname.v
# #     $wname showView $wname.v
# #
# #     wm deiconify $wname
# #     return $wname.v
# # }


#######################################################################
#### Displayer
# This class is a top level window that can contain one or more
# <a href="View.html">View</a> objects. It provides a status bar
# at the bottom and a menu at
# the top for each view. It can also optionally provide a tool bar.
# Distinct menu, status and tool bars are created for each view that is
# attached to the displayer, so views can have different menu
# structures, and information in the status bar can be preserved as the
# focus changes between views. Only one each of the menu, status, and
# tool bars are displayed at a time, the one corresponding to the view
# with the focus.
# <p>
# FIXME: Here is an example:
# <tcl><pre>
# ::tycho::Displayer .dm
# .dm centerOnScreen
# </pre></tcl>
#
class ::tycho::Displayer {
    inherit ::tycho::TopLevel

    constructor {args} {}
    destructor {}

    # If non-zero, treat this window as the application master.
    itk_option define -master master Master "0"

    # If non-zero, show a tool bar for each view.
    itk_option define -toolbar toolbar Toolbar "0"

    ###################################################################
    ####                         public methods                    ####

    # Register a view and create its menu and status bars
    method attachView {view}

    # Destroy a view, removing it from the display.
    method destroyView {view}

    # Give the focus to the current view.
    method focusin {}

    # Resize the window to the full screen size.
    method fullScreen {}

    # Resize the window to half the height of the screen.
    method halfHeight {}

    # Hide the given view without destroying it.
    method hideView {view}

    # Resize the window to the original requested size.
    method originalSize {}

    # Attempt to save the data of any views of type File.
    method saveCrash {}

    # Show the menu and status bars for the specified view, or the default.
    method setCurrentView {view}

    # Show the menu and status bars for the empty view
    method setEmptyView {}

    # Display the specified view inside the displayer.
    method showView {view args}
    
    #################################################################
    ####                   public procedures                     ####

    # Set or report whether C-x C-c is bound in future instances to exit.
    proc normalExit {{enable {}}} {}

    #################################################################
    ####                   protected methods                     ####

    # Check to see whether the specified view is attached with the Displayer.
    protected method verifyView {view {method {}}}

    #################################################################
    ####                   protected variables                   ####

    # Avoid self-destructing recursively.
    protected variable alreadyexiting 0

    # Text to insert in close button
    protected variable closetxt "Close"

    # The name of the current view, if there is one.
    protected variable currentView {}

    # If 1, C-x C-c will be bound in future instances to exit the program.
    protected common normalexit 1

    # An array mapping view window paths to a name for making components
    # This array can be used to get the names of all views.
    protected variable _viewtag

    # An array of views with value indicating whether it is displayed.
    protected variable _showing

    # Keep tack of the vertical window position for screen placement.
    protected common vertpos {+}
}

###################################################################
#### -master configuration
# If the value of this option is non-zero, then this window is treated
# as a master window in the sense that when it is closed, it queries
# the user to see whether to exit the program. By default, a Displayer
# is not a master. A master Displayer has its close button labelled
# "Quit" instead of "Close."
#
configbody ::tycho::Displayer::master {
    if $itk_option(-master) {
        set closetxt "Quit"
    } {
        set closetxt "Close"
    }
    foreach view [array names _viewtag] {
        $itk_component(status$view) configure -closetext $closetxt
    }
}

###################################################################
#### -toolbar configuration
# If the value of this option is "1", show the toolbar for each widget.
# Otherwise, hide the toolbar.
# FIXME: This should create and destroy toolbars when the value
# is changed.
configbody ::tycho::Displayer::toolbar {
    if $itk_option(-toolbar) {
        # The frame is packed "-before" the childsite to prevent the
        # bar from disappearing when the window is made smaller (see
        # Welch page 126).
        pack $itk_component(toolFrame) -side top -fill x \
                -before $itk_component(childsite)
    } {
        if [winfo ismapped $itk_component(toolFrame)] {
            pack forget $itk_component(toolFrame)
        }
    }
}

#######################################################################
#### constructor
#
body ::tycho::Displayer::constructor {args} {

    # Add the width and height options omitted by the top level.
    # This is needed for the window manager ops to work correctly.
    itk_option add hull.width hull.height

    # Fashioned after emacs bindings, the following bindings control
    # placement and size on the screen.
    bind $prefix {<Control-x><Key 1>} "$this fullScreen; break"
    # FIXME: Doesn't quite work yet.  Window manager bugs?
    bind $prefix {<Control-x><Key 2>} "$this halfHeight; break"
    bind $prefix {<Control-x><Key 6>} "$this originalSize; break"

    # Again following emacs convention, the following will exit the
    # program if in normal exit mode.
    # NOTE: This should probably be promoted to TopLevel, along with
    # normalexit.
    if {$normalexit == 1} {
	bind $prefix <Control-x><Control-c> {::tycho::TopLevel::exitProgram}
    } else {
	bind $prefix <Control-x><Control-c> {}
    }

    # Setup a frame for the menu bar
    itk_component add menuFrame {
	frame $itk_interior.menuFrame -relief raised -bd 2
    } {
	keep -background -cursor
    }
    # The frame is packed "-before" the childsite to prevent the
    # bar from disappearing when the window is made smaller (see
    # Welch page 126).
    pack $itk_component(menuFrame) -side top -fill x \
            -before $itk_component(childsite)

    # Setup a frame for the tool bar
    itk_component add toolFrame {
	frame $itk_interior.toolFrame -relief raised -bd 2
    } {
	keep -background -cursor
    }

    # Setup a frame for the status bar
    itk_component add statusFrame {
	frame $itk_interior.statusFrame -relief raised -bd 2
    } {
	keep -background -cursor
    }
    pack $itk_component(statusFrame) -side bottom -fill x \
            -before $itk_component(childsite)

    # Create the default menubar at the global scope.
    # This also creates some options needed by preferences.
    itk_component add menubar {
	uplevel #0 ::tycho::MenuBar $itk_component(menuFrame).menubar
    } {
	keep -background -cursor -font
	rename -padx -menupadx menuPadX MenuPadX
	rename -pady -menupady menuPadY MenuPadY
    }

    # Create the default status bar at the global scope.
    itk_component add status {
 	uplevel #0 ::tycho::StatusBar $itk_component(statusFrame).status \
		-closetext $closetxt \
                -closecommand [list "$this nextWindow; delete object $this"]
    } {
	keep -background -font -activebackground -cursor \
		-highlightthickness -activeforeground \
		-foreground -highlightcolor -highlightbackground
	rename -padx -buttonpadx buttonPadX ButtonPadX
	rename -pady -buttonpady buttonPadY ButtonPadY
    }
    
    eval itk_initialize $args
    eval preference excludeoptions $this $args
    preference subscribeoptions $this \
	    -font menuFont \
	    -buttonpadx buttonPadX \
	    -buttonpady buttonPadY \
	    -menupadx menuPadX \
	    -menupady menuPadY

    if $itk_option(-master) {
        $itk_component(status) configure -closetext "Quit"
    } {
        $itk_component(status) configure -closetext "Close"
    }

    # Show just the default status bar
    setEmptyView

    # Response to crash recovery
    wm protocol $prefix WM_SAVE_YOURSELF "$this saveCrash"
}

#########################################################################
#### destructor
# If this displayer is a master, query the user for exiting the program,
# then exit.  Otherwise, destroy each of the views.
#
body ::tycho::Displayer::destructor {} {
    if {[::tycho::TopLevel::returnExitCon]} {return}
    # To prevent hanging on incomplete construction, we check for
    # existence of everything. 
    if {[info exists alreadyexiting] && [info exists itk_option(-master)]} {
	if $alreadyexiting {return}
	set alreadyexiting 1
	if {$itk_option(-master) != 0} {
            # We want to exit the entire program, not just this object.
            # In order to get the proper safety checks and confirmation,
            # we cancel the current destruction with silentError and
            # then at the top-level, invoke exitProgram.
            # Calling exitProgram from here directly is not good because
            # it tries to delete the current object, and we are already
            # in the middle of deleting it.
            after idle ::tycho::TopLevel::exitProgram
            ::tycho::silentError
	}
	set alreadyexiting 0
    }
    # Destroy all the registered views.
    foreach view [array names viewCommand] {
        destroyView $view
    }
    # NOTE: The following appears to not be necessary anymore.
    #     if {[info exists prefix] && [winfo ismapped $prefix]} {
    # 	wm withdraw $prefix
    #     }
}


###################################################################
###################################################################
####                      public methods                       ####


#######################################################################
#### attachView
# Register a view with the Displayer and create menu, tool, and
# status bars for it. The first argument is the window name of the
# view. This method calls the protected methods initializeMenubar{},
# initializeToolbar{}, and initializeStatusbar{} of the view. The
# view is not displayed -- call <code>showView</code> to do this.
#
body ::tycho::Displayer::attachView {view} {
    set view [::info namespace tail $view]

    if [::info exists _viewtag($view)] {
	error "View $view already exists in Displayer $this"
    }

    # Add the view to the list of views
    set tag [::tycho::autoName ""]
    set _viewtag($view) $tag
    set _showing($view) 0

    # Create the menubar at the global scope.
    itk_component add menubar$tag {
	uplevel #0 ::tycho::MenuBar $itk_component(menuFrame).menubar$tag
    } {
	keep -background -cursor -font
	rename -padx -menupadx menuPadX MenuPadX
	rename -pady -menupady menuPadY MenuPadY
    }

    # Create the status bar
    itk_component add status$tag {
	uplevel #0 ::tycho::StatusBar \
		$itk_component(statusFrame).status$tag \
		-closetext $closetxt \
		-closecommand [list "$this nextWindow; delete object $this"]
    } {
	keep -background -font -activebackground -cursor \
		-highlightthickness -activeforeground \
		-foreground -highlightcolor -highlightbackground
	rename -padx -buttonpadx buttonPadX ButtonPadX
	rename -pady -buttonpady buttonPadY ButtonPadY
    }

    # Create a tool bar if -toolbar is set
    if { $itk_option(-toolbar) } {
	itk_component add toolbar$tag {
	    uplevel #0 ::tycho::ToolBar \
		    $itk_component(toolFrame).toolbar$tag \
		    -statusbar $itk_component(status$tag)
	} {
	    keep -background -cursor -font
	    rename -padx -buttonpadx buttonPadX ButtonPadX
	    rename -pady -buttonpady buttonPadY ButtonPadY
	}
    }

    # Return the view's menubar, status bar, and tool bar, so
    # it can initialize them.
    if { $itk_option(-toolbar) } {
        return [list $itk_component(menubar$tag) \
                $itk_component(status$tag) \
                $itk_component(toolbar$tag)]
    } else {
        return [list $itk_component(menubar$tag) \
                $itk_component(status$tag) \
                {}]
    }
}

#######################################################################
#### destroyView
# Remove a view from the display and destroy it. If there are no
# more attached views, display the default menubar and status bar.
#
body ::tycho::Displayer::destroyView {view} {
    set view [::info namespace tail $view]
    verifyView $view detachView

    # Destroy the view, its menubar, status bar, and toolbar
    # The view is destroyed first because the destruction might be
    # cancelled by triggering an error.
    set tag $_viewtag($view)
    delete object [winfo command $view]
    delete object $itk_component(menubar$tag)
    delete object $itk_component(status$tag)
    catch {delete object $itk_component(toolbar$tag)}

    # De-register the view
    unset _viewtag($view)
    unset _showing($view)

    # Give focus to some other view that is showing, if there is one.
    set newview {}
    foreach view [array names _viewtag] {
        if $_showing($view) {
            set newview $view
            break
        }
    }
    if {$newview == {}} {
	# Display empty view if no other views
	setEmptyView
    } else {
	$newview focusin
    }
}

#########################################################################
#### focusin
# Grab the focus.
#
body ::tycho::Displayer::focusin {} {
    if {$currentView != {}} {
	[winfo command $currentView] focusin
    }
}

###################################################################
#### fullScreen
# Resize the window to the full screen size.
#
body ::tycho::Displayer::fullScreen {} {
    wm withdraw $prefix
    set width [winfo screenwidth $prefix]
    set height [winfo screenheight $prefix]
    set grid [wm grid $prefix]
    if {$grid != {}} {
        # Window is gridded, so size request has to be changed
        # to grid units.
        set widthInc [lindex $grid 2]
        set heightInc [lindex $grid 3]
        # FIXME: The fudge factors appear to be needed because the "wm
        # geometry" command does not really work as advertized.
        set width [expr int(0.95*$width/$widthInc.0)]
        set height [expr int(0.87*$height/$heightInc.0)]
    }
    wm geometry $prefix "${width}x$height+0+0"
    wm deiconify $prefix
}

###################################################################
#### halfHeight
# Resize the window to the half of the screen height. The window is
# also repositioned. If this function has been invoked an even number
# of times (including zero), the window is put at the top of the
# screen. If this function has been invoked an odd number of times, it
# is put at the bottom of the screen.
# NOTE: This does not currently work properly, at least under fvwm,
# because the inside text window, for some reason, is the one that
# gets the half height size.
#
body ::tycho::Displayer::halfHeight {} {
    wm withdraw $prefix
    set width [winfo width $prefix]
    set height [winfo screenheight $prefix]
    set grid [wm grid $prefix]
    if {$grid != {}} {
        # Window is gridded, so size request has to be changed
        # to grid units.
        set widthInc [lindex $grid 2]
        set heightInc [lindex $grid 3]
        set width [expr int($width/$widthInc.0)]
        set height [expr int($height/(2.0*$heightInc))]
    }
    wm geometry $prefix "${width}x$height+0${vertpos}0"
    if {$vertpos == {+}} {set vertpos {-}} {set vertpos {+}}
    wm deiconify $prefix
}

#######################################################################
#### hideView
# Remove the specified view from the display without destroying it.
# The view can be re-inserted in the display by calling <code>showView</code>.
# If the view is not in the display, do nothing.
#
body ::tycho::Displayer::hideView {view} {
    set view [::info namespace tail $view]
    if { ! [info exists _viewtag($view)] || !! $_showing($view) } {
        return
    }

    # Remove menubar, status bar, and view
    set tag $_viewtag($view)
    pack forget $itk_component(menubar$tag)
    pack forget $itk_component(status$tag)
    catch {pack forget $itk_component(toolbar$tag)}
    pack forget $view
    
    # Indicate that view is no longer showing.
    set _showing($view) 0
    
    # Give focus to some other view that is showing, if there is one.
    set newview {}
    foreach view [array names _viewtag] {
        if $_showing($view) {
            set newview $view
            break
        }
    }
    if {$newview == {}} {
	# No views are _showing; use the default menu.
	setEmptyView
    } else {
	$newview focusin
    }
}

###################################################################
#### originalSize
# Resize the window to its original requested size.
#
body ::tycho::Displayer::originalSize {} {
    wm withdraw $prefix
    wm geometry $prefix {}
    wm deiconify $prefix
}

#######################################################################
#### saveCrash
# Attempt to save the data of child views of type File.
#
body ::tycho::Displayer::saveCrash {} {
    foreach view [array names _viewtag] {
	# Really, we shouldn't be testing for membership of
	# the subclass File here! FIXME
	if [[winfo command $view] isa ::tycho::File] {
	    [winfo command $view] saveCrash
	}
    }
}

#######################################################################
#### setCurrentView
# Show the menu bar, tool bar, and status bar belonging to the
# specified view. If no view is specified, show the default menu bar
# and status bar. The most recent call to this method determines the
# currentView.
# 
body ::tycho::Displayer::setCurrentView {view} {
    set view [::info namespace tail $view]

    # Only pack new menubar and status bar if different from previous
    if {$view != $currentView} {
	verifyView $view setCurrentView

	# Unpack existing components
	if { $currentView == "" } {
	    set tag ""
	} else {
	    set tag $_viewtag($currentView)
	}
	catch {pack forget $itk_component(menubar$tag)}
	catch {pack forget $itk_component(status$tag)}
	catch {pack forget $itk_component(toolbar$tag)}

	# Pack the menu bar, status bar, and toolbar into the window
	set tag $_viewtag($view)
	pack $itk_component(menubar$tag) \
		-in $itk_component(menuFrame) \
		-fill x \
		-expand 0

	pack $itk_component(status$tag) \
		-in $itk_component(statusFrame) \
		-fill x \
		-expand 0

	if { $itk_option(-toolbar) } {
	    pack $itk_component(toolbar$tag) \
		    -in $itk_component(toolFrame) \
		    -fill x \
		    -expand 0
	}
	set currentView $view
    }
}

#######################################################################
#### setEmptyView
# Show the default status bar, and nothing else.
# 
body ::tycho::Displayer::setEmptyView {} {
    # Unpack existing components
    if { $currentView == "" } {
	set tag ""
    } else {
	set tag $_viewtag($currentView)
    }
    catch {pack forget $itk_component(menubar$tag)}
    catch {pack forget $itk_component(status$tag)}
    catch {pack forget $itk_component(toolbar$tag)}

    # Pack the default menu bar
    pack $itk_component(menubar) \
	    -in $itk_component(menuFrame) \
	    -fill x \
	    -expand 0

    # Pack the default status bar
    pack $itk_component(status) \
	    -in $itk_component(statusFrame) \
	    -fill x \
	    -expand 0

    # The current view is blank
    set currentView {}
}

#######################################################################
#### showView
# Display the given view inside the displayer. The first argument is
# the name of the view. The view must have been attached to the
# Displayer. If the view is already showing in
# the display, then this method gives it the focus and returns.
# If not, the view is packed using the Tk pack command
# with the default options <code>-fill both -expand true -side bottom</code>,
# meaning that the view should be expanded if
# the window is expanded, that the view should fill available space in
# both in the horizontal and vertical direction, and that it should be
# put at the bottom of the window. 
# If additional arguments are given, these also are passed to the
# pack command, and override the default options.
#
body ::tycho::Displayer::showView {view args} {
    set view [::info namespace tail $view]
    verifyView $view showView

    # If view is already visible, give it the focus and return.
    if $_showing($view) {
	[winfo command $view] focusin
	return
    }

    # Pack into the view frame in the window childsite. Allow
    # caller-specified options to override default options.
    array set temp {-fill both -expand true -side bottom}
    array set temp $args
    eval pack $view \
	    -in $itk_component(childsite) \
	    [array get temp]

    # Install the appropriate menu and status bars
    # setCurrentView $view
    set _showing($view) 1

    # This used to be deferred because this code was being executed
    # while still in the View constructor. Deferment is no longer
    # needed because showView is called after the constructor returns.
    # after idle [code [winfo command $view] focusin]
    [winfo command $view] focusin
}

###################################################################
###################################################################
####                      public procedures                    ####

###################################################################
#### normalExit
# If the argument is 1, then for all instances of Displayer or derived
# classes created henceforth, bind C-x C-c to exit the program.
# If the argument is 0, then make no such binding.  If the argument
# is absent, then report whether such a binding has been set.
# This procedure is provided for the benefit of other applications
# that might be using Tycho, but which have their own method for exiting.
#
body ::tycho::Displayer::normalExit {{enable {}}} {
    if {$enable != {}} {
        set normalexit $enable
    }
    return $normalexit
}

#################################################################
#################################################################
####                   private methods                       ####

#######################################################################
#### verifyView
# Check to see whether the specified view is attached with the Displayer.
# If not, trigger an error.  Otherwise, return.
# 
body ::tycho::Displayer::verifyView {view {method {}}} {
    if ![::info exists _viewtag($view)] {
	error "::tycho::Displayer::$method: View $view is not attached to display $this."
    }
}
