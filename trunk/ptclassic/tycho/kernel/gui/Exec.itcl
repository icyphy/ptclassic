# Ptolemy Tycho class that exec's a process and displays the output
#
# @Author: Christopher Hylands
#
# @Version: $Id$
#
# @Copyright (c) 1996-%Q% The Regents of the University of California.
# All rights reserved.
#
# Permission is hereby granted, without written agreement and without
# license or royalty fees, to use, copy, modify, and distribute this
# software and its documentation for any purpose, provided that the above
# copyright notice and the following two paragraphs appear in all copies
# of this software.
#
# IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY
# FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
# ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF
# THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.
#
# THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE
# PROVIDED HEREUNDER IS ON AN "AS IS" BASIS, AND THE UNIVERSITY OF
# CALIFORNIA HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,
# ENHANCEMENTS, OR MODIFICATIONS.
# 
#                                        PT_COPYRIGHT_VERSION_2
#                                        COPYRIGHTENDKEY
#######################################################################

##############################################################################
#### tyexec
# Invoke an external program, passing it the specified arguments.
# The format of the command is exactly that of the Tcl "exec" command.
# The main purpose of this procedure is to generate an informative
# error message if the "exec" fails.
#
proc ::tycho::tyexec { args } {
    global tcl_platform
    if {$tcl_platform(platform) == "macintosh"} {
	error "Sorry, the tcl \"exec\" command is not supported on the\
		Macintosh.\nThe command:\n$args\ncannot be executed"
    }
    # NOTE: Unix-ism.
    if [catch {eval exec $args} msg] {
        # The command failed.  It would be nice to check to see
        # whether the program exists, and generate a suitable message,
        # but it's not clear how to do this.
        error "The following command invocation failed:\n \
                $args\n \
                Is the program [lindex $args 0] installed and in your path?\n \
                $msg"
    }
}

#######################################################################
#### execModal
# Short cut to run a Modal Exec by creating an Exec widget,
# automatically starting and automatically exiting.
# If you call this proc with no arguments, then 'make' is run. 
#
# This proc returns a two element list, the first element is 
# the state of the Exec widget, either "running", "abnormal, or "normal"
# The second element of the list is the name of the Exec widget
# that was created.  If this proc is called with the third argument *execWidget*
# being a non-empty string, then the Exec widget named by *execWidget*
# is reused.  If the third argument is the empty string, then
# a new Exec widget is created.
#
# Here's an example:
# <tcl></pre>
# set retVal [::tycho::execModal {ls -l} {/tmp}]
# ::tycho::execModal {} {} [lindex $retVal 1]
# </pre></tcl>
# The above example runs <code>ls -l</code> the first time, then
# the user can edit the command to a different command and then
# the command is run.  If the user did not edit the command then
# <code>ls -l</code> is rerun.
#
proc ::tycho::execModal {{command {}} {dir {}} {execWidget {}}} {
    if {$execWidget == {}} {
        set win [::tycho::autoName .makeExec]
        set execWidget [::tycho::Exec $win]
    }


    # Get the name of the variable that will contain the status of 
    # exec after the exec is deleted
    set statusVariableName ::tycho::Exec::[$execWidget getStatusVariableName]

    if {$command != {} } {
	$execWidget configure -command $command
    }
    if {$dir != {} } {
	$execWidget configure -dir $dir
    }
    $execWidget centerOnScreen
    $execWidget execProcess
    #::tycho::Dialog::wait $win
    uplevel #0 [tkwait variable $statusVariableName]

    # Get the return value and unset the variable that contained it
    set retval [uplevel #0 "set $statusVariableName"]
    return [list $retval $execWidget]
}

#######################################################################
#### Exec
# Exec a process, and if there is output, display the output.
# See
# <a href="../internals/exec.html">$TYCHO/kernel/doc/internals/exec.html</a>
# for further documentation.
#
# <p>
# Here is an example of how to use the Exec:
# <tcl><pre>
#     set win [::tycho::autoName .execExample]
#     ::tycho::Exec $win -command {make all}
#     $win centerOnScreen
#     ::tycho::Dialog::wait $win
#     ::tycho::inform "We waited until the Exec window was closed"
# </pre></tcl>
# In the above example, we bring up the Exec window and then wait  
# until the user closes it.
#
# In this example, we automatically start up the subprocess, and then
# close the window if the subprocess completed without an error
# <tcl><pre>
#     set win [::tycho::autoName .execExample]
#     ::tycho::Exec $win &#92
#        -command {make all} &#92
#        -autostart 1 &#92
#        -autodestroy 1
#     $win centerOnScreen
# </pre></tcl>
# If the make in the above example had returned an error, then the window
# would not have been destroyed.
#
class ::tycho::Exec {
    inherit ::tycho::Query
    constructor {args} {}
    destructor {}
    
    ###################################################################
    ####                            options                        ####

    # If non-zero, close widget if the subprocess exits with an ok status.
    itk_option define -autodestroy autodestroy Autodestroy 0

    # If non-zero, start the subprocess automatically
    itk_option define -autostart autostart Autostart 0

    # Command to be executed.
    itk_option define -command command Command "make"

    # Directory to execute the command in.
    itk_option define -dir dir Dir {}

    ###################################################################
    ####                         public methods                    ####

    # Exec a process, if there is any output, bring up a window and display it.
    method execProcess {}

    # Get the name of the global variable that will contain the return status.
    method getStatusVariableName {} {return $statusVariableName}

    # Get the contents of the history window, if any.
    method getHistory {start {end end}} {}

    # Open a help window.
    method help {}

    # Read from the file descriptor, and close if we are at eof.
    method readOrClose {fd}

    ###################################################################
    ####                         public procs                       ####

    # Return 1 if the Exec widget will work on the current platform
    proc execWidgetIsSupported {} 

    ###################################################################
    ####                         private variables                 ####

    # The value of the cursor before we set it to the busy cursor.
    private variable oldCursor

    # The name of the global variable that will contain the exit status.
    private variable statusVariableName {}

    # File descriptor of the process.
    private variable fd {}
}

#######################################################################
#### -autodestroy configuration
# If non-zero, destroy the widget if the process exits with an 'ok'
# status
configbody ::tycho::Exec::autodestroy {
    if {$itk_option(-autodestroy) == 0} {
        insert autoDestroy No
    } else {
        insert autoDestroy Yes
    }
}

#######################################################################
#### -command configuration
# Command to be executed.
#
configbody ::tycho::Exec::command {
    clear commandToExec
    insert commandToExec $itk_option(-command)
}

#######################################################################
#### -dir configuration
# The directory that we should exec from.  If the value of this option
# is {}, then we don't change the current directory.  Otherwise,
# we cd to the value of this option.
#
configbody ::tycho::Exec::dir {
    clear dirToExecFrom
    insert dirToExecFrom $itk_option(-dir)
}

#######################################################################
#### constructor
#
body ::tycho::Exec::constructor {args} {
    configure -queries [list \
            {line commandToExec {Command to Exec:} make} \
            {line dirToExecFrom {Directory to Exec from:} {}} \
            {radio autoDestroy {Close window automatically:} {Yes No} No} \
    ]

    eval itk_initialize $args

    # If the command option has not been set, set the default now.
    # This has to be done in the constructor rather than in the class
    # definition (as a default) because "$this" is known here.
    if {$itk_option(-command) == {}} {
	configure -command {make}
    }

    $itk_component(bbox) buttonconfigure ok \
	    -text {Exec <Ret>} \
	    -command "$this execProcess"

    $itk_component(bbox) buttonconfigure cancel \
	    -text {Close <Esc>}

    $itk_component(bbox) add help \
	    -text "Help" \
	    -command "$this help"
    if {![info exists itk_component(history)] || \
            ![winfo exists $itk_component(history)]} {
        # We have not yet created the history window, so do so now.
        itk_component add history {
            ::tycho::Edit $itk_component(hull).history -textheight 15
        } {
            keep -readonly -textwidth -background \
                    -highlightbackground -highlightcolor -selectforeground \
                \
                -cursor -insertbackground -textforeground -textfont \
                -textbackground
        }
        pack $itk_component(history) -expand yes -fill both
        $itk_component(history) configure -readonly 1
    }

    set statusVariableName [::tycho::autoName gExecStatus]
    global $statusVariableName
    set $statusVariableName "constructed"


    # If autostart is not equal to zero, then start the subprocess
    if {$itk_option(-autostart) != 0} {
        $this execProcess
    }
}

#######################################################################
#### destructor
#
body ::tycho::Exec::destructor {} {
    # Adding this close seems to hang the window manager
    #close $fd
    # Unregister our fileevent handler
    catch {fileevent $fd readable {}}

    # Mark the editor as unmodified so that we are not prompted as
    # to whether we want to save it.
    if {[info exists itk_component(history)] && \
            [winfo exists $itk_component(history)]} {
        #$itk_component(history) configure -readonly 0
        #$itk_component(history) clear
        $itk_component(history) markUnmodified
    }
    catch {unset ::tycho::Exec::$statusVariableName}
}

    ###################################################################
    ###################################################################
    ####                      public methods                       ####

#######################################################################
#### execProcess
# Execute a process.  If there is any output, display it.
#
body ::tycho::Exec::execProcess {} {
    # Clear the history if it is present
    if {[info exists itk_component(history)] && \
        [winfo exists $itk_component(history)]} {
        $itk_component(history) configure -readonly 0
        $itk_component(history) clear
        $itk_component(history) configure -readonly 1
    }

    # If necessary, cd to the proper directory.
    set dirToExecFrom [get dirToExecFrom]
    if { $dirToExecFrom != {} } {
        set saveDir [pwd]
        cd "$dirToExecFrom"
    }

    # Set the busy cursor
    set oldCursor [lindex [config -cursor] end]
    config -cursor {watch}
    ::tycho::safeUpdate $this

    # Open a non-blocking pipe from the command
    # FIXME: Unixism - Brent Welch says to use '|& cat' here to get standard
    # error.  However, this presupposes that 'cat' is a command, which might
    # not be true under Windows or Macintosh.
    if [catch {set fd [open \
	    [concat "|[get commandToExec] |& cat"] {RDONLY NONBLOCK}]} errMsg] {
        config -cursor $oldCursor
	error "$errMsg"
    }

    # Register our file event handler
    fileevent $fd readable "$this readOrClose $fd"

    if { $dirToExecFrom != {} } {
        cd "$saveDir"
    }
    global $statusVariableName
    set $statusVariableName "running"
    return $statusVariableName
}

#####################################################################
#### getHistory
# Return the contents of the history buffer, if any.
# 
body ::tycho::Exec::getHistory {start {end end}} {
    if {![info exists itk_component(history)] || \
            ![winfo exists $itk_component(history)]} {
	return {}
    }
    return [$itk_component(history) get $start $end]
}

######################################################################
#### help
# Open a help window.
#
body ::tycho::Exec::help {} {
    global ::TYCHO
    ::tycho::File::openContext \
	    [file join $TYCHO kernel doc usersGuides ExecHelp.html]
}

#####################################################################
#### readOrClose
# Read from the file descriptor.  If we are at the end of file, then
# close it.  It is expected that the name of this method will be passed
# to fileevent.
# Note that this should be a protected method, but 'fileevent' calls
# things in the global scope.
#
body ::tycho::Exec::readOrClose {fd} {
    $itk_component(history) configure -readonly 0
    $itk_component(history) insertData "[gets $fd]\n"
    $itk_component(history) center
    $itk_component(history) configure -readonly 1

    # If we are at the end of the file, close the descriptor.
    # See the man page for the fileevent tcl command.
    if [eof $fd] {
        global $statusVariableName
        config -cursor $oldCursor
        if ![catch {close $fd} errMsg] {
            set $statusVariableName "normal"
            $itk_component(history) configure -readonly 0
            $itk_component(history) insertData "<<Process exited Normally>>\n"
            $itk_component(history) configure -readonly 1
            if {[get autoDestroy] == "Yes" } {
                after 5000 delete object $this
            }
        } else {
            set $statusVariableName "abnormal"
            $itk_component(history) configure -readonly 0
            $itk_component(history) insertData "<<Process exited Abnormally>>\n"
            $itk_component(history) configure -readonly 1
        }
    }
}

    ###################################################################
    ###################################################################
    ####                      public procs                          ####

#####################################################################
#### execWidgetIsSupported
# Return 1 if the Exec widget will work on the current platform, otherwise
# return 0.
#
body ::tycho::Exec::execWidgetIsSupported {} {
    global tcl_platform
    global tcl_platform
    switch $tcl_platform(platform) {
	macintosh {
	    return 0
	}
	unix {
	    return 1
	}
	windows {
	    return 0
	}
    }
}
