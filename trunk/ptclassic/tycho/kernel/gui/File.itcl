# Definition of a basic viewer widget with an interface to the file system.
#
# @Author: Edward A. Lee
# @Contributors: Joel King, Farhana Sheikh, Christopher Hylands
#
# @Version: $Id$
#
# @Copyright (c) 1995-1996 The Regents of the University of California.
# All rights reserved.
# 
# Permission is hereby granted, without written agreement and without
# license or royalty fees, to use, copy, modify, and distribute this
# software and its documentation for any purpose, provided that the
# above copyright notice and the following two paragraphs appear in all
# copies of this software.
# 
# IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY
# FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
# ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF
# THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.
# 
# THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE
# PROVIDED HEREUNDER IS ON AN "AS IS" BASIS, AND THE UNIVERSITY OF
# CALIFORNIA HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,
# ENHANCEMENTS, OR MODIFICATIONS.
# 
# 						PT_COPYRIGHT_VERSION_2
# 						COPYRIGHTENDKEY
#######################################################################

#######################################################################
#### File
# This is a base class for widgets that have persistent data in files.
# It handles auto-saving, crash recovery saving, version control,
# saving before exiting, and other interfaces to the file system. A
# copy of the file is made automatically periodically with an interval
# given by the -autosaveinterval option. If the compiled version of
# Tycho is used (for example, running it with Ptolemy), then crash
# recovery files are also automatically created if the program crashes.
# Unfortunately, there appears to be no way to accomplish this when using
# a standard itkwish.
# <p>
# If the File a is "attached" to a Displayer object, then the File
# object initialize its menu bar with three menus. The "File" menu
# contains commands to open a file, insert a file, save data to a file,
# save as some other file name, print, evaluate the data, reload the
# last saved version, toggle read-only, version control, close the
# window, and exit the application. The "Window" menu contains commands
# to open new (blank) top-level windows of all types that have been
# registered with the <code>File</code> class using one of the
# <code>register...</code> procedures. It also contains commands to
# bring to the foreground any currently open editor that has a file
# name associated with it. Note that editors with the default name
# "NoName" do not appear on this list. Finally, a "Help" menu contains
# pointers to key Tycho documentation.
# <p>
# Here is an example:
# <tcl><pre>
# ::tycho::view File
# </pre></tcl>
# <p>
# Derived classes should normally redefine the methods
# <ul>
# <li> <code>clear</code>,
# <li> <code>help</code>,
# <li> <code>insertData</code>,
# <li> <code>print</code>, and
# <li> <code>saveText</code>.
# </ul>
# In order to support hypertext jumps into particular points in the
# display, the derived class may also redefine <code>seeFragment</code>,
# and <code>currentPoint</code>. These two should always be redefined
# as a pair, since <code>currentPoint</code> is assumed to return a
# syntax understood by <code>seeFragment</code>. Derived classes may wish
# to redefine <code>indicateReadOnly</code>, for example to disable menu
# entries. Finally, most derived classes will want to redefine
# <code>focusin</code> to give the focus to a key widget.
#
class ::tycho::File {
    inherit ::tycho::View

    # Specify the interval (in minutes) between auto-save operations.
    itk_option define -autosaveinterval autoSaveInterval AutoSaveInterval 5

    # Specify initial data to display (ignored in this base class).
    itk_option define -data data Data {}

    # NOTE: The following should really be a public variable, not an
    # Itk option. But the Itk implementation does not recognize public
    # variables as options. When this is fixed, change this to a public
    # variable and remove the protected variable "file".

    # Specify the name of the file associated with the data being edited.
    itk_option define -file file File "NoName"

    # If zero, do not query for saving on exit.
    itk_option define -save save Save 1

    # NOTE: This should really be a public variable, not an Itk option.
    # But the Itk implementation does not recognize public variables as
    # options.  When this is fixed, change this to a public variable.

    # Specify whether this is a temporary file
    itk_option define -tmpfile tmpfile Tmpfile 0

    constructor {args} {}
    destructor {}

    ##########################################################################
    ####                         public methods                           ####

    # Query the user for another file to edit in the same window.
    method altFile {}

    # Save a backup file and arrange to be called again later.
    method autoSave {}

    # In derived classes, clear the data being displayed or edited.
    method clear {} {}

    # Query the user for a filename, then evaluate its contents as Tcl commands.
    method evaluate {}

    # Return the name of the file associated with the object.
    method filename {} {return $file}

    # Open a help window.  Redefine in derived classes.
    method help {}

    # Open a file and go to its internal point identified by name.
    method hyperJump {filename {point {}}}

    # Specify whether or not modifications are allowed in the displayed text.
    method indicateReadOnly {bool}

    # Insert the specified data.  Redefine in derived classes.
    method insertData {data}

    # Insert the contents of a file specified via a file browser.
    method insertFile {}

    # Return 1 if the text has been modified since the last save, 0 otherwise.
    method isModified {}

    # If possible, indicate that data has been modified.
    method markModified {}

    # If possible, mark the window as containing unmodified data.
    method markUnmodified {}

    # Open up the Itcl HTML documentation
    method openItclHTMLPage {} {}

    # Open a file browser, and then open an editor for the file.
    method openWinMethod {} {}

    # Print the contents of the file. The default behavior is an error.
    method print {}

    # Reload from the last saved version of the file.
    method reload {}

    # Create a revision control object for the current file.  
    method revisionControl {}

    # Save to a given filename or if none is given, to the current file.
    method save {{name ""}}

    # Open the file browser to save to some other file name.
    method saveAs {}

    # Change the associated file to the specified file name and then save.
    method saveAsFile {filename}

    # Save data to a crash recovery file.
    method saveCrash {}

    # If the file is modified, then ask the user if they want to save it
    method saveQuery {useSaveAs}

    # Toggle the read-only status of a file (maybe invoking revision control).
    method toggleReadOnly {}

    # Add me to the window menus of all open File objects.
    method windowMenuAddAll {label}

    # Append a file editor to the window menu.
    method windowMenuAppend {obj label {type {}}}

    # Remove a filename from the window menus of all open File objects.
    method windowMenuRemoveAll {filename}

    ##########################################################################
    ####                         public procedures                        ####

    # If the argument is a File object, call its autoSave method.
    proc callAutoSave {obj} {}

    # Call the saveCrash method for all File objects.
    proc emergencySave {} {}

    # Open a file browser, and then open an editor for the file.
    proc openWin {} {}

    # Edit a file using the file extension to select an editor.
    proc openContext {filename} {}

    # Register directory contents and an associated viewing command.
    proc registerContents \
	    {contents filecommand {description {}} {editorclass {}}} {}

    # Register file extensions and an associated viewing command.
    proc registerExtensions \
	    {extensions filecommand {description {}} {editorclass {}}} {}

    # Register file names and an associated viewing command.
    proc registerFilenames \
	    {filename filecommand {description {}} {editorclass {}}} {}

    # Return the registered viewing commands for a file or directory name.
    proc registeredCommands {name} {}

    # Is the file already open? if YES, then return the window name,
    # if NO, then return 0.
    proc isFileOpen {filename} {}
	
    ##########################################################################
    ####                  protected methods                               ####

    # Return the data to be saved. Redefine in derived classes.
    protected method saveText {}

    ##########################################################################
    ####                         protected variables                      ####

    # FIXME: This should be removed when Itk is fixed to understand
    # public variables.

    # The current file name.
    # FIXME: This variable should be renamed to "completeFilePath"
    # or something similar. As it is, the name "file" is too easy
    # to use somewhere in a subclass and then spend three hours
    # chasing a very bizarre bug (don't ask me how I know this! -- hjr).
    protected variable file "NoName"

    # This array stores object names indexed by file names so that
    # if the same file is opened a second time, we can just raise the window.
    protected common filesOpen

    # This array stores the "type" of a file, indexed by file names,
    # so that the Window submenus can be set up properly.
    protected common filesOpenTypes

    # Indicate whether or not the file has been modified since it was
    # last saved.
    protected variable modified 0    

    # Recall the previous filename associated with
    # the window in case the name is changed.
    protected variable previousfile {}

    # The most recently used print command (or the default if none).
    # FIXME: default print command should be a preference.
    protected common printCmd {lpr}

    ##########################################################################
    ####                  private methods                                 ####

    # Initialize the menubar
    private method initializeMenubar {}

    # Remove the backup file that gets automatically created periodically.
    private method removeBackupFiles {}

    ##########################################################################
    ####                  private procedures                              ####

    # Check for auto-save or crash-recovery files, and return the file to open.
    private proc checkForAutoSaveFiles {filename} {}

    # Given a class name, if it is not fully qualified, qualify it.
    private proc normalizeClassname {classname}

    ##########################################################################
    ####                         private variables                        ####

    # List of registered viewing commands by extension.
    private common editorsExtension

    # List of registered viewing commands by filename.
    private common editorsFilename

    # List of registered viewing commands by directory contents.
    private common editorsContents

    # This array stores the names of all currently active objects
    # of type File.  This is used to create crash recovery files.
    private common fileObjects

    # Keep track of registered editors to put them into the Window menu.
    private common windowMenuEntries {}

    # Class identifier
    private variable myclass {}
}

#########################################################################
#########################################################################
####                          option configure                       ####

#########################################################################
#### -data configuration
# Specifies initial data to display.
#
configbody ::tycho::File::data {
    if {$itk_option(-data) != {}} {
        insertData $itk_option(-data)
    }
}

#########################################################################
#### -file configuration
# Set or change the name of the file being edited.
# Set the window title and icon name to match, and set the
# protected "file" variable equal to the file name.  The filename
# is expanded into an absolute filename, resolving any references
# environment variables, user home directories, etc.  See
# <code>::tycho::expandPath</code> for details about how this is done.
# Note that the file is not actually loaded.  Call <code>reload</code>
# after configuring this option to accomplish that (the constructor does
# this automatically)
#
configbody ::tycho::File::file {
    set file $itk_option(-file)
    if {$file != $previousfile} {
        if {$itk_option(-file) != {NoName}} {
            set file [::tycho::expandPath $file]
        }
        if {[info exists filesOpen($file)] \
                && ![$filesOpen($file) getReadOnly] \
                && !$readOnly} {
            $filesOpen($file) raiseWindow
            if {![safeEval ::tycho::askuser \
                    "File $file is already open for writing. \
                    Proceed anyway?"]} {
                # Exit by triggering an error.
                ::tycho::silentError
            }
        }
        # Following used to be conditional using:
        # if { $itk_option(-file) != "" && $itk_option(-file) != "NoName" }
        displayer configure -title "$file"
        
        # Keep track of which files are open by name.
        # This is used to avoid opening the same file twice.
        # It is also used to maintain the Window menu entries.
        if {$previousfile != {}} {
            windowMenuRemoveAll $previousfile
            # unmap the revcontrol window.
            set topwin $itk_component(hull)
            if {[winfo exists $topwin.revcontrol]} {
                wm withdraw $topwin.revcontrol
            }
            # unmap the search window.
            if {[winfo exists $topwin.search]} {
                wm withdraw $topwin.search
            }
            # unmap the spell check window.
            if {[winfo exists $topwin.spell]} {
                wm withdraw $topwin.spell
            }
        }
        if {$file != "NoName"} {
            # Add the current object to the menu entries in all open editors.
            windowMenuAddAll $file
            set previousfile $file
        }
	# Remove Control-X from the <<Cut>> event 
	# In Itcl2.2, we have virtual events, so Control-Key-x is bound to
	#<<Cut>> in tk.tcl.  This means that we cannot have things like C-x C-r
	# bound to reload.
	if {[namespace ::itcl {set version}] > 2.1 } {
	    event delete <<Cut>> <Control-Key-x>
	}
    }
    focusin
}

#########################################################################
#### -tmpfile configuration
# Specifies initial tmpfile to display.
#
configbody ::tycho::File::tmpfile {
}

#########################################################################
#########################################################################
####                      constructor & destructor                   ####

###################################################################
#
body ::tycho::File::constructor {args} {
    global tcl_platform

    # Store my class identifier in a private variable.
    set myclass "[info class]"

    # Bindings.
    # Bind C-xC-f so that it opens a browser in the same directory
    # as the current file.
    bind $prefix <Control-x><Control-f> \
	    "$this ::tycho::File::openWinMethod; break"
    bind $prefix <Control-x><Control-s> "$this save; break"
    bind $prefix <Control-x><Control-v> "$this altFile; break"
    bind $prefix <Control-x><Control-w> "$this saveAs; break"
    bind $prefix <Control-x><Key-i> "$this insertFile; break"
    bind $prefix <Control-x><Key-p> "$this print; break"
    bind $prefix <Control-x><Control-r> "$this evaluate; break"
    bind $prefix <Control-x><Control-q> "$this toggleReadOnly; break"
    bind $prefix <Control-x><v> "$this revisionControl; break"

    # Insert items in the menu bar. This is in a separate method
    # because this constructor is so long. As it turns out, it's
    # faster as well.
    if {$myMenubar != {}} {
        # We have to qualify the call to this supposed-ly private
        # method because Itcl (2.2) has virtual private methods!
        ::tycho::File::initializeMenubar
    }

    # The following initialize options and then invoke any
    # configuration options, assuming there are options specified.
    eval itk_initialize $args

    # Subscribe to the preference set
    preference subscribeoptions $this \
	    -autosaveinterval autoSaveInterval

    # Identify the object for crash recovery
    set fileObjects($this) $this

    # This is deferred so that it runs after constructors are done.
    after idle [code evalIfExists $this reload]

    # Initiate the auto-save loop
    autoSave

    # FIXME: Because of some Itcl bogosity, filesOpen finds itself
    # not settable as an array.  Here we force it to be an array
    # and hope nobody uses the file name here.
    set filesOpen(junktychofileforitclbogosity) junk
}

#####################################################################
#### destructor
# If the modified flag is set, query the user to see whether the
# file should be saved.  If the user cancels the close, trigger an
# error.  This has the effect of undoing the destruction.
#
body ::tycho::File::destructor {} {

    if {[info exists modified]} {
	if {$itk_option(-tmpfile)} { 
	    # This is a temporary file, if it is modified, as the user
	    # if they want to save it.  If they do, call saveAs
	    set useSaveAs 1
            set copyFilename $file
	    saveQuery $useSaveAs
            ::tycho::rm $copyFilename
	} else {
	    saveQuery 
	}
    }

    windowMenuRemoveAll $file

    # If an error occurred in construction, this may not exist.
    if [info exists fileObjects($this)] {
	unset fileObjects($this)
    }
    
    # Do not get rid of the backup files.  This should be done
    # only on a successful save.
    # removeBackupFiles
}

#########################################################################
#########################################################################
####                          public methods                         ####

#####################################################################
#### altFile
# Query the user for a filename, and edit its contents
# using the current editor.
#
body ::tycho::File::altFile {} {
    saveQuery

    set prevfile $itk_option(-file)

    set filename [safeEval ::tycho::queryfilename {Alternate file to load:}]

    if {$filename != {}} {
	configure -file $filename
	windowMenuRemoveAll $prevfile
        # Reset the insertion cursor to the origin, or else we will
        # try to preserve the point in the file.
        $itk_component(text) mark set insert 1.0
        markUnmodified
        reload
    }
    after 1 [code evalIfExists $this focusin]
}

#####################################################################
#### autoSave
# If the data has been modified, save the data to a file with the name
# given in the -file option, but with the prefix "#auto#". Then arrange
# to be called later again, with the time interval given by the option
# -autosaveinterval.  A value of zero for this option disables auto-saving.
#
body ::tycho::File::autoSave {} {
    if !$itk_option(-save) {return}
    if {$modified && $file != ""} {
	set filename [file tail $file]
        set filename "#auto#$filename"
	set filename [file join [file dirname $file] $filename]
	if {[catch "save $filename" message] != 0} {
	    safeEval ::tycho::warn "Auto-save failed: $message"
	}
	markModified
    }
    set interval [expr int(60000*$itk_option(-autosaveinterval))]
    if {$interval < 0 || $interval > 7200000} {
	error "Auto-save interval is out of range (object $this)"
    }
    if {$interval != 0} {
	after $interval "::tycho::File::callAutoSave $this"
    }
}

#####################################################################
#### evaluate
# Query the user for a filename, then evaluate its contents as Tcl commands.
#
body ::tycho::File::evaluate {} {
    set filename [safeEval ::tycho::queryfilename {Tcl file to evaluate:}]

    if {$filename != {}} {
	source $filename
    }
}

#########################################################################
#### help
# Open a window with help on the current widget.
# This should be redefined in derived classes.
#
body ::tycho::File::help {} {
    global ::TYCHO
    ::tycho::File::openContext \
	    [file join $TYCHO kernel doc usersGuides FileHelp.html]
}

#####################################################################
#### hyperJump
# Open a file and go to its internal point identified by name. If the
# filename is the empty string, just call <code>seeFragment</code>,
# passing it the second argument. If the filename is relative (does not
# begin with "/", "~", or "$"), then prepend the directory of the file
# currently being edited or viewed. Then, expand the filename using
# <code>::tycho::expandPath</code> and open the resulting file with
# <code>::tycho::File::openContext</code>, which will choose an editor
# based on the filename extension. Finally, invoke
# <code>seeFragment</code> to view the specified point within the file.
# The format for the <i>point</i> argument depends on the type of file
# being opened. For HTML files, it will normally be the name of an
# anchor in the file. For text files, it will normally be either "{line
# <i>linenumber</i>}" or "{range <i>start</i> <i>end</i>}", where
# <i>start</i> and <i>end</i> have the form
# <i>linenumber.characternumber</i>.
#
body ::tycho::File::hyperJump {filename {point {}}} {
    if {$filename != {}} {
	if [::tycho::isRelative $filename] {
            set filename [file join [file dirname $file] $filename]
        }
    }
    ::tycho::TWidget::hyperJump $filename $point
}

#####################################################################
#### insertData
# Insert the specified data.
# In this base class, trigger an error.
#
body ::tycho::File::insertData {data} {
    error "Sorry, insert data not implemented yet."
}

#####################################################################
#### insertFile
# Insert the contents of a file.
# Open a file browser to query the user for a filename, and then
# insert the contents of that file via the method <code>insertData</code>.
#
body ::tycho::File::insertFile {} {
    set filename [safeEval ::tycho::queryfilename {File to insert:}]

    if {$filename != "" && $filename != "NoName"} {
	if {[file exists $filename]} {
	    if {[file readable $filename]} {
		set fd [open $filename r]
		set data [read $fd]
		close $fd
		insertData $data
                markModified
	    } {
		safeEval ::tycho::warn "File is not readable: $filename"
	    }
	} {
	    safeEval ::tycho::warn "File does not exist: $filename"
	}
    }
}

###################################################################
#### isModified
#
body ::tycho::File::isModified {} {
    return $modified
}

#####################################################################
#### markModified
# If this view is with a Displayer object, show that the data has been
# modified by putting an icon in the lower left corner.
#
body ::tycho::File::markModified {} {
    if !$modified {
 	statusbar configure -filestatus "modified"	
        set modified 1
    }
}

#####################################################################
#### markUnmodified
# If this view is with a Displayer object, show that the data is
# unmodified by clearing the icon in the lower left corner.
#
body ::tycho::File::markUnmodified {} {
    if $modified {
	if $readOnly {
 	    statusbar configure -filestatus "readonly"	    
	} {
	    statusbar configure -filestatus "readwrite"
	}
        set modified 0
    }
}

#####################################################################
#### openItclHTMLPage
# Open up the Itcl HTML documentation.  The Itcl2.2 sources
# contain the Itcl HTML documentation at itcl2.2/html/TclTkMainList.html
# Tycho does not understand frames, so Tycho can't read the index.html
# file in that directory
# In Tycho, the itclHTMLPage preference controls what file is opened.
#
body ::tycho::File::openItclHTMLPage {} {
    set itclhtmlpage [::tycho::preference get misc itclHTMLPage]
    if { $itclhtmlpage != "" } {
	set itclhtmlpage [::tycho::expandPath $itclhtmlpage]
    }
    
    if [file exists $itclhtmlpage] {
        ::tycho::File::openContext "$itclhtmlpage"
    } else {
	error "Sorry, $itclhtmlpage does not exist. You can\nuse\
	the itclHTMLPage Miscellaneous preference to set the\npath\
	of the file that is opened by this page.\nThe Itcl2.2 sources\
	come with html man pages located at\nitcl2.2/html/TclTkMainList.html"
    }
}


#####################################################################
#### openWinMethod
# Open a file browser, and then open an editor for the file.
# The editor is chosen based on the file extension, if the extension
# is recognized.  Otherwise, the <code>Edit</code> class is used to open an
# ordinary text editor.
#
body ::tycho::File::openWinMethod {} {
    ::tycho::Dialog::new FileBrowser [::tycho::autoName .fileBrowser] \
	    -command "::tycho::File::openContext " \
	    -text "Open File:" \
            -default $file
}
#####################################################################
#### print
# Print the contents of the file. The default behavior is an error.
#
body ::tycho::File::print {} {
    error "Sorry, print not implemented yet."
}

#####################################################################
#### reload
# Reload from the last saved version of the current file. This method
# first disables read-only status (if it is set), then replaces the
# current data with data from the current file, and then sets read-only
# status based on the permissions of the file. The data is marked
# unmodified after loading the file, and the clipboard is restored to
# its form prior to the reload. If the file does not exist, then
# the current data is cleared, leaving a blank slate. If the current
# file exists but is not readable, an error occurs. The actual
# replacement of the data occurs via the method
# <code>insertData</code>. Note that if the data is modified, then
# changes will be lost -- if this is a possibility then callers
# must be sure to call the saveQuery{} method before calling
# reload{}.
#
body ::tycho::File::reload {} {
    if {$file == "NoName" || $file == ""} {
	return 
    }
    # This call to saveQuery has been commented out because it
    # was causing erroneous save queries after checking
    # in a modified file and not saving changes. Hopefully
    # it won't break anything else. See the method comment.
    # saveQuery
    set saveclipboard [getClipboard]
    if [file exists $file] {
        if [file readable $file] {
	    configure -readonly 0
            set point [currentPoint]
            clear
            set fd [open $file r]
            configure -data [read $fd]
            close $fd
            seeFragment $point
            if {[file writable $file]} {
		configure -readonly 0
            } else {
		configure -readonly 1
            }
        } {
            error "File $file exists but is not readable"
        }
    } {
        # File does not exist.  Simply clear current data.
	configure -readonly 0
        clear
    }
    setClipboard $saveclipboard
    # In case the reloading marks the buffer modified as a side effect.
    markUnmodified
}

###################################################################
#### revisionControl
# Invoke revision control.  If the file is under the control of a
# recognized revision control system (such as SCCS and RCS), then use
# that system.  Otherwise, query the user about putting the file under
# revision control.  A control panel is opened that permits the user
# to check in or check out the file, examine its revision history, etc.
#
body ::tycho::File::revisionControl {} {
    ::tycho::RevControl::setup $itk_component(hull) $this
}

#####################################################################
#### save
# Save to a file, with an optional filename specified.  If no filename
# is specified, then the name given in the -file option is used.
# If no -file option was given, the given name is "NoName", or
# the name begin with "#auto#" or "#crash#", then saveAs is invoked.
# Return 1 if it successfully saves, and 0 (or an error) otherwise.
#
body ::tycho::File::save {{name ""}} {
    if {$name == {}} {
	set filename $file
    } {
	set filename $name
    }
    set ft [file tail $filename]
    if {$name == {} && \
            ([string match {#auto#*} $ft] || [string match {#crash#*} $ft])} {
        # The file was automatically created.  Invoke saveAs in the
        # proper directory with the proper default.
        ::tycho::FileBrowser::setCWD [file dirname $filename]
        regsub {(#auto#)|(#crash#)} $ft {} prefname
        ::tycho::FileBrowser::setLastFile $prefname
	if {[saveAs] == 0} {return 0}
        set filename $file
    } elseif {$filename != {} && $filename != "NoName"} {
        set txt [saveText]
	set fd [open $filename w+]
	puts -nonewline $fd $txt
	close $fd
    } {	
	# The file has not been specified.  Invoke saveAs
	if {[saveAs] == 0} {return 0}
        set filename $file
    }
    if {$name == ""} {
	removeBackupFiles
    }
    markUnmodified
    putStatus "Saved $filename"
    return 1
}

#####################################################################
#### saveAs
# Invoke the file browser to prompt the user for a file name,
# and then, if the file is writable or creatable, save the contents
# of the editor to that file.  Note that in the base class, this
# will eventually fail because we do not know how to save.
#
body ::tycho::File::saveAs {} {
    set filename [safeEval ::tycho::queryfilename {Save As File:}]
    if {$filename == {NoName}} {
	error "Cannot use name NoName"
    }
    # Ignore if the user cancels
    if {$filename != {}} {
	return [saveAsFile $filename]
    } {
        return 0
    }
}

#####################################################################
#### saveAsFile
# Change the associated file to the specified file name and then save.
# Return 1 if the save is successful.  Return 0 or trigger an error
# if the save is not successful.
#
body ::tycho::File::saveAsFile {filename} {
    if {[file exists $filename]} {
	if [safeEval ::tycho::askuser \
                "File \"$filename\" exists.  Overwrite?"] {
	    removeBackupFiles
            if [save $filename] {
                configure -file $filename
                return 1
            }
	} {
            focusin
            ::tycho::silentError
	}
    } {
	removeBackupFiles
	set oldname $itk_option(-file)
	if [save $filename] {
            configure -file $filename
            focusin
	    return 1
	}
    }
    focusin
    return 0
}

#####################################################################
#### saveCrash
# Save data to a crash recovery file.
# The crash recovery filename is constructed from the true file name
# by prepending the prefix "#crash#".
#
body ::tycho::File::saveCrash {} {
    if {$modified && $file != ""} {
	set filename [file tail $file]
        set filename "#crash#$filename"
	set filename [file join [file dirname $file] $filename]
	save $filename
    }    
}

#####################################################################
#### saveQuery
# If the file is marked as modified, then ask the user whether to save it.
# This method should be called before invoking any operation on the disk
# image of the file, such as checking it in, running a program on it, etc.
# If the optional argument is given and has a non-zero value,
# then <code>saveAs</code> is used instead of <code>save</code>,
# so that the user is prompted for a file name.
# <p> 
# If the file is not modified, or if the -save option was given with
# value 0, return 2 and do nothing.
# If the file is modified and is saved, return 1.
# If the file is modified but not saved, return 0.
# If the user hits cancel, trigger a silentError, which unravels
# the calling stack all the way to the top-level.  This has the effect
# of cancelling the entire operation.
#
body ::tycho::File::saveQuery { {useSaveAs 0}} {
    if {$modified == 1 && $itk_option(-save)} {
	set title [file tail $file]
        set nm [::tycho::autoName .filedestr]
        uplevel #0 [list ::tycho::YesNoCancel $nm \
		-text "Save changes to $title?"]
	set response [safeEval ::tycho::Dialog::wait $nm]
	# If the user hits the cancel button, trigger a silent error.
	if {$response == -1} {
 	    ::tycho::silentError
	}
	if {$response == 1} {
	    if {$useSaveAs} {
		saveAs
	    } else {
		save
	    }
	}
	return $response
    }
    return 2
}

#####################################################################
#### toggleReadOnly
# Toggle the read-only status of the file.  If the file is under
# revision control (e.g. SCCS or RCS), then check in or check out
# the file.
#
body ::tycho::File::toggleReadOnly {} {
    global tcl_platform
    # This method will only work under Unix, as it uses the chmod command
    # (Actually, Windows might have a third party chmod command, but
    # we can't assume that).
    if {$tcl_platform(platform) != "unix"} {
	return
    }

    set revclass [::tycho::RevControl::whichRevClass $this]
    if {$revclass != {}} {
        if {![file writable [filename]]} {
            $revclass::checkOut $this
        } {
            $revclass::checkIn $this
        }
    } {
        # NOTE: Unix-only implementation here.
        if ![file exists [filename]] {
            saveQuery
        }
        if [file exists [filename]] {
            if ![file writable [filename]] {
                catch {exec chmod +w [filename]}
                configure -readonly 0
            } {
                if {$modified} {
                    if [safeEval ::tycho::askuser \
                            "Save modifications before making \
                            file read-only?"] {
                        # update changes since last save
                        save
                    }
                }
                catch {exec chmod -w [filename]}
                configure -readonly 1
            }
        } {
            bell
        }
    }
    focusin
}

#####################################################################
#### windowMenuAddAll
# Add me to all "Window" menus of all current file objects.
# The argument, normally a file name, gives the menu label.
# If a menu entry already exists with the given label, leave it alone
# and ignore the call. Also ignore it if this View is not inside a
# Displayer.
#
body ::tycho::File::windowMenuAddAll {label} {
    if {![info exists filesOpen($file)] && [displayer] != {}} {
        set filesOpen($label) $this
	set filesOpenTypes($label) $viewType
        foreach fileobj [array names fileObjects] {
            catch {$fileobj windowMenuAppend $this $label $viewType}
        }
    }
}

#####################################################################
#### windowMenuAppend
# Place the name of an open file editor in the "Window" menu.
# The second argument, normally a filename, gives the menu label.
# If the given file object has a non-null value of its "viewType"
# variable, then the editor is placed into an appropriate
# sub-menu of the Window menu, otherwise it is appended to the end.
#
body ::tycho::File::windowMenuAppend {obj label {type {}}} {
    # Avoid entries with empty names or NoName
    if {$label != {NoName} && $label != {}} {
	switch -exact $type {
	    "text" {
		menubar command $label {Open text editors} \
			-command "$obj raiseWindow"
		menubar enable {Open text editors}
	    }
	    "html" {
		menubar command $label {Open HTML viewers} \
			-command "$obj raiseWindow"
		menubar enable {Open HTML viewers}
	    }
	    "graphics" {
		menubar command $label {Open graphics editors} \
			-command "$obj raiseWindow"
		menubar enable {Open graphics editors}
	    }
	    "tools" {
		menubar command $label {Open tools} \
			-command "$obj raiseWindow"
		menubar enable {Open tools}
	    }
	    default {
		# Add to the end of the main menu
		menubar command $label Window -command "$obj raiseWindow"
	    }
	}
    }
}

#####################################################################
#### windowMenuRemoveAll
# Remove the specified filename from the Window menu of all open
# <code>File</code> objects.  The specified filename must match
# exactly the label given in the call to <code>windowMenuAddAll</code>
# that created the entry in the first place, and the object referenced
# by the menu must be this one.
#
body ::tycho::File::windowMenuRemoveAll {filename} {
    if {[info exists filesOpen] && \
            [info exists filesOpen($filename)] && \
            $filesOpen($filename) == $this} {
	unset filesOpen($filename)
	unset filesOpenTypes($filename)
	foreach fileobj [array names fileObjects] {
	    # NOTE: the catch is in case due to an error $fileobj
            # doesn't exist.
	    catch {
		set menuname [$fileobj menubar menuname $filename]
		$fileobj menubar delete $filename
		# Disable the submenu if it's empty
		if { [$fileobj menubar empty $menuname] } {
		    $fileobj menubar disable $menuname
		}
	    }
	}
    }
}

#########################################################################
#########################################################################
####                          public procedures                      ####

#####################################################################
#### callAutoSave
# Check to see whether the object whose name is passed as an argument
# exists and is a File object, and if so, call its autoSave method.
#
body ::tycho::File::callAutoSave {obj} {
    if {[info objects $obj] != "" && [$obj isa ::tycho::File]} {
	$obj autoSave
    }
}

#####################################################################
#### emergencySave
# Call the saveCrash method for all existing objects that are of
# class File, or are derived from class File.
#
body ::tycho::File::emergencySave {} {
    foreach obj [array names fileObjects] {
	$obj saveCrash
    }
}

#####################################################################
#### indicateReadOnly
# Indicate in the status bar and in the menus
# whether modifications are allowed on the buffer.
#
body ::tycho::File::indicateReadOnly {bool} {

    ::tycho::View::indicateReadOnly $bool
    
    if {$bool} {
        menubar disable {Insert...}
        menubar disable Save
    } {
        menubar enable {Insert...}
        menubar enable Save
    }
}

#####################################################################
#### openWin
# Open a file browser, and then open an editor for the file.
# The editor is chosen based on the file extension, if the extension
# is recognized.  Otherwise, the <code>Edit</code> class is used to open an
# ordinary text editor.
#
body ::tycho::File::openWin {} {
    ::tycho::Dialog::new FileBrowser [::tycho::autoName .fileBrowser] \
	    -command "::tycho::File::openContext " \
	    -text "Open File:"
}

#####################################################################
#### openContext
# If an editor has been registered for the file or directory, use it to
# open the file or directory. Otherwise, if it is a file, open a plain
# text editor and return the name of the editor object. If a window
# already exists editing this file, simply raise it instead. New
# windows are always opened at the global scope. File names are
# expanded using <code>::tycho::expandPath</code>, making them absolute
# and unique.
#
body ::tycho::File::openContext {filename} {
    set filename [::tycho::expandPath $filename]

    if {[info exists filesOpen] && \
	    [info exists filesOpen($filename)]} {
	$filesOpen($filename) raiseWindow
	return $filesOpen($filename)
    } {
	#check for existing autosave files
	set filename [checkForAutoSaveFiles $filename]
        set reg [registeredCommands $filename]
        if {$reg != {}} {
            if [catch {
                set command [format $reg $filename]
                set result [uplevel #0 $command]
            } msg] {
                global ::errorInfo
                set saveInfo $errorInfo
                error "Registered command failed on $filename:\n$msg" $saveInfo
            }
            return $result
        } {
            ::tycho::view Edit -file $filename
        }
    }
}

#####################################################################
#### registerContents
# Register directory contents and an associated viewing command.
# By "directory contents" we mean a list of file or directory names
# that may exist inside a directory. The purpose of this method is to
# define an editor or viewer for relatively complicated data that is
# stored in multiple files inside a directory. When such an editor or
# viewer is registered by this method, then any future open-file
# command (via the <code>openContext</code> procedure in this class)
# will recognize a directory that contains the given contents and invoke
# the specified command. The directory must contain <i>all</i> of the
# specified contents items to be recognized.
# <p>
# The <i>filecommand</i> argument is a string with a "%s" embedded.
# The "%s" is replaced with the file name before invoking the command,
# using the Tcl <code>format</code>command. For example, if the command is
# "::tycho::view EditItcl -file {%s}", then the Tycho
# <code>::tycho::view</code>
# procedure will be used to open the file using an
# <code>EditItcl</code> view object. The braces around the "%s" allow
# the file name to have spaces.
# <p>
# If a <i>description</i> argument is a non-empty string, then the
# command will be added to the "Window" menu of all <code>File</code>
# objects opened in the future using the value of this description as
# the menu label. This permits the user to open a new blank editor of
# the given class.
# <p>
# If the <i>editorclass</i> argument is supplied and non-empty, then
# is selects the sub-menu of the Window menu into which the entry
# to open a blank editor will be placed. Legal values are
# "text", "graphics", and "tools".
#
body ::tycho::File::registerContents \
	{contents filecommand {description {}} {editorclass {}}} {
    set editorsContents($contents) $filecommand
    if {$description != {}} {
	lappend windowMenuEntries [list $filecommand $description $editorclass]
    }
}

#####################################################################
#### registerExtensions
# Register one or more file extensions and an associated viewing
# commands. Any future open-file command (via the
# <code>openContext</code> or <code>displayData</code> procedures in
# this class) will recognize a file name that has the given extension
# and will use the specified command to open it. Note that the leading
# period is considered part of the extension, as in ".itcl".
# <p>
# The <i>filecommand</i> argument is a string with a "%s" embedded.
# The "%s" is replaced with the file name before invoking the command,
# using the Tcl <code>format</code>command. For example, if the command is
# "::tycho::view EditItcl -file {%s}", then the Tycho
# <code>::tycho::view</code>
# procedure will be used to open the file using an
# <code>EditItcl</code> view object. The braces around the "%s" allow
# the file name to have spaces.
# <p>
# If a <i>description</i> argument is a non-empty string, then the
# command will be added to the "Window" menu of all <code>File</code>
# objects opened in the future using the value of this description as
# the menu label. This permits the user to open a new blank editor of
# the given class.
# <p>
# If the <i>editorclass</i> argument is supplied and non-empty, then
# is selects the sub-menu of the Window menu into which the entry
# to open a blank editor will be placed. Legal values are
# "text", "graphics", and "tools".
#
body ::tycho::File::registerExtensions \
        {extensions filecommand {description {}} {editorclass {}}} {
    foreach extension $extensions {
	set editorsExtension($extension) $filecommand
    }
    if {$description != {}} {
	lappend windowMenuEntries [list $filecommand $description $editorclass]
    }
}

#####################################################################
#### registerFilenames
# Register one or more file names and an associated viewing command.
# Any future open-file command (via the <code>openContext</code>
# procedure in this class) will recognize a file that has one of the
# given names and will use the specified command to open it.
# <p>
# The <i>filecommand</i> argument is a string with a "%s" embedded.
# The "%s" is replaced with the file name before invoking the command,
# using the Tcl <code>format</code>command. For example, if the command is
# "::tycho::view EditItcl -file {%s}", then the Tycho
# <code>::tycho::view</code>
# procedure will be used to open the file using an
# <code>EditItcl</code> view object. The braces around the "%s" allow
# the file name to have spaces.
# <p>
# If a <i>description</i> argument is a non-empty string, then the
# command will be added to the "Window" menu of all <code>File</code>
# objects opened in the future using the value of this description as
# the menu label. This permits the user to open a new blank editor of
# the given class.
# <p>
# If the <i>editorclass</i> argument is supplied and non-empty, then
# is selects the sub-menu of the Window menu into which the entry
# to open a blank editor will be placed. Legal values are
# "text", "graphics", and "tools".
#
body ::tycho::File::registerFilenames \
	{filenames filecommand {description {}} {editorclass {}}} {
    foreach name $filenames {
	set editorsFilename($name) $filecommand
    }
    if {$description != {}} {
	lappend windowMenuEntries [list $filecommand $description $editorclass]
    }
}

#####################################################################
#### registeredCommands
# Given a file or directory name, return the registered viewing commands.
# If none has been registered, return an empty string.  Otherwise, the
# returned value the registered command for opening a file.
#
body ::tycho::File::registeredCommands {name} {
    if [file isdirectory $name] {
        if {[info exists editorsContents]} {
            set fname [::tycho::expandPath $name]
            foreach cnt [array names editorsContents] {
                set recognized 1
                foreach file $cnt {
                    if ![file exists [file join $fname $file]] {
                        set recognized 0
                        break
                    }
                }
                if $recognized {
                    return $editorsContents($cnt)
                }
            }
        }
        return {}
    } {
	set ext [file extension $name]
	set base [file tail $name]
        if {[info exists editorsExtension] && \
                [info exists editorsExtension($ext)]} {
            return $editorsExtension($ext)
	} elseif {[info exists editorsFilename] && \
                [info exists editorsFilename($base)]} {
            return $editorsFilename($base)
	} else {
            return {}
        }
    }
}

#####################################################################
#### isFileOpen
# Check if the file is already open, if YES, then return the window name,
# if NO, then return empty string.
#
body ::tycho::File::isFileOpen {filename} {
    set filename [::tycho::expandPath $filename]
    if {[info exists filesOpen($filename)]} {
	set winName $filesOpen($filename)
    } else {
	set winName ""
    }
    return $winName
}

#########################################################################
#########################################################################
####                          protected methods                      ####

#####################################################################
#### initializeMenubar
# Initialize the menu bar.  Adds entries specific to this class.
#
body ::tycho::File::initializeMenubar {} {
    global tcl_platform

    # Construct the menus
    $myMenubar addMenu File -underline 0
    $myMenubar addMenu Window -underline 0
    $myMenubar addMenu Help -side right -underline 0

    # File menu contents
    $myMenubar add {Open...} File -underline 0 \
	    -accelerator "C-x C-f" \
	    -command "$this openWinMethod"
    
    $myMenubar command "Switch File..." File -underline 4 \
	    -accelerator "C-x C-v" -command "$this altFile"
    
    $myMenubar command {Insert...} File -underline 0 \
	    -accelerator "C-x i" -command "$this insertFile"
    
    $myMenubar command Save File -underline 0 -accelerator "C-x C-s" \
	    -command "$this save"
    
    $myMenubar command {SaveAs...} File -underline 4 \
	    -accelerator "C-x C-w" -command "$this saveAs"
    
    $myMenubar command {Print...} File -underline 0 \
	    -accelerator "C-x p" -command "$this print"
    
    $myMenubar command Evaluate File -underline 0 \
	    -accelerator "C-x C-r" -command "$this evaluate"
    
    $myMenubar command Reload File -underline 0 \
	    -command "$this reload"
    
    $myMenubar command "Toggle Read-Only" File -underline 0 \
	    -accelerator "C-x C-q" -command "$this toggleReadOnly"

    $myMenubar command "Revision Control..." File -underline 2 \
	    -accelerator "C-x v" -command "$this revisionControl"

    # Windows might have a chmod and RCS.
    if {$tcl_platform(platform) == "macintosh"} {
	$myMenubar disable "Toggle Read-Only"
	$myMenubar disable "Revision Control..."
    }

    $myMenubar addSeparator File
    
    $myMenubar command Close File -underline 0 -accelerator "C-x k" \
	    -command "[displayer] nextWindow; delete object [displayer]"
    
    if {[::tycho::Displayer::normalExit] == 1} {
	$myMenubar command Quit File -underline 0 \
		-accelerator "C-x C-c" \
		-command "::tycho::TopLevel::exitProgram"
    }
    
    # Window menu contents
    
    # Create the submenus for blank editors
    $myMenubar add {Text editors} Window -type cascade
    $myMenubar add {Graphics editors} Window -type cascade
    $myMenubar add {Tools} Window -type cascade

    # Construct menu entries for registered editors.
    foreach entry $windowMenuEntries {
	# Put NoName in place of the filename
	set command [format [lindex $entry 0] NoName]
	set desc [lindex $entry 1]
	set class [lindex $entry 2]
	# Add to a menu
	switch -exact $class {
	    "text" {
		$myMenubar command $desc {Text editors} -command $command
	    }
	    "graphics" {
		$myMenubar command $desc {Graphics editors} -command $command
	    }
	    "tools" {
		$myMenubar command $desc {Tools} -command $command
	    }
	    default {
		# Add to the end of the main menu
		$myMenubar command $desc Window -command $command
	    }
	}
    }
    $myMenubar addSeparator Window

    # Create the submenus for open files
    $myMenubar add {Open HTML viewers} Window -type cascade -state disabled
    $myMenubar add {Open text editors} Window -type cascade -state disabled
    $myMenubar add {Open graphics editors} Window -type cascade\
	    -state disabled
    $myMenubar add {Open tools} Window -type cascade -state disabled

    # use the filesOpen variable to construct menu entries for all open
    # files.
    foreach filename [array names filesOpen] {
	# FIXME: Temporary check for Itcl bug.
	if {$filename != {junktychofileforitclbogosity}} {
	    windowMenuAppend $filesOpen($filename) \
		    $filename $filesOpenTypes($filename)
	}
    }
    
    # Help menu contents
    
    $myMenubar command "About Tycho" Help -underline 0 -command \
	    {::tycho::welcomeMessage $TychoBinaryInfo $TychoVersionInfo}
    
    global ::TYCHO
    $myMenubar command "Tycho Home Page" Help -underline 0 -command \
	    {::tycho::File::openContext \
	    [file join $TYCHO doc index.html]}

    $myMenubar command "Guide to $myclass widget" Help -underline 0 \
	    -command "$this help"
    
    $myMenubar command "Concept Index..." Help -underline 8 \
	    -command {::tycho::File::openContext \
	    [file join \$TYCHO lib idx tycho.idx]}
    
    set nm [::tycho::autoName .index]
    $myMenubar command "Code Index..." Help -underline 0 \
	    -command "::tycho::IndexBrowser $nm \
	    -file [file join \$TYCHO lib idx codeDoc.idx] \
	    -width 80; $nm centerOnScreen"
    
    $myMenubar command "Class Diagram" Help -underline 6 -command \
	    {::tycho::File::openContext \
	    [file join \$TYCHO doc tychoClasses.dag]}

    $myMenubar command "Itcl man pages" Help -underline 0 \
	    -command "$this ::tycho::File::openItclHTMLPage"

    # Add the Preferences menu. This is probably the wrong place
    # for it, but it will do until we figure out a good menu to
    # put it in that doesn't keep disappearing...
    $myMenubar command "Preferences..." Help -underline 0 \
	    -command { ::tycho::preferencedialog }
}

#####################################################################
#### saveText
# Return the text to save.  In this base class, trigger an error,
# since we don't know how to save.  This should be redefined in derived
# classes.
#
body ::tycho::File::saveText {} {
    error "Tried to save to file: $file.\nSave not implemented yet."
}

#########################################################################
#########################################################################
####                          private methods                        ####

#####################################################################
#### removeBackupFiles
# Remove the backup file that gets automatically created periodically,
# if it exists.  Also remove the crash-recovery file, if it exists.
#
body ::tycho::File::removeBackupFiles {} {
    set savefile [file join [file dirname $file] "#auto#[file tail $file]"]
    ::tycho::rm -f $savefile
    set savefile [file join [file dirname $file] "#crash#[file tail $file]"]
    ::tycho::rm -f $savefile
}


#########################################################################
#########################################################################
####                          private procedures                     ####

#####################################################################
#### checkForAutoSaveFiles
# Check to see whether there is an auto-save or crash recovery file for
# the supplied filename that is newer than the file corresponding to
# the supplied filename. If so, query the user to see whether first the
# crash recovery file, then the autosave file should be opened. Return
# the name of the file that should be opened.
#
body ::tycho::File::checkForAutoSaveFiles {filename} {

    # Get the names of the backup and crash recovery files.
    set filetail [file tail $filename]
    set emerfile [file join [file dirname $filename] "#crash#$filetail"]
    set backfile [file join [file dirname $filename] "#auto#$filetail"]

    # See whether a backup or crash recovery files exists and is
    # newer than the file being opened.
    if [file exists $emerfile] {
	if [file exists $filename] {
	    if {[file mtime $emerfile] > [file mtime $filename]} {
		if [::tycho::askuser "A crash recovery file exists for\
			$filename. \
			\nDo you wish to open it instead?"] {
		    return $emerfile
		}
	    }
	} else {
	    if [::tycho::askuser "A crash recover file exists, but\
		    $filename does not.\
		    \nDo you wish to open the crash recovery file instead?"] {
		return $emerfile
	    }
	}
    }
    if [file exists $backfile] {
	if [file exists $filename] {
	    if {[file mtime $backfile] > [file mtime $filename]} {
		if [::tycho::askuser "A newer auto-save file exists\
			for $filename. \
			\nDo you wish to open it instead?"] {
		    return $backfile
		}
	    }
	} else {
	    if [::tycho::askuser "A auto-save file exists, but \
		    $filename does not.\
		    \nDo you wish to open the auto-save file instead?"] {
		return $backfile
	    }
	}
    }   

    # The original file is the file to open.
    return $filename
}

#####################################################################
#### normalizeClassname
# Given a class name, if it is not fully qualified, qualify it.
# That is, if it begins with "::", then return it unchanged.
# Otherwise, prepend "::tycho::" and return the modified classname.
#
body ::tycho::File::normalizeClassname {classname} {
    if [string match {::*} $classname] {
        return $classname
    } {
        return "::tycho::$classname"
    }
}
