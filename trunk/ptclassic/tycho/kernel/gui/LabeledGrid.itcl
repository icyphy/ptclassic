#
# Labeledgrid
# ----------------------------------------------------------------------
# The Labeledgrid class implements a grid of labeled widgets. It is
# generally used to layout widgets for user inputs, such as entry fields,
# radiobuttons and checkbuttons, option menus, and so on. It uses the
# Tk <b>grid</b> geometry manager to lay out labeled widgets, and
# divides the grid into regions, where each region contains a labeled
# widget, or a labeled group of widgets, each of which can itself contain
# labeled widget or further groups. A number of display styles governing
# label placement and the presence of a border are available.
#
## WISH LIST:
#   This section lists possible future enhancements.  
#
#   1) The Tk grid is really great, but really fails in not providing
#      a way to allow you to say "make columns 3 to 5 all the same width."
#      This support could be added here, perhaps using the techniques
#      in ButtonBox.
#   2) The iwidgets optionmenu won't take the focus. Maybe it should, so
#      you could use cursor keys to change the selection.
#   3) Cursor keys should traverse the grid, like in Widgettree.
#
# ----------------------------------------------------------------------
#  AUTHOR: H. John Reekie              EMAIL: johnr@eecs.berkeley.edu
#
#  Based on the tycho::Labeledgrid widget by Prof. Edward A. Lee of
#  UC Berkeley.  iwidgets::Labeledgrid adds more structured grid
#  placement, different display styles, and the facility to support
#  arbitrary widget types. Original author is  Prof. Edward A. Lee;
#  additional contributions by Joel R. King, Bilung Lee, Christopher Hylands,
#  Seehyun Kim, and Mark L. Ulferts. Labeledgrid is contributed to
#  [incr Widgets] by the Tycho project at UC Berkeley:
#  http://ptolemy.eecs.berkeley.edu/tycho.
#
#  $Id$
# ----------------------------------------------------------------------
#
# Copyright (c) 1995-1997 The Regents of the University of California.
# All rights reserved.
# 
# Permission is hereby granted, without written agreement and without
# license or royalty fees, to use, copy, modify, and distribute this
# software and its documentation for any purpose, provided that the
# above copyright notice and the following two paragraphs appear in all
# copies of this software.
# 
# IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY
# FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
# ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF
# THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.
# 
# THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE
# PROVIDED HEREUNDER IS ON AN "AS IS" BASIS, AND THE UNIVERSITY OF
# CALIFORNIA HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,
# ENHANCEMENTS, OR MODIFICATIONS.
# 
# 						PT_COPYRIGHT_VERSION_2
# 						COPYRIGHTENDKEY
#######################################################################

#
# Usual options.
#
itk::usual Labeledgrid {
    keep -font -background -cursor -highlightthickness -highlightcolor
}

# ------------------------------------------------------------------
##                            QUERY
# ------------------------------------------------------------------
#
# The Labeledgrid class implements a grid of labeled widgets. It is
# generally used to layout widgets for user inputs, such as entry fields,
# radiobuttons and checkbuttons, option menus, and so on. It uses the
# Tk <b>grid</b> geometry manager to lay out labeled widgets, and
# divides the grid into regions, where each region contains a labeled
# widget, or a labeled group of widgets, each of which can itself contain
# labeled widget or further groups. A number of display styles governing
# label placement and the presence of a border are available.
#
# Because a labeled grid is typically used to provide layout for dialog
# boxes for user input, Labeledgrid provides a set of standard operations
# on widgets regardless of what type they are. The operations are: setting
# the current value, reading the current value, enabling and disabling
# user input, and creating and deleting the widget.
#
# Labeledgrid provides a useful set of widgets for placing into a layout,
# including entry and text fields, radio buttons and check buttons,
# and option menus. Since the number of different kinds of widget that
# could be placed into a Labeledgrid window is potentially unlimited,
# the newtype{} procedure is provided so that new widget types can
# be added to Labeledgrid's collection of known widget types.
# ------------------------------------------------------------------
class iwidgets::Labeledgrid {
    inherit itk::Widget
    
    constructor {args} {}
    destructor {}
    
    itk_option define -columnspan columnSpan ColumnSpan 4
    itk_option define -childcolumnspan childColumnSpan ChildColumnSpan 4
    itk_option define -childstyle childStyle ChildStyle "simple"

    itk_option define -entrybackground entryBackground Background grey90

    itk_option define -font font Font \
            "-Adobe-Helvetica-Medium-R-Normal--*-120-*-*-*-*-*-*"
    itk_option define -labelfont labelFont Font  \
            "-Adobe-Helvetica-Bold-R-Normal--*-120-*-*-*-*-*-*"
    itk_option define -labelforeground labelForeground Foreground black
    itk_option define -labelanchor labelAnchor Anchor "e"

    itk_option define -highlightcolor highlightColor HighlightColor black
    itk_option define -highlightthickness highlightThickness \
	    HighlightThickness 2

    itk_option define -padx padX PadX 0
    itk_option define -pady padY PadY 0
    
    method add     {type tag args}
    method assign  {tag value}
    method delete  {tag}
    method disable {tag}
    method enable  {tag}
    method exists  {tag}
    method get     {{tag {}}}
    method group   {tag args}
    method hskip   {{group {}} args}
    method names   {{group {}}}
    method vskip   {{group {}} args}
    
    proc newtype {type args} {}   ;# add a new type
    
    private method _do   {cmdtype tag args}
    private method _drawitem \
            {tag style label col row colspan rowspan {path {}} {sticky {}}}
    private method _text {path value args}
    

    # Unique counters
    private common widgetCounter 0   ;# counter to generate unique numbers
    private variable itemCounter 0   ;# Counter to generate widget paths
    private variable unique          ;# unique for each widget

    # Gridding variables: one entry per item, indexed by tag
    private variable _row           ;# item row w/o borders
    private variable _col           ;# item column w/o borders
    private variable _rowspan       ;# the height of this item with borders
    private variable _lastcol       ;# last column of item
    private variable _nextcol       ;# next column after this item
    private variable _height        ;# height of the current row w/ borders
    private variable _curcol        ;# current grid column
    private variable _currow        ;# current grid row
    private variable _childspan     ;# default span of child widgets
    private variable _childstyle    ;# default style of child widgets

    # Item information, one per item
    private variable _type          ;# the type of each item
    private variable _children      ;# the children of each group

    private common _assign     ;# assign to a widget
    private common _create     ;# create a new widget
    private common _disable    ;# disable a widget
    private common _enable     ;# enable a widget
    private common _get        ;# get a widget's value
    private common _sticky     ;# options for stickiness of each type
    private common _options    ;# options for itk_component add

    # Default type options
    private common _defaulttypeoptions {
	-assign   {set %v %x}
	-create   {}
	-delete   {destroy %w}
	-disable  {%w configure -state disabled}
	-enable   {%w configure -state normal}
	-get      {set %v}
	-sticky   "ew"
	-options  {usual}
    }
    method debug {args} {
	eval $args
    }
}

#
# Use option database to override default resources.
#
# option add *Labeledgrid.thickness 3 widgetDefault ???

#
# Provide a lowercase access method for the Labeledgrid class.
#
proc ::iwidgets::labeledgrid { path args } {
    # Create widget
    uplevel ::iwidgets::Labeledgrid $path $args
}

# ------------------------------------------------------------------
##                        CONSTRUCTOR
# ------------------------------------------------------------------
body iwidgets::Labeledgrid::constructor {args} {
    set _row() 0
    set _col() 0
    set _currow() 0
    set _curcol() 0
    set _height() 1
    set _type() "group"

    set unique [incr widgetCounter]
    
    # Evaluate options
    eval itk_initialize $args
}


# ------------------------------------------------------------------
##                             OPTIONS
# ------------------------------------------------------------------

# ----------------------------------------------------------------------
## OPTION -childcolumnspan
#
# The default column span of top-level items. If zero, the span
# will be the same as the -columnspan option. The default is zero.
# Changing this option only affects the default column span of
# items subsequently added to the grid, not of items already added. 
# ----------------------------------------------------------------------
configbody iwidgets::Labeledgrid::childcolumnspan {
    set _childspan() $itk_option(-childcolumnspan)
}

# ----------------------------------------------------------------------
## OPTION -childstyle
#
# The default style of top-level items. The default is "simple".
# ----------------------------------------------------------------------
configbody iwidgets::Labeledgrid::childstyle {
    set _childstyle() $itk_option(-childstyle)
}

# ----------------------------------------------------------------------
## OPTION -columnspan
#
# The column span in the grid. The default is four. Changing
# this option only affects the layout of items subsequently added
# to the grid, not of items already added.
# ----------------------------------------------------------------------
configbody iwidgets::Labeledgrid::columnspan {
    set _columnspan() $itk_option(-columnspan)
    set _nextcol() $itk_option(-columnspan)
    set _lastcol() $itk_option(-columnspan)
}

# ----------------------------------------------------------------------
## OPTION -labelanchor
#
# The default anchoring of the text labels in the <b>simple</b>
# style. The value of this option
# is passed directly to the <b>-sticky</b> option of the Tk <b>grid</b>
# command. It can be overridden for individual widgets and labels
# by calling the <b>grid configure</b>command with the Tk widget
# path as argument.
# ----------------------------------------------------------------------
configbody iwidgets::Labeledgrid::labelanchor {
}

# ----------------------------------------------------------------------
## OPTION -labelforeground
#
# The foreground color of the text labels.
# ----------------------------------------------------------------------
configbody iwidgets::Labeledgrid::labelforeground {
}

# ----------------------------------------------------------------------
## OPTION -labelfont
#
# The font of the text labels.
# ----------------------------------------------------------------------
configbody iwidgets::Labeledgrid::labelfont {
}

# ----------------------------------------------------------------------
## OPTION -padx
#
# The horizontal padding to use when gridding widgets.
# ----------------------------------------------------------------------
configbody iwidgets::Labeledgrid::padx {
    foreach tag [array names _type] {
	if { $_type($tag) != "group" } {
	    grid configure $itk_component($tag) -padx $itk_option(-padx)
	}
    }
}

# ----------------------------------------------------------------------
## OPTION -pady
#
# The horizontal padding to use when gridding widgets.
# ----------------------------------------------------------------------
configbody iwidgets::Labeledgrid::pady {
    foreach tag [array names _type] {
	if { $_type($tag) != "group" } {
	    grid configure $itk_component($tag) -pady $itk_option(-pady)
	}
    }
}


# ------------------------------------------------------------------
##                             METHODS
# ------------------------------------------------------------------

# ------------------------------------------------------------------
## METHOD: add type tag ?option value...? 
#
# Add a new item to the layout. The first argument is the widget type,
# and is following by the unique tag and an option-value list.
# Options can be any valid for _type_ plus those listed in the docs.
# ------------------------------------------------------------------
body iwidgets::Labeledgrid::add {type tag args} {
    if [::info exists _layout($tag)] {
	error "Item already exists: \"$tag\""
    }
    if ![::info exists _create($type)] {
	error "Unknown item type \"$type\": must be one of \
		[join [array names _create] {, }]"
    }
    # Decompose the tag
    regexp {^((.*)\.)?[^\.]+$} $tag _ _ par

    # Remember key parameters
    set _type($tag) $type
    lappend _children($par) $tag
    set path $itk_interior._[incr itemCounter]

    # Extract options
    array set opts [list \
	    -initial {} -label {} \
	    -columnspan $_childspan($par) \
 	    -style $_childstyle($par) \
            -sticky $_sticky($type) ]
    array set opts $args

    set value  $opts(-initial)
    set span   $opts(-columnspan)
    set label  $opts(-label)
    set sticky $opts(-sticky)
    set style  $opts(-style)

    unset \
	    opts(-initial)  \
	    opts(-label) \
            opts(-columnspan) \
            opts(-sticky) \
            opts(-style)
    set args [array get opts]

    if ![::info exists [scope $par$unique]] {
	set var [scope $tag$unique]
    } else {
	set var [scope $par$unique]
    }
    # Create the widget and add as a component
    eval $_create($type)
    itk_component add $tag {set path} $_options($type)

    # Draw the item according to its style. Side-effect layout parameters
    _drawitem $tag $style $label \
            $_curcol($par) $_currow($par) \
            $span 1 $itk_component($tag) $sticky

    # Set the initial value if not in a shared group and the value is supplied
    if { ![::info exists [scope $par$unique]] && $value != "" } {
	eval $_assign($type)
    }
    # Adjust counters
    if { $_rowspan($tag) > $_height($par) } {
	set _height($par) $_rowspan($tag)
    }
    if { $_nextcol($tag) >= $_lastcol($par) } {
	set _curcol($par) $_col($par)
	incr _currow($par) $_height($par)
	set _height($par) 1
    } else {
	set _curcol($par) $_nextcol($tag)
    }
}

# ------------------------------------------------------------------
## METHOD: assign tag value
#
# Assign a value to an item. If a shared group, just set the variable.
# If a widget, evaluate its script. If a group, set each child.
# ------------------------------------------------------------------
body iwidgets::Labeledgrid::assign {tag value} {
    if ![::info exists _type($tag)] {
	error "Unknown tag: \"$tag\""
    }
    if { $_type($tag) == "group" } {
	if [::info exists [scope $tag$unique]] {
	    # Shared group
	    set [scope $tag$unique] $value
	} else {
	    # Not a shared group
	    foreach {t v} $value {
		assign $t $v
	    }
	}
    } else {
	_do assign $tag $value
    }
}

# ------------------------------------------------------------------
## METHOD: delete tag
#
# Delete an item. Delete recursively if the item is a group.
# ------------------------------------------------------------------
body iwidgets::Labeledgrid::delete {tag} {
    if ![::info exists _type($tag)] {
	error "Unknown tag: \"$tag\""
    }
    if { $_type($tag) == "group" } {
	foreach t $_children($tag) {
	    delete $t
	}
    }
    _do delete $tag
    catch {destroy $itk_component($tag)}
    catch {destroy$itk_component(${tag}label)}
    catch {destroy $itk_component(${tag}frame)}
    catch {destroy $itk_component(${tag}border)}

    catch {grid forget $itk_component($tag)}
    catch {grid forget $itk_component(${tag}label)}
    catch {grid forget $itk_component(${tag}frame)}
    catch {grid forget $itk_component(${tag}border)}
    
    # Clean up internal data
    unset _row($tag)
    unset _col($tag)
    unset _currow($tag)
    unset _curcol($tag)
    unset _columnspan($tag)
    unset _rowspan($tag)
    unset _childspan($tag)
    
    if [regexp {^((([^\.]+).)*)[^\.]+$} $tag _ _ par] {
        set t [lsearch -exact $_children($par) $tag]
        set _children($par) [lreplace $_children($par) $t $t]
    }
}

# ------------------------------------------------------------------
## METHOD: disable tag
#
# Disable an item. Disable recursively if the item is a group.
# ------------------------------------------------------------------
body iwidgets::Labeledgrid::disable {tag} {
    if ![::info exists _type($tag)] {
	error "Unknown tag: \"$tag\""
    }
    if { $_type($tag) == "group" } {
	foreach t $_children($tag) {
	    disable $t
	}
    } else {
	_do disable $tag
    }
}

# ------------------------------------------------------------------
## METHOD: enable tag
#
# Enable an item. Enable recursively if the item is a group.
# ------------------------------------------------------------------
body iwidgets::Labeledgrid::enable {tag} {
    if ![::info exists _type($tag)] {
	error "Unknown tag: \"$tag\""
    }
    if { $_type($tag) == "group" } {
	foreach t $_children($tag) {
	    enable $t
	}
    } else {
	_do enable $tag
    }
}

# ------------------------------------------------------------------
## METHOD: exists tag
#
# Return one if _tag_ exists, otherwise zero.
# ------------------------------------------------------------------
body iwidgets::Labeledgrid::exists {tag} {
    ::info exists _type($tag)]
}

# ------------------------------------------------------------------
## METHOD: get ?tag?
#
# Get the value of an item. If _tag_ is a widget or shared group,
# return its value. If it's a non-shared group, return a name-value
# list, where _name_ is relative to _tag_. The list is _not_ recursive.
# ------------------------------------------------------------------
body iwidgets::Labeledgrid::get {{tag {}}} {
    if ![::info exists _type($tag)] {
	error "Unknown tag: \"$tag\""
    }
    if { $_type($tag) == "group" } {
	if [::info exists [scope $tag$unique]] {
	    # Shared group
	    set [scope $tag$unique]
	} else {
	    # Not a shared group.
	    set result {}
	    foreach t $_children($tag) {
		regsub ^[list $tag]\.? $t {} nm
		if [::info exists [scope $t$unique]] {
		    lappend result $nm [set [scope $t$unique]]
		} elseif { $_type($t) != "group" } {
		    lappend result $nm [_do get $t]
		}
	    }
	    return $result
	}
    } else {
	# Simple widget
        _do get $tag
    }
}

# ------------------------------------------------------------------
## METHOD: group tag $args
#
# Add a group. Options are as described in <i>Item Groups</i> above.
# Raise an error if an item with that tag already exists.
# ------------------------------------------------------------------
body iwidgets::Labeledgrid::group {tag args} {
    if [::info exists _layout($tag)] {
	error "Item already exists: \"$tag\""
    }
    # Decompose the tag
    regexp {^((.*)\.)?[^\.]+$} $tag _ _ par

    # Remember key parameters
    set _type($tag) group
    lappend _children($par) $tag
    set path $itk_interior._[incr itemCounter]

    # Extract options
    array set opts [list \
            -initial    {} \
            -label      {} \
            -row        $_currow($par) \
            -column     $_curcol($par) \
            -rowspan    1 \
            -columnspan $_childspan($par) \
            -childcolumnspan  1 \
            -style      $_childstyle($par) \
            -childstyle plain]
    array set opts $args

    # Draw the borders according to style. Side-effect layout parameters
    _drawitem $tag $opts(-style) $opts(-label) \
            $_curcol($par) $_currow($par) \
            $opts(-columnspan) $opts(-rowspan)

    # Set up counters for this group
    set _currow($tag) $_row($tag)
    set _curcol($tag) $_col($tag)
    set _height($tag) 1
    set _childspan($tag)  $opts(-childcolumnspan)
    set _childstyle($tag) $opts(-childstyle)

    # Adjust counters
    if { $_rowspan($tag) > $_height($par) } {
	set _height($par) $_rowspan($tag)
    }
    if { $_nextcol($tag) >= $_lastcol($par) } {
	set _curcol($par) $_col($par)
	incr _currow($par) $_height($par)
	set _height($par) 1
    } else {
	set _curcol($par) $_nextcol($tag)
    }
    # If the initial value is not null, create the shared variable and
    # assign it -- that way we know it's a shared group later
    if { $opts(-initial) != "" } {
        set [scope $tag$unique] $opts(-initial)
    }
}

# ------------------------------------------------------------------
## METHOD: hskip ?group? ?option value... ?
#
# Skip a column. If _group_ is supplied, then this is the group to
# skip within. Options can be any supported by the Tk grid
# columnconfigure{} command. If we skip past the end of the row,
# call vskip{} to move to the next row. 
# ------------------------------------------------------------------
body iwidgets::Labeledgrid::hskip {{group {}} args} {
    if { [llength $args] & 1 } {
	set args [concat $group $args]
	set group {}
    }
    if { $args != "" } {
	eval grid columnconfigure $itk_interior $_curcol($group) $args
    }
    if { [incr $_curcol($group)] >= $_lastcol($group) } {
        vskip $tag
    }
}

# ------------------------------------------------------------------
## METHOD: names ?group?
#
# Get a list of names. If _group_ is supplied, it must be a non-shared
# group, and this method will return the names within that group.
# If _group_ is not supplied, return the names at the top level.
# Raise an error if _group_ is unknown or not an unshared group.
# ------------------------------------------------------------------
body iwidgets::Labeledgrid::names {{group {}}} {
    if ![::info exists _type($group)] {
	error "Unknown tag: \"$group\""
    }
    if { $_type($group) != "group" } {
	error "Cannot get names in non-group item \"$group\""
    }
    set result {}
    foreach c $_children($group) {
	lappend result [lindex [split $c .] end]
    }
    return $result
}

# ------------------------------------------------------------------
## METHOD: vskip ?group? ?option value... ?
#
# Skip a row. If _group_ is supplied, then this is the group to
# skip within. Options can be any supported by the Tk grid
# rowconfigure{} command. The number of rows skipped is the rowspan
# of the largest item in the given group.
# ------------------------------------------------------------------
body iwidgets::Labeledgrid::vskip {{group {}} args} {
    if { [llength $args] & 1 } {
	set args [concat $group $args]
	set group {}
    }
    if { $args != "" } {
	eval grid rowconfigure $itk_interior $_currow($group) $args
    }
    set _curcol($group) $_col($group)
    incr _currow($group) $_height($group)
    set _height($group) 1
}

# ------------------------------------------------------------------
##                           PRIVATE METHODS
# ------------------------------------------------------------------

# ------------------------------------------------------------------
## METHOD: _drawitem tag style label col row colspan rowspan ?path? ?sticky?
#
# Draw an item and update the grid parameters accordingly. Input:
# <ul>
# <li>_col_ is the absolute base column of the item including borders
# <li>_row_ is the absolute base row of the item including borders
# <li>_colsnap_ is the column span of the item without borders
# <li>_rowspan_ is the row span of the item without borders
# </ul>
#
# Output:
# <ul>
# <li><i>_col($tag)</i> is the absolute base column of the item without borders
# <li><i>_row($tag)</i> is the absolute base row of the item without borders
# <li><i>_lastcol($tag)</i> is the last column of this item
# <li><i>_nextcol($tag)</i> is the next column after this item
# <li><i>_rowspan($tag)</i> is the height including borders
# </ul>
# ------------------------------------------------------------------
body iwidgets::Labeledgrid::_drawitem {tag style label \
	col row colspan rowspan {path {}} {sticky {}}} {
    set delta 0
    switch -exact $style {
	"plain" {
	    if { $path != "" } {
		grid $path \
			-row $row -column $col \
			-columnspan $colspan \
			-rowspan $rowspan \
			-sticky $sticky \
			-padx $itk_option(-padx) \
			-pady $itk_option(-pady)
            }
	}
	"simple" {
	    # Label
	    itk_component add ${tag}label {
		label $itk_interior._[incr itemCounter] -text $label
	    } {
		keep -background -cursor
		rename -font -labelfont labelFont Font
		rename -foreground -labelforeground labelForeground Foreground
	    }
	    grid $itk_component(${tag}label) \
		    -row $row \
		    -column $col \
		    -sticky $itk_option(-labelanchor)
	    incr col
	    incr colspan -1

	    # Item
	    if { $path != "" } {
		grid $path \
			-row $row -column $col \
			-columnspan $colspan \
			-rowspan $rowspan \
			-sticky $sticky \
			-padx $itk_option(-padx) \
			-pady $itk_option(-pady)
	    }
        }
        "separated" {
	    # Create and grid the frame that contains the separator and label
            itk_component add ${tag}frame {
                frame $itk_interior._[incr itemCounter] -height 36
            }
            grid $itk_component(${tag}frame) \
                    -row $row -column $col \
                    -rowspan 1 -columnspan [expr $colspan+1] \
                    -sticky ew

            # Create the label and grid it.
            itk_component add ${tag}label {
                label $itk_interior._[incr itemCounter] -text $label
            }
	    grid $itk_component(${tag}label) \
		    -row $row -column $col -sticky sw -pady 9
	    incr col
	    incr colspan -1

	    # Create and place the separator line
            itk_component add ${tag}separator {
                frame $itk_interior._[incr itemCounter] \
                        -height 2 -borderwidth 1 -relief sunken
            }
            place $itk_component(${tag}separator) \
                    -x 0 -rely 1 -y -9 \
                    -relwidth 1 \
                    -in $itk_component(${tag}frame)

            # Now grid the item and raise it so it shows
            incr row
	    if { $path != "" } {
		grid $path \
			-row $row -column $col \
			-columnspan $colspan \
			-rowspan $rowspan \
			-sticky $sticky \
			-padx $itk_option(-padx) \
			-pady $itk_option(-pady)
                raise $path
            }
            incr rowspan 1
	}
	"boxed" {
	    # Create and grid the frame that covers the whole region
            itk_component add ${tag}frame {
                frame $itk_interior._[incr itemCounter]
            }
            grid $itk_component(${tag}frame) -row $row -column $col \
                    -rowspan $rowspan -columnspan $colspan \
                    -sticky nsew

            # Configure the border rows and columns. (How can we avoid
            # doing this redundantly?)
            grid columnconfigure $itk_interior $col -minsize 12
            grid columnconfigure $itk_interior [expr $col+$colspan-1] \
                    -minsize 12
            grid rowconfigure $itk_interior $row -minsize 24
            grid rowconfigure $itk_interior [expr $row+$rowspan-1] -minsize 12

            # Create the border and place it
            itk_component add ${tag}border {
                frame $itk_interior._[incr itemCounter] \
                        -borderwidth 2 -relief groove
            }
            place $itk_component(${tag}border) \
                    -x 6 -y 12 \
                    -width -12 -height -18 -relwidth 1 -relheight 1 \
                    -in $itk_component(${tag}frame)

            # Create the label and place it. -labelanchor is ignored.
            itk_component add ${tag}label {
                label $itk_interior._[incr itemCounter] -text $label
            }
            place $itk_component(${tag}label) -x 12 -y 12 -anchor w \
                    -in $itk_component(${tag}frame)

            # Now grid the item and raise it so it shows
            incr col
	    incr colspan -2
            incr row
	    if { $path != "" } {
		grid $path \
			-row $row -column $col \
			-columnspan $colspan \
			-rowspan $rowspan \
			-sticky $sticky \
			-padx $itk_option(-padx) \
			-pady $itk_option(-pady)
                raise $path
            }
            incr delta
            incr rowspan 2
	}
	default {
	    error "Unknown style: \"$style\""
	}
    }
    # By the time we get here, row and col must be the base
    # of the actual item. rowspan must be the full height;
    # colspan must be the distance to the next item
    set _col($tag) $col
    set _row($tag) $row
    set _lastcol($tag) [incr col $colspan]
    set _nextcol($tag) [incr col $delta]
    set _rowspan($tag) $rowspan
}

# ------------------------------------------------------------------
## METHOD: _do mode tag ?value?
#
# Evaluate a command to evaluate on an item. The _cmdtype_ argument
# selects the command type.
# ------------------------------------------------------------------
body iwidgets::Labeledgrid::_do {cmdtype tag {value {}}} {
    set command [set _[set cmdtype]($_type($tag))]

    regexp {^((.*)\.)?[^\.]+$} $tag _ _ par
    if [::info exists [scope $par$unique]] {
        set var [scope $par$unique]
    } else {
        set var [scope $tag$unique]
    }
    set path $itk_component($tag)
    
    eval [set _[set cmdtype]($_type($tag))]
}

# ------------------------------------------------------------------
## METHOD: _text path args
#
# Helper method to create a text item.
# ------------------------------------------------------------------
body iwidgets::Labeledgrid::_text {path args} {
    # Create the widget
    eval ::iwidgets::scrolledtext $path \
	    -hscrollmode dynamic \
	    -vscrollmode dynamic \
	    -height 100 \
	    $args

    # Make it so that Tab traversal still works. Firstly, we
    # have to unset the -takefocus option from various components.
    $path component text configure -takefocus 0
    $path component horizsb configure -takefocus 0
    $path component vertsb configure -takefocus 0
    
    # [incr Tk]'s -takefocus handling is bogus. Bypass it.
    bind $path <FocusIn> "focus [$path component text]; break"

    # Now override the text widget Tab binding to pass the focus on
    bind [$path component text] <Tab> \
	    "focus \[tk_focusNext [$path component text]\]; break"
}

# ------------------------------------------------------------------
##                          PROCEDURES
# ------------------------------------------------------------------

# ------------------------------------------------------------------
## PROCEDURE: newtype type ?option value?
#
# Add a new item type to the Labeledgrid class. Following arguments are
# an option-value list, where legal options are as described in the
# docs. Raise an error if the _type_ already exists, or if an invalid
# option is specified.
# ------------------------------------------------------------------
body iwidgets::Labeledgrid::newtype {type args} {
    if [::info exists _create($type)] {
	error "Type \"$type\" is already defined"
    }
    array set opts $_defaulttypeoptions
    array set opts $args

    # Get the control scripts and substitute for % keys
    foreach c {assign create delete disable enable get} {
        set script $opts(-$c)
        unset opts(-$c)
	regsub -all %w $script {$path} script
        regsub -all %v $script {$var} script
        regsub -all %t $script {$tag} script
        regsub -all %Q $script {$this} script
        regsub -all %a $script {$args} script
        regsub -all %x $script {$value} script
	set _[set c]($type) $script
    }

    # Get the options and stuff
    foreach c {sticky options} {
	set _[set c]($type) $opts(-$c)
        unset opts(-$c)
    }
    if { [array names opts] != "" } {
	error "bad option: \"[lindex [array names opts] 0]\""
    }
}

# ------------------------------------------------------------------
# Initialize predefined types. Unfortunately, we can't put this code
# in the class definition because the proc body hasn't been defined yet...
# ------------------------------------------------------------------
Labeledgrid::newtype checkbutton \
        -create {eval ::checkbutton %w -variable {%v} %a} \
        -sticky "w"

Labeledgrid::newtype entry \
        -create {eval ::entry %w -textvariable {%v} %a} \
        -assign {%w delete 0 end; %w insert 0 %x} \
        -options {
    usual
    rename -background -entrybackground entryBackground Background
}

Labeledgrid::newtype optionmenu \
        -create {eval ::iwidgets::optionmenu %w %a} \
        -assign {%w select %x}

Labeledgrid::newtype radiobutton \
        -create {eval ::radiobutton %w -variable {%v} %a} \
        -sticky "w"

Labeledgrid::newtype text \
        -create {eval _text %w %a} \
        -assign {%w delete 0.0 end; %w insert end %x} \
	-get {%w get 0.0 end} \
	-options {
    usual
    keep -highlightthickness -highlightcolor
    rename -textbackground -entrybackground entryBackground Background
    rename -textfont -font font Font
}
