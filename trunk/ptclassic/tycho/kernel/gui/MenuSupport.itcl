# Definition of a menu bar widget
# 
# @Author: Farhana Sheikh
# @Contributors: Edward A. Lee, John Reekie
#
# @Version: $Id$
# 
# @Copyright (c) 1995-%Q% The Regents of the University of California.
# All rights reserved.
#
# Permission is hereby granted, without written agreement and without
# license or royalty fees, to use, copy, modify, and distribute this
# software and its documentation for any purpose, provided that the above
# copyright notice and the following two paragraphs appear in all copies
# of this software.
#
# IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY
# FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
# ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF
# THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.
#
# THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE
# PROVIDED HEREUNDER IS ON AN "AS IS" BASIS, AND THE UNIVERSITY OF
# CALIFORNIA HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,
# ENHANCEMENTS, OR MODIFICATIONS.
# 
#                                        PT_COPYRIGHT_VERSION_2
#                                        COPYRIGHTENDKEY
#######################################################################

#######################################################################
#### MenuSupport
# This class defines functionality that supports a simple interface
# for creating, deleting, enabling, and disabling menus. Do not
# instantiate this class: use its subclasses, such as <i>MenuBar</i>
# and <i>PopupMenu</i>.
#
# The MenuSupport code is designed with some assumptions about how
# menus will be used. First, all menus are accessed by name, including
# sub-menus. Second, as much as possible, menus and entries are accessed
# only by name -- for example, you can disable the menu entry "Undo"
# without knowing which menu the entry is contained in. This makes
# it easier for different widgets to manipulate a common set of menus,
# as well as requiring only one change rather than several if an entry
# needs to be moved. Third, the methods are very forgiving about "errors":
# for example, if you try to create an entry that already exists, then
# the new entry simply replaces the old one; if you try and disable a
# menu entry that does not exist, then the method silently does
# absolutely nothing, on the assumption that one piece of code somewhere
# deleted that entry and it's just easier for you not to have to
# know this (this is very easy to do with a class hierarchy in which
# menus are manipulated at different levels of the hierarchy.)
# What this means is that if you _do_ make an error, such as disabling
# a non-existent menu entry, you will not be notified of the mistake,
# so be careful.
#
class ::tycho::MenuSupport {
    inherit ::tycho::TWidget

    constructor {args} {}
    destructor {}

    ##########################################################################
    ####                            options                               ####

    # The font to use for displaying menus
    itk_option define -font font Font [::tycho::font helvetica]

    # The horizontal menu button padding
    itk_option define -padx padX Pad 5

    # The vertical menu button padding
    itk_option define -pady padY Pad 4

    ###################################################################
    ####                         public methods                    ####

    # Add a menu entry to a menu
    method add {name inMenu args}

    # Add a separator to a menu
    method addSeparator {inMenu args}

    # Clear all entries from a menu (but don't delete the menu)
    method clear {menu}

    # Add a command menu entry to a menu
    method command {name inMenu args}

    # Delete a menu or menu entry
    method delete {name}

    # Disable an entry or an entire menu
    method disable {name}

    # Test if a menu is empty
    method empty {name}

    # Enable an entry or an entire menu
    method enable {name}

    # Get an option of a menu entry
    method entrycget {name option}

    # Set options of a menu entry
    method entryconfigure {name args}

    # Insert a menu entry before the specified entry
    method insert {name before args}

    # Insert a separator before the specified entry
    method insertSeparator {before}

    # Invoke the action for the menu entry
    method invoke {inMenu name} {}

    # Return the menu in which an entry is contained
    method menuname {name}

    # Get an option of a menu
    method menucget {name option}

    # Set options of a menu
    method menuconfigure {name args}


    ##########################################################################
    ####                         protected variables                      ####

    # Each menu has an access path
    protected variable menupath

    # Each entry is contained in a menu
    protected variable entrypath
}


#######################################################################
#### constructor
#
body ::tycho::MenuSupport::constructor {args} {
    eval itk_initialize $args
}

###################################################################
###################################################################
####                      public methods                       ####


#####################################################################
#### add
#
# Add a menu entry to the end of a menu. The method takes the name of
# the menu entry, the name of the menu in which the menu entry is to be
# added and other menu entry options. By default, the created entry
# is a "command" type entry, which executes the specified command when
# the entry is selected. The *-type* option can be used to choose
# a different type of entry. Some common options are:
#
# <ul>
# <li>*-type* _type_: Select the type of entry. Can be _command_
# (the default), _cascade_ (for sub-menus), _radiobutton_, or
# _checkbutton_.
# <li>*-command* _command_: The command to be executed when the entry is
# selected.
# <li>*-underline* _index_: Underline the character of the entry name
# specified by _index_.
# <li>*-accelerator* _string_: Display _string_ next to the entry name.
# </ul>
#
# Any other options understood by the *add* method of the Tk menu widget
# can be given, except for *-menu* and *-label*. If there is already
# an entry with the specified name, an error is generated.
#
body ::tycho::MenuSupport::add {name inMenu args} {
    # Check if the menu exists
    if { ! [::info exists menupath($inMenu)] } {
	error "Menu $inMenu does not exist"
    }

    # If the entry already exists, complain
    if { [::info exists entrypath($name)] } {
	error "Menu $name already exists"
    }

    # Read the "type" option
    if { [set t [lsearch -exact $args -type]] == -1 } {
	set type "command"
    } else {
	set type [lindex $args [expr $t+1]]
	set args [lreplace $args $t [expr $t+1]]
    }

    # Create a sub-menu
    if { $type == "cascade" } {
	set entrypath($name) $menupath($inMenu)
	set menupath($name) $menupath($inMenu).[string tolower [join $name ""]]
	itk_component add $menupath($name) {
	    menu $menupath($name) -tearoff 0
	} {
	    keep -background -cursor -font
	}
	eval $menupath($inMenu) add cascade $args \
		-label [list $name] \
		-menu $menupath($name)
    } else {
	# Create some other type of menu entry
	set entrypath($name) $menupath($inMenu)
	eval $menupath($inMenu) add $type $args -label [list $name]
    }
}

#####################################################################
#### addSeparator
# Add a separator to the end of the specified menu. The first argument
# is the name of the menu. The remaining arguments are passed
# unchanged to the Tk <i>menu</i> <code>add separator</code> command.
#
body ::tycho::MenuSupport::addSeparator {inMenu args} {
    # Check if the menu exists
    if { ! [::info exists menupath($inMenu)] } {
	error "Menu $inMenu does not exist"
    }

    eval $menupath($inMenu) add separator $args
}

#####################################################################
#### clear
# Clear all entries from a menu. If the menu does not exist, then assume
# that it was already deleted, and just return.
#
body ::tycho::MenuSupport::clear {menu} {
    # Check validity
    if { ! [::info exists menupath($menu)] } {
	return
    }

    set i [$menupath($menu) index end]
    if { $i == "none" } {
	return
    }
    # Go from highest to lowest index
    while { $i >= 0 } {
	switch [$menupath($menu) type $i] {
	    "cascade" {
		$this delete [$menupath($menu) entrycget $i -label]
	    }
	    "separator" {
		$menupath($menu) delete $i
	    }
	    default {
		set name [$menupath($menu) entrycget $i -label]
		$menupath($menu) delete $i
		unset entrypath($name)
	    }
	}
	incr i -1
    }
}

#####################################################################
#### command
#
# Add a "command" menu entry to the end of a menu. This is a version
# of the add{} method that is streamlined for the most common type
# of menu entry: command entries.
#
body ::tycho::MenuSupport::command {name inMenu args} {
    # Check if the menu exists
    if { ! [::info exists menupath($inMenu)] } {
	error "Menu $inMenu does not exist"
    }

    # If the entry already exists, complain
    if { [::info exists entrypath($name)] } {
	error "Menu $name already exists"
    }

    # Create the menu entry
    set entrypath($name) $menupath($inMenu)
    eval $menupath($inMenu) add command $args -label [list $name]
}

#####################################################################
#### delete
# Delete a menu or a menu entry. If the specified menu or entry
# does not exist, assume that it was already deleted and just return.
#
body ::tycho::MenuSupport::delete {name} {
    # Check validity
    if { ! [::info exists entrypath($name)] } {
	return
    }

    # If it's a menu, delete it
    if { [::info exists menupath($name)] } {
	# Delete nested submenus
	clear $menupath($name)

	# Delete and forget the menu
	destroy $menupath($name)
	unset menupath($name)
    }

    # Remove the entry from the menu
    $entrypath($name) delete $name
    unset entrypath($name)
}

#####################################################################
#### disable
# Disable a menu or a menu entry. Do nothing if the menu or entry
# does not exist.
#
body ::tycho::MenuSupport::disable {name} {
    # Check validity
    if { ! [::info exists entrypath($name)] } {
	return
    }

    # Disable the menu entry
    $entrypath($name) entryconfigure $name -state disabled
}

#####################################################################
#### enable
# Enable a menu or a menu entry. Do nothing if the menu or entry
# does not exist.
#
body ::tycho::MenuSupport::enable {name} {
    # Check validity
    if { ! [::info exists entrypath($name)] } {
	return
    }

    # Enable the menu entry
    $entrypath($name) entryconfigure $name -state normal
}

#####################################################################
#### empty
# Test if a menu is empty. Flag an error if the menu does not exist.
#
body ::tycho::MenuSupport::empty {name} {
    # Check validity
    if { ! [::info exists menupath($name)] } {
	error "Menu $name does not exist"
    }
    return [string match [$menupath($name) index last] "none"]
}

#####################################################################
#### entrycget
# Get a configuration option of a menu entry. Flag an error if the entry
# does not exist.
#
body ::tycho::MenuSupport::entrycget {name option} {
    # Check validity
    if { ! [::info exists entrypath($name)] } {
	error "$name is not a menu entry"
    }

    # Get the option
    $entrypath($name) entrycget $name $option
}

#####################################################################
#### entryconfigure
# Get or configure options of a menu entry. Flag an error if the entry
# does not exist.
#
body ::tycho::MenuSupport::entryconfigure {name args} {
    # Check validity
    if { ! [::info exists entrypath($name)] } {
	error "$name is not a menu entry"
    }
    
    # Get or set the option(s)
    eval $entrypath($name) entryconfigure [list $name] $args
}

#####################################################################
#### insert
# Insert an entry before the specified entry. An error is flagged
# if the entry to insert before does not exist. If the new entry
# already exists, delete it first so that the new one "replaces"
# the old one.
#
body ::tycho::MenuSupport::insert {name before args} {
    # Check if the entry to insert before exists
    if { ! [::info exists entrypath($before)] } {
	error "Entry $before does not exist"
    }

    # If the entry already exists, delete the old one
    if { [::info exists entrypath($name)] } {
	$this delete $name
    }

    # Read the "type" option
    if { [set t [lsearch -exact $args -type]] == -1 } {
	set type "command"
    } else {
	set type [lindex $args [expr $t+1]]
	set args [lreplace $args $t [expr $t+1]]
    }

    # Create a sub-menu
    if { $type == "cascade" } {
	set entrypath($name) $entrypath($before)
	set menupath($name) [menu $entrypath($before).[string tolower \
		[join $name ""]] \
		-tearoff 0]

	eval $entrypath($before) insert [list $before] cascade $args \
		-label [list $name] \
		-menu $menupath($name)
    } else {
	# Create some other type of menu entry
	set entrypath($name) $entrypath($before)
	eval $entrypath($before) insert [list $before] \
		$type $args -label [list $name]
    }
}

#####################################################################
#### insertSeparator
# Insert a separator before the specified entry. An error is flagged
# if the specified entry does not exist.
#
body ::tycho::MenuSupport::insertSeparator {before} {
    # Check if the entry exists
    if { ! [::info exists entrypath($before)] } {
	error "Entry $before does not exist"
    }

    $entrypath($before) insert $before separator
}

#####################################################################
#### invoke
# Invoke the action for the menu entry.
#
# See the Tk menu man page for a full description of the name argument,
# but briefly index is either a number, 'active', 'end', 'last', 'none'
# @number or a pattern.  Note that since we are doing an eval of $name
# you may need to wrap multi-word menu patterns in two levels of curly
# brackets.
#
body ::tycho::MenuSupport::invoke {inMenu name} {
    # Check if the menu exists
    if { ! [::info exists menupath($inMenu)] } {
	error "Menu $inMenu does not exist"
    }

    eval $menupath($inMenu) invoke $name
}

#####################################################################
#### menuname
# Return the menu in which an entry is contained. Flags an error
# if the entry doesn't exist.
#
body ::tycho::MenuSupport::menuname {name} {
    # Check validity
    if { ! [::info exists entrypath($name)] } {
	error "$name is not a entry"
    }
    foreach {menuname menu} [array get menupath] {
	if { $menu == $entrypath($name) } {
	    return $menuname
	}
    }
    return {}
}

#####################################################################
#### menucget
# Get a configuration option of a menu. Flag an error if the
# menu does not exist. (FIXME: Should it just exit silently?)
#
body ::tycho::MenuSupport::menucget {name option} {
    # Check validity
    if { ! [::info exists menupath($name)] } {
	error "$name is not a menu"
    }
    
    # Get the option
    $menupath($name) cget $option
}

#####################################################################
#### menuconfigure
# Get or configure options of a menu. Flag an error if the
# menu does not exist. (FIXME: Should it just exit silently?)
#
body ::tycho::MenuSupport::menuconfigure {name args} {
    # Check validity
    if { ! [::info exists menupath($name)] } {
	error "$name is not a menu"
    }
    
    # Get or set the option(s)
    eval $menupath($name) configure $args
}
