# Top-level window class.
#
# @Author: Edward A. Lee
#
# @Version: $Id$
#
# @Copyright (c) 1995-%Q% The Regents of the University of California.
# All rights reserved.
# 
# Permission is hereby granted, without written agreement and without
# license or royalty fees, to use, copy, modify, and distribute this
# software and its documentation for any purpose, provided that the
# above copyright notice and the following two paragraphs appear in all
# copies of this software.
# 
# IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY
# FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
# ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF
# THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.
# 
# THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE
# PROVIDED HEREUNDER IS ON AN "AS IS" BASIS, AND THE UNIVERSITY OF
# CALIFORNIA HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,
# ENHANCEMENTS, OR MODIFICATIONS.
# 
# 						PT_COPYRIGHT_VERSION_2
# 						COPYRIGHTENDKEY
##########################################################################


##########################################################################
#### autoName 
# Return a name constructed by augmenting the provided
# stem with a number to guarantee that the name is unique. A global
# (within the tycho namespace) array autoNames is used to keep track of
# the numbers used for each stem. This procedure should be used for
# window classes instead of the #auto facility in itcl to assign to the
# class valid names for windows. Window names must begin with a period.
# By convention, for a class named "Class", we would use the stem
# ".class". Thus, the single argument should be ".class".
# Note that if you invoke this outside the namespace "tycho", you
# must call it "::tycho::autoName".
#
namespace ::tycho {
    proc autoName {stem} {
	global ::autoNames
	if {[info exists autoNames] && [info exists autoNames($stem)]} {
	    incr autoNames($stem)
	} else {
	    set autoNames($stem) 0
	}
	return "$stem$autoNames($stem)"
    }
}

##########################################################################
#### exit
# Redefine the Tcl exit procedure to cleanly exit, querying the user
# to save work.
#
rename ::exit ::tclexit
proc ::exit {{queryUser 1}} {
    ::tycho::TopLevel::exitProgram $queryUser
}

##########################################################################
#### tkMbLeave
# FIXME: For some mysterious reason¸ tk occationally issues this command
# when the window it refers to no longer exists.  A seemly random error
# message appears on the screen.  For now, we just catch.
#
rename ::tkMbLeave ::originalTkMbLeave
proc ::tkMbLeave {arg} {
    catch {::originalTkMbLeave $arg}
}

##########################################################################
#### saferUpdate
# Calling update or even "update idletasks" within a method of any Itcl
# object is very dangerous.  The itcl object may be deleted during the
# update, so when the update returns, you will be trying to execute a
# method for an object that no longer exists.  At least in version 2.0,
# it seems to be safe to test a return value and exit the method, even
# if the object no longer exists.  Thus, if you really have to call update
# inside a method, call saferUpdate instead and return immediately if
# it returns 0.
#
proc ::tycho::saferUpdate {obj} {
    update
    if {[info objects $obj] != {}} {
	return 1
    } {
	return 0
    }
}


##########################################################################
#### TopLevel
# This class creates a top-level window with a single frame in it
# (called <code>$itk_component(childsite)</code>. The class provides
# methods and options for controlling the position of the window on the
# screen, its size, and the focus. It also manages a global list of
# top-level windows for controlling the switching of the focus from one
# window to the next. It also defines miscellaneous generic procedures
# and methods. The window is created in the withdrawn state. It is up
# to the creator of the window to map the window using either "wm
# deiconify" or the method "centerOnScreen". This is normally done
# right after creating the window. The reason for requiring this
# explicit mapping is that windows are often constructed piecemeal by
# combining widgets, and deferring the mapping prevents the visually
# distracting artifact of seeing the window being constructed piece by
# piece. Also, by the time the window gets mapped, its size is known,
# so its position can be controlled effectively.
#
class ::tycho::TopLevel {

    inherit ::itk::Toplevel

    # Specify the logical "next window" (C-x o shifts the focus there).
    itk_option define -before before Before {}

    # Specify the size and/or placement of the window.
    itk_option define -geometry geometry Geometry "" {
 	wm geometry $itk_component(hull) $itk_option(-geometry)
    }

    constructor {args} {}
    destructor {}

    #################################################################
    ####                     public methods                      ####

    # Change the cursor to the "watch" and execute the arguments.
    method busy {args} {}

    # Center the window on the screen.
    method centerOnScreen {}

    # In derived classes, return the current point in a form usable by seePoint.
    method currentPoint {} {return {}}

    # Give the window or a subwindow the focus.
    method focusin {}

    # Prevent interactive resizing of the window.
    method freezeWindowSize {}

    # Open a file and go to its internal point identified by name.
    method hyperJump {file {point {}}}

    # Shift the focus to the next window in the topLevelWindows list.
    method nextWindow {{raise 0}}

    # Return the name of my top-level window.
    method windowName {} {return $itk_component(hull)}

    # Raise the window.
    method raiseWindow {}

    # Find and make visible a point in the display.
    method seePoint {point}

    #################################################################
    ####                   public procedures                     ####

    # Exit the program
    public proc exitProgram {{queryUser 1}} {}

    # Return 1 if we are in the process of exiting, 0 otherwise.
    public proc returnExitCon {} {}

    # Specify whether to exit when the last window is closed.
    public proc exitWhenNoMoreWindows {bool} {}

    #################################################################
    ####                  protected variables                    ####

    # The prefix is just a shorthand for $itk_component(hull).
    # It is the name of the top-level window.
    protected variable prefix

    #################################################################
    ####                  private procedures                     ####

    # Check to see whether any windows are left and exit the program if not.
    private proc exitIfNoMoreWindows {} {}

    #################################################################
    ####                  private variables                      ####

    # A circular list of top-level windows is kept here and supported by
    # the <Control-x><o> binding, which switches the focus to the
    # next window in the list.  The order of the windows in the list
    # is determined as follows: If a window in this application has the
    # focus when a new window is created, then the new window is put in
    # the list right before the one with the focus.  Otherwise, it is
    # put at the beginning of the list.  Thus, the first entry in the list
    # list is always the one to most recently have the focus.
    private common topLevelWindows

    # To ensure that we ask the user only once for confirmation
    # on exiting the program, we use this variable.
    private common exitconfirmed 0

    # If this is non-zero, then when the last window is closed,
    # the program will be exited.
    private common exitflag 1
}

#####################################################################
#### -before option
# By default, a top-level window is inserted in the beginning of the
# list of top-level windows.  Thus, scrolling through windows
# using the "C-x o" binding will visit the windows in the reverse order
# in which they are created.  However, sometimes, we wish to
# place a window in a particular place in this order.  If the
# value of the -before option is non-null, it is taken to be
# the window name of a top-level window that currently exists,
# and the new window is placed in the window order before that one.
#
configbody ::tycho::TopLevel::before {
    # Check to see that $itk_option(-before) is not null before calling winfo
    if {$itk_option(-before) != {} } {
	set tl [winfo toplevel $itk_option(-before)]
	if {$tl != {} &&  \
		[uplevel #0 info objects $tl] != {} && \
		[$tl isa ::tycho::TopLevel]} {
	    $topLevelWindows remove $prefix
	    $topLevelWindows insert $prefix $tl
	}
    }
}

#####################################################################
#### -geometry option
# By default, the geometry option is set to the
# null string, deferring to the window manager the control over
# position. It can be set alternatively to a string of the
# form "+x+y", where x and y give the screen position of
# the upper left corner of the window relative to the upper
# left corner of the screen.  Using "-" instead of "+" will
# define the screen position relative to the right or
# bottom of the screen rather than the left or top.
# FIXME: Putting this here causes Itcl 2.0 to crash.  Should be
# fixed in 2.1.
# 
#configbody ::tycho::TopLevel::geometry {
#    wm geometry $itk_component(hull) $itk_option(-geometry)
#}

#####################################################################
#
body ::tycho::TopLevel::constructor {args} {
    
    # Import the tycho namespace
    import add ::tycho

    # The name of the window
    set prefix $itk_component(hull)
    wm withdraw $prefix
    
    # Create a childsite for the contents of the window
    itk_component add childsite {
	frame $itk_interior.childsite
    } {
	keep -background -cursor
    }
    pack $itk_component(childsite) -fill both -expand yes
    
    # Create a single common instance of the topLevelWindows list.
    if {![info exists topLevelWindows]} {
	set topLevelWindows [::tycho::CircularList #auto]
    }
    
    # Support for switching the focus from one window to the next.
    # We put the new window at the beginning of the list.  It may be
    # later moved using the -before option.
    $topLevelWindows insert $prefix

    bind $prefix <Control-x><o> "$this nextWindow 1; break"
    
    # To prevent the "o" from appearing in Entry windows,
    bind Entry <Control-x><o> { }

    # Explicitly handle configs that may have been ignored earlier.
    eval itk_initialize $args

    # Grab the focus when the window gets mapped.
    bind $itk_component(hull) <Map> "$this focusin; break"

    # Bind the file-open command.
    bind $prefix <Control-x><Control-f> "::tycho::File::openWin; break"

    # Prevent the window manager delete function from exiting.
    wm protocol $prefix WM_DELETE_WINDOW \
	    "$this nextWindow; delete object $this"
}

#####################################################################
#### Destructor
# Destroy the window containing the widget. If there are no remaining
# top-level windows, then exit the program. The latter functionality
# can be disabled by calling
# <code>::tycho::TopLevel::exitWhenNoMoreWindows</code> with the
# argument "0". Normally, you should call <code>nextWindow</code>
# before destroying any top-level that has the focus. This puts the
# focus into the next logical window in the window sequence. Note that
# if the mouse is not over a window belonging to this application after
# a window is deleted, the focus will be given up entirely by the
# application.
# <p>
# NOTE: It would be better if the user were queried for confirmation
# about exiting the program, but this appears to be impossible with the
# current Itcl version.  A call to askuser in this destructor leads to
# very strange behavior, often a core dump. Also, the window is getting
# unmapped before we get to this point, so in effect, there will be no
# remaining open windows even if the user tries to cancel the close.
#
body ::tycho::TopLevel::destructor {} {

    if {[info exists topLevelWindows] && \
	    [info exists prefix] && \
	    [info exists exitflag]} {
	# NOTE: It would be nice to call nextWindow here, rather than
	# having to call it each time before invoking the destructor.
	# However, this produces very erratic behavior.  Often, the
	# application has lost the focus by the time the destructor
	# gets invoked. Tk gets into a weird state.
	$topLevelWindows remove $prefix
	
	# Check to see whether this is the last open window.
	# If so, exit the program.
	if $exitflag {
            after 100 [code ::tycho::TopLevel::exitIfNoMoreWindows]
        }
    }
}

#################################################################
#################################################################
####                     public methods                      ####

#####################################################################
#### busy
# Change the cursor in the childsite widget of this window to the
# "watch" cursor (to indicate that the object is busy), execute the
# arguments as a method invocation for this object, and change the
# cursor back to whatever it was before. In order for the cursor to
# actually change, the method calls "update", and therefore the object
# may no longer exist when the procedure returns (it might be deleted
# during the call to update). If the object does not exist, the
# procedure returns 0. Otherwise, it returns 1 (or an error). You
# should test the return value immediately and return from all methods
# immediately. A typical invocation is therefore as follows:
# <pre>
#     if {![busy methodname arg1 arg2]} {return}
# </pre>
# Be sure you are not just returning to another method.
# If the method is invoked at the top-level, for example in response to
# a key binding, then there is no need to test its return value.
#
body ::tycho::TopLevel::busy {args} {
    set oldCursor [lindex [$itk_component(childsite) config -cursor] end]
    $itk_component(childsite) config -cursor {watch}
    if {![::tycho::saferUpdate $this]} {return 0}

    # Catch errors so that we can reset the cursor
    if {[catch [code [concat $this $args]] msg] != 0} {
	$itk_component(childsite) config -cursor $oldCursor
        global ::errorInfo
        set saveInfo $errorInfo
	error $msg $saveInfo
    }
    $itk_component(childsite) config -cursor $oldCursor
    return 1
}

#####################################################################
#### centerOnScreen
# This procedure will request of the window manager that it center
# the window.  To properly accomplish such centering, this
# should be called after all the widgets have been packed into the
# window, but before any tkwait visibility.
# <p>
# FIXME: This procedure doesn't work with widgets that defer mapping
# (like most iwidgets, including the only one we use, the buttonbox).
# The width of the button box is not taken into account depite the fact
# that everything has been packed into it already. This is because the
# widget actually defers the packing using an "after" command.
#
body ::tycho::TopLevel::centerOnScreen {} {
    # We used to withdraw the window here, but it appears unnecessary.
    update idletasks    

    # Use the larger of the actual width and the requested width
    set w [winfo width $prefix]
    set rw [winfo reqwidth $prefix]
    if {$w > $rw} {set width $w} {set width $rw}
    
    # Use the larger of the actual height and the requested height
    set h [winfo height $prefix]
    set rh [winfo reqheight $prefix]
    if {$h > $rh} {set height $h} {set height $rh}
    
    set x [expr [winfo screenwidth $prefix]/2-$width/2-\
	    [winfo vrootx [winfo parent $prefix]]]
    set y [expr [winfo screenheight $prefix]/2-$height/2-\
	    [winfo vrooty [winfo parent $prefix]]]
    wm geometry $prefix +$x+$y
    wm deiconify $prefix
}

#########################################################################
#### focusin
# Grab the focus.  This should be redefined in derived classes to give
# the focus to the appropriate subwindow.
#
body ::tycho::TopLevel::focusin {} {
    focus $itk_component(hull)
}

#####################################################################
#### freezeWindowSize
# This method freezes the window at its current size, prohibiting
# resizing by the user.
#
body ::tycho::TopLevel::freezeWindowSize {} {
    wm resizable $prefix 0 0
}

#####################################################################
#### hyperJump
# Open a file and go to its internal point identified by name. If the
# filename is the empty string, just call <code>seePoint</code>,
# passing it the second argument. Otherwise, the
# file is opened  with <code>::tycho::File::openContext</code>,
# which will choose an editor based on the filename extension.
# Invoke <code>seePoint</code> to view the specified point within the
# file. The format for the <i>point</i> argument depends on the type of
# file being opened. For HTML files, it will normally be the name of an
# anchor in the file. For text files, it will normally be either "{line
# <i>linenumber</i>}" or "{range <i>start</i> <i>end</i>}", where
# <i>start</i> and <i>end</i> have the form
# <i>linenumber.characternumber</i>.
# 
body ::tycho::TopLevel::hyperJump {file {point {}}} {
    if {$file != {}} {
        set obj [uplevel #0 [list ::tycho::File::openContext $file]]
        if {$point != {}} {
            # The seePoint call is postponed to give time for the widget
            # to be created. The catch is in case it is immediately deleted.
            after 200 [list catch [list $obj seePoint $point]]
        }
    } {
        seePoint $point
    }
}

#####################################################################
#### nextWindow
# Switch the focus to the next window listed in the array topLevelWindows.
# If an argument is given, and is non-zero, then raise the window as well.
#
body ::tycho::TopLevel::nextWindow {{raise 0}} {
    foreach win [$topLevelWindows elements $prefix] {
	if {$win == $prefix} {continue}
	if {[winfo exists $win] && \
		[winfo ismapped $win] && \
		[uplevel #0 info objects $win] != {} && \
		[$win isa ::tycho::TopLevel]} {
	    $win focusin
	    if {$raise != 0} {$win raiseWindow}
	    break
	}
    }
}

#####################################################################
#### raiseWindow
# Bring the corresponding window to the foreground, and make sure it
# is deiconified.
#
body ::tycho::TopLevel::raiseWindow {} {
    wm deiconify $itk_component(hull)
    raise $itk_component(hull)
    focusin
}

#####################################################################
#### seePoint
# In derived classes, this method will go to the point in the display
# identified by the name argument.  What this means depends on what
# type of data being displayed.  In this base class, do
# nothing.
#
body ::tycho::TopLevel::seePoint {point} {
}

#################################################################
#################################################################
####                   public procedures                     ####

#####################################################################
#### exitProgram
# Confirm exit with a dialog, then quit. The destructors will query
# for save of any windows with modified data.  If this routine returns,
# it will return 0 if the user canceled the exit, and 1 if the exit
# is in progress.
#
body ::tycho::TopLevel::exitProgram {{queryUser 1}} {
    if {$queryUser == 1} {
	set response [::tycho::askuser "OK to exit the program?"]
    } else {
	set response 1
    }
    if {$exitconfirmed} {return 1}
    if {$response} {
	set exitconfirmed 1
	# Need to delete all Toplevel objects first to make sure destructors
	# are invoked before the exit process begins.  Catch errors here
	# because an error means that the exit was aborted.
	if {[catch {
	    foreach obj [::info objects] {
		# A second check for object instance is necessary, because the
		# object may have been deleted earlier in the loop.
		if {[::info objects $obj] != {} && \
			[$obj isa ::tycho::TopLevel]} {
		    delete object $obj
		}
	    }
	}] == 0} {
	    ::tclexit
	} {
	    set exitconfirmed 0
	}
    }
    return 0
}

#####################################################################
#### exitWhenNoMoreWindows
# If the argument is zero, then disable the feature (which is enabled
# by default) that when the last window is removed, the program is
# exited (after confirmation).
#
body ::tycho::TopLevel::exitWhenNoMoreWindows {bool} {
    set exitflag $bool
}

#####################################################################
#### returnExitCon
# Return 1 if a confirmed exit is in progress, and 0 otherwise.
#
body ::tycho::TopLevel::returnExitCon {} {
    return $exitconfirmed
}

    #################################################################
    ####                  private procedures                     ####

#####################################################################
#### exitIfNoMoreWindows
# Check to see whether any windows are left and exit the program if not.
#
body ::tycho::TopLevel::exitIfNoMoreWindows {} {
    set noMore 1
    foreach win [$topLevelWindows elements] {
        if [winfo exists $win] {
            # Tycho fonts window handled specially
            if {$win != {.tychoFonts}} {
                set noMore 0
                break
            }
        }
    }
    if $noMore {
        after 100 {::tclexit}
    }
}
