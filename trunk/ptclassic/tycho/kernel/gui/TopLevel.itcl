# Top-level window class.
#
# $Id$
# Author: Edward A. Lee
#
# Copyright (c) 1990-%Q% The Regents of the University of California.
# All rights reserved.
# 
# Permission is hereby granted, without written agreement and without
# license or royalty fees, to use, copy, modify, and distribute this
# software and its documentation for any purpose, provided that the above
# copyright notice and the following two paragraphs appear in all copies
# of this software.
# 
# IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY
# FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
# ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF
# THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.
# 
# THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE
# PROVIDED HEREUNDER IS ON AN "AS IS" BASIS, AND THE UNIVERSITY OF
# CALIFORNIA HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,
# ENHANCEMENTS, OR MODIFICATIONS.
#                                                         COPYRIGHTENDKEY
##########################################################################


##########################################################################
#### autoName 
# This procedure returns a name constructed by augmenting the provided
# stem with a number to guarantee that the name is unique. A global
# (within the tycho namespace) array autoNames is used to keep track of
# the numbers used for each stem. This procedure should be used for
# window classes instead of the #auto facility in itcl to assign to the
# class valid names for windows. Window names must begin with a period.
# By convention, for a class named "Class", we would use the stem
# ".class". Thus, the single argument should be ".class".
# Note that if you invoke this outside the namespace "tycho", you
# must call it "::tycho::autoName".
#
namespace ::tycho {
    proc autoName {stem} {
	global autoNames
	if {[info exists autoNames] && [info exists autoNames($stem)]} {
	    incr autoNames($stem)
	} else {
	    set autoNames($stem) 0
	}
	return "$stem$autoNames($stem)"
    }
}

##########################################################################
#### exit
# We redefine the Tcl exit procedure to cleanly exit, querying the user
# to save work.
#
rename ::exit ::tclexit
proc ::exit {{queryUser 1}} {
    ::tycho::TopLevel::exitProgram $queryUser
}

##########################################################################
#### TopLevel
# This class creates a top-level window with nothing in it, and provides
# a repository for common functions on windows, such as centering them
# on the screen.  The window is created in the withdrawn state.  It is
# up to derived classes to map the window using either "wm deiconify"
# or the method "centerOnScreen".
#
class ::tycho::TopLevel {

    inherit ::itk::Toplevel

    #### -before option
    # Position the window in the list of windows before the given one.
    itk_option define -before before Before {}

    #### -geometry option
    # By default, the geometry option is set to the
    # null string, deferring to the window manager the control over
    # position. It can be set alternatively to a string of the
    # form "+x+y", where x and y give the screen position of
    # the upper left corner of the window relative to the upper
    # left corner of the screen.  Using "-" instead of "+" will
    # define the screen position relative to the right or
    # bottom of the screen rather than the left or top.
    # 
    itk_option define -geometry geometry Geometry "" {
	wm geometry $itk_component(hull) $itk_option(-geometry)
    }

    constructor {args} {}
    destructor {}

    #################################################################
    ####                     public methods                      ####

    #### centerOnScreen
    # Center the window on the screen.
    method centerOnScreen {}

    #### focusin
    # Give the window or a subwindow the focus.
    method focusin {}

    #### freezeWindowSize
    # Prevent interactive resizing of the window.
    method freezeWindowSize {}

    #### nextWindow
    # Shift the focus to the next window in the topLevelWindows list.
    method nextWindow {{raise 0}}

    #### windowName
    # Return the name of my top-level window.
    method windowName {} {return $itk_component(hull)}

    #### raiseWindow
    # Raise the window.
    method raiseWindow {}

    #################################################################
    ####                   public procedures                     ####

    #### exitProgram
    # Exit the program
    public proc exitProgram {{queryUser 1}} {}

    #### returnExitCon
    # Return the value of the exitconfirmed variable.
    public proc returnExitCon {} {}

    #### exitWhenNoMoreWindows
    # If the argument is zero, disable exiting when the last window
    # is closed.
    public proc exitWhenNoMoreWindows {bool} {}

    #################################################################
    ####                  protected variables                    ####

    #### prefix variable
    # The prefix is just a shorthand for $itk_component(hull).
    # It is the name of the top-level window.
    protected variable prefix

    #################################################################
    ####                  private variables                      ####

    # A circular list of top-level windows is kept here and supported by
    # the <Control-x><o> binding, which switches the focus to the
    # next window in the list.  The order of the windows in the list
    # is determined as follows: If a window in this application has the
    # focus when a new window is created, then the new window is put in
    # the list right before the one with the focus.  Otherwise, it is
    # put at the beginning of the list.  Thus, the first entry in the list
    # list is always the one to most recently have the focus.
    private common topLevelWindows

    # To ensure that we ask the user only once for confirmation
    # on exiting the program, we use this variable.
    private common exitconfirmed 0

    # If this is non-zero, then when the last window is closed,
    # the program will be exited.
    private common exitflag 1
}

#####################################################################
#### -before option
# By default, a top-level window is inserted in the beginning of the
# list of top-level windows.  Thus, scrolling through windows
# using the "C-x o" binding will visit the windows in the reverse order
# in which they are created.  However, sometimes, we wish to
# place a window in a particular place in this order.  If the
# value of the -before option is non-null, it is taken to be
# the window name of a top-level window that currently exists,
# and the new window is placed in the window order before that one.
#
configbody ::tycho::TopLevel::before {
    set tl $itk_option(-before)
    if {$tl != {} &&  \
	    [uplevel #0 info objects $tl] != {} && \
	    [$tl isa ::tycho::TopLevel]} {
	$topLevelWindows remove $prefix
	$topLevelWindows insert $prefix $tl
    }
}

#####################################################################
#
body ::tycho::TopLevel::constructor {args} {
    
    # The name of the window
    set prefix $itk_component(hull)
    wm withdraw $prefix
    
    # Create a single common instance of the topLevelWindows list.
    if {![info exists topLevelWindows]} {
	set topLevelWindows [CircularList #auto]
    }
    
    # Support for switching the focus from one window to the next.
    # We put the new window at the beginning of the list.  It may be
    # later moved using the -before option.
    $topLevelWindows insert $prefix

    bind $prefix <Control-x><o> "$this nextWindow 1; break"
    
    # To prevent the "o" from appearing in Entry windows,
    bind Entry <Control-x><o> { }

    # Explicitly handle configs that may have been ignored earlier.
    eval itk_initialize $args

    # Grab the focus when the window gets mapped.
    bind $itk_component(hull) <Map> "$this focusin; break"

    # Bind the file-open command.
    bind $prefix <Control-x><Control-f> "File::openWin; break"

    # Prevent the window manager delete function from exiting.
    wm protocol $prefix WM_DELETE_WINDOW "$this nextWindow; delete object $this"
}

#####################################################################
#### Destructor
# Destroy the window containing the widget. If there are no remaining
# top-level windows that are mapped, then exit the program. The latter functionality can be
# disabled by calling ::tycho::TopLevel::exitWhenNoMoreWindows with the
# argument "0". Normally, you should call nextWindow before destroying
# any top-level that has the focus. This puts the focus into the next
# logical window in the window sequence. Note that if the mouse is not
# over a window belonging to this application after a window is
# deleted, the focus will be given up entirely by the application.
# <p>
# NOTE: It would be better if the user were queried for confirmation
# about exiting the program, but this appears to be impossible with the
# current Itcl version.  A call to askuser in this destructor leads to
# very strange behavior, often a core dump. Also, the window is getting
# unmapped before we get to this point, so in effect, there will be no
# remaining open windows even if the user tries to cancel the close.
#
body ::tycho::TopLevel::destructor {} {

    if {[info exists topLevelWindows] && \
	    [info exists prefix] && \
	    [info exists exitflag]} {
	# NOTE: It would be nice to call nextWindow here, rather than
	# having to call it each time before invoking the destructor.
	# However, this produces very erratic behavior.  Often, the
	# application has lost the focus by the time the destructor
	# gets invoked. Tk gets into a weird state.
	$topLevelWindows remove $prefix
	
	# Check to see whether this is the last open window.
	# If so, exit the program.
	if $exitflag {
	    set noMore 1
	    foreach win [$topLevelWindows elements] {
		if {[winfo exists $win] && [winfo ismapped $win]} {
		    set noMore 0
		    break
		}
	    }
	    if $noMore {
		after 100 {::tclexit}
	    }
	}
    }
}

#################################################################
#################################################################
####                     public methods                      ####

#####################################################################
#### centerOnScreen
# This procedure will request of the window manager that it center
# the window.  To properly accomplish such centering, this
# should be called after all the widgets have been packed into the
# window, but before any tkwait visibility.
# <p>
# FIXME: This procedure doesn't work with widgets that defer mapping
# (like the iwidget buttonbox). The width of the button box is not
# taken into account depite the fact that everything has been packed
# into it already. This is because the widget actually defers the
# packing using an "after" command. This is allegedly done for speed
# reasons, but seems like a bit of a hack to me.
#
body ::tycho::TopLevel::centerOnScreen {} {
    # We used to withdraw the window here, but it appears unnecessary.
    update idletasks    

    # Use the larger of the actual width and the requested width
    set w [winfo width $prefix]
    set rw [winfo reqwidth $prefix]
    if {$w > $rw} {set width $w} {set width $rw}
    
    # Use the larger of the actual height and the requested height
    set h [winfo height $prefix]
    set rh [winfo reqheight $prefix]
    if {$h > $rh} {set height $h} {set height $rh}
    
    set x [expr [winfo screenwidth $prefix]/2-$width/2-\
	    [winfo vrootx [winfo parent $prefix]]]
    set y [expr [winfo screenheight $prefix]/2-$height/2-\
	    [winfo vrooty [winfo parent $prefix]]]
    wm geometry $prefix +$x+$y
    wm deiconify $prefix
}

#########################################################################
#### focusin
# Grab the focus.  This should be redefined in derived classes to give
# the focus to the appropriate subwindow.
#
body ::tycho::TopLevel::focusin {} {
    focus $itk_component(hull)
}

#####################################################################
#### freezeWindowSize
# This method freezes the window at its current size, prohibiting
# resizing by the user.
#
body ::tycho::TopLevel::freezeWindowSize {} {
    wm resizable $prefix 0 0
}

#####################################################################
#### nextWindow
# Switch the focus to the next window listed in the array topLevelWindows.
# If an argument is given, and is non-zero, then raise the window as well.
#
body ::tycho::TopLevel::nextWindow {{raise 0}} {
    foreach win [$topLevelWindows elements $prefix] {
	if {$win == $prefix} {continue}
	if {[winfo exists $win] && \
		[winfo ismapped $win] && \
		[uplevel #0 info objects $win] != {} && \
		[$win isa ::tycho::TopLevel]} {
	    $win focusin
	    if {$raise != 0} {$win raiseWindow}
	    break
	}
    }
}

#####################################################################
#### raiseWindow
# Bring the corresponding window to the foreground, and make sure it
# is deiconified.
#
body ::tycho::TopLevel::raiseWindow {} {
    wm deiconify $itk_component(hull)
    raise $itk_component(hull)
    focusin
}

#################################################################
#################################################################
####                   public procedures                     ####

#####################################################################
#### exitProgram
# Confirm exit with a dialog, then quit. The destructors will query
# for save of any windows with modified data.  If this routine returns,
# it will return 0 if the user canceled the exit, and 1 if the exit
# is in progress.
#
body ::tycho::TopLevel::exitProgram {{queryUser 1}} {
    if {$queryUser == 1} {
	set response [askuser "OK to exit the program?"]
    } else {
	set response 1
    }
    if {$exitconfirmed} {return 1}
    if {$response} {
	set exitconfirmed 1
	# Need to delete all Toplevel objects first to make sure destructors
	# are invoked before the exit process begins.  Catch errors here
	# because an error means that the exit was aborted.
	if {[catch {
	    foreach obj [::info objects] {
		# A second check for object instance is necessary, because the
		# object may have been deleted earlier in the loop.
		if {[::info objects $obj] != {} && \
			[$obj isa ::tycho::TopLevel]} {
		    delete object $obj
		}
	    }
	}] == 0} {
	    ::tclexit
	} {
	    set exitconfirmed 0
	}
    }
    return 0
}

#####################################################################
#### exitWhenNoMoreWindows
# If the argument is zero, then disable the feature (which is enabled
# by default) that when the last window is removed, the program is
# exited (after confirmation).
#
body ::tycho::TopLevel::exitWhenNoMoreWindows {bool} {
    set exitflag $bool
}

#####################################################################
#### returnExitCon
#
body ::tycho::TopLevel::returnExitCon {} {
    return $exitconfirmed
}
