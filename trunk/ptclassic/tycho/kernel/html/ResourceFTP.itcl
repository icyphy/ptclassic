# A Resource for receiving on FTP daemon on default port 21
# 
# @Author: Kevin Chang
#
# @Version: $Id$
# 
# @Copyright (c) %Q% The Regents of the University of California.
# All rights reserved.
#
# Permission is hereby granted, without written agreement and without
# license or royalty fees, to use, copy, modify, and distribute this
# software and its documentation for any purpose, provided that the above
# copyright notice and the following two paragraphs appear in all copies
# of this software.
#
# IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY
# FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
# ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF
# THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.
#
# THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE
# PROVIDED HEREUNDER IS ON AN "AS IS" BASIS, AND THE UNIVERSITY OF
# CALIFORNIA HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,
# ENHANCEMENTS, OR MODIFICATIONS.
# 
#                                        PT_COPYRIGHT_VERSION_2
#                                        COPYRIGHTENDKEY
#######################################################################

# The current status of an ftpget. This is a common array
# so that tkwait can access it. Can be "header," "body,"
# "abort," or "done".
## DO NOT USE THIS VARIABLE DIRECTLY! Use method ftpset instead.
set _ftpstatus(ftp://127.0.0.1) done

#######################################################################
#### ResourceFTP
#
class ::tycho::ResourceFTP {
    inherit ::tycho::Resource

    constructor {args} {}
    destructor {}

    #####################################################################
    ####                          options                            ####

    ###################################################################
    ####                         public methods                    ####

    # Close the resource. Calls ftpget to send out the message.
    method close {}

    # Return the eof of file status
    method eof {}

    # Read a string from a streamable resource
    method gets {{varName {}}}
    
    # Not open by default
    method isopen {} {return 0}

    # if there's timeout on protocol, we can't connect to the ftp server.
    method ftptimeout {oldstate}

    # Open the resource. Enable puts.
    method open {mode}

    # Get the progress of sending ftp
    method progress {} {return $progress}

    # Write a string to a streamable resource.
    method puts {string}

    # Get a cached copy of the data
    method cachefile {}

    ###################################################################
    ####                           public procs                    ####

    # Change the permissions of a resource
    proc chmod {permissions path} {error "Not implemented yet"}

    # Return the content type of the current file
    proc contenttype {path}

    # Delete a resource
    proc delete {path} {error "Not implemented yet"}

    # Return a directory listing
    proc dirlist {path}

    # See if the server or hostname exists
    proc exists {path}

    # Forward the location
    # NOTE: This is unique (ie. not in the base class)
    proc forward {url}

    # Create a new directory
    proc mkdir {path} {error "Mkdir not implemented yet"}

    # Create a new resource object
    proc new {path args}

    # Query properties of a file
    proc query {path option}

    # Get the status of a resource
    proc stat {path varName}

    ###################################################################
    ####                         protected methods                 ####

    # Puts a string to console of the debug option is set
    protected method debugputs {string}

    # 1) Initiate a connection on the FTP server. Called by open.
    public method ftpget {{url {}}}

    # 2) Protocol handler for ftp server. Called by ftpget. 
    public method ftphandler {}

    # 3) The first method to call to open up the socket to receive data.
    public method ftpdataportopen {}

    # 4) When server connects to our port, this will initialize the right port.
    public method ftpdataportinit {fd location port}

    # 5) This is used to handle incoming data in the data port.
    public method ftpdataport {fd}

    # 6) This is called to close the sockets, to update cache, etc...
    public method ftpdone {fd}

    # Abort in the middle of ftphandler transaction.
    protected method ftpabort {message}

    # This will set or read the global variable value
    protected method ftpstatus {value} 

    # This will wait until the ftpstatus is set to "done"
    protected method ftpwait {}

    ###################################################################
    ####                        protected commons                  ####

    # forward (ie. ftp://ptolemy/pub --> ftp://ptolemy/pub/)
    protected common _forward

    # A flag tagging whether a given URL exists or not.
    protected common _exists

    # Stat information, used for caching the LIST info.
    protected common _stat

    # Timeout for sending/receiving protocol message. Default 5 seconds
    protected common timeout 5000

    ###################################################################
    ####                        protected variables                ####

    # The url this object is accessing
    protected variable currentURL {}

    # The progress, can be used with the statusbar
    protected variable progress 0.0

    # The state of transfer 
    protected variable state {DISCONNECTED}

    # The return status of previous FTP command
    protected variable status 200

    # By all UNIX default (/etc/services), 21 is the port to open.
    protected variable _socketid {}

    # Attribute of the FTP server and the file/directory.
    protected variable ftpserver {}
    protected variable ftpport "21"
    protected variable ftppath /
    protected variable ftpfile {}
    protected variable ftpsize 0

    # Attribute of the current connection (FTP client). Attributes
    # are set after "fconfigure _socketid -sockname", which returns:<br>
    # <tt>n1.n2.n3.n4  client_name  unique_16_bit_client_socket</tt>
    protected variable _dataport 0
    protected variable _dataaddr 127.0.0.1
    protected variable _datafd -1

    # Transfer could be either "file" or "directory" (distince FTP commands).
    protected variable ftptype "directory"

    # Attribute of myself (FTP client)
    protected variable _myusername "anonymous"
    protected variable _mypassword "tycho@"

    ###################################################################
    ####                         private variables               ####
    
    # Debug status. Print if 1
    private variable debug 1

    # Cache file id
    private variable fileid

    # Cache file name
    private variable filename

    # True if the file is open
    private variable fileIsOpen 0

}


#######################################################################
#### constructor
#
#
body ::tycho::ResourceFTP::constructor {args} {
    eval configure $args

}

#######################################################################
#### destructor
#
body ::tycho::ResourceFTP::destructor {} {
    # If we're still loading, forget it
}

#########################################################################
#########################################################################
####                      public methods                             ####

#####################################################################
#### close
body ::tycho::ResourceFTP::close {} {
    if !$fileIsOpen {
	error "File \"$this\" is not open."
    }
    set fileIsOpen 0
}

#####################################################################
#### forward
# Get a file name, and forward it automatically.
# Used with _forward to forward the right location. For example,<br>
# <tt>ftp://ptolemy/pub   -->   ftp://ptolemy/pub/</tt>
#
body ::tycho::ResourceFTP::forward {url} {
    while { [::info exists _forward($url)] } {
	set url $_forward($url)
    }
    return $url
}

#####################################################################
#### open
# Open a connection for ftp on port 21.
#
body ::tycho::ResourceFTP::open {{mode "r"}} {
    if {$fileIsOpen} {error "File is already open!"}

    set currentURL [forward [path]]

    # FIXME: Need to implement write on FTP!
    if {$mode != "r"} {
        error "Only read feature is implemented"
    }

    if { ! [exists $currentURL] } {
	error "File $currentURL does not exist"
    }
    set currentURL [forward $currentURL]
    
    # Seek out on network for the file
    if {![::tycho::cache exists $currentURL]} {
        # Get it if not already
        ftpget $currentURL
        ftpwait
    }

    # FIXME: Add check for cache
    set fileIsOpen 1
    set progress 1.0

    if {$status>=400} {return 0} {return 1}
}

#####################################################################
#### puts
body ::tycho::ResourceFTP::puts {string} {
    if {!$fileIsOpen} {error "File is not open."}
    lappend ftpbuffer $string
}

#########################################################################
#########################################################################
####                          public procedures                      ####

#####################################################################
#### contenttype
# Return the content type of the open file.
body ::tycho::ResourceFTP::contenttype {url} {
    # In order to speed up, check the cache manager
    set url [forward $url]
    set URLexists [exists $url]
    set url [forward $url]

    if {$URLexists && [info exists _stat($url)]} {
        array set tmp $_stat($url)
        return $tmp(type)
    } else {
        set ftpobj [::tycho::resource new $url]
        $ftpobj open
        after $timeout "delete object $ftpobj"

        if {[info exists _stat($url)]} {
            # Cache always contains the content type
            array set tmp $_stat($url)
            return $tmp(type)
        }
        return NOTHING
        #error "contenttype: URL $url does not exist"
    }
}

#####################################################################
#### dirlist
# 
body ::tycho::ResourceFTP::dirlist {url} {
    # Many times we're passed in the format: ftp://ptolemy/*, so need
    # to manually get rid of the "*".
    set url [string trimright $url "*"]

    set URLexists [forward [exists $url]]
    set url [forward $url]

    if {!$URLexists} {error "URL $url doesn't exist!"}
    
    # It's possible to exist, but not cached...
    if {![::tycho::cache exists $url]} {
        set ftpobj [::tycho::resource new $url]
        $ftpobj open
        after $timeout "delete object $ftpobj"
    }
    if {![::tycho::cache exists $url]} {error "Can't cache $url"}

    set cachefile [::tycho::cache getcachefile $url]
    set fd [::open $cachefile "r"]
    set buffer {}
    while {![::eof $fd]} {
        ::gets $fd line
        if {[lindex $line 8]!={}} {
            append buffer \
                    "[forward [::tycho::url join $url [lindex $line 8]]] "
        }
    }
    ::close $fd
    return $buffer
}

#####################################################################
#### exists
# Check if the given URL exists. If the URL has already been
# accessed before, use the data obtained from the earlier
# load. Otherwise open the URL and download the entire file.
# Returns 0 if the server cannot be accessed or if the file
# does not exist on the server.
#
body ::tycho::ResourceFTP::exists {url} {
    set url [forward $url]
    
    # Do we already know if it exists?
    if {[::info exists _exists($url)]} {return $_exists($url)}

    # If not, need to get it again (once per session). Set to -1
    # so that during httpget, we don't invoke Tcl's error.
    set _exists($url) -1
    set resource [::tycho::resource new $url]
    $resource open
    after $timeout "::delete object $resource"

    return $_exists($url)
}

#####################################################################
#### new
# Create a new FTP object.
#
body ::tycho::ResourceFTP::new {path args} {
    #::puts "::tycho::ResourceFTP::new $path $args"
    uplevel #0 ::tycho::ResourceFTP [::tycho::autoName resourceFTP] \
	    $args
}

#####################################################################
#### query
# Query properties of a file
#
body ::tycho::ResourceFTP::query {url option} {
    set url [forward $url]

    switch -exact $option {
        "executable" {
	    # FIXME: Do directories need to be executable to read them?
	    if [query $url isdirectory] {
		return 1
	    } else {
		return 0
	    }
        }
        "exists" {
            exists $url
        }
        "isdirectory" {
            if [exists $url] {
                if {[::tycho::resource contenttype $url]=="directory"} {
                    return 1
                }
            }
            return 0
        }
        "isfile" {
            if [exists $url] {
                if {[::tycho::resource contenttype $url]=="file"} {
                    return 1
                }
	    }
	    return 0
        }
        "readable" {
            exists $url
        }
        "isremote" {
            return 1
        }
        "writable" {
            # NOTE: Need to change to 1 when we implement write
            return 0
        }
	default {
	    error "Unknown option \"$option\" on $url"
	}
    }
}

#########################################################################
#### stat
#
body ::tycho::ResourceFTP::stat {url varName} {
    set url [forward $url]

    if [info exists _stat($url)] {
        upvar $varName v
        array set v $_stat($url)
    }
}


#########################################################################
#########################################################################
####                     protected methods                           ####

#########################################################################
#### debugputs
# Puts a string to the console if the *-debug* option is set.
#
body ::tycho::ResourceFTP::debugputs {string} {
    if $debug {
	::puts $string
    }
}

#########################################################################
#### ftpget
# Opening a ftp connection, and set the fileevent.
#
body ::tycho::ResourceFTP::ftpget {{url {}}} {
    # Parse URL into hostname, port, and path
    if {$url!={}} {set currentURL $url}

    ftpstatus "getting"

    # Setup destination according to url:
    #       server             path        file
    #       v                  v           v
    # ftp://www.servername.com/path1/path2/file.tar.gz
    set ftppath   [::tycho::url path $currentURL]
    set ftpfile   [::tycho::url tail $currentURL]
    set ftpserver [::tycho::url server $currentURL]
    set ftpport   [lindex [split $ftpserver :] 1]
    set ftpserver [lindex [split $ftpserver :] 0]
    if {$ftpport=={}} {set ftpport 21}
    # The following is needed because path returns the following:
    #   tycho::url path ftp://server.com/p1/p2/file1 == p1/p2/file1
    #
    # The correct path is:
    #   tycho::url path ftp://server.com/p1/p2/file1 == p1/p2/
    regsub [::tycho::url tail $currentURL] $ftppath {} ftppath

    # If trailing char is /, then it is a directory. Else, probably file.
    if [regexp {^.*/$} $currentURL] {
        set ftptype "directory"
    } else {
        set ftptype "file"
    }
    debugputs "$ftpserver:$ftpport   path:$ftppath   file:$ftpfile"

    # Connect to server
    if {[catch {socket -async $ftpserver $ftpport} _socketid]} {
	catch {unset $_socketid}
        ftpabort "Can't open $ftpserver, $ftpport"
        return
    }

    # Connected, now write everything to cache file
    set filename [::tycho::cache tmpCacheName $currentURL]
    set fileid [::open $filename "w+"]
    debugputs "Cache file $filename on $fileid"

    # Set my port information
    set tmpinfo [fconfigure $_socketid -sockname]
    set _dataaddr [lindex $tmpinfo 0]   ;# Client location
    set _dataport [lindex $tmpinfo 2]   ;# Client's port connecting to server

    set state USER
    set status 200

    # Set up the file events for incoming data
    ::fileevent $_socketid w {}
    ::fileevent $_socketid readable \
            [list @scope ::tycho::ResourceFTP [list $this ftphandler]]
    #"[list catch [list @scope ::tycho::ResourceFTP [list $this ftphandler]]]"

    ::fconfigure $_socketid -blocking no    ;#-translation crlf
    ::fconfigure $_socketid -translation auto
}

#########################################################################
#### ftphandler
# The following is the handshake protocol between the client and
# the server. When the ftphandler gets the expected state from
# the server, it'll send out the right data.
# <pre>
# State          Expect from Server             Send/"Action"
# -----          ------------------             -----------
#
# </pre>
body ::tycho::ResourceFTP::ftphandler {} {
    if {[::eof $_socketid] && $state!="DISCONNECTED"} {
        ftpabort "FTP handshaking failed"
        return
    }
    # Line will contain the status
    ::gets $_socketid line
    debugputs "$state> $line"

    # This returns the status number. 200-299 is okay (just like HTTP)
    # Need to use regexp instead of lindex because some servers return
    # number followed by - (ie. 200- This is just a comment).
    if {![regexp {^([0-9]+) .*} $line _ status]} {return}

    set cmd {}
    # The following is a state machine
    switch -- $state {
        USER {
            # USER 220 messier.eecs.berkeley.edu FTP server
            if [regexp -nocase {^22[0-9] .*} $line] {
                set cmd "USER $_myusername"
                set state PASS
                after $timeout "eval $this ftptimeout $state"
            }
            set progress 0.1
        }

        PASS {
            # 331 Guest login ok, send ident as password.
            if [regexp -nocase {^33[0-9] .*} $line] {
                set cmd "PASS $_mypassword"
                set state PWD
                after $timeout "eval $this ftptimeout $state"
            }
        }

        PWD {
            # 230 Guest login ok, access restrictions apply.
            if [regexp -nocase {^23[0-9] .*} $line] {
                set cmd "PWD"
                set state PASV
                after $timeout "eval $this ftptimeout $state"
            }
        }

        PASV {
            # 257 "/" is current directory.
            if [regexp -nocase {^25[0-9] .*} $line] {
                set cmd "PASV"
                set state SIZE
                after $timeout "eval $this ftptimeout $state"
            }
        }

        SIZE {
            # 227 Entering Passive Mode (128,32,240,78,165,11)
            if [regexp -nocase {^22[0-9] .*} $line] {
                set cmd "SIZE [::tycho::url join $ftppath $ftpfile]"
                set state PORT
                after $timeout "eval $this ftptimeout $state"
            }
        }

        PORT {
            # 213 5000
            # 500 SIZE not a good command
            if [regexp -nocase {^2[0-9][0-9] .*} $line] {
                set ftpsize [lindex $line 1]
            } else {
                set status 213
                set ftpsize 0
            }

            # Setup a ftpdataport
            if {[ftpdataportopen]<=0} {
                ftpabort "$status> Could not open up a client socket"
                return
            }
            set tmpport [join [split $_dataaddr .] ,]
            set p1 [expr $_dataport / 256]        ;# upper 8 bits
            set p2 [expr $_dataport - ($p1*256)]  ;# lower 8 bits
            set cmd "PORT $tmpport,$p1,$p2"
            if {$ftptype=="file"} {
                set state TYPE
            } elseif {$ftptype=="directory"} {
                set state CWD
            } else {
                ftpabort "syntax error: ftptype is unknown: $ftptype"
                return
            }
            after $timeout "eval $this ftptimeout $state"
        }

        TYPE {
            # 200 PORT command successful.
            if [regexp -nocase {^20[0-9] .*} $line] {
                set cmd "TYPE I"    ;# Always binary transfer
                set state RETR
                after $timeout "eval $this ftptimeout $state"
            }
        }
        RETR {
            # 200 Type set to I.
            if [regexp -nocase {^20[0-9] .*} $line] {
                set cmd "RETR [::tycho::url join $ftppath $ftpfile]"
                set state FILE_DIR
                after $timeout "eval $this ftptimeout $state"
            }
        }
        FILE_DIR {
            # This is unique, because if this is not a file, then we'll
            # re-attempt to access this as a directory.
            #
            # 150 Binary data connection for README (1,2,3,4,9999) (555 bytes)
            # 550 /pub: not a plain file.
            if [regexp -nocase {^15[0-9] .*} $line] {
                # Attempt to get size of the file
                regexp -nocase {^.*\(([0-9]+) bytes\).*$} $line _ ftpsize
                # Successful, just wait for ready string
                set state TRANSFER2
                # DO NOT SET A TIMEOUT!
            } else {
                # This is probably a directory then. Take a guess...
                set _forward($currentURL) "$currentURL/"
                set ftptype "directory"
                set status 150          ;# Error shouldn't fault
                set cmd "CWD [::tycho::url join $ftppath $ftpfile]"
                set state LIST
                after $timeout "eval $this ftptimeout $state"
            }
        }

        CWD {
            # Protocol for file list
            # 200 PORT command successful.
            if [regexp -nocase {^20[0-9] .*} $line] {
                set cmd "CWD $ftppath"
                set state LIST
                after $timeout "eval $this ftptimeout $state"
            }
        }
        LIST {
            # 250 CWD command successful.
            if [regexp -nocase {^25[0-9] .*} $line] {
                set cmd "LIST"
                set state TRANSFER1
                after $timeout "eval $this ftptimeout $state"
            }
        }
        TRANSFER1 {
            # 150 Binary data connection for README (1.3.4.5,8192) (350 bytes).
            if [regexp -nocase {^15[0-9] .*} $line] {
                # Just wait until end of dataport transfer
                set state TRANSFER2
                # DO NOT SET A TIME OUT! File transfer could take a while.
            }
        }
        TRANSFER2 {
            # 226 ASCII Transfer complete.
            if [regexp -nocase {^22[0-9] .*} $line] {
                set cmd "QUIT"
                set state QUIT
                after $timeout "eval $this ftptimeout $state"
            }
        }
        
        
        QUIT {
            # 221 Goodbye.
            if [regexp -nocase {^22[0-9] .*} $line] {
                set state DISCONNECTED
                # DO NOT SET A TIME OUT!
                catch {::close $_socketid}
            }
        }
        
    }

    # The following is required because Tcl will buffer all output
    if {$cmd!={}} {
        debugputs "$state> $cmd"
        ::puts $_socketid $cmd
        ::flush $_socketid
    }

    # Timeout 421
    if {$status==421} {ftpabort "$state> $line";return}

    # we have $status now, check if it's error
    if {$status>=400} {
        ftpabort "$state> ERROR: $line"
        return
    }
}


#########################################################################
#### ftpdataportopen
# Open up a socket so that server can send data into
# the socket. The socket number is determined by 
# (the current socket connecting to the server) + 1 + (n tries)
# 
# Return ftpdataport's file descriptor if successfully opened up a socket.
# 0 if failed n times.
#
body ::tycho::ResourceFTP::ftpdataportopen {} {
    # Try to open up socket 15 times.
    set n 15

    # Port incremental amount. If a port is already taken, increment
    set iamount 1
    set _dataport [expr $_dataport + $iamount]
    while {$n > 0} {
        debugputs "Going to open up port $_dataport"
        
        if {![catch {
            socket -server \
                    "@scope ::tycho::ResourceFTP $this ftpdataportinit" \
                    $_dataport
        } _datafd]} {
            debugputs "SUCCESS: ($_datafd), [fconfigure $_datafd -sockname]"
            fconfigure $_datafd -blocking no
            return $_datafd
        }
        incr n -1
        # Increase the port amount more will increase the probability
        # of hitting an empty port.
        set _dataport [expr ($_dataport + [incr iamount $iamount])%(256*256)]
    }
    return 0
}

#########################################################################
#### ftpdataportinit
# When a connection is first made, this method is called. This method
# three arguments passed automatically with the line "socket -server <meth>".
# 
# They are fd, location, and port (originator's port)
body ::tycho::ResourceFTP::ftpdataportinit {fd location port} {
    debugputs "OKAY ($_datafd) GOT ($fd) $location $port"

    fconfigure $fd -blocking no -translation auto
    fileevent $fd writable {}
    fileevent $fd readable \
            "@scope ::tycho::ResourceFTP $this ftpdataport $fd"
    # Close off client's initial socket connection.
    catch {::close $_datafd}
}

#########################################################################
#### ftpdataport
# Dataport handler, receive data and save it.
#
body ::tycho::ResourceFTP::ftpdataport {fd} {
    if [::eof $fd] {
        ftpdone $fd
        return
    }
    ::gets $fd line
    ::puts $fileid $line
    debugputs "$fd> $line"
}

#########################################################################
#### ftpdone
# Clean up after getting the FTPed file. $fd is the id of the data port.
#
body ::tycho::ResourceFTP::ftpdone {fd} {
    debugputs "--->EOF"

    catch {::close $fd}
    catch {::close $_socketid}
    catch {::close $fileid}
    set fd -1
    set _sockid -1
    set fileid -1
    set state DISCONNECTED

    set tmpURL [forward $currentURL]
    set _exists($tmpURL) 1
    set _stat($tmpURL) \
            [list type $ftptype mtime 0 size $ftpsize url [forward $tmpURL]]
    debugputs "_stat($tmpURL) = $_stat($tmpURL)"
    ::tycho::cache update \
            $tmpURL \
            {} \
            $ftpsize \
            $ftptype \
            $filename

    if {$ftptype=="file"} {
        # Do cache update here -----
        set _exists([string trimright $tmpURL /]/) 0
        debugputs "url: $tmpURL ($ftptype) ($ftpsize bytes)"
        debugputs "cache file: $filename"
    } elseif {$ftptype=="directory"} {
        set _exists([string trimright $tmpURL /]) 1
        set _forward([string trimright $tmpURL /]) $tmpURL
        # Need to parse the contents of the listing
        # dr-xr-xr-x   2 root     other        512 Jun  5  1995 dev
        # dr-xr-xr-x   2 root     other        512 Jun  5  1995 etc
        # -rw-r--r--   1 6269     30        223856 Jun 15 19:41 ls-lR.Z
        # drwxrws--x   2 4035     244          512 May  9 05:22 private
        # drwxr-xr-x   6 root     root         512 Aug 14  1996 pub
        # drwxr-xr-x   4 root     other        512 Jun  5  1995 usr

        # Open the cache file to retrieve content
        set cachefd [::open $filename]

        while {![::eof $cachefd]} {
            ::gets $cachefd line

            if {[lindex $line 8]!={}} {
                set fname [::tycho::url join $tmpURL [lindex $line 8]]
                set permission [lindex $line 0]
                if [regexp -nocase {^d.*$} $permission] {
                    set ftype "directory"
                    # Used for systems that don't append / to directories
                    set fname "[string trimright $fname /]/"
                    set _forward([string trimright $fname /]) $fname
                } elseif [regexp -nocase {^-.*$} $permission] {
                    set ftype "file"
                } elseif [regexp -nocase {^l.*$} $permission] {
                    set ftype "symbolic"
                } else {
                    set ftype "unknown"
                }
                set _exists($fname) 1
 
                set _stat($fname) [list \
                        type $ftype \
                        mtime 0 \
                        size [lindex $line 4] \
                        url [forward $fname]]
            }
        }
        ::close $cachefd
    }

    ftpstatus "done"
}


#########################################################################
#### ftpstatus
# A procedure that handles set and read of the status.
#
body ::tycho::ResourceFTP::ftpstatus {{value {}}} {
    if {$value!={}} {
        uplevel #0 "set _ftpstatus($currentURL) $value"
    }

    if ![uplevel #0 "::info exists _ftpstatus($currentURL)"] {
        error "ASSERTION FAILED: _ftpstatus($currentURL) does not exist!"
    }

    # Return the value
    uplevel #0 "set _ftpstatus($currentURL)"
}

#########################################################################
#### ftpwait
# Wait until the current GET completes
body ::tycho::ResourceFTP::ftpwait {} {
    # Wait until the status becomes "done"
    while { [ftpstatus] != "done" } {
        uplevel #0 "tkwait variable _ftpstatus($currentURL)"
    }
    return
}

#########################################################################
#### ftptimeout
# After certain amount of time, we hope that the state has transitioned.
# Otherwise, there's a timeout on the network or on the server, and
# we have to stop the transaction. This method will compare the oldstate
# with the current state.
#
body ::tycho::ResourceFTP::ftptimeout {oldstate} {
    if {$oldstate==$state} {
        debugputs "Timeout on $currentURL, state $oldstate"
        ftpabort "Timeout on $currentURL, state $oldstate"
    }
}

#########################################################################
#### ftpabort
# When the protocol fails, output an error message, and close socket
#
body ::tycho::ResourceFTP::ftpabort {message} {
    catch {::close $_socketid}
    catch {::close $fileid}
    catch {unset _forward([string trimright $currentURL /])}
    catch {unset _forward([string trimright $currentURL /]/)}
    set _sockid -1
    set fileid -1
    set state DISCONNECTED
    set status 500
    set fileIsOpen 0

    # If we're not executing proc exists, then output error.
    if {$_exists($currentURL)!=-1} {error $message}
    set _exists([string trimright $currentURL /]) 0
    set _exists([string trimright $currentURL /]/) 0
    ftpstatus "done"
}
