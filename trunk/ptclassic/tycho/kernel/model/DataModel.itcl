##########################################################################
# @Version: $Id$
# @Author: John Reekie
#
# @Copyright (c) 1996-%Q% The Regents of the University of California.
# All rights reserved.
# 
# Permission is hereby granted, without written agreement and without
# license or royalty fees, to use, copy, modify, and distribute this
# software and its documentation for any purpose, provided that the
# above copyright notice and the following two paragraphs appear in all
# copies of this software.
# 
# IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY
# FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
# ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF
# THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.
# 
# THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE
# PROVIDED HEREUNDER IS ON AN "AS IS" BASIS, AND THE UNIVERSITY OF
# CALIFORNIA HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,
# ENHANCEMENTS, OR MODIFICATIONS.
# 
# 						PT_COPYRIGHT_VERSION_2
# 						COPYRIGHTENDKEY
##########################################################################


##########################################################################
#### DataModel
#
# DataModel extends the Model class to support data models and the
# TIM interchange format.  TIM is a simple meta-data format that
# encourages a simple and clean representation of data, both in
# in-memory objects and in an external file representation.
#
# The data stored in a DataModel object is hierarchical. Each item is
# referenced by its name, which consists of a list of name segments.
# A name segment is the item type and name, separated by a colon. For
# example, a top-level item may have the name <code>group:foo</code>,
# where _group_ is a type defined for this particular model. An item
# contained within that item may have the name
# <code>group:foo icon:bar</code>, where _icon_ is another type defined
# for this model. Item names are unique within each type -- for example,
# I could also have an item named <code>icon:foo</code>.
#
# The methods of _DataModel_ fall into several categories:
# <dl>
# <dt><b>Initialization and setup</b>
# <dd>
# _DataModel_ is designed to be subclassed to create application-specific
# models. The constructor of each subclass must call the <b>type define</b>
# method to define the types in that model. Clients and subclasses
# can also use options such as <b>type cget</b> and <b>type configure</b>
# to access types.
#
# <dt><b>Loading and saving</b>
# <dd>
# The data in a model can be loaded into and out of a readable string
# format. The <b>parse</b> method loads data into the model, while the
# <b>describe</b> method produces a description of its data.
#
# <dt><b>Data modification</b>
# <dd>
# There are several methods that modify the data in the model:
# <b>add</b>, <b>assign</b>, <b>clear</b>, <b>delete</b>, and
# <b>itemconfigure</b>`. All of these, with the exception of
# <b>clear</b>, return an undo command, so they can be recorded
# and/or published with methods in the _Model_ superclass.
#
# <dt><b>Data query</b>
# <dd>
# There are several methods that provide ways of accessing the
# data in a model. <b>itemcget</b> gets data from a single item,
# while <b>names</b> and <b>get</b> perform glob-style matching
# on item names. The <b>match</b> method returns an ordered
# list of child items within a given context, while <b>sort</b>
# allows that ordering to be changed. <b>search</b> provides an
# efficient searching mechanism over model data, and <b>exists</b>
# provides a simple test whether data is present.
#
# </dl>
#
# _DataModel_ has the following types:
# <dl>
# <dt><b>model</b> _name_
# <dd>
# A nested model. Nested models have the following attributes:
#   <dl>
#   <dt><b>-data</b> _description_
#   <dd>
#   A description of the model. This attribute is generally present
#   in the external format. By convention, clients that access
#   a nested model and find the <b>-object</b> attribute empty
#   use the value of this attribute to construct a new model, and
#   then clear this attribute.
#
#   <dt><b>-object</b> _object-name_
#   <dd>
#   The nested model object. This attribute is null in the external
#   format. Clients that create a sub-model should set this
#   attribute to point to the new sub-model.
#   </dl>
# </dl>
#
class ::tycho::DataModel {
    inherit ::tycho::Model

    constructor {args} {}
    destructor {}

    #################################################################
    ####                        options                          ####

    #################################################################
    ####                     public methods                      ####

    # Add a new item
    method add {name args}

    # Assign an attribute list to an item
    method assign {name value}

    # Remove all data
    method clear {}

    # Delete an item
    method delete {name}

    # Describe the data as a string in TIM format
    method describe {{name {}} {prefix {}}}

    # Check if an item, and optionally, an attribute, exists
    method exists {name {attribute {}}}

    # Get the names and attributes of each item matching a pattern
    method get {{pattern *}}

    # Get an attribute or attributes of an item
    method itemcget {name attribute}

    # Configure attributes of an item
    method itemconfigure {name args}

    # Match children of a given type with matching attributes
    method match {type {context {}} args}

    # Get an attribute or attributes of the model
    method modelcget {attribute}

    # Configure attributes of the model
    method modelconfigure {args}

    # Get the names of each item matching a pattern
    method names {{pattern *}}

    # Load data from a TIM string
    method parse {data {context {}}}
    
    # Search for items with regexp or glob-syle matching
    method search {mode args}

    # Sort items in a given context
    method sort {type {context {}} args}

    # Define or configure item types
    method type {mode {type {}} args}

    #################################################################
    ####                   protected methods                     ####

    # Add a nested model
    protected method _addmodel {name args} {eval add $name $args}
 
    # Return a description of a single item
    protected method _describe {name {prefix {}}}
    
    # Return a description of the children of an item
    protected method _describechildren {name {prefix {}}}
    
    # Describe a nested model
    protected method _describemodel {name {prefix {}}}
    
    # Create a header string
    protected method _header {}

    # Update the cache if it's out of date
    protected method _update

    # Do a cache update
    protected method _updatecache

    # Manipulate the data cache
    protected method cache {mode args}

    #################################################################
    ####                  protected variables                    ####

    # The path of the currently-parsed model
    protected common _object_ {}

    # The name of the currently-parsed model
    protected common _current_ {}

    # The context currently being parsed in
    protected common _context_ {}

    #################################################################
    ####                    private methods                      ####

    # Generate a parsing procedure
    private method _mkparseproc {type}

    # Verify that an item exists
    private method _verify {name}

    #################################################################
    ####               private common variables                  ####

    private common defaulttypeconfig {
        :leafonly 0
        :override 0
    }

    # The safe interpreter provided for safe parsing
    private common safeinterp [uplevel #0 interp create]

    # The types defined in each scopem indexed by scope
    private common _types

    # The types configuration of each type, indexed by $scope:$type
    private common _typeconfig

    #################################################################
    ####                  private variables                    ####

    # The name used to construct the data arrays
    private variable _dataname

    # Default attributes, indexed by type
    private variable _defaults

    # Local copy of the :leafonly flag, indexed by type
    private variable _leafonly
 
    # Local copy of the :override flag, indexed by type
    private variable _override
 
    # Search data
    private variable _searchdata
 
    # Search mode
    private variable _searchtype
 
    # Search expression
    private variable _searchexp
 
    # Debugging only
    method debug {args} {
        eval $args
    }
}

########################################################################
#### constructor
#
body ::tycho::DataModel::constructor {args} {

    # Make sure the namespaces exist in the safe interpreter
    $safeinterp eval namespace ::tycho
    $safeinterp eval namespace $scope

    # Initialize the array name
    set _dataname [::info namespace tail $this]

    # Initialize the model attributes
    @scope $scope set [set _dataname]() {}

   # Create a proc to parse the "modelconfigure" syntax
    @scope $scope eval {
        proc __parse_modelconfigure {args} {
            global _object_
            global $_object_
            eval $_object_ modelconfigure $args
        }
    }
 
    # Link it into the safe interpreter
    $safeinterp alias $scope::modelconfigure $scope::__parse_modelconfigure

    # Evaluate options
    eval configure $args

    # Define the "model" type
    type define model \
    	:leafonly 1 \
    	:override 1 \
    	-data {} \
    	-model {}
}

########################################################################
#### destructor
#
body ::tycho::DataModel::destructor {} {
    # Clear data so as not to leak...
    clear
}

########################################################################
#### add
#
# Add a new item. _name_ is its full name including types. Following
# arguments are attribute-value pairs. If the item already exists,
# raise an error. Append to the history if recording.
#
body ::tycho::DataModel::add {name args} {
    if [@scope $scope ::info exists [set _dataname]($name)] {
        error "An item \"$name\" already exists in $modelname"
    }

    # Invalidate cache
    @scope $scope set [set _dataname].cachevalid 0

    # Add to history
    if $recording {
        history append "add $name $args" "delete $name"
    }

    # Extract type and tail
    regexp {([^:]+):(.+)} [lindex $name end] _ type tail
    set context [lreplace $name end end]

    # Extract contents
    if { !$_leafonly($type) && ([llength $args] & 1) } {
    	set contents [lindex $args end]
    	set args [lreplace $args end end]
    } else {
    	set contents {}
    }

    # Store the data of this item
    @scope $scope set [set _dataname]($name) $args

    # Add it to the list of children of its parent
    @scope $scope lappend [set _dataname]:[set type]($context) $tail

    # Parse contents
    if { $contents != "" } {
        set _context_ $name
        $safeinterp eval [list @scope $scope $contents]
    }
}

########################################################################
#### assign
#
# Set the value of the item named _name_. The special item name
# <b>{}</b> denotes the model itself. If only the _name_ argument is
# supplied, return the list of attributes previsouly set for this
# item (analogous to the Tcl <b>set</b> command). Note that this
# does not include default values, as returned by the <b>itemconfigure</b>
# if called with no attributes. If a single additional argument is supplied,
# it is interpreted as a list of attribute name-value pairs, which is
# assigned to the item. If more than one additional argument is
# supplied, teh list of arguments is interpreted as a list of
# attribute-value pairs. If the item does not exist, raise an
# error. Append to the history if additional arguments are supplied
# and if currently recording.
#
body ::tycho::DataModel::assign {name args} {
    _verify $name

    # Remember the old data
    set old [@scope $scope set [set _dataname]($name)]

    if { $args == "" } {
        # Return old value
        return $old
    } elseif { [llength $args] == 1 } {
        # Got a single list
        set data [lindex $args 0]
    } else {
        set data $args
    }
    
    # Append to the history
    if $recording {
        history append [list assign $name $data] [list assign $name $old]
    }

    # Invalidate cache
    @scope $scope set [set _dataname].cachevalid 0
        
    # Write the new data
    @scope $scope set [set _dataname]($name) $data
}

########################################################################
#### clear
#
# Clear all data from the model and invalidate the cache. The top-level
# model attributes will not be deleted. This method does not append to the
# history because of the potential size of the undo command.
#
body ::tycho::DataModel::clear {} {
    # Invalidate the cache
    cache invalidate

    # Remember the top-level attributes
    set attributes [@scope $scope set [set _dataname]()]

    # Unset the data of all items and the children of each type
    catch {
        @scope $scope unset $_dataname
        @scope $scope unset $_dataname.cachevalid
        foreach type $_types($scope) {
            @scope $scope unset $_dataname:$type
        }
    }
    # Restore the top-level attributes
    @scope $scope set [set _dataname]() $attributes
}

########################################################################
#### delete
#
# Delete the item specified by _name_. Raise an error if
# the item does not exist.  The item and all child items will
# be deleted. Append to the history if recording. In order to
# facilitate deletion of hierarchical items, this method
# returns a description of the deleted item.
#
body ::tycho::DataModel::delete {name} {
    _verify $name
    regexp {([^:]+):(.+)} [lindex $name end] _ type tail
    set context [lreplace $name end end]

    # Invalidate cache
    @scope $scope set [set _dataname].cachevalid 0

    # Append to the history
    if $recording {
        set cd [_describechildren $name]
        if { $cd != "" } {
            history append "delete $name" "add $name [assign $name] \{\n$cd\}"
        } else {
            history append "delete $name" "add $name [assign $name]"
        }
    }
    # Remove from the parent list
    @scope $scope set [set _dataname]:[set type]($context) \
            [::tycho::ldelete \
            [@scope $scope set [set _dataname]:[set type]($context)] $tail]

    # Delete data
    @scope $scope unset [set _dataname]($name)

    # Delete children, making sure that commands are not recorded
    if !$_leafonly($type) {
    	set saved $recording
    	set recording 0
        foreach t $_types($scope) {
            foreach child [match $t $name] {
                delete [concat $name $t:$child]
            }
        }
        set recording $saved    
    }
}

########################################################################
#### describe
#
# Generate a TIM description. If no name is supplied, generate a
# description of all the data. The description starts with an emacs-style
# header string that contains the mode, class, and version attributes,
# and the current date. If the _name_ is supplied, generate a description
# of just that item. If the _prefix_ argument is also
# supplied, prepend the prefix to each line produced.
#
body ::tycho::DataModel::describe {{name {}} {prefix {}}} {
    if { $name!= "" } {
        _verify $name
        _describe $name $prefix
	
    } else {
        set string "# -*- [_header] -*-\n"
        foreach {attr val} [assign {}] {
            append string "\n$prefix"
            lappend string modelconfigure $attr $val
        }
        append string "\n"
        foreach type $_types($scope) {
            # Describe each root item
            foreach n [match $type] {
                append string [_describe $type:$n $prefix]
            }
        }
        return $string
    }
}

########################################################################
#### exists
#
# Test if the item given by _name_ is present in the model, returning
# 1 if it does and 0 if not. If the item does exists and _attribute_
# is given, test if the item has that attribute (including its
# defaults), and return 1 if it does and 0 if it dies not.
#
body ::tycho::DataModel::exists {name {attribute {}}} {
    if { $attribute == "" } {
	@scope $scope ::info exists [set _dataname]($name)
    } else {
	if [@scope $scope ::info exists [set _dataname]($name)] {
	    regexp {^[^:]+} [lindex $name end] type
	    array set data $_defaults($type)
	    array set data [@scope $scope set [set _dataname]($name)]
	    ::info exists data($attribute)
	} else {
	    return 0
	}
    }
}

########################################################################
#### get
#
# Return the names and data of items with names that match _pattern_.
# If _pattern_ is not supplied, get the names and data of all items.
# Note that this method matches item names against a pattern, so
# that a pattern such as <code>item:foo.*</code> will return all
# descendents, not just children, of <code>item:foo</code>. The returned
# list will not be ordered.
#
body ::tycho::DataModel::get {{pattern *}} {
    @scope $scope array get $_dataname $pattern
}

########################################################################
#### itemcget
#
# Get an attribute or attributes of the item specified by
# _name_. The special item name <b>{}</b> denotes top-level attributes
# of the model. Raise an error if the item does not exist or
# if the attribute is unknown.
#
body ::tycho::DataModel::itemcget {name attribute} {
    _verify $name

    # Merge with defaults
    regexp {^[^:]+} [lindex $name end] type
    array set data $_defaults($type)
    array set data [@scope $scope set [set _dataname]($name)]

    # Get a single attribute
    if { ! [::info exists data($attribute)] } {
        error "Unknown attribute $attribute in $modelname"
    }
    return $data($attribute)
}

########################################################################
#### itemconfigure
#
# Configure attributes of the item specified by _name_. Following
# arguments are an attribute-value list, which are merged with the
# existing attributes. Append to the history if recording. If no
# attributes are suypplied, return the list of attributes and values
# and do not append to the history. Raise an error if the item
# does not exist.
#
body ::tycho::DataModel::itemconfigure {name args} {
    _verify $name

   if { $args == "" } {
        # Return attributes including defaults
        regexp {^[^:]+} [lindex $name end] type
        array set attrs $_defaults($type)
        array set attrs [@scope $scope set [set _dataname]($name)]
        array get attrs
    } else {
        # Invalidate cache
        @scope $scope set [set _dataname].cachevalid 0

        # Append to the history
        if { $recording } {
            history append \
                    "itemconfigure $name $args" \
                    "assign $name [@scope $scope set [set _dataname]($name)]"
        }
        # Merge the new data and return result
        array set attrs [@scope $scope set [set _dataname]($name)]
        array set attrs $args
        @scope $scope set [set _dataname]($name) [array get attrs]
    }
}

########################################################################
#### match
#
# Match child items of the given _type_. If the _context_ is given,
# match children of that item; otherwise match top-level items. The
# returned names are the names within the given context only.
# For example, if the model contains items with full names *item:foo*
# and *item:bar*, then the call
# <pre>
#     $model match item
# </pre>
# will return <code>{foo bar}</code>. (In comparison, the names{}
# method will return <code>{item:foo item:bar}</code>.) Children
# are returned in the same order in which they were added to
# the model -- the order of children of a given type can be altered
# with the <b>sort</b> method. If additional arguments are given,
# they specify attributes of the items that must be matched in order
# to include an item in the return list. This matching is exact.
# If the context does not exist, raise an error.
#
body ::tycho::DataModel::match {type {context {}} args} {
    if [string match -* $context] {
        set args [linsert $args 0 $context]
        set context {}
    } elseif ![exists $context] {
        error "Unknown context \"$context\""
    }
    # Get all children in order
    if [@scope $scope ::info exists [set _dataname]:[set type]($context)] {
        set children [@scope $scope set [set _dataname]:[set type]($context)]
        if { $args == "" } {
            return $children
        }
    } else {
        return {}
    }
    # Filter by attribute
    set result {}
    foreach n $children {
        set name [concat $context $type:$n]

        array set attrs $_defaults($type)
        array set attrs [@scope $scope set [set _dataname]($name)]

    	set matching 1
    	foreach {attr val} $args {
	    if { $attrs($attr) != $val } {
                set matching 0
                break
            }
        }
        if { $matching } {
            lappend result $n
    	}
    }
    return $result
}

########################################################################
#### modelcget
#
# Get an attribute or attributes of the model. Raise an error if
# the the attribute is unknown.
#
body ::tycho::DataModel::modelcget {attribute} {
    array set data [@scope $scope set [set _dataname]()]
    if { ! [::info exists data($attribute)] } {
        error "Unknown attribute $attribute in $modelname"
    }
    return $data($attribute)
}

########################################################################
#### modelconfigure
#
# Configure attributes of the model. Arguments are
# arguments are an attribute-value list, which are merged with the
# existing attributes. Append to the history if recording. If no
# attributes are suypplied, return the list of attributes and values
# and do not append to the history.
#
body ::tycho::DataModel::modelconfigure {args} {
    if { $args == "" } {
        # Just return attributes
        @scope $scope set [set _dataname]()
    } else {
        # Invalidate cache
        @scope $scope set [set _dataname].cachevalid 0

        # Append to the history
        if { $recording } {
            history append \
                    "modelconfigure $args" \
                    "assign {} [@scope $scope set [set _dataname]($name)]"
        }
        # Merge the new data and return result
        array set attrs [@scope $scope set [set _dataname]()]
        array set attrs $args
        @scope $scope set [set _dataname]() [array get attrs]
    }
}

########################################################################
#### names
#
# Return item names that match _pattern_. If _pattern_ is not supplied
# get the names of all items in the model. Note that this method matches
# item names against a pattern, so that a pattern such as
# <code>item:foo.*</code> will return all descendants, not just children
# of <code>item:foo</code>. Use the match{} method to get just
# children. The returned list will not be ordered.
#
body ::tycho::DataModel::names {{pattern *}} {
    @scope $scope array names $_dataname $pattern
}

########################################################################
#### parse
#
# Read data from a string containing a TIM representation of a
# model. Each non-comment line must start with the name of a type
# defined for this model. The item name follows, then attribute-value
# pairs, and then nested items within curly braces. If any item
# already exists, then an error is raised. Do not add anything to
# the history. If _context_ is supplied, then this is the name of an
# item, and _data_ will be parsed relative to that item.
#
body ::tycho::DataModel::parse {data {context {}}} {
    global _current_ _context_ _object_
    set saved $_context_

    set _current_ $_dataname
    set _context_ $context
    set _object_ $this
    $safeinterp eval [list @scope $scope $data]
    set _context_ $saved
}

########################################################################
#### search
#
# Search the model for data. This method has several forms, depending
# on the _mode_ argument:
#
# <dl>
# <dt><b>done</b> _index_
# <dd>
# Terminate a search. _index_ must be a value returned by a previous
# call to <b>search glob</b> or <b>search regexp</b>.
#
# <dt><b>glob</b> _attribute_ _glob_ ?_pattern_?
# <dd>
# Start a glob-style expression search and return an index to be
# used in future calls to the <b>next</b> and <b>done</b> options.
# The glob-style pattern _glob_ will be matched against
# the values of each attribute named _attribute_. _attribute_
# is itself a glob-style pattern. The glob-style patterns
# are as for the Tcl <b>string match</b> command. If _pattern_
# is supplied, it is a glob-style pattern that is matched against
# the item names -- this can be used to limit the items through
# which the search is performed.
#
# <dt><b>next</b> _index_
# <dd>
# Return the name of the next item that matches the search 
# criteria given by _index_. _index_ must be a value returned
# by a previous call to <b>search glob</b> or <b>search regexp</b>.
# If no item is found, return null. Note that the search it somewhat
# optimistic: it is possible for an item to be returned that does
# not in fact match the search criteria. Clients should therefore
# verify that a proper match occurred by performing a <b>regexp</b>
# or <b>string match</b> on the attributes of found items.
#
# <dt><b>regexp</b> _attribute_ _regexp_ ?_pattern_?
# <dd>
# Start a regular expression search and return an index to be
# used in future calls to the <b>next</b> and <b>done</b> options.
# The regular expression _regexp_ will be matched against
# the values of each attribute named _attribute_. _attribute_
# is itself a regular expression. The regular expressions are as
# for the Tcl <b>regexp</b> command, but cannot contain an initial
# <b>^</b> or final <b>$</b> character. If _pattern_ is supplied,
# it is a glob-style pattern that is matched against the item
# names -- this can be used to limit the items through which the
# search is performed.
#
# </dl>
#
body ::tycho::DataModel::search {mode args} {
    switch -exact $mode {
        "done" {
            if { [llength $args] != 1 } {
		error "wrong # args: should be \"search done index\""
            }
            set index [lindex $args 0]
            if ![::info exists _searchdata($index)] {
                error "invalid search index \"$index\""
            }
           unset _searchdata($index)
           unset _searchtype($index)
            unset _searchexp($index)
        }
        "glob" -
        "regexp" {
	    if { [llength $args] < 2 || [llength $args] > 3 } {
		error "wrong # args: should be \"search $mode \
                        attribute $mode ?pattern?\""
	    }
            set index [::tycho::autoName search]
            set attribute [lindex $args 0]
            set expression [lindex $args 1]
            if { $mode == "glob" } {
                set exp "*$attribute $expression*"
            } else {
                set exp "$attribute $expression"
            }

            set _searchtype($index) $mode
            set _searchexp($index) $exp
            if { [llength $args] == 2 } {
                set _searchdata($index) [get]
            } else {
                set _searchdata($index) [get $pattern]
            }
            return $index
	}
       "next" {
	    if { [llength $args] != 1 } {
		error "wrong # args: should be \"search next index\""
	    }
            set index [lindex $args 0]
            if ![::info exists _searchdata($index)] {
                error "invalid search index \"$index\""
            }
            set data $_searchdata($index)
            set t [lsearch -$_searchtype($index) \
                    $data \
                    $_searchexp($index)]

            if { $t == -1 } {
                # Nothing found
                set item ""
                set data ""
            } elseif { !($t & 1) } {
                # Oops, matched against item name...
                set item [lindex $data $t]
                set data [lreplace $data 0 [expr $t+1]]
            } else {
                # Matched against data
                set item [lindex $data [expr $t-1]]
                set data [lreplace $data 0 $t]
            }
            set _searchdata($index) $data
            return $item
        }
        default {
            error "Invalid option \"$mode\": must be done, \
                    glob, regexp, or next"
        }
    }
}

########################################################################
#### sort
#
# Sort the items in a given context. The items within _context_ are
# sorted by name using the Tcl <b>lsort</b> procedure, with the
# optional arguments passed to <b>lsort</b>. This method does
# not add anything to the history.
#
body ::tycho::DataModel::sort {type {context {}} args} {
    set children [@scope $scope set [set _dataname]:[set type]($context)]
    set children [eval lsort $args [list $children]]
    @scope $scope set [set _dataname]:[set type]($context) $children
}

########################################################################
#### type
#
# Manipulate item types. Nothing is added to the command history.
# This command has several forms, depending on the _mode_ argument:
#
# <dl>
# <dt><b>cget</b> _type_ ?_attribute_?
# <dd>
# Get the value of the _attribute_ attribute of _type_. If
# _attribute_ is not supplied, get the default attributes of
# this type.
#
# <dt><b>configure</b> _type_ ?_attribute_ _value_ ...?
# <dd>
# Configure attributes of _type_.
# 
# <dt><b>defaults</b>
# <dd>
# Return a list of attributes and their default values for this type.
#
# <dt><b>define</b> _type_ ?_attribute_ _value_... ?
# <dd>
# Define a new type. The new type will be defined only the first
# time this option is called for a given class. The attributes and
# values set default attributes of the type.
#
# <dt><b>names</b>
# <dd>
# Return a list of types defined for this class.
#
# </dl>
#
# The following special attributes specify information about the
# type rather than default attributes.  These special attributes
# being with a leading colon rather than a dash, and apply across
# all models of a given class:
#
# <dl>
# <dt><b>:leafonly</b> _bool_
# <dd>
# If true, items of this type most be a leaf item -- that is,
# they cannot contain nested items. This should be set in any
# situation where a type can only be a leaf, since parsing is more
# efficient. The default is false.
#
# <dt><b>:override</b> _bool_
# <dd>
# If true, items of this type will be parsed by calling a method
# named <b>_add</b>_type_, and printed by calling a method named
# <b>_describe</b>_type_. This is used if models need to do
# additional processing when items are or printed.
#
# </dl>
#
# For example, the call
# <pre>
#     $datamodel type define foo :leafonly 1 -bar hello
# </pre>
# will create the type <b>foo</b> and declare it to only be a leaf item.
# In addition, any item of type <b>foo</b> will have the default
# value "hello" of the option <b>-bar</b>.
#
body ::tycho::DataModel::type {mode {type {}} args} {
    switch -exact $mode {
	"cget" {
            array set attrs _typeconfig($type)
            array set attrs _defaults($type)
	    if { $args == "" } {
		array get attrs
	    } else {
		return $attrs([lindex $args 0])
	    }
	}
	"configure" {
            if ![::info exists _defaults($type)] {
                error "Unknown type: \"$type\""
            }
	    array set opts $args
            if { [array names opts :*] != "" } {
                error "Reconfiguring type-control attribute not yet supported"
	    }
	    array set attrs $_defaults($type)
	    array set attrs $args
	    set _defaults($type) [array get attrs]
	}
	"define" {
	    # Regenerate the parsing proc if this is true
	    set regenerate 0

	    if { ![::info exists _typeconfig($scope:$type)] } {
		# This is the first time this type has been defined in this
		# scope. Get default type options.
		array set opts $defaulttypeconfig
		array set opts $args

		# Remember the type and the type configuration
		lappend _types($scope) $type
		set _typeconfig($scope:$type) [array get opts :*]
		set regenerate 1
	    } else {
		# This type has previously been defined. Get default
		# type options and default attributes from before.
		array set opts $_typeconfig($scope:$type)
		array set opts $args

		# If the type configuration differs, update it
		set config [array get opts :*]
		if { [lsort $_typeconfig($scope:$type)] != [lsort $config] } {
		    set _typeconfig($scope:$type) $config
		    set regenerate 1
		}
	    }
            # Remember or update the attribute defaults for this object
            if [::info exists _defaults($type)] {
                array set t $_defaults($type)
            }
            array set t $args
            set _defaults($type) [array get t -*]

            # Local copies of configuration
            foreach {cfg val} $_typeconfig($scope:$type) {
                set _[string trimleft $cfg :]($type) $val
            }

	    # Regenerate the parsing procedure if configuration changed
	    if $regenerate {
		# Create and define the parsing proc
                @scope $scope eval [_mkparseproc $type]

		# Link the proc into the safe interpreter
		$safeinterp alias $scope::$type $scope::__parse_$type
	    }
	}
	"defaults" {
	    return $_defaults($type)
        }
	"names" {
	    return $_types($scope)
	}
	default {
	    error "unknown option: must be one of \
		    \"cget, configure, define, or names\""
        }
    }
}


#####################################################################
#####################################################################
####                     protected methods                       ####

########################################################################
#### _describe
#
# Return a string describing the item given by _name_
# in the TIM format. _prefix_, if supplied, is prepended to each line.
#
body ::tycho::DataModel::_describe {name {prefix {}}} {
    regexp {([^:]+):(.+)} [lindex $name end] _ type tail

    # If override is on for this type, call its method
    if $_override($type) {
        return [@scope $scope $this _describe$type $name $prefix]
    }

    # Start string with type followed by local name
    set string "$prefix$type $tail"

    # Print attributes
    # This is fast:
    # eval lappend string [@scope $scope set [set _dataname]($name)]
    #
    # This looks better:
    array set attrs [@scope $scope set [set _dataname]($name)]
    foreach attr [lsort [array names attrs]] {
        append string " \\\n$prefix        "
        lappend string $attr $attrs($attr)
    }

    # Print children if I have any
    if !$_leafonly($type) {
    	set cd [_describechildren $name "$prefix    "]
    	if { $cd != "" } {
            append string " \{\n$cd$prefix\}"
        }
    }
    return $string\n
}

########################################################################
#### _describechildren
#
# Return a string describing the children of the item given by _name_
# in the TIM format. The _prefix_, if supplied, is prepended to each line.
# Enclosing braces are not printed.
#
body ::tycho::DataModel::_describechildren {name {prefix {}}} {
    set string ""
    foreach t $_types($scope) {
        foreach child [match $t $name] {
            append string [_describe [concat $name $t:$child] $prefix]
        }
    }
    return $string
}

########################################################################
#### _describemodel
#
# Return an item of type <b>model</b>.
#
body ::tycho::DataModel::_describemodel {name {prefix {}}} {
    if { [set m [itemcget $name -model]] != "" } {
        list model $name -data [$m describe {} "        "]
    } else {
        list model $name -data [itemcget $name -data]
    }
}

########################################################################
#### _header
#
# Return a header string for this model. The returned string contains
# only the field name-value pairs, so that subclasses can chain
# and add additional fields. This method
# returns a string containing the current values of the mode, version,
# and class attributes, and the current time as the mtime field.
#
body ::tycho::DataModel::_header {} {
    set header ""
    # append header "mode: [modelcget -mode]; "
    # append header "class: [modelcget -class]; "
    # append header "version: [modelcget -version] "
    append header "mtime: [clock format [clock seconds]] "
    return $header
}

########################################################################
#### _update
#
# Build an updated version of the cache if it's out of date.
# This is short-cut version of <b>cache update</b>.
#
body ::tycho::DataModel::_update {} {
    if ![@scope $scope set [set _dataname].cachevalid] {
        _updatecache
    }
}

########################################################################
#### _updatecache
#
# Build an updated version of the cache. This method should
# be overridden by subclasses that maintain internal data derived
# from the loaded data.
#
body ::tycho::DataModel::_updatecache {} {
    ;# Does nothing
}

########################################################################
#### cache
#
# Manipulate the cache state flag. Models often create internal
# data derived from the data loaded into them, and this method
# is provided as a means for method to keep this derived information
# up-to-date.
# 
# <dl>
# <dt><b>invalidate</b>
# <dd>
# Declare that the cache data is not valid. This option is called
# any time data is added to or deleted from the model.
#
# <dt><b>update</b>
# <dd>
# Update the cache data. If the cache is not up to date, the
# protected method </b>updatecache</b> will be called. Subclasses
# that rely on cached data should call this (or the <b>_update</b>
# short-cut) before executing code that relies on cached data.
#
# <dt><b>valid</b>
# <dd>
# If the cache data is valid, return true, otherwise false.
#
# <dt><b>validate</b>
# <dd>
# Declare that the cache data is valid. This option should be called
# at the completion of the _updatecache method.
#
# </dl>
#
body ::tycho::DataModel::cache {mode args} {
    switch -exact $mode {
        "invalidate" {
	    if { $args != "" } {
		error "wrong # args: should be \"cache invalidate\""
	    }
	    @scope $scope set [set _dataname].cachevalid 0
        }
        "update" {
 	    if { $args != "" } {
		error "wrong # args: should be \"cache update\""
	    }
            _update
        }
        "valid" {
	    if { $args != "" } {
		error "wrong # args: should be \"cache valid\""
	    }
	    @scope $scope set [set _dataname].cachevalid
	}
        "validate" {
	    if { $args != "" } {
		error "wrong # args: should be \"cache validate\""
	    }
	    @scope $scope set [set _dataname].cachevalid 1
        }
	default {
	    error "bad option \"$mode\": should be invalidate, \
		    update, valid, or validate"
	}
    }
}

#####################################################################
#####################################################################
####                       private methods                       ####

########################################################################
#### _mkparseproc
#
# Create a proc to parse an item
#
body ::tycho::DataModel::_mkparseproc {type} {
    # Proc header
    set proc "proc $scope::__parse_$type "
    if $_override($type) {
        append proc "{args}"
    } else {
        append proc "{tail args}"
    }
    append proc " \{\n"

    # Proc body
    append proc "    set type $type\n"


    # If the override option is set, call a method on the
    # object instead of generating code to load its data.
    if $_override($type) {
        append proc {
            global _object_
            global $_object_
            eval $_object_ _add$type $args
        }
    } else {
        # Declare various data global
        append proc {
            global _current_ _context_
            global $_current_
            global $_current_:$type
            global $_current_.cachevalid
        }
        # Generate the full name of the item
        append proc {
            set name [concat $_context_ $type:$tail]
        }
        # Check whether the item already exists
        append proc {
            if [::info exists [set _current_]($name)] {
                error "An item \"$name\" already exists in $_current_"
            }
        }
        # Extract contents if the item is not always a leaf
        if !$_leafonly($type) {
            append proc {
                if { [llength $args] & 1 } {
                    set contents [lindex $args end]
                    set args [lreplace $args end end]
                } else {
                    set contents {}
                }
            }
        }
        # Set the data of this item
        append proc {
            set [set _current_]($name) $args
	}
        # Add the item tail to the list of children of its parent
        append proc {
            lappend [set _current_]:[set type]($_context_) $tail
        }
        # Clear the cache valid flag
        append proc {
            set $_current_.cachevalid 0
        }
        # Parse contents if the item is not a leaf. Use the safe
		# interpreter to ensure safety.
        if !$_leafonly($type) {
            append proc {if { $contents != "" }}
            set t {
                set saved $_context_
                set _context_ $name
            }
            append t "$safeinterp eval @scope $scope \$contents\n"
            append t {
                set _context_ $saved
            }
            append proc " \{$t\}"
        }
    }
    # Complete the proc and return it
    append proc "\}"
}

########################################################################
#### _verify
#
# Verify that the item given by _name_ exists, raising an
# error if it does not.
#
body ::tycho::DataModel::_verify {name} {
    if ![@scope $scope ::info exists [set _dataname]($name)] {
    	error "Unknown item \"$name\" in $modelname"
    }
}
