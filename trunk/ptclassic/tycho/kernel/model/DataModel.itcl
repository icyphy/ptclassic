##########################################################################
# @Version: $Id$
# @Author: John Reekie
#
# @Copyright (c) 1996-%Q% The Regents of the University of California.
# All rights reserved.
# 
# Permission is hereby granted, without written agreement and without
# license or royalty fees, to use, copy, modify, and distribute this
# software and its documentation for any purpose, provided that the
# above copyright notice and the following two paragraphs appear in all
# copies of this software.
# 
# IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY
# FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
# ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF
# THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.
# 
# THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE
# PROVIDED HEREUNDER IS ON AN "AS IS" BASIS, AND THE UNIVERSITY OF
# CALIFORNIA HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,
# ENHANCEMENTS, OR MODIFICATIONS.
# 
# 						PT_COPYRIGHT_VERSION_2
# 						COPYRIGHTENDKEY
##########################################################################


##########################################################################
#### DataModel
#
# DataModel extends the Model class to support data models and the
# TIM interchange format.  TIM is a simple meta-data format that
# encourages a simple and clean representation of data, both in
# in-memory objects and in an external file representation.  TIM
# is a _very_ simple version of the object models used in OMT
# (Object Modeling Technique) -- as such, it has _types_, items
# of those types, attributes, and hierarchy. Another way of looking
# at this class is as a wrapper around a hierarchical Tcl array. See 
# <a href="../../../doc/tim.html">the TIM documentation</a> for more 
# details.
#
# The data stored in a DataModel object is hierarchical. Each
# item is referenced by its name, which consists of a dot-separated
# series of name segments. A name segment contains a type name, followed
# by a colon and the item name. For example, a top-level item may
# have the name <code>group:foo</code>, where _group_ is a type
# defined for this particular model. An item contained
# within that item may have the name <code>group:foo.icon:bar</code>,
# where _icon_ is another type defined for this model. Item names
# are unique within each type -- for example, I could also have
# an item named <code>icon:foo</code>.
#
# DataModel is designed to be subclassed to create application-specific
# models. The constructor of each subclass must call the <b>definetype</b>
# procedure to define the types in that model. Clients can then use
# methods such as <b>parse</b>, <b>add</b>, <b>delete</b>, and
# <b>itemconfigure</b> to add and change data in the model. Each
# of these methods, except for <b>parse</b>, returns an undo command,
# so that these changes can be recorded and published (see 
# <a href="Model.html">Model</a>). Sub-classes may also choose
# to override these methods, or define other, model-specific methods
# to add or change data.
#
class ::tycho::DataModel {
    inherit ::tycho::Model

    constructor {args} {}
    destructor {}

    #################################################################
    ####                        options                          ####

    #################################################################
    ####                     public methods                      ####

    # Add a new item
    method add {name args}

    # Get children of the given type
    method children {type {context {}}}

    # Remove all data
    method clear {}

    # Delete an item
    method delete {name}

    # Describe the data as a string in TIM format
    method describe {{name {}} {prefix {}}}

    # Check if an item exists
    method exists {name}

    # Get the names and attributes of each item matching a pattern
    method get {{pattern {}}}

    # Get an attribute or attributes of an item
    method itemcget {name {attribute {}}}

    # Configure attributes of an item
    method itemconfigure {name args}

    # Get the names of each item matching a pattern
    method names {{pattern {}}}

    # Load data from a TIM string
    method parse {data}

    # Sort items in a given context
    method sort {type {context {}} args}

    #################################################################
    ####                   protected methods                     ####

    # Return a description of a single item
    protected method _describeitem {context type tail name {prefix {}}}
    
    # Create a header string
    protected method _header {}

    # Define a new type of item
    protected method definetype {type args}

    #################################################################
    ####                  protected variables                    ####

    # The path of the currently-parsed model
    protected common _object_ {}

    # The name of the currently-parsed model
    protected common _current_ {}

    # The context currently being parsed in
    protected common _context_ {}

    #################################################################
    ####                    private methods                      ####

    # Generate a parsing procedure
    private method _mkparseproc {type args}

    # Verify that an item exists
    private method _verify {name}

    # Verify that an item does not exist
    private method _verifynot {name}

    #################################################################
    ####                  private variables                    ####

    private common defaulttypeoptions {
        -describe {}
        -leafonly 0
        -override 0
    	-strict 0
    	-valued 0
    }

    # The safe interpreter provided for safe parsing
    private common safeinterp [uplevel #0 interp create]

    # The scope in which we store data
    private variable scope

    #### _typeinfo
    # This array contains a set of entries for each item type.
    # It is set up and accessed by the newtype{} and
    # typeconfigure{} methods.
    # <pre>
    #    _typeinfo()                  -> List of types in order defined
    #    _typeinfo($type)             -> $type
    #    _typeinfo($type,defaults)    -> Default attribute values
    #    _typeinfo($type,describe)    -> Script to describe this item
    #    _typeinfo($type,leafonly)    -> Must be a leaf?
    #    _typeinfo($type,override)    -> Use a method to parse items?
    #    _typeinfo($type,strict)      -> Are attributes checked strictly?
    #    _typeinfo($type,valued)      -> Has a value?
    # </pre>
    private common _typeinfo

    # Debugging only
    method debug {args} {
        eval $args
    }
}

########################################################################
#### constructor
#
body ::tycho::DataModel::constructor {args} {

    # Set the scope variable
    set scope [info class]

    # Make sure the namespaces exist in the safe interpreter
    $safeinterp eval namespace ::tycho
    $safeinterp eval namespace $scope

    # Evaluate options
    eval configure $args
}

########################################################################
#### add
#
# Add a new item. _name_ is its full name including types. Following
# arguments are option-value pairs. Note that the *-valued* attribute (as
# declared in a call to definetype{}) is ignored -- if the item
# is valued, the value can be specified as an option named
# *-value*. Raise an error if the item already exists.
# Return the undo command.
#
body ::tycho::DataModel::add {name args} {
    _verifynot $name

    # Extract type field
    regexp {^(([^.]*)\.)?([^:]+):(.*)$} $name _ _ context type tail

    # Extract contents
    if { [llength $args] & 1 } {
    	set contents [lindex $args end]
    	set args [lreplace $args end end]
    } else {
    	set contents {}
    }

    # Store the data of this item
    @scope $scope set [set modelname]($name) $args

    # Add it to the list of children of its parent
    @scope $scope lappend [set modelname].[set type]($context) $tail

    # Parse contents
    if { $contents != "" } {
        set _context_ $name
        $safeinterp eval [list @scope $scope $contents]
    }
    # Return undo command
    list delete $name
}

########################################################################
#### children
#
# Return a list of child items of the given _type_. If the
# _context_ is given, return children of that item; otherwise
# return top-level items. The returned names are the names
# within the given context only. For example, if the model
# contains items with full names *item:foo* and *item:bar*,
# then the call
# <pre>
#     $model children item
# </pre>
# will return <code>{foo bar}</code>. (In comparison, the names{}
# method will return <code>{item:foo item:bar}</code>. Children
# are returned in the same order in which they were added to
# the model -- the order of children of a given type can be altered
# with the sort{} method.
#
body ::tycho::DataModel::children {type {context {}}} {
    @scope $scope set [set modelname].[set type]($context)
}

########################################################################
#### clear
#
# Clear all data from the model.
# This method is not, by default, undoable, because of the potential
# size of the undo command. A client could add an undo command to
# the history explicitly with the <code>history add</code>.
#
body ::tycho::DataModel::clear {} {
    @scope $scope unset $modelname
    foreach type $_typeinfo($scope) {
        @scope $scope unset $modelname.$type
    }
    # Not undoable
    return ""
}

########################################################################
#### delete
#
# Delete the item specified by _name_. Raise an error if
# the item does not exist.  This method deletes child items
# as well. Return the undo command.
#
body ::tycho::DataModel::delete {name} {
    _verify $name
    regexp {^(([^.]*)\.)?([^:]+):(.*)$} $name _ _ context type tail

    # Get a description for the undo command
    set desc [_describeitem $context $type $tail $name]
    
    # Remove from the parent list
    @scope $scope set [set modelname].[set type]($context)] \
            [::tycho::ldelete [@scope $scope \
            set [set modelname].[set type]($context)] $tail]

    # Delete attributes
    @scope $scope unset [set modelname]($name)
    
    # Return the undo command
    list parse $data
}

########################################################################
#### describe
#
# Generate a TIM description. If no arguments are supplied, generate a
# description of all the data. The description starts with an emacs-style
# header string that contains the mode, class, and version attributes,
# and the current date. If the _name_ is supplied, generate a description
# of just that item. If the _prefix_ argument is also
# supplied, prepend the prefix to each line produced. Note that this
# method can safely be called to produce a description of a single 
# item from within the *-describe* attribute of a type (see newtype{}).
#
body ::tycho::DataModel::describe {{name {}} {prefix {}}} {
    if { $name!= "" } {
        _verify $name
        regexp {^(([^.]*)\.)?([^:]+):(.*)$} $name _ _ context type tail
        _describeitem $context $type $tail $name $prefix
        
    } else {
        set string "# -*- [_header] -*-\n"
        foreach type $_typeinfo($scope) {
            # Get the root items of this type
            set items [children $type]
            
            # Append a description of each to the result string
            if { $_typeinfo($scope,$type,describe) != "" } {
                # Call external script to get description
                foreach n $items {
                    append string [uplevel #0 \
                            $_typeinfo($scope,$type,describe) \
                            [list $type:$n $prefix]
                }
            } else {
                foreach n $items {
                    append string [_describeitem {} $type $n $type:$n \
                            $prefix]
                }
            }
        }
        return $string
    }
}

########################################################################
#### exists
#
# Test if the item given by _name_ exists, returning 1 if it
# does and 0 if not.
#
body ::tycho::DataModel::exists {name} {
    @scope $scope ::info exists [set modelname]($name)
}

########################################################################
#### get
#
# Return the names and data of items with names that match _pattern_.
# If _pattern_ is not supplied, get the names and data of all items.
# Note that this method matches item names against a pattern, so
# that a pattern such as <code>item:foo.*</code> will return all
# descendents, not just children, of <code>item:foo</code>. Use the
# children{} method to get just children. Note also that the returned
# list will not be ordered, whereas the result from children{} will be.
#
body ::tycho::DataModel::get {{pattern {}}} {
    @scope $scope array get $modelname $pattern
}

########################################################################
#### itemcget
#
# Get an attribute or attributes of the item specified by
# _name_. If the _attribute_ argument is supplied, return the
# value of that attribute. Otherwise return a list containing
# all attributes and their values. Raise an error if the item
# does not exist or if the attribute is unknown.
#
body ::tycho::DataModel::itemcget {name {attribute {}}} {
    _verify $name

    if { $attribute == "" } {
        @scope $scope set [set modelname]($name)
    } else {
        array set opts [@scope $scope set [set modelname]($name)]
        if { ! [::info exists opts($attribute)] } {
            error "Unknown attribute $attribute in $modelname"
        }
        return $opts($attribute)
    }
}

########################################################################
#### itemconfigure
#
# Configure the item specified by _name_. Following arguments
# are an attribute-value list. If the *-strict* attribute of the item's type
# is set, then each attribute must have been defined in a call to definetype{}
# or an error will be raised. Otherwise, any attribute can be given to
# the item. Raise an error if the item does not exist. 
# Return the undo command.
#
body ::tycho::DataModel::itemconfigure {name args} {
    _verify $name
    regexp {^(([^.]*)\.)?([^:]+):(.*)$} $name _ _ context type tail

    # Get defaults as an array
    array set opts $_typeinfo($scope,$type,defaults)
    
    if { ! $_typeinfo($scope,$type,strict) } {
        # If checking is turned off, just add the new attributes
        array set opts $args
    } else {
        # Flag an error if a given attribute is not in the defaults
        foreach {attribute value} $args {
            if { ! [::info exists opts($attribute)] } {
                # Error
                error "Unknown attribute $attribute in $modelname"
            }
            set opts($attribute) $value
        }
    }
    # Set result and return undo command
    set data [@scope $scope set [set modelname]($name)]
    @scope $scope set [set modelname]($name) [array get opts]
    concat itemconfigure [list $name] $data
}

########################################################################
#### names
#
# Return item names that match _pattern_.
# If _pattern_ is not supplied, get the names of _all_ items.
# Note that this method matches item names against a pattern, so
# that a pattern such as <code>item:foo.*</code> will return all
# descendants, not just children of <code>item:foo</code>. Use the
# children{} method to get just children. Note also that the returned
# list will not be ordered, whereas the result from children{} will be.
#
body ::tycho::DataModel::names {{pattern {}}} {
    @scope $scope array names $modelname $pattern
}

########################################################################
#### parse
#
# Read data from a string containing a TIM representation of a
# model. Each non-comment line must start with the name of a type
# defined for this model. The item name follows, then the item value
# if it is a valued type, then attributes, and then nested items
# within curly braces. This method can be called even if the model
# already contains data -- however, an error will be generated if data
# with the same name as existing data is added. This method is not
# undoable.
#
body ::tycho::DataModel::parse {data} {
    global _current_ _context_ _object_
    set _current_ $modelname
    set _context_ {}
    set _object_ $this
 
    $safeinterp eval [list @scope $scope $data]
    return ""
}

########################################################################
#### sort
#
# Sort the items in a given context. This method can be called
# only if the given _type_ has the *-ordered* flag set. If so,
# the ordering of the items in _context_ is changed to that produced
# by performing an *lsort* on the item names, with the following
# arguments passed to the Tcl lsort{} procedure.
#
# FIXME: Error-checking
#
body ::tycho::DataModel::sort {type {context {}} args} {
    regexp {^(([^.]*)\.)?([^:]+):(.*)$} $name _ _ context type tail

    # Sort the child list
    set var [set modelname].[set type]($context)
    @scope $scope set $var [eval lsort $args [list @scope $scope set $var]]
}

#####################################################################
#####################################################################
####                     protected methods                       ####

########################################################################
#### _describeitem
#
# Return a string describing the item given by _name_
# in the TIM format. This method performs no error-checking, so
# the item must exist or an obscure Tcl error will be raised.
# The _prefix_, if supplied, is prepended to each line.
# Subclasses can override this method if they don't like the
# way that items are printed.
#
body ::tycho::DataModel::_describeitem {context type tail name {prefix {}}} {
    # Start string with type followed by local name
    set string $prefix$type
    lappend string $tail

    # If this type has a value, append that
    if { $_typeinfo($scope,$type,valued) } {
        array set t [@scope $scope set [set modelname]($name)]
        lappend string $data(-value)
        unset t(-value)
        set attributes [array get t]
    } else {
    	set attributes [@scope $scope set [set modelname]($name)]
    }

    # Get default attributes
    array set dflt $_typeinfo($scope,$type,defaults)

    # Print my attributes
    foreach {opt val} $attributes {
        if { ! [::info exists dflt($opt)] || $dflt($opt) != $val } {
            lappend string $opt $val
            # FIXME: Add line wrapping here
        }
    }
    
    # Print children if I have any    
    if !$_typeinfo($scope,$type,leafonly) {
        set haschildren 1
        foreach t $_typeinfo($scope) {
            if ![@scope $scope ::info exists [set modelname].[set t]($name)] {
                set haschildren 0
                break
            }
        }

        # If I have children, print enclosing braces and child items
        if $haschildren {
            set childprefix $prefix
            append childprefix "    "
            append string " \{\n"
            foreach t $_typeinfo($scope) {
                foreach child [names $t $name] {
                    append string \
                            [_describeitem $name $t $child $name.$t:$child \
                            $childprefix]
                }
            }
            append string "$prefix\}"
        }
    }
    return $string\n
}

########################################################################
#### _header
#
# Return a header string for this model. The returned string contains
# only the field name-value pairs, so that subclasses can chain
# and add additional fields. This method
# returns a string containing the current values of the mode, version,
# and class attributes, and the current time as the mtime field.
#
body ::tycho::DataModel::_header {} {
    set header ""
    # append header "mode: [modelcget -mode]; "
    # append header "class: [modelcget -class]; "
    # append header "version: [modelcget -version] "
    append header "mtime: [clock format [clock seconds]] "
    return $header
}

########################################################################
#### definetype
#
# Define a new item type. If the type has already been defined, just
# ignore this call. The first argument is the type of the item.
# Following arguments are attribute names and their default values. The
# following special attributes are recognised:
# <ul>
# <li><b>-describe</b> _script_: If not null, a script that will be 
# evaluated to describe each item of this type. The item name,
# and a prefix string, will be appended to the script, and the script
# evaluated in the global scope. The script must return a
# valid description of the item or null (in which case no description
# of that item will be produced by describe{}). The default is null.
# <li><b>-leafonly</b> _bool_: If true, items of this type most be
# a leaf item -- that is, they cannot contain nested items. This should
# be set in any situation where a type can only be a leaf, since
# parsing is more efficient. The default is false.
# <li><b>-override</b> _bool_: If true, items of this type will
# be parsed by calling a method with the same name as _type_
# on the target object. This can be used if models need to do
# additional processing when items are parsed.
# <li><b>-strict</b> _bool_: If true, the attributes of this type
# are limited to those that are declared with definetype{}.
# If not true, any attributes can be given to items of this type.
# The default is false.
# <li><b>-valued</b> _bool_: If true, items of this type have
# a value. If not true, no value will be parsed or printed in the
# external format. The default is false.
# </ul>
# Any other attribute names become an attribute of this type. For
# example, the call
# <pre>
#     $NewInterchange newtype foo -ordered 1 -bar hello
# </pre>
# will create the type *foo* and make instances of it ordered.
# In addition, any item of type *foo* can accept the attribute
# *-bar*, which will have the default value "hello." An error
# will be raised if the type already exists.
#
body ::tycho::DataModel::definetype {type args} {
    # Ignore if already exists
    if { [@scope $scope ::info procs __parse_$type] != "" } {
        return
    }
    lappend _typeinfo($scope) $type

    array set opts $defaulttypeoptions
    array set opts $args

    # Set special attributes
    set _typeinfo($scope,$type) $type
    foreach {a _} $defaulttypeoptions {
        set _typeinfo($scope,$type,[string trim $a "-"]) $opts($a)
        unset opts($a)
    }
    
    # Set defaults
    set _typeinfo($scope,$type,defaults) [array get opts]

    # Create and define the parsing proc
    # puts [list @scope $scope eval [eval _mkparseproc $type $args]]
    @scope $scope eval [eval _mkparseproc $type $args]

    # Link the proc into the safe interpreter
    # puts [list $safeinterp alias $scope::$type $scope::__parse_$type]
    $safeinterp alias $scope::$type $scope::__parse_$type
}

#####################################################################
#####################################################################
####                       private methods                       ####

########################################################################
#### _mkparseproc
#
# Create a proc to parse an item
#
body ::tycho::DataModel::_mkparseproc {type args} {
    # Get options
    array set opts $defaulttypeoptions
    array set opts $args

    # Proc header
    set proc "proc $scope::__parse_$type "
    if $opts(-override) {
        append proc "{args}"
    } elseif $opts(-valued) {
        append proc "{name value args}"
    } else {
        append proc "{name args}"
    }
    append proc " \{\n"

    # Proc body
    append proc "    set type $type\n"

    # If the override option is set, call a method on the
    # object.
    if $opts(-override) {
        append proc {
            global _object_
            global $_object_
            eval $_object_ $type $args
        }
    } else {
        # Extract contents
        if !$opts(-leafonly) {
            append proc {
                if { [llength $args] & 1 } {
                    set contents [lindex $args end]
                    set args [lreplace $args end end]
                } else {
                    set contents {}
                }
            }
        }
        # Set the data
        append proc {
            global _current_ _context_
            global $_current_
            set [set _current_]($_context_.$type:$name) $args
            global   $_current_.$type
            lappend [set _current_].[set type]($_context_) $name
        }
        # Set the value
        if $opts(-valued) {
            append proc {
                lappend [set _current_]($_context_.$type:$name) value $value
            }
        }
        # Parse contents
        if !$opts(-leafonly) {
            set t {
                set saved $_context
                set _context_ $_context_.$type:$name
            }
            append t "$safeinterp eval [list @scope $scope \$contents]\n"
            append t {
                set _context_ $saved
            }
            append proc {if { $contents != "" }}
            append proc " \{$t\}"
        }
    }
    # Complete proc and return
    append proc "\}"
}

########################################################################
#### _verify
#
# Verify that the item given by _name_ exists, raising an
# error if it does not.
#
body ::tycho::DataModel::_verify {name} {
    if ![@scope $scope ::info exists [set modelname]($name)] {
    	error "Unknown item \"$name\" in $modelname"
    }
}

########################################################################
#### _verifynot
#
# Verify that no item with the given _name_ exists, raising
# an error if it does.
#
body ::tycho::DataModel::_verifynot {name} {
    if [@scope $scope ::info exists [set modelname]($name)] {
    	error "An item \"$name\" already exists in $modelname"
    }
}
