##########################################################################
# Version: $Id$
# Author: John Reekie, Edward A. Lee
#
# Copyright (c) 1996 The Regents of the University of 'California'.
#  rights reserved.
# 
# Permission is hereby granted, without written agreement and without
# license or royalty fees, to use, copy, modify, and distribute this
# software and its documentation for any purpose, provided that the above
# copyright notice and the following two paragraphs appear in all copies
# of this software.
# 
# IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY
# FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
# ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF
# THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.
# 
# THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE
# PROVIDED HEREUNDER IS ON AN "AS IS" BASIS, AND THE UNIVERSITY OF
# CALIFORNIA HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,
# ENHANCEMENTS, OR MODIFICATIONS.
#                                                         COPYRIGHTENDKEY
##########################################################################


##########################################################################
#### Model
#
# This class is the abstract superclass of Tycho's implementation of the 
# _model_ component of the model-view user interface architecture.  The 
# model-view architecture is a derivation of the well-known 
# model-view-controller architecture developed as part of Smalltalk.
# The model-view derivation combines 
# MVC's view and controller into a single abstraction -- the key forces 
# driving this change are the increased control functionality provided 
# these days by widgets in UI frameworks (including Tk) and the increased 
# amount of direct manipulation and feedback, which makes the 
# functionality of the view and controller more tightly coupled -- 
# see the book _Designing Object-oriented User Interfaces_, Dave Collins,
# 1995.
#
# The _Model_ class is subclassed to provide application-specific (or 
# application-related, at least), information models.  (The corresponding 
# view class in Tycho is named _View_.) This abstract superclass supports 
# multiple views using the ``publish-and-subscribe'' design pattern (known 
# as the ``Observer'' pattern in books such as Gamma _et al's_ `Design 
# Patterns.'' It also incorporates two additional factors not essential 
# to, but very useful to, the model abstraction: standard data
# interchange formats, persistence and a 
# command history.
#
# Multiple views can _subscribe_ to the same model -- when any view 
# changes the data in the model, the other subscribed views are notified 
# of the change.  (Note: I always use ``notify'' instead of ``update'' to 
# avoid possible confusion with Tk's update{} procedure.) The notification 
# model is what is known as the ``push'' model: when data is changed, the 
# subscribers are informed of the type of the change _and_ the changed 
# data.  Some subclasses may choose to implement instead a ``pull'' model, 
# in which subscribers query the model for changed information.  All data 
# is accessed by means of an _index_.  Depending on the functionality 
# implemented by specific subclasses, this index could a simple integer or 
# string key, or something more complex: a region of a file between two 
# positions, a regular expression indicating the text associated with a 
# particular method, or some other symbolic representation of a portion of 
# or position within the data contained by one of these objects.  
# Different subclasses support subscription of varying complexity -- for 
# example, an object may be able to subscribe to changes only of a certain 
# type.  By default, subscription and notification uses glob-style 
# pattern-matching to provide flexible and reasonably-efficient (in Tcl) 
# access to indexes.
#
# Persistent data is an important aspect of information models: the user 
# opens and closes windows, but the information model, representing the 
# user's conceptual understanding of the semantics of the operations he or 
# she performs via the user interface, is persistent across window 
# openings and closings, and even across invocations of the application 
# program.  It is supported by the three options *-sourcefile*, 
# *-datafile*, and *-statefile*.  These are all file names, and any may be 
# used, depending on the subclass and the particular application.  The 
# "source" is a file containing information needed to build the data and 
# is never modified by the data object; the "file" is a file containing 
# the same information, but can be written by the data object: it is thus 
# the same as the usual *-file* option to the Tycho editors; the "state" 
# is a file containing the data in a form that can be rapidly 
# reconstructed by the data object.  The state is a simple Tcl 
# implementation of the ``Memento'' design pattern (Gamma _et al_).
#
# A key aspect of a user interface that encourages user interaction and 
# exploration is the ability to ``undo'' any operation.  This class 
# implements a reasonably flexible, unbounded, undo and redo 
# mechanism, so that any change to a model can be undone and redone.  The 
# undo history implemented by this class is linear -- an interesting 
# extension of the history mechanism is to make it tree-structured, for 
# applications such as design exploration, where a designer may want to 
# try out a number of different design paths and "milestone" significant 
# designs in a tree or forest of alternative designs.
#
# <i>(Edward has pointed out the relation between persistence, undo, 
# and version control. We need to work out a good abstraction for
# these mechanisms.)</i>
#
# An alternative (better?) class structure is certainly possible: split 
# the undo history into a separate class.  (This would make it an instance 
# of the ``CommandServer'' pattern of Buschmann et al's _A System of 
# Patterns_.) This would be more flexible -- for example, substituting a 
# tree-structured history for the linear history would be straightforward.  
# There is some close coupling between the history and the persistence 
# (the history is saved in the state) which makes it convenient to combine 
# them into one class.  Perhaps after some usage this issue should be 
# examined to see whether to split the history out.
#
# The methods in the _Model_ classes fall into six groups:
#
# <ul>
# <li>Change commands: add{}, replace{}, dataconfigure{}, delete{}, 
#     execute{}, and so on.
#     These are the commands that are available for undo/redo
#     and publishing. In this abstract superclass, only the execute{} 
#     command (which executes a list of commands) is implemented: other 
#     commands must be provided by subclasses. Suggested commands are :
#    
#     <ul>
#     <li>*add* _index_ _data_ _args_: Add new data at the given index.
#          Some subclasses may not allow this operation if data already
#          exists at the given index, while others will just insert
#          additional data at that index. If the data subclass accepts
#          data options, then following arguments are option values.
#  		   The methid is often named for the type of data: _entry_,
#		   _vertex_, _edge_, and so on.
#     <li>*assign* _index_ _data_: Assign a new value to the data at the
# 	 	   given index. Some subclasses may not allow this operation
#          if data does not exist at the given index; others will.
#     <li>*create* _index_ _args_: Create some kind of data with the given
#          index, where the additional arguments describe how to create
#          the data. This method is appropriate for models of graphical
#          diagrams. <i>See note below regarding returned values.</i>
#     <li>*dataconfigure* _index_ ?_option_? ?_value_? ...: Configure options of
#          data at the given index. This method is appropriate in any 
#          model in which some data can be given additional attributes.
#          It is often renamed according to the model: entryconfigure{},
#          itemconfigure{}, textconfigure{}, and so on.
#     <li>*delete* _index_: Delete data at the given index.
#     </ul>
#
#     Every data change command 
#     must return an _inverse_ command -- that is, a command that can be 
#     executed (in the scope of the model object) to undo the change.
#     Some commands may choose to return the null string if the command
#     failed.    
#     <b>Note</b>: Commands such as create{} cannot return a new 
#     identifier, since they must return an inverse command. This shifts
#     the onus onto the client to provide names for new graphical objects
#     (for example), but is not difficult (after all, that's what Tk
#     widgets require).
#    
# <li>Access commands: These comands get values of the data. Examples
#     might include get{}, match{}, names{}. Most subclasses will define a 
#     function called datacget{} or something similar, which can be used
#     to access configuration options of data.
#    
# <li>File commands: load{}, save{}, internalize{}, externalize{},
#     read{}, write{}, describe{}. load{} and save{} must never be overridden; 
#     the others usually are.
#    
# <li>Publish-subscribe commands: subscribe{}, unsubscribe{}, and publish{}.
#     None of these must ever be overridden (except in special
#     circumstances, such as the _Publisher_ and _WidgetPreferences_ 
#     classes).
#   
# <li>Undo-redo commands: record{}, undo{}, redo{}, mark{},
#     clearHistory{}, and 
#     compactHistory{}. These commands manipulate the undo history in various
#     ways. None of these must ever be overridden (except in special
#     circumstances, such as the _Publisher_ and _WidgetPreferences_ 
#     classes).
#
# <li>Protected methods: notify{}, and writeData{}. All 
#     of these do sensible things by default, although subclasses may
#     choose to override them to change behavior or for efficiency.
# </ul>
#
class ::tycho::Model {
    inherit ::tycho::Object

    constructor {args} {}
    destructor {}
    
    #################################################################
    ####                        options                          ####

    # The name of this data object
    public variable dataname ""

    # The file that this data is based on
    public variable datafile {}

    # How to match when looking for subscribers to notify. Can be
    # "exact," (the default) "glob", "all"
    public variable notifymode "exact"

    # A script that changes the default notification mechanism
    public variable notifyscript {}

    # A script saying how to parse data from a "source" file
    public variable parsescript {}

    # The separator character for hierarchical models. If 
    # null, do not execute code that assumes hierarchy.
    public variable separator ""

    # The immutable file that this data is based on
    public variable sourcefile {}

    # The file used for storing this data
    public variable statefile {}

    #################################################################
    ####                     public methods                      ####

    # Clear the undo history
    method clearHistory {args}
    
    # Compact a portion of the undo history
    method compactHistory {from to publish {command {}} {inverse {}}}
    
    # Compare two marks
    method compareMarks {mark1 operator mark2}

    # Describe the data in the model, in the same format as write{}
    method describe {{prefix {}}}

    # Externalize the model into a state file
    method externalize {fd {nohistory {}}}
    
    # Add to the model from a state file or a string
    method internalize {type data}
    
    # Load data into the object
    method load {args}

    # Get or set a mark in the undo history
    method mark {{markname {}} {position current}}

    # Parse data into the model
    method parse {type context data}
    
    # Publish a change in data
    method publish {command index args}

    # Read data into the model
    method read {type data}
    
    # Record a change in data
    method record {command index args}

    # Redo changes to the data
    method redo {{distance 1}}

    # Write the model to its files
    method save {args}

    # Subscribe to data changes that match an index pattern
    method subscribe {subscriber pattern {whattodo {}}}

    # Undo changes to the data
    method undo {{distance 1}}

    # Unsubscribe from data changes
    method unsubscribe {subscriber {pattern {}}}

    # Update the model with a change in data
    method update {subscriber command index args}

    # Write the model to a file
    method write {fd {prefix {}}}
    
    #################################################################
    ####                  protected methods                      ####

    # Return the children of an entity
    protected method _children {index args}

    # Return the parent of the entry
    protected method _parent {index type}
    
    # Return the root of the entry
    protected method _root {index type}
    
    # Return the root entities of the given types.
    protected method _roots {args}

    # Return the type of the named entity
    protected method _type {index}

    # Return a description of an entity
    protected method describeEntity {index type prefix}

    # Notify the subscribers of a change in data
    protected method notify {subscriber command pattern args}

    #################################################################
    ####                  protected variables                    ####

    # The types of association in  this model
    protected variable associationTypes {}
    
    
    # The types of entity in this model
    protected variable entityTypes {}
    
    # The marks in the redo/undo history
    protected variable historyMark
    
    # The array of flags indicating whether an undo/redo command was published
    protected variable publishable
    
    # The array of subscriptions. Each array index is a pair of
    # the subscriber and the pattern and the value is the notify
    # script (if any).
    protected variable subscriptions
    
    # The array of redo commands
    protected variable redoCommands

    # The array of undo commands
    protected variable undoCommands

    #################################################################
    ####                   private methods                       ####
    
    # Evaluate code in this object's context
    private method evalInSpecificContext {args} {eval $args}
}


########################################################################
#### constructor
#
body ::tycho::Model::constructor {args} {
    # Initialize history marks
    set historyMark(current) 0
    set historyMark(first) 0
    set historyMark(last) 0
    set historyMark(loaded) 0
    set historyMark(published) 0
    set historyMark(saved) 0

    # Initialize the first node of the history
    set undoCommands(0) {}
    set redoCommands(0) {}
    set publishable(0) 0

    # Evaluate options
    eval configure $args

    # If there is no dataname, supply a default
    if { $dataname == "" } {
	set dataname [::info namespace tail $this]
    }
}

########################################################################
#### destructor
#
body ::tycho::Model::destructor {} {
    # If the model is persistent and modified, save it
    # FIXME: Need to really work out the logic of persistence and
    # loading and writing.
    #    if { $persistent && $modified } {save}
}

########################################################################
#### clearHistory
#
# Clear the undo history. The first argument is the command to clear
# from, the second the one to clear to. The arguments can be omitted,
# in which case they default to "first" and "last." The commands in
# the history are deleted from the one _after_ the "from" mark up
# to _and including_ the "to" mark. (The "first" command is a null
# command, so you don't have to worry about that fact that you cannot
# actually delete it.)
#
# If the "from" mark is not earlier than the "to" mark, there will
# be no error generated, but no commands will be cleared either.
# If either mark does not exist, then an error will be generated.
# Any marks that point to a deleted command will be changed to point
# to the "from" mark. (Any marks that are above the "to" mark still
# point to  the same commands, although the actual index of that
# command will have changed.)
#
# The two indexes can also be raw integer indexes into the history,
# but this is intended for internal use only.
#
body ::tycho::Model::clearHistory {{from first} {to last}} {
    # Get the indexes corresponding to the marks
    if { ! [info exists historyMark($from)] } {
	error "Unknown mark $from in $dataname"
    }
    if { ! [info exists historyMark($to)] } {
	error "Unknown mark $to in $dataname"
    }
    if { ! [string match {[0-9]*} $from] } {
	set fromindex $historyMark($from)
    } else {
	set fromindex $from
    }
    if { ! [string match {[0-9]*} $to] } {
	set toindex $historyMark($to)
    } else {
	set toindex $to
    }

    # Do nothing if from is not earlier than to
    if { $fromindex >= $toindex } {
	return
    }

    # Clear the commands
    set i [expr $fromindex + 1]
    while { $i <= $toindex } {
	unset undoCommands($i)
	unset redoCommands($i)
	unset publishable($i)
	incr i
    }

    # Because the history indexes are contiguous, we have to shift
    # any commands above "to" down to fill in the gap left by the
    # deleted commands. (Note: i is already set to "to + 1")
    set delta [expr $toindex - $fromindex] 
    while { $i <= $historyMark(last) } {
	set undoCommands([expr $i - $delta]) $undoCommands($i)
	set redoCommands([expr $i - $delta]) $redoCommands($i)
	set publishable([expr $i - $delta]) $publishable($i)

	unset undoCommands($i)
	unset redoCommands($i)
	unset publishable($i)
	incr i
    }

    # If any marks got clobbered, set them to "from". Any marks
    # above "to" are shifted down the right amount.
    foreach {mark index} [array get historyMark] {
	if { $index > $fromindex || $index <= $toindex } {
	    set historyMark($mark) $fromindex
	} elseif { $index > $toindex } {
	    set historyMark($mark) [expr $index - $delta]
	}
    }
}

########################################################################
#### compactHistory
#
# Compact a portion of the undo history. The first two arguments are the 
# marks of the command to compact from and the command to compact to: commands
# from _the one after_ "from" up to _and including_ "to" are compacted
# into a single command. The third
# argument is a flag indicating whether the compacted command is to
# be marked as publishable: if it is, then an undo or redo of the 
# compacted command will be published. If the
# fourth and fifth arguments are supplied, they are the commands that
# replace the compacted commands; without these commands, this method
# will append the compacted commands.
#
# Any valid marks can be specified -- see clearHistory{} for
# more information. The "from" mark must be earlier than the
# "to" mark: an error will be flagged if it is not.
# If either mark does not exist, then an error will be generated.
#
body ::tycho::Model::compactHistory {from to publish {command {}} {inverse {}}} {
    # Get the indexes corresponding to the marks
    if { ! [info exists historyMark($from)] } {
	error "Unknown mark $from in $dataname"
    }
    if { ! [info exists historyMark($to)] } {
	error "Unknown mark $to in $dataname"
    }
    set fromindex $historyMark($from)
    set toindex   $historyMark($to)

    # Flag an error if from is not earlier than to
    if { $fromindex >= $toindex } {
	error "Cannot compact from $from ($fromindex) to $to ($toindex) in $dataname"
    }
    
    # Build composite commands if not supplied
    if { $command == "" } {
	set i [expr $fromindex + 1]
	while { $i <= $toindex } {
	    append command "    " redoCommands($i) "\n"
	    append inverse "    " undoCommands($i) "\n"
	}
    }

    # Put the new command into the history
    set redoCommands($toindex) $command
    set undoCommands($toindex) $inverse
    set publishable($toindex) $publish

    # Clear the compacted commands
    clearHistory $from [expr $toindex - 1]
}

########################################################################
#### compareMarks
#
# Compare two marks, where _operator_ is a relational operator such
# as &amp;. This is most often used to compare a mark withe _current_.
# For example, to test whether the model has been modified since
# it was last saved, execute
# <pre>
#     $model compareMarks current > saved
# </pre>
#
body ::tycho::Model::compareMarks {mark1 operator mark2} {
    if { ! [::info exists historyMark($mark1)] } {
	error "Unknown mark $mark1 in $dataname"
    }
    if { ! [::info exists historyMark($mark2)] } {
	error "Unknown mark $mark2 in $dataname"
    }
    # FIXME: Will this work with the Tcl8.0 byte-compiler?
    expr $historyMark($mark1) $operator $historyMark($mark2)
}

########################################################################
#### describe
#
# Return a string that describes the model. The data format is exactly
# that generated by the write{} method -- note that it is 
# _not_ a well-formed Tcl list. The _prefix_ argument, if present,
# is a string to place at the start of each line.
# By default, this method produces correctly
# formed output for the data of any properly-written model subclass.
# Subclasses may need to override (and chain) to produce 
# additional attributes in the output.
#
body ::tycho::Model::describe {{prefix {}}} {
    set string ""

    foreach type $entityTypes {
	lappend string "configure -[set type]options
	[set [set type]options]"
	append string "\n"
    }
    if { $separator != "" } {
	append string "configure -separator $separator\n"
    }
    foreach {r t} [_roots] {
	append string [describeEntity $r $t $prefix]
    }
    return $string
}

########################################################################
#### externalize
#
# Write a class-dependent description of the data to a file.
# The argument is a file descriptor so that this method can be used
# to write a collection of models to a single file. In the Model class,
# this method writes the undo/redo history. Subclasses should override
# this method and use chain to include the undo history. If the second
# argument is present and true, don't write the history to the file.
#
# The format of the state file must be such that the object can be
# reconstructed by the internalize{} method. Usually, this will mean
# that the object can be loaded by sourcing the file within the
# object context. In general, the file will be a collection of set{}
# and *array set* commands.
#
body ::tycho::Model::externalize {fd {nohistory {}}} {
    puts $fd "# Tycho model state file for $dataname\n\n"
    if { $nohistory == "" || ! $nohistory } {
	puts $fd "# Undo/redo history\n"
	puts $fd "array set undoCommands [list [array get undoCommands]]\n"
	puts $fd "array set redoCommands [list [array get redoCommands]]\n"
	puts $fd "array set publishable  [list [array get publishable]]\n"
	puts $fd "array set historyMark  [list [array get historyMark]]\n"
    }
    return ""
}

########################################################################
#### internalize
#
# Load a class-dependent description of the data. If the _type_ argument
# is "string" then _data_ is a string that can be evaluated in the
# object context to load the data. If it is "file", then _data_ is
# the _name_ (note: not the descriptor) of a file that can be sourced
# to load the data.
#
# <b>Important</b>: Subclasses generally do not need to override
# this method. However, they _must_ provide a method called
# <i>evalInSpecificContext</i>, which just evals its args.
# This is needed so that the scoping of variables
# is correct: since the file sets variables in the superclass, it
# must be executed within that scope. There appears to be no way around
# this even using @scope.
#
body ::tycho::Model::internalize {type data} {
    if { $type == "file" } {
	# Evaluate in object-specific context. To make sure the correct
	# method exists, qualify the call. To access the method (since
	# it's private to prevent general use) use @scope.
	@scope [info class] [list \
		$this [info class]::evalInSpecificContext source $data]
    } elseif { $type == "string" } {
	@scope [info class] [list \
		$this [info class]::evalInSpecificContext $data]
    } else {
	error "Invalid type $type"
    }
    return ""
}

########################################################################
#### load
#
# Load the data from files. With no arguments given, this method
# reads from the most recent of the *-datafile*, *-sourcefile*,
# and *-statefile* options.
# If there are arguments, they are option-value pairs, where the
# valid options are *-datafile*, *-sourcefile*, and *-statefile*,
# and the values are used instead of the options of the object. To
# prevent a file from being read, supply a null value for that option.
#
# Note that none of the *-datafile*, *-sourcefile*, or *-statefile* options
# cause the data to be reloaded when they are changed: this must be done
# explicitly by a) deleting the data and b) calling this method.
# In all cases, a load _adds_ (or overwrites) data already in this
# class, so if a load is intended to give an object all of its data
# then must first be cleared (depending on the particular subclass, this
# may require one or many calls to delete{}). (It would probably just
# be faster to delete the object and create a new one.)
#
# <i>Do not override this method: override read{} and
# internalize{} instead.</i>
#
body ::tycho::Model::load {args} {
    # Override options with args
    set temp(-sourcefile) $sourcefile
    set temp(-datafile) $datafile
    set temp(-statefile) $statefile
    array set temp $args

    # Figure out which is the most recent file.
    set time 0 ;# FIXME: is this reliable???
    set file ""
    set type ""
    foreach {y f} [array get temp] {
	if { $f  != "" } {
	    set f [::tycho::expandPath $f]
	    if { [file exists $f] } {
		set t [file mtime $f]
		if { $t > $time } {
		    set file $f
		    set type $y
		    set time $t
		}
	    }
	}
    }
    if { $file == "" } {
	error "No file found to load"
    }

    # Remember this position
    set historyMark(loaded) $historyMark(current)

    # Load data from the file according to what type of file it
    # is.
    switch -exact /$type {
        "/-sourcefile" {
            # Load the model from the source file. If the -parsescript
            # option is present, execute that to load the file. Otherwise
            # assume that the source file format is the same as the data
            # file format and use read{}.
            if { $parsescript != "" } {
                uplevel #0 [list apply $parsescript $file $this]
            } else {
                read "file" $file
            }
        }
        "/-datafile" {
            # Load the model from the data file
            read "file" $file
        }
        "/-statefile" {
            # Load the model from the state file
            internalize "file" $file
        }
    }
}

########################################################################
#### mark
#
# Place a mark in the undo history. The first argument is the name of
# the mark to set. The second is the name of the mark to set it to;
# if omitted, it defaults to "current". Models maintain at least 
# the following marks, which can be the second argument to
# this method but not the first:
# <ul>
# <li>*current*: The most recent command executed.
# <li>*root*: The first command in the history.
# <li>*published*: The most recently published command.
# <li>*saved*: The last command before the last save to files.
# <li>*loaded*: The last command before the file was last loaded.
# </ul>
#
# (Note the policy with marking commands: the command marked is the
# last one executed to get to the state represented by the given
# mark. Thus, the "current" command is the most recently-executed
# one: to undo, execute the inverse of that command; to redo,
# re-execute the following command.)
#
# If _position_ is the empty string, delete the mark.
# An error is flagged if _position_ is not empty and not a mark
# in the history. <b>Note</b>: Do not assume that a value of zero
# is the position of the first command in the undo history. Note also that
# mark names are unique: you cannot have more than one mark of the same
# name.
#
# If no arguments at all are supplied, return a list containing the
# names of all marks.
#
# Marks are a powerful and general mechanism for manipulating the undo
# history. For example, if a client wishes to makes a series of
# incremental changes but have the undo mechanism treat all those
# changes as a single change, it can set a mark before the incremental
# changes, and either i) make sure that it calls undo{} and redo{}
# using the marks it has set, or ii) _compact_ the history since that
# mark into a single command (see the compactHistory{} method).
#
body ::tycho::Model::mark {{markname {}} {position current}} {
    # Return all mark names
    if { $markname == "" } {
	return [array names historyMark]
    }

    if { $position == "" } {
	# Delete a mark
	unset historyMark($markname)
    } else {
	if { ! [::info exists historyMark($position)] } {
	    error "Mark $position unknown in $dataname"
	}
	# Set a mark
	set historyMark($mark) $historyMark($position)
    }
}

########################################################################
#### parse
#
# Parse a string which represents a complete entity. This 
# method is here to support hierarchical models. Attributes are first,
# and can be one or more per line. Entities and associations follow. The
# syntax parsed is
# <pre>
#   entity     = {attribute value ["\n"]} {entitydecl "\n"}
#   entitydecl = type name value "{" entity "}"
#              | type name value {attribute value}
# </pre>
#
# (FIXME: This doesn't allow for associations yet.)
#
# The _type_ argument is the type of entity: for example, "entry"
# or "vertex." _context_ is its assigned name, and is used to place
# nested entities in the correct context in the model being built.
# _string_ is the string being parsed.
#
body ::tycho::Model::parse {type context data} {
    # Remove leading white space
    regsub "^\[ \t\n\]*" $data {} data

    # Scan the string by dropping lines.
    while { $data != "" } {
	if { [string match {#*} $data] } {
	    # Discard comment line and white space
	    regsub "^\[^\n\]*\[ \t\n\]*" $data {} data

	} elseif { [string match {-*} $data] } {
	    # Process a single attribute
	    set attribute [lindex $data 0]
	    set value [lindex $data 1]
	    set data [lreplace $data 0 1]
	    $this [set type]configure $context $attribute $value
	    
	    # Skip white space
	    regsub "^\[ \t\n\]*" $data {} data

	} else {
	    # The line is an entity creation command. Figure out if 
	    # it's hierarchical. First get a line.
	    regexp "^\[^\n\]*" $data line
	    set type [lindex $line 0]
	    set name [lindex $line 1]
	    set value [lindex $line 2]

	    # Need a catch here since the line may have more open braces
	    # than close braces.
	    if { ! [catch {llength $line}] && ([llength $line] == 3 \
		    || ( [llength $line] > 3 \
		    && [string index [lindex $line 3] 0] == "-" )) } {

		# Not hierarchical: evaluate this line
		eval [list $this $type $context$separator$name $value] \
			[lreplace $line 0 2]

		# Dump the line and following white space
		regsub "^\[^\n\]*\[ \t\n\]*" $data {} data

	    } else {

		# Must be hierarchical. Get the nested stuff using list
		# indexing
		$this $type $context$separator$name $value [lindex $data 3]

		# Drop the first four elements and skip white space
		set data [lreplace $data 0 3]
		regsub "^\[ \t\n\]*" $data {} $data
	    }
	}
    }
}

########################################################################
#### publish
#
# Publish data. This is the same as recording it, except that 
# the change is forwarded to any subscribers (see notify{})
# that have subscribed to the given index. The change is forwarded
# by the notify{} method, which can be overridden to change the
# notification behaviour. This method is designed to be called by
# entities that are _not_ also subscribers to this model; subscribers
# must call the update{} method. The first argument
# is the command to execute on the model; the second the data index,
# and remaining arguments are additional arguments to the command.
#
body ::tycho::Model::publish {command index args} {
    eval [list update {} $command $index] $args
}

########################################################################
#### read
#
# Read data from a data file or from a string. If the _type_ argument
# is "string" then _data_ is a string; if it is "file", then _data_ is
# the _name_ (note: not the descriptor) of a file that contains the
# data. By default, the file format is taken to be executable Tcl
# that calls methods. Subclasses can override for more sophisticated
# behavior.
#
body ::tycho::Model::read {type data} {
    if { $type == "file" } {
	# Evaluate in object-specific context. To make sure the correct
	# method exists, qualify the call. To access the method (since
	# it's private to prevent general use) use @scope.
	@scope [info class] [list \
		$this [info class]::evalInSpecificContext source $data]
    } elseif { $type == "string" } {
	@scope [info class] [list \
		$this [info class]::evalInSpecificContext $data]
    } else {
	error "Invalid type $type"
    }
    return ""
}

########################################################################
#### record
#
# Execute a command on this data object and record the command and
# its inverse for undoing.
#
body ::tycho::Model::record {command index args} {
    # Clear the redo future if needed
    if { $historyMark(current) < $historyMark(last) } {
	clearHistory current last
    }

    # Execute the command and remember its result (the undo command).
    # If the command causes an error, this method will abort,
    # and neither the command nor its undo command will be recorded.
    set undo [eval [list $this $command $index] $args]

    # If there was no error, proceed to record the command
    incr historyMark(current)
    incr historyMark(last)
    set redoCommands($historyMark(current)) \
	    [concat [list $command $index] $args]
    set publishable($historyMark(current)) 0

    # Record the undo command
    set undoCommands($historyMark(current)) $undo

    # Mark the command as not publishable
    set publishable($historyMark(current)) 0
}

########################################################################
#### redo
#
# Redo a data change. If an argument is given and it is an integer,
# redo that many steps, or until the end of the redo future is reached.
# If not an integer, the argument must be a mark, and commands are redone
# up to _and including_ the marked command. Flag an error if the mark
# does not exist. If the mark is not later than the current position,
# then do nothing. 
#
# As each command is redone, the change is published if the original
# command was published. 
#
# Return the number of commands redone.
#
body ::tycho::Model::redo {{distance 1}} {
    # If a mark is given, figure out the distance
    if { ! [string match {[0-9]*} $distance] } {
	# Check that the mark exists
	if { ! [::info exists historyMark($distance)] } {
	    error "Unknown mark $distance in $dataname"
	}
	set distance [expr $historyMark($distance) - $historyMark($current)]
    }
    # Go forward only as far as the last command
    if { $distance > $historyMark(last) - $historyMark(current) } {
	set distance [expr $historyMark(last) - $historyMark(current)]
    }

    # Redo the commands
    set count 0
    while { $count < $distance } {
	# Adjust indexes
	incr historyMark(current)
	incr count

	# Execute the command
	# FIXME: This should do a catch?
	eval $this $redoCommands($historyMark(current))

	# Publish if publishable
	if { $publishable($historyMark(current)) } {
	    eval notify noone $redoCommands($historyMark(current))
	}
    }

    # Return the number of commands redone
    return $distance
}

########################################################################
#### save
#
# Write the data to a file. With no arguments given, this method
# writes to both files given by the *-datafile* and *-statefile* options.
# If there are arguments, they are option-value pairs, where the
# valid options are *-datafile* and *-statefile*, and the values
# are used instead of the options of the object. Nothing is
# written if either file is null.
#
# The file given by *-datafile* is written in a "user-editable" form:
# depending on the particular subclass, it may be just plain text,
# or it may be a series of method calls that reconstruct the 
# data. The file given by the *-statefile* option contains information
# in a form the particular subclass finds useful, and
# includes code that "clones" the data object quickly, as 
# well as the undo/redo history of that data. Subscription
# information is _not_ written to the state file.
#
# <i>Do not override this method: override write{} and
# externalize{} instead.</i>
#
body ::tycho::Model::save {args} {
    # Override options with args
    set temp(-datafile) $datafile
    set temp(-statefile) $statefile
    array set temp $args

    # Remember this position
    set historyMark(saved) $historyMark(current)
    
    # Expand file names
    if { $temp(-datafile) != "" } {
	set df [tycho::expandPath $temp(-datafile)]
    } else {
	set df ""
    }
    if { $temp(-statefile) != "" } {
	set sf [tycho::expandPath $temp(-statefile)]
    } else {
	set sf ""
    }
    
    # Open files
    set dd ""
    if { $df != "" } {
	if { ! [file exists $df] || [file writable $df] } {
	    set dd [open $df "w"]
	}
    }
    set sd ""
    if { $sf != "" } {
	if { ! [file exists $sf] || [file writable $sf] } {
	    set sd [open $sf "w"]
	}
    }

    # Write the data file and state file. Note that the state
    # file must be written _after_ the data file if load{}
    # is to work correctly.
    if { $dd != "" } {
	write $dd
	close $dd
    }
    if { $sd != "" } {
	externalize $sd
	close $sd
    }
}

########################################################################
#### subscribe
#
# Subscribe to data that matches an index pattern. The first argument
# is the name of the subscriber; the second is a pattern to match against
# the symbolic index of changed data to determine whether to notify
# this subscriber. By default, when data is published, the
# subscriber's publish{} method is called with the data change
# command (add, replace, dataconfigure, or delete) and its arguments
# as arguments. If the third argument is supplied, it is applied
# (at the global context) to four arguments: the subscriber, the
# command name, the index, and the remaining arguments. 
#
# Note that the index is
# not necessarily the same as the index used when the data is 
# subscribed to: for example, a subscriber could subscribe to
# all the data in a text data object, but would be notified
# on every character insertion. See the notify{} method for
# a description of the matching process.
#
# To subscribe to all changes, simply use the pattern "*".
#
body ::tycho::Model::subscribe {subscriber pattern {whattodo {}}} {
    set subscriptions($subscriber,$pattern) $whattodo
}

########################################################################
#### undo
#
# Undo a data change. If an argument is given and it is an integer,
# undo that many steps, or until the start of the undo history. If not
# an integer, the argument must be a mark, and commands are undone
# back to _but not including_ the marked command. If the mark is not earlier
# in the history than the current position, do nothing. If the mark
# does not exist, flag an error. 
#
# As each command is undone, the change is published if the original
# command was published. 
#
# Return the number of commands undone.
#
body ::tycho::Model::undo {{distance 1}} {
    # If a mark is given, figure out the distance
    if { ! [string match {[0-9]*} $distance] } {
	# Check that the mark exists
	if { ! [::info exists historyMark($distance)] } {
	    error "Unknown mark $distance in $dataname"
	}
	set distance [expr $historyMark($current) - $historyMark($distance)]
    }

    # Go back only as far as the first command (but don't actually
    # execute the first command, since it is a null command)
    if { $distance > $historyMark(current) - $historyMark(first) } {
	set distance [expr $historyMark(current) - $historyMark(first)]
    }
    # Mark model as modified
    set modified 1

    # Undo the commands
    set count 0
    while { $count < $distance } {
	# Execute the command
	eval $this $undoCommands($historyMark(current))

	# Publish if publishable
	if { $publishable($historyMark(current)) } {
	    eval notify noone $undoCommands($historyMark(current))
	}

	# Adjust indexes
	incr historyMark(current) -1
	incr count
    }

    # Return the number of commands undone
    return $distance
}

########################################################################
#### unsubscribe
#
# Unsubscribe from data at a given index. The subscriber is 
# removed from the subscription list for that index. Note that 
# the index must exactly match an index given to
# the subscribe{} method: it cannot be used to implement
# an exclusion mechanism (one cannot, for example, say "I have
# already subscribed to all character insertions, and I want
# to unsubscribe from all insertions of carriage returns").
#
# If the _pattern_ argument is not supplied, the subscriber is
# unsubscribed from all patterns it has subscribed to.
#
body ::tycho::Model::unsubscribe {subscriber {pattern {}}} {
    if { $pattern != "" } {
	# Unsubscribe from a given pattern
	catch {unset subscriptions($subscriber,$pattern)}
    } else {
	# Unsubscribe from all patterns
	foreach index [array names subscriptions $subscriber,*] {
	    unset subscriptions($index)
	}
    }
}

########################################################################
#### update
#
# Update data. This is the same as recording it, except that 
# the change is forwarded to subscribers (other than the caller)
# that have subscribed to the given index. The change is forwarded
# by the notify{} method, which can be overridden to change the
# notification behaviour. This method is designed to be called by
# subscribers to the model: the first argument is the name of the
# subscriber that is performing the update, and is used to prevent
# the model from updating the caller. To cause a data update from
# a non-subscriber, call the publish{} method. The second argument
# is the command to execute on the model; the third the data index,
# and remaining arguments are additional arguments to the command.
#
body ::tycho::Model::update {subscriber command index args} {
    # Record the command
    eval [list record $command $index] $args

    # Mark command as publishable
    set publishable($historyMark(current)) 1

    # Remember where it happened
    set historyMark(published) $historyMark(current)

    # Notify subscribers.
    eval [list notify $subscriber $command $index] $args
}

########################################################################
#### write
#
# Write data to a data file. The first argument is a file descriptor
# so that multiple objects can be streamed to a single file. The
# second argument, if present, is a string to place at the start
# of each line. By default, this method produces correctly
# formed output for the data of any properly-written model subclass.
# Subclasses may need to override (and chain) to write additional
# attributes to the output.
#
body ::tycho::Model::write {fd {prefix {}}} {
    foreach type $entityTypes {
	puts $fd "configure -[set type]options [set [set type]options]"
    }
    if { $separator != "" } {
	puts $fd "configure -separator $separator"
    }

    foreach {r t} [_roots] {
	puts $fd [describeEntity $r $t $prefix]
    }
}

########################################################################
########################################################################
####                     protected methods


########################################################################
#### _children
#
# Return the children of the entry of the given entity 
# types. Note that this includes all
# children, not just the ones that are nodes of the tree. 
# The returned list alternates the child's name with its 
# entity type. Some subclasses may choose to make a version
# of this method publically available.
#
body ::tycho::Model::_children {index args} {
    # First check if index is null, and if so, return roots
    if { $index == "" } {
	eval roots $args
    }
    # If there's no separator, noone has any children
    if { $separator == "" } {
	return ""
    }
    set result {}
    
    foreach type $args {
	set len [expr [llength [split $index $separator]] + 1]
	
	# Find descendents and select out the children
	foreach entity [array names _[set type]value $index$separator*] {
	    if { [llength [split $entity $separator]] == $len } {
		lappend children $entity $type
	    }
	}
    }
    return $children
}

########################################################################
#### _parent
#
# Return the parent of the entry. The type must be specified.
# To get the type of the parent, use type{}.
#
body ::tycho::Model::_parent {index type} {
    if { $separator == "" } {
	error "This model is not hierarchical"
    }
    if { ! [::info exists _[set type]value($index)] } {
	error "Unknown entry $index in $dataname"
    }
    join [lreplace [split $index $separator] end end]
}

########################################################################
#### _root
#
# Return the root of the entry. The type must be specified.
#
body ::tycho::Model::_root {index type} {
    if { $separator == "" } {
	error "This model is not hierarchical"
    }
    if { ! [::info exists _[set type]value($index)] } {
	error "Unknown entry $index in $dataname"
    }
    lindex [split $index $separator] 0
}

########################################################################
#### _roots
#
# Return the root entities of the given types.
#
body ::tycho::Model::_roots {args} {
    set roots {}
    if { $separator == "" } {
	# All entities are roots
	foreach type $args {
	    eval lappend roots \
		    [@scope [info class] \
		    evalInSpecificContext array names _[set type]value]
	}
    } else {
	# Entities are roots only if they have no separator
	foreach type $args {
	    puts _[set type]value
	    puts [array names _[set type]value]
	    foreach entity [@scope [info class] \
		    evalInSpecificContext array names _[set type]value] {
		if { [llength [split $entity $separator]] == 1 } {
		    lappend roots $entity $type
		}
	    }
	}
    }
    return $roots
}

########################################################################
#### _type
#
# Return the type of the named entity. Error if it doesn't 
# exist.
#
body ::tycho::Model::_type {index} {
    foreach type $entityTypes {
	if { [::info exists _[set type]value($index)] } {
	    return $type
	}
    }
    error "Unknown entity $index in $dataname"
}

########################################################################
#### describeEntity
#
# Return a string describing the entity of type _type_ named 
# _index_. The _prefix_ is prepended to each line.
#
body ::tycho::Model::describeEntity {index type prefix} {
    array set default ${type}options
    set string ""

    # Output my type, name, and value
    set value $_[set type]value($index)
    append string $prefix $type
    if { $separator == "" } {
    	lappend string $index $value
    } else {
    	lappend string [lindex [split $index $separator] end] $value
    }

    # Figure out if I have children
    set children [_children $index $entityTypes]
    
    # If not, print my attributes only
    if { $children == "" } {
	foreach {opt val} $_[set type]optns($index) {
	    if { ! [::info exists default($opt)] || $default($opt) != $val } {
       	        lappend string $opt $val
	    }
	}
    } else {
	# If I have, then print enclosing braces, then attributes,
	# then each child
	set childprefix $prefix
	append childprefix "    "
	append string " \{"
	
	# Output attributes
	foreach {opt val} $_[set type]optns($index) {
	    if { ! [::info exists default($opt)] || $default($opt) != $val } {
       	        append string "\n"$childprefix
       	        lappend string $opt $val
            }
            # Output children
            foreach {t c} $children {
            	append string \
            		"\n"[describeEntity $index$separator$c $t $childprefix]
            }
            append string "\n\}"
        }
    }
    return $string\n
}

########################################################################
#### notify
#
# Notify subscribers except _subscriber_ with the given change in data.
# How subscribers are found depends 
# Matching is done using glob-style pattern-matching. The
# default notification method is very direct: if _index_ matches an
# index pattern to which the subscriber is subscribed, the given command
# is called directly in the subscriber. This behavior can be changed by
# setting the *-notifyscript* option, which must be a function-script
# that can be applied to four arguments: the subscriber, the command name,
# the index, and a list of remaining arguments. Individual subscribers
# may themselves choose a different notification mechanism when they
# subscribe by providing the *whattodo* argument to subscribe{}.
#
# Although subscribers are supposed to
# unsubscribe themselves before dying, this doesn't always happen
# (especially when debugging!). So this method checks that the subscriber
# still exists, and if it doesn't, unsubscribes the offending subscriber.
#
body ::tycho::Model::notify {subscriber command index args} {
    set subscribers {}
    # Scan for subscribers with a pattern that matches the index
    switch -exact $notifymode {
	"exact" {
	    foreach subindex [array names subscriptions *,$index] {
		eval lappend subscribers [split $subindex ","] \
			[list $subscriptions($subindex)]
	    }
	}
	"glob" {
	    foreach subindex [array names subscriptions] {
		set si [split $subindex ","]
		set sub [lindex $si 0]
		set idx [lindex $si 1]
		if { [string match *,$pattern $index] } {
		    lappend subscribers $sub $idx $subscriptions($subindex)
		}
	    }
	}
	"all" {
	    foreach subindex [array names subscriptions] {
		eval lappend subscribers [split $subindex ","] \
			[list $subscriptions($subindex)]
	    }
	}
    }

    # Process each subscriber
    foreach {sub index script} $subscribers {
	# Don't notify the caller
	if { $sub == $subscriber } {
	    continue
	}
	# Unsubscribe the subscriber if it no longer exists!
	if { [::info which -command $sub] == "" } {
	    unsubscribe $sub
	    continue
	}

	if { $script != "" } {
	    # if there's a script supplied by the subscriber, apply it
	    # FIXME: should $args be inside the list?
	    uplevel #0 ::tycho::apply \
		    [list $script $sub $command $index] $args
	} elseif { $notifyscript != "" } {
	    # Or if there's a global script, apply that
	    # FIXME: should $args be inside the list?
	    uplevel #0 ::tycho::apply \
		    [list $notifyscript $sub $command $index] $args
	} else {
	    # By default, call the subscriber directly
	    uplevel #0 $sub $command [list $index] $args
	}
    }
}
