##########################################################################
# Version: $Id$
# Author: John Reekie, Edward A. Lee
#
# Copyright (c) 1996-1997 The Regents of the University of California.
#  rights reserved.
# 
# Permission is hereby granted, without written agreement and without
# license or royalty fees, to use, copy, modify, and distribute this
# software and its documentation for any purpose, provided that the above
# copyright notice and the following two paragraphs appear in all copies
# of this software.
# 
# IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY
# FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
# ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF
# THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.
# 
# THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE
# PROVIDED HEREUNDER IS ON AN "AS IS" BASIS, AND THE UNIVERSITY OF
# CALIFORNIA HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,
# ENHANCEMENTS, OR MODIFICATIONS.
#                                                         COPYRIGHTENDKEY
##########################################################################


##########################################################################
#### Model
#
# This class is the abstract superclass of Tycho's implementation of 
# the _model_ component of the model-view user interface architecture.  
# (The corresponding view class in Tycho is named _View_.) Sub-classes 
# of Model implement application-specific (or application-related, at 
# least), information models.  Model-view is a derivation of the 
# well-known model-view-controller (MVC) architecture of Smalltalk; 
# the model-view derivation combines MVC's view and controller into a 
# single abstraction.  The key forces driving this change are the 
# increased control functionality provided these days by widgets in UI 
# frameworks (including Tk) and the increased amount of direct 
# manipulation and feedback, making the functionality of the view and 
# controller more tightly coupled -- see the book <i>Designing 
# Object-oriented User Interfaces</i> by Dave Collins, 1995.
#
# <p>Models are based on the TIM format (see <a 
# href="Interchange.html">the Interchange class</a> and <a 
# href="../../../doc/tim.html">the TIM documentation</a> for more 
# details).  As such, they contains entities, links between entities, 
# and attributes of entitities and links.  The methods 
# defineEntityType{} and defineLinkType{} define the structure of a 
# model and are generally called in the subclass constructor; the 
# methods configureEntityType{}, and configureLinkType{} add 
# additional attributes to the model or change attribute defaults and 
# are generally used by clients to tailor a model to their specific 
# needs.  Much of the TIM-related functionality is inherited from the 
# <a href="Interchange.html">Interchange</a> class.
#
# <p>_Model_ supports multiple views using a "publish-and-subscribe" 
# mechanism (known as the "Observer" pattern in books such as Gamma 
# _et al's_ <i>Design Patterns</i>).  It also incorporates other 
# facilities not essential to, but very useful to, the model 
# abstraction: a standard data interchange format (based on TIM), a 
# simple "serialization" mechanism, and a change history.
#
# <p>Multiple views can subscribe to the same model; when any view 
# changes the data in the model, the other subscribed views are 
# notified of the change.  (Note: I use "notify" instead of "update" 
# to avoid possible confusion with Tk's update{} procedure.) Views can 
# specify whether they are interested in data with a particular name,
# or in changes to all data. Notification uses what is known as 
# the "push" model: when data is changed, the subscribers are informed 
# of the type of the change _and_ the changed data. The subscribe{}, 
# unsubscribe{}, and notifyDataChange{} methods implement this mechanism.
# In addition, subscriber can subscribe to specific "events" such
# as loading or saving the model from and to disk -- this
# mechanism is implemented by the subscribeEvent{}, 
# unsubscribeEvent{}, and notifyEvent{} methods.
#
# <p>A model has three file-related options: *-sourcefile*, 
# *-datafile*, and *-statefile*.  These are all file names, and the 
# code responsible for creating and managing a model can choose to use 
# none, all, or any combination of the three.  The data file is a file 
# in TIM format (see <a href="Interchange.html">the Interchange 
# class</a> and <a href="../../../doc/tim.html">the TIM 
# documentation</a> for more details).  The state file is Tycho's 
# serialization mechanism -- it contains a class-dependent description 
# of the model that can only be understood by instances of that class.  
# Loading from a state file is substantially faster than parsing a TIM 
# file.  Finally, the source file is a file containing the data in the 
# model, but in a format not understood by the model itself.  For 
# example, an HTML file could be a source file for a "formatted text" 
# model, or an Oct facet could be the source file for a "Ptolemy 
# galaxy" model.
#
# <p>High-level file I/O support is provided by the save{} and load{} 
# methods.  save{} writes data to the data and state files (if 
# specified), while load{} reads data from the most-recently modified 
# file.  See the documentation for these methods below for more 
# details.  Reading and writing data in TIM format is provided by the 
# read{} and write{} methods, while reading and writing data in the 
# state file format is provided by the internalize{} and externalize{} 
# methods.
#
# <p>Because user interfaces typically allow a user to undo and redo 
# operations, _Model_ implements a reasonably flexible, unbounded, 
# undo and redo mechanism.  The undo history is linear -- an 
# interesting extension of the history mechanism would to make it 
# tree-structured, for applications such as design exploration, where 
# a designer may want to try out a number of different design paths 
# and "milestone" significant designs in a tree or forest of 
# alternative designs.  To implement undo and redo correctly, every 
# undo-able method must return an inverse command -- that is, code 
# that can be executed in the scope of the model object to undo the 
# change -- which is recorded if the method is called via the 
# record{}, update{}, or publish{} methods. <p><i>(Edward has pointed out the 
# relation between persistence, undo, and version control.  We need to 
# work out a good abstraction for these mechanisms.)</i>
#
# <p>A model generally contains six groups of methods:
#
# <p> <ul> <li>Data change methods.  These are the methods that are 
# available for undo/redo and publishing.  The four types of method 
# encouraged by the <a href="Interchange.html">Interchange</a> 
# superclass are: i) Add data with a name, value, and attributes; ii) 
# assign a new value to some existing data; iii) configure the 
# attributes of existing data, and iv) delete some data.  Note that 
# every data change method must return an inverse command.  To prevent 
# a method from being recorded or published, have it return a null 
# string -- record{} and publish{} will generate a run-time error.
#
# <p><b>Note</b>: Methods cannot return a new identifier, since they must 
# return an inverse command.  This shifts the onus onto the client to 
# provide names for new graphical objects (for example), but is not 
# difficult (after all, that's what Tk widgets require).
#  
# <li>Access methods: These methods get information from the model.
# They could return a single item or multiple items selected by 
# pattern-matching. Typically, there will also be methods to get
# attributes of the data.
#  
# <li>File methods: load{}, save{}, internalize{}, externalize{}, 
# read{}, write{}, describe{}.  load{} and save{} should never be 
# overridden; the others often are.
#  
# <li>Publish-subscribe methods: subscribe{}, unsubscribe{}, 
# publish{}, and update{}.  These should rarely  be overridden.
# 
# <li>Undo-redo methods: record{}, undo{}, redo{}, mark{}, 
# compareMarks{}, clearHistory{}, and compactHistory{}.  These methods 
# manipulate the undo history in various ways.  These methods should 
# rarely be overridden .
#   
# </ul>
#
class ::tycho::Model {
    inherit ::tycho::Object ::tycho::Interchange

    constructor {args} {}
    destructor {}
    
    #################################################################
    ####                        options                          ####

    # The name of this model
    public variable modelname ""

    # The file that this data is based on
    public variable datafile {}

    # A script saying how to parse data from a "source" file
    public variable parsescript {}

    # The separator character for hierarchical models. If 
    # null, do not execute code that assumes hierarchy.
    public variable separator "."

    # The immutable file that this data is based on
    public variable sourcefile {}

    # The file used for storing this data
    public variable statefile {}

    # If true, options are checked, otherwise any are allowed
    public variable strictoptions 1

    #################################################################
    ####                     public methods                      ####

    # Append a command to the undo history
    method appendHistory {redo undo {publishable 1}}
    
    # Clear the undo history
    method clearHistory {args}
    
    # Compact a portion of the undo history
    method compactHistory {from to publish {command {}} {inverse {}}}
    
    # Compare two marks
    method compareMarks {mark1 operator mark2}

    # Add or change default attributes of an entity type
    method configureEntityType {type args}
    
    # Add or change default attributes of a link type
    method configureLinkType {type args}
    
    # Add a new type of entity to the model
    method defineEntityType {type args}
    
    # Add a new type of link to the model
    method defineLinkType {type args}
    
    # Describe the data in the model in TIM
    method describe {{prefix {}}}

    # Get the internal state of the medel
    method describeState {{mode all}}

    # Externalize the model into a state file
    method externalize {fd {mode all}}
    
    # Add to the model from a state file or a string
    method internalize {type data}
    
    # Load data into the object
    method load {args}

    # Get or set a mark in the undo history
    method mark {{markname {}} {position current}}

    # Notify all subscribers of a change in data
    method notify {command pattern args}

    # Publish a change in data
    method publish {command index args}

    # Read data into the model
    method read {type data}
    
    # Record a change in data
    method record {command index args}

    # Redo changes to the data
    method redo {{distance 1}}

    # Write the model to its files
    method save {args}

    # Subscribe to data changes that match an index pattern
    method subscribe {subscriber {name all} {whattodo {}}}

    # Subscribe to a significant event like loading and saving
    method subscribeEvent {subscriber event {whattodo {}}}

    # Undo changes to the data
    method undo {{distance 1}}

    # Unsubscribe from data changes
    method unsubscribe {subscriber {name {}}}

    # Unsubscribe from an event
    method unsubscribeEvent {subscriber {event {}}}

    # Update the model with a change in data
    method update {subscriber command index args}

    # Write the model to a file in TIM format
    method write {fd {prefix {}}}
    
    #################################################################
    ####                  protected methods                      ####

    # Return the "name" to print in error messages
    protected method _dataname {}

    # Notify the subscribers of a change in data
    protected method notifyDataChange {subscriber command pattern args}

    # Notify the subscribers of an event
    protected method notifyEvent {event}

    # Execute a sequence of commands in a list
    protected method sequence {cmdlist}

    #################################################################
    ####                  protected variables                    ####

    # The marks in the redo/undo history
    protected variable historyMark
    
    # The array of subscriptions to events. Each array index is a pair of
    # the subscriber and the event name, and the value is the notify
    # script (if any).
    protected variable _eventsubscription
    
    # The array of flags indicating whether an undo/redo command
    # was published
    protected variable _publishable
    
    # The array of subscriptions. Each array index is a pair of
    # the subscriber and the date name, and the value is the notify
    # script (if any).
    protected variable _subscription
    
    # A flag saying whether commands are being recorded (usually true)
    protected variable recording 1

    # The array of redo commands
    protected variable redoCommands

    # The array of undo commands
    protected variable undoCommands

    # Evaluate code in this object's context
    protected method evalInSpecificContext {args} {eval $args}

    # Debugging only
    method debug {args} {
	eval $args
    }

    # HACK FIXME
    method getUndo {mark} {set undoCommands($historyMark($mark))}
    method getRedo {mark} {set redoCommands($historyMark($mark))}
    method setUndo {mark cmd} {set undoCommands($historyMark($mark)) $cmd}
    method setRedo {mark cmd} {set redoCommands($historyMark($mark)) $cmd}
}


#########################################################################
#### -strictoptions configuration
# This option provides external access to the _strictoptions variable
# in the _Interchange_ superclass, which controls whether
# options are checked for validity.
#
configbody ::tycho::Model::strictoptions {
    set _strictoptions $strictoptions
}

#########################################################################
#### -separator configuration
# This option provides external access to the _separator variable
# in the _Interchange_ superclass, which specifies the separator
# character used to separator hierarchy levels. It is null if the
# model does not support hierarchy. The separator cannot be changed
# if the model already contains data.
#
configbody ::tycho::Model::separator {
    if { [array names _info] != "" } {
	error "Model $modelname already contains data"
    }
    set _separator $separator
}

########################################################################
#### constructor
#
body ::tycho::Model::constructor {args} {
    # Initialize history marks
    set historyMark(current) 0
    set historyMark(first) 0
    set historyMark(last) 0
    set historyMark(loaded) 0
    set historyMark(published) 0
    set historyMark(saved) 0

    # Initialize the first node of the history
    set undoCommands(0) {}
    set redoCommands(0) {}
    set _publishable(0) 0

    # Evaluate options
    eval configure $args

    # If there is no modelname, supply a default
    if { $modelname == "" } {
	set modelname [::info namespace tail $this]
    }
}

########################################################################
#### appendHistory
#
# Append an undo and redo command to the command history. This
# method is not for casual use. The third optional argument is
# a boolean indicating whether this command is to be published
# to subscribers when undone or redone -- by default, it is.
#
body ::tycho::Model::appendHistory {redo undo {publishable 1}} {
    # Clear the redo future if needed
    if { $historyMark(current) < $historyMark(last) } {
	clearHistory current last
    }

    # Record the commands
    incr historyMark(current)
    incr historyMark(last)
    set redoCommands($historyMark(current)) $redo
    set undoCommands($historyMark(current)) $undo
    set _publishable($historyMark(current)) $publishable
}

########################################################################
#### clearHistory
#
# Clear the undo history. The first argument is the command to clear
# from, the second the one to clear to. The arguments can be omitted,
# in which case they default to "first" and "last." The commands in
# the history are deleted from the one _after_ the "from" mark up
# to _and including_ the "to" mark. (The "first" command is a null
# command, so you don't have to worry about that fact that you cannot
# actually delete it.)
#
# If the "from" mark is not earlier than the "to" mark, there will
# be no error generated, but no commands will be cleared either.
# If either mark does not exist, then an error will be generated.
# Any marks that point to a deleted command will be changed to point
# to the "from" mark. (Any marks that are above the "to" mark still
# point to  the same commands, although the actual index of that
# command will have changed.)
#
# The two indexes can also be raw integer indexes into the history,
# but this is intended for internal use only.
#
body ::tycho::Model::clearHistory {{from first} {to last}} {
    # Get the indexes corresponding to the marks
    if { [string match {[0-9]*} $from] } {
	set fromindex $from
    } else {
	if { ! [info exists historyMark($from)] } {
	    error "Unknown mark $from in $modelname"
	}
	set fromindex $historyMark($from)
    }
    if { [string match {[0-9]*} $to] } {
	set toindex $to
    } else {
	if { ! [info exists historyMark($to)] } {
	    error "Unknown mark $to in $modelname"
	}
	set toindex $historyMark($to)
    }

    # Do nothing if from is not earlier than to
    if { $fromindex >= $toindex } {
	return
    }

    # Clear the commands
    set i [expr $fromindex + 1]
    while { $i <= $toindex } {
	unset undoCommands($i)
	unset redoCommands($i)
	unset _publishable($i)
	incr i
    }

    # Because the history indexes are contiguous, we have to shift
    # any commands above "to" down to fill in the gap left by the
    # deleted commands. (Note: i is already set to "to + 1")
    set delta [expr $toindex - $fromindex] 
    while { $i <= $historyMark(last) } {
	set undoCommands([expr $i - $delta]) $undoCommands($i)
	set redoCommands([expr $i - $delta]) $redoCommands($i)
	set _publishable([expr $i - $delta]) $_publishable($i)

	unset undoCommands($i)
	unset redoCommands($i)
	unset _publishable($i)
	incr i
    }

    # If any marks got clobbered, set them to "from". Any marks
    # above "to" are shifted down the right amount.
    foreach {mark index} [array get historyMark] {
	if { $index > $fromindex && $index < $toindex } {
	    set historyMark($mark) $fromindex
	} elseif { $index >= $toindex } {
	    set historyMark($mark) [expr $index - $delta]
	}
    }
}

########################################################################
#### compactHistory
#
# Compact a portion of the undo history. The first two arguments are the 
# marks of the command to compact from and the command to compact to:
# commands from _the one after_ "from" up to _and including_ "to"
# are compacted into a single command. The third
# argument is a flag indicating whether the compacted command is to
# be marked as publishable: if it is, then an undo or redo of the 
# compacted command will be published. If the
# fourth and fifth arguments are supplied, they are the commands that
# replace the compacted commands; without these commands, this method
# will append the compacted commands.
#
# Any valid marks can be specified -- see clearHistory{} for
# more information. The "from" mark must be earlier than the
# "to" mark: an error will be flagged if it is not.
# If either mark does not exist, then an error will be generated.
#
body ::tycho::Model::compactHistory \
	{from to publish {command {}} {inverse {}}} {

    # Get the indexes corresponding to the marks
    if { [string match {[0-9]*} $from] } {
	set fromindex $from
    } else {
	if { ! [info exists historyMark($from)] } {
	    error "Unknown mark $from in $modelname"
	}
	set fromindex $historyMark($from)
    }
    if { [string match {[0-9]*} $to] } {
	set toindex $to
    } else {
	if { ! [info exists historyMark($to)] } {
	    error "Unknown mark $to in $modelname"
	}
	set toindex   $historyMark($to)
    }

    # Flag an error if from is not earlier than to
    if { $fromindex >= $toindex } {
	error "Cannot compact from $from ($fromindex) to $to ($toindex) in $modelname"
    }

    # Build composite commands if not supplied
    if { $command == "" && [expr $fromindex+1] < $toindex } {
	set i [expr $fromindex + 1]
	set command [list sequence]
	set inverse [list sequence]
	while { $i <= $toindex } {
	    lappend command $redoCommands($i)
	    lappend inverse $undoCommands($i)
	    incr i
	}
	# Put the new command into the history
	set redoCommands($toindex) $command
	set undoCommands($toindex) $inverse
	set _publishable($toindex) $publish
	
	# Clear the compacted commands
	clearHistory $fromindex [expr $toindex - 1]
    }
}

########################################################################
#### compareMarks
#
# Compare two marks, where _operator_ is a relational operator such
# as &amp;. This is most often used to compare a mark withe _current_.
# For example, to test whether the model has been modified since
# it was last saved, execute
# <pre>
#     $model compareMarks current > saved
# </pre>
#
body ::tycho::Model::compareMarks {mark1 operator mark2} {
    if { ! [::info exists historyMark($mark1)] } {
	error "Unknown mark $mark1 in $modelname"
    }
    if { ! [::info exists historyMark($mark2)] } {
	error "Unknown mark $mark2 in $modelname"
    }
    # FIXME: Will this work with the Tcl8.0 byte-compiler?
    expr $historyMark($mark1) $operator $historyMark($mark2)
}

########################################################################
#### configureEntityType
#
# Add or change default attributes of an entity type. The argument list
# consists of attribute-value pairs. For each, if a default
# attribute does not exist, add it; if it does exist, change the
# default value to the given one. Default attributes cannot be
# changed once the model contains entities of that type, so the
# method flags an error if that is the case. The
# special attribute <b>-valued</b> sets the flag
# that states whether an entity has a value; the special attribute
# <b>-ordered</b> sets the flag that states whether instances of
# this type of entity are ordered. This method is not
# undoable or publishable.
# 
body ::tycho::Model::configureEntityType {type args} {
    if { [array names _info [list $type * * *]] != "" } {
	error "Cannot change default attributes of $type: data exists"
    }
    array set temp $_typeinfo($type,defaults)
    array set temp $args
    if { [::info exists temp(-valued)] } {
	set _typeinfo($type,valued) temp(-valued)
	unset temp(-valued)
    }
    if { [::info exists temp(-ordered)] } {
	set _typeinfo($type,ordered) temp(-ordered)
	unset temp(-ordered)
    }
    set _typeinfo($type,defaults) [array get temp]
    return ""
}

########################################################################
#### configureLinkType
#
# Add or change default attributes of a link type. The argument list
# consists of attribute-value pairs. For each, if a default
# attribute does not exist, add it; if it does exist, change the
# default value to the given one. Default attributes cannot be
# changed once the model contains links of that type, so the
# method flags an error if that is the case.  The
# special attribute <b>-named</b> sets the flag
# that states whether an entity has a name; the special attribute
# <b>-order</b> sets the number of entities linked
# by this link type. This method is not undoable or publishable.
#
body ::tycho::Model::configureLinkType {type args} {
    if { [array names _info([list $type * * *])] != "" } {
	error "Cannot change default attributes of $type: data exists"
    }
    array set temp $_typeinfo($type,defaults)
    array set temp $args
    if { [::info exists temp(-named)] } {
	set _typeinfo($type,named) temp(-named)
	unset temp(-named)
    }
    if { [::info exists temp(-order)] } {
	set _typeinfo($type,order) temp(-order)
	unset temp(-order)
    }
    set _typeinfo($type,defaults) [array get temp]
    return ""
}

########################################################################
#### defineEntityType
#
# Add a new type of entity to the model. The first argument
# is the type name of the entity.
# Following arguments are attribute names and their default values.
# The special attribute <b>-valued</b> is a flag that states
# whether an entity has a value (default is zero); the special attribute
# <b>-ordered</b> sets the flag that states whether instances of
# this type of entity are ordered.. This method is not
# undoable or publishable. 
# Flag an error if the given type already exists (either as an
# entity or a link). This method is not undoable or pubishable.
#
body ::tycho::Model::defineEntityType {type args} {
    array set temp {-valued 0 -ordered 0}
    array set temp $args
    set valued $temp(-valued)
    set ordered $temp(-ordered)
    unset temp(-valued)
    unset temp(-ordered)
    _defineentity $type $valued $ordered [array get temp]
    return ""
}

########################################################################
#### defineLinkType
#
# Add a new type of link to the model. The first argument
# is the type name of the link; the second argument is
# zero or one, indicating whether the link has a value;
# the third argument is the number of entities it links.
# Following arguments are option names and their default values.
# The special attributes <b>-named</b> is a flag
# that states whether an entity has a name (default is zero);
# the special entity <b>-order</b> sets the number of entities linked
# by this link type (default is two).
# Flag an error if the given type already exists (either as an
# entity or a link). This method is not undoable or pubishable.
# 
body ::tycho::Model::defineLinkType {type args} {
    array set temp {-named 0 -order 2}
    array set temp $args
    set named  $temp(-named)
    set order $temp(-order)
    unset temp(-named)
    unset temp(-order)
    _definelink $type $named $order $args
}

########################################################################
#### describe
#
# Return a string that describes the model.
# See the <a href="Interchange.html"> Interchange</a> class.
#
body ::tycho::Model::describe {{prefix {}}} {
    _describe $prefix
}

########################################################################
#### describeState
#
# Produce a class-dependent description of the data in a string.
# In the Model class,
# this method produces the undo/redo history. Subclasses should override
# this method and use chain to include the undo history. The second
# argument, if present, can be one of "all," (the default), "nohistory,"
# or "historyonly."
#
# The format of the string must be such that the object can be
# reconstructed by the internalize{} method. Usually, this will mean
# that the object can be loaded by evaluating the string within the
# object context. In general, the string will be a collection of set{}
# and *array set* commands.
#
body ::tycho::Model::describeState {{mode all}} {
    append string "# Tycho model state file for $modelname\n"
    append string "# This file is automatically generated:\n"
    append string "# do not modify it!\n\n"
    
    if { $mode != "nohistory" } {
	append string "# Undo/redo history\n"
	append string "array set undoCommands [list [array get undoCommands]]\n"
	append string "array set redoCommands [list [array get redoCommands]]\n"
	append string "array set _publishable  [list [array get _publishable]]\n"
	append string "array set historyMark  [list [array get historyMark]]\n"
    }
    _describestate
}

########################################################################
#### externalize
#
# Write a class-dependent description of the data to a file.
# The argument is a file descriptor so that this method can be used
# to write a collection of models to a single file. In the Model class,
# this method writes the undo/redo history. Subclasses should override
# this method and use chain to include the undo history. The second
# argument, if present, can be one of "all," (the default), "nohistory,"
# or "historyonly."
#
# The format of the state file must be such that the object can be
# reconstructed by the internalize{} method. Usually, this will mean
# that the object can be loaded by sourcing the file within the
# object context. In general, the file will be a collection of set{}
# and *array set* commands.
#
body ::tycho::Model::externalize {fd {mode all}} {
    puts $fd "# Tycho model state file for $modelname"
    puts $fd "# This file is automatically generated:"
    puts $fd "# do not modify it!\n\n"
    
    if { $mode != "nohistory" } {
	puts $fd "# Undo/redo history\n"
	puts $fd "array set undoCommands [list [array get undoCommands]]\n"
	puts $fd "array set redoCommands [list [array get redoCommands]]\n"
	puts $fd "array set _publishable  [list [array get _publishable]]\n"
	puts $fd "array set historyMark  [list [array get historyMark]]\n"
    }
    _externalize $fd
}

########################################################################
#### internalize
#
# Load a class-dependent description of the data.
# See the <a href="Interchange.html"> Interchange</a> class.
#
body ::tycho::Model::internalize {type data} {
    _internalize $type $data
}

########################################################################
#### load
#
# Load the data from files. With no arguments given, this method
# reads from the most recent of the *-datafile*, *-sourcefile*,
# and *-statefile* options.
# If there are arguments, they are option-value pairs, where the
# valid options are *-datafile*, *-sourcefile*, and *-statefile*,
# and the values are used instead of the options of the object. To
# prevent a file from being read, supply a null value for that option.
#
# Note that none of the *-datafile*, *-sourcefile*, or *-statefile* options
# cause the data to be reloaded when they are changed: this must be done
# explicitly by a) deleting the data and b) calling this method.
# In all cases, a load _adds_ (or overwrites) data already in this
# class, so if a load is intended to give an object all of its data
# then must first be cleared (depending on the particular subclass, this
# may require one or many calls to delete{}). (It would probably just
# be faster to delete the object and create a new one.)
#
# <i>Do not override this method: override read{} and
# internalize{} instead.</i>
#
body ::tycho::Model::load {args} {
    # Override options with args
    set temp(-sourcefile) $sourcefile
    set temp(-datafile) $datafile
    set temp(-statefile) $statefile
    array set temp $args

    # Figure out which is the most recent file.
    set time 0 ;# FIXME: is this reliable???
    set file ""
    set type ""
    foreach {y f} [array get temp] {
	if { $f  != "" } {
	    set f [::tycho::expandPath $f]
	    if { [file exists $f] } {
		set t [file mtime $f]
		if { $t > $time } {
		    set file $f
		    set type $y
		    set time $t
		}
	    }
	}
    }
    if { $file == "" } {
	error "No file found to load"
    }

    # Remember this position
    set historyMark(loaded) $historyMark(current)

    # Load data from the file according to what type of file it
    # is.
    switch -exact /$type {
        "/-sourcefile" {
            # Load the model from the source file. If the -parsescript
            # option is present, execute that to load the file. Otherwise
            # assume that the source file format is the same as the data
            # file format and use read{}.
            if { $parsescript != "" } {
                uplevel #0 [list apply $parsescript $file $this]
            } else {
                read "file" $file
            }
        }
        "/-datafile" {
            # Load the model from the data file
            read "file" $file
        }
        "/-statefile" {
            # Load the model from the state file. If there's an error,
	    # and we're loading the default files, try again with the
	    # datafile.
            if [catch {internalize "file" $file}] {
		if { ! [::info exists temp(-statefile)] } {
		    set savedstatefile $statefile
		    set statefile ""
		    load
		    set statefile $savedstatefile
		}
	    }
        }
    }
    # Notify subscribers that the model has been loaded
    notifyEvent "load"
}

########################################################################
#### mark
#
# Place a mark in the undo history. The first argument is the name of
# the mark to set. The second is the name of the mark to set it to;
# if omitted, it defaults to "current". Models maintain at least 
# the following marks, which can be the second argument to
# this method but not the first:
# <ul>
# <li>*current*: The most recent command executed.
# <li>*root*: The first command in the history.
# <li>*published*: The most recently published command.
# <li>*saved*: The last command before the last save to files.
# <li>*loaded*: The last command before the file was last loaded.
# </ul>
#
# (Note the policy with marking commands: the command marked is the
# last one executed to get to the state represented by the given
# mark. Thus, the "current" command is the most recently-executed
# one: to undo, execute the inverse of that command; to redo,
# re-execute the following command.)
#
# If _position_ is the empty string, delete the mark.
# An error is flagged if _position_ is not empty and not a mark
# in the history. <b>Note</b>: Do not assume that a value of zero
# is the position of the first command in the undo history. Note also that
# mark names are unique: you cannot have more than one mark of the same
# name.
#
# If no arguments at all are supplied, return a list containing the
# names of all marks.
#
# Marks are a powerful and general mechanism for manipulating the undo
# history. For example, if a client wishes to makes a series of
# incremental changes but have the undo mechanism treat all those
# changes as a single change, it can set a mark before the incremental
# changes, and either i) make sure that it calls undo{} and redo{}
# using the marks it has set, or ii) _compact_ the history since that
# mark into a single command (see the compactHistory{} method).
#
body ::tycho::Model::mark {{markname {}} {position current}} {
    # Return all mark names
    if { $markname == "" } {
	return [array names historyMark]
    }

    if { $position == "" } {
	# Delete a mark
	unset historyMark($markname)
    } else {
	if { ! [::info exists historyMark($position)] } {
	    error "Mark $position unknown in $modelname"
	}
	# Set a mark
	set historyMark($markname) $historyMark($position)
    }
}

########################################################################
#### notify
#
# Notify all subscribers of a change in data. This is like
# publish{} in that the command is forwarded to all subscribers.
# Unlike publish{}, however, nothing is executed on the model,
# and nothing is recorded in the undo history.
#
body ::tycho::Model::notify {command index args} {
    eval [list notifyDataChange {} $command $index] $args
}

########################################################################
#### publish
#
# Publish data. This is the same as recording it, except that 
# the change is forwarded to any subscribers (see notify{})
# that have subscribed to the given index.  Normally, the
# execution of the local command returns the inverse command, which
# is recorded together with the command for undo and redo. If the
# local command returns null, then the command is still published but
# is not recorded. This method is intended to be called by
# entities that are _not_ also subscribers to this model; subscribers
# should call the update{} method. The first argument
# is the command to execute on the model; the second the data index,
# and remaining arguments are additional arguments to the command.
#
body ::tycho::Model::publish {command index args} {
    eval [list update {} $command $index] $args
}

########################################################################
#### read
#
# Read data from a data file or from a string.
# See the <a href="Interchange.html">
# Interchange</a> class.
#
body ::tycho::Model::read {type data} {
    _read $type $data
}

########################################################################
#### record
#
# Execute a command on this data object. If the command returns
# a non-null value, the returned value must be a command that
# undoes the command just executed -- the "inverse command."
# The command and inverse command are recorded for undoing.
#
body ::tycho::Model::record {command index args} {
    # Clear the redo future if needed
    if { $historyMark(current) < $historyMark(last) } {
	clearHistory current last
    }

    # Execute the command and remember its result (the undo command).
    # If the command causes an error, this method will abort,
    # and neither the command nor its undo command will be recorded.
    set undo [eval [list $this evalInSpecificContext $command $index] $args]

    # If there was no error and the inverse command is not null,
    # record the command and the inverse command
    if { $undo != "" } {
    	appendHistory \
   	    	[concat [list $command $index] $args] \
	    	$undo \
	    	0
    }

    # Return the inverse command so publish{} knows what happened
    return $undo
}

########################################################################
#### redo
#
# Redo a data change. If an argument is given and it is an integer,
# redo that many steps, or until the end of the redo future is reached.
# If not an integer, the argument must be a mark, and commands are redone
# up to _and including_ the marked command. Flag an error if the mark
# does not exist. If the mark is not later than the current position,
# then do nothing. 
#
# As each command is redone, the change is published if the original
# command was published. 
#
# Return the number of commands redone.
#
body ::tycho::Model::redo {{distance 1}} {
    # If a mark is given, figure out the distance
    if { ! [string match {[0-9]*} $distance] } {
	# Check that the mark exists
	if { ! [::info exists historyMark($distance)] } {
	    error "Unknown mark $distance in $modelname"
	}
	set distance [expr $historyMark($distance) - $historyMark($current)]
    }
    # Go forward only as far as the last command
    if { $distance > $historyMark(last) - $historyMark(current) } {
	set distance [expr $historyMark(last) - $historyMark(current)]
    }

    # Redo the commands
    set count 0
    while { $count < $distance } {
	# Adjust indexes
	incr historyMark(current)
	incr count

	# Execute the command.
	# FIXME: This is in a catch because the command might not exist on
	# this model. Need to figure out better notification mechanism
        # Note that here we reset the "recording" flag, so that
        # any methods that usually write to the history know not to.
        set recording 0
#         if [catch {$this evalInSpecificContext \
#                 eval $redoCommands($historyMark(current))} result] {
#             set recording 1
# 	    puts "Debug: $result"
# 	}
        $this evalInSpecificContext eval $redoCommands($historyMark(current))
        set recording 1

	# Publish if publishable
	if { $_publishable($historyMark(current)) } {
	    eval notifyDataChange noone $redoCommands($historyMark(current))
	}
    }
    # Return the number of commands redone
    return $distance
}

########################################################################
#### save
#
# Write the data to a file. With no arguments given, this method
# writes to both files given by the *-datafile* and *-statefile* options.
# If there are arguments, they are option-value pairs, where the
# valid options are *-datafile* and *-statefile*, and the values
# are used instead of the options of the object. Nothing is
# written if either file is null.
#
# The file given by *-datafile* is written in a "user-editable" form:
# depending on the particular subclass, it may be just plain text,
# or it may be a series of method calls that reconstruct the 
# data. The file given by the *-statefile* option contains information
# in a form the particular subclass finds useful, and
# includes code that "clones" the data object quickly, as 
# well as the undo/redo history of that data. Subscription
# information is _not_ written to the state file.
#
# <i>Do not override this method: override write{} and
# externalize{} instead.</i>
#
body ::tycho::Model::save {args} {
    # Override options with args
    set temp(-datafile) $datafile
    set temp(-statefile) $statefile
    array set temp $args

    # Remember this position
    set historyMark(saved) $historyMark(current)
    
    # Expand file names
    if { $temp(-datafile) != "" } {
	set df [tycho::expandPath $temp(-datafile)]
    } else {
	set df ""
    }
    if { $temp(-statefile) != "" } {
	set sf [tycho::expandPath $temp(-statefile)]
    } else {
	set sf ""
    }
    
    # Open files
    set dd ""
    if { $df != "" } {
	if { ! [file exists $df] || [file writable $df] } {
	    set dd [open $df "w"]
	}
    }
    set sd ""
    if { $sf != "" } {
	if { ! [file exists $sf] || [file writable $sf] } {
	    set sd [open $sf "w"]
	}
    }

    # Write the data file and state file. Note that the state
    # file must be written _after_ the data file if load{}
    # is to work correctly.
    if { $dd != "" } {
	write $dd
	close $dd
    }
    if { $sd != "" } {
	externalize $sd
	close $sd
    }
    # Notify subscribers that the model has been saved
    notifyEvent "save"
}

########################################################################
#### subscribe
#
# Subscribe to data. The first argument is the name of the
# subscriber. The second, if supplied, is the name of the data
# the subscriber wants to be kept informed about. If not supplied,
# the subscriber will be notified of all changes in data. Note
# that some subclasses may not support exact data names, but
# only the "all" keyword. By default, when data
# is updated, the subscriber is notified by calling its notify{}
# method, with the change command and arguments as its arguments.
# If, however, a third argument is given to this method, it is
# taken to be a script to be evaluated instead of directly notifying
# the subscriber.
#
body ::tycho::Model::subscribe {subscriber {name all} {whattodo {}}} {
    set _subscription($subscriber,$name) $whattodo
}

########################################################################
#### subscribeEvent
#
# Subscribe to an event such as loading or saving the model. As for
# subscribing to data, the default notification mechanism is to call
# the subscriber's notify{} method, but this can be overridden by
# supplying a script as the third argument to this method. notify{}
# will only be passed a single argument, being the name of the
# events. The events supported by this class are:
# <ul>
# <li><b>save</b>: The model has been saved.
# <li><b>load</b>: The model has been loaded from disk.
# </ul>
#
# Subclasses may choose to add additional events: the methods of the
# subclass only need to call the protected method notifyEvent{}
# with the event name as an argument.
#
body ::tycho::Model::subscribeEvent {subscriber event {whattodo {}}} {
    set _eventsubscription($subscriber,$event) $whattodo
}

########################################################################
#### undo
#
# Undo a data change. If an argument is given and it is an integer,
# undo that many steps, or until the start of the undo history. If not
# an integer, the argument must be a mark, and commands are undone
# back to _but not including_ the marked command. If the mark is not earlier
# in the history than the current position, do nothing. If the mark
# does not exist, flag an error. 
#
# As each command is undone, the change is published if the original
# command was published. 
#
# Return the number of commands undone.
#
body ::tycho::Model::undo {{distance 1}} {
    # If a mark is given, figure out the distance
    if { ! [string match {[0-9]*} $distance] } {
	# Check that the mark exists
	if { ! [::info exists historyMark($distance)] } {
	    error "Unknown mark $distance in $modelname"
	}
	set distance [expr $historyMark($current) - $historyMark($distance)]
    }

    # Go back only as far as the first command (but don't actually
    # execute the first command, since it is a null command)
    if { $distance > $historyMark(current) - $historyMark(first) } {
	set distance [expr $historyMark(current) - $historyMark(first)]
    }

    # Undo the commands
    set count 0
    while { $count < $distance } {
        # Execute the command
	# FIXME: This is in a catch because the command might not exist on
	# this model. Need to figure out better notification mechanism
        # Note that here we reset the "recording" flag, so that
        # any methods that usually write to the history know not to.
        set recording 0
#         if [catch {$this evalInSpecificContext \
#                 eval $undoCommands($historyMark(current))} result] {
# 	    puts "Debug: $result"
# 	}
        $this evalInSpecificContext eval $undoCommands($historyMark(current))
        set recording 1

        # Publish if publishable
        if { $_publishable($historyMark(current)) } {
            eval notifyDataChange noone $undoCommands($historyMark(current))
        }
        # Adjust indexes
        incr historyMark(current) -1
        incr count
    }

    # Return the number of commands undone
    return $distance
}

########################################################################
#### unsubscribe
#
# Unsubscribe from data at a given index. The subscriber is 
# removed from the subscription list for that index. Note that 
# the index must exactly match an index given to
# the subscribe{} method: it cannot be used to implement
# an exclusion mechanism (one cannot, for example, say "I have
# already subscribed to all character insertions, and I want
# to unsubscribe from all insertions of carriage returns").
#
# If the _pattern_ argument is not supplied, the subscriber is
# unsubscribed from all patterns it has subscribed to.
#
body ::tycho::Model::unsubscribe {subscriber {pattern {}}} {
    if { $pattern != "" } {
	# Unsubscribe from a given pattern
	catch {unset _subscription($subscriber,$pattern)}
    } else {
	# Unsubscribe from all patterns
	foreach index [array names _subscription $subscriber,*] {
	    unset _subscription($index)
	}
    }
}

########################################################################
#### update
#
# Update data. This is the same as recording it, except that 
# the change is forwarded to subscribers (other than the caller)
# that have subscribed to the given index. Normally, the
# execution of the local command returns the inverse command, which
# is recorded together with the command for undo and redo. If the
# local command returns null, then the command is still published but
# is not recorded. The change is forwarded
# by the notify{} method, which can be overridden to change the
# notification behaviour. This method is designed to be called by
# subscribers to the model: the first argument is the name of the
# subscriber that is performing the update, and is used to prevent
# the model from updating the caller. To cause a data update from
# a non-subscriber, call the publish{} method. The second argument
# is the command to execute on the model; the third the data index,
# and remaining arguments are additional arguments to the command.
#
body ::tycho::Model::update {subscriber command index args} {
    # Record the command
    set undo [eval [list record $command $index] $args]

    # Some actions only occur if the command did not return null
    if { $undo != "" } {
        # Mark command as publishable
        set _publishable($historyMark(current)) 1
        
        # Remember where it happened
        set historyMark(published) $historyMark(current)
    }
    # Notify subscribers.
    eval [list notifyDataChange $subscriber $command $index] $args
}

########################################################################
#### write
#
# Write data to a data file. See the <a href="Interchange.html">
# Interchange</a> class.
#
body ::tycho::Model::write {fd {prefix {}}} {
    _write $fd $prefix
}

########################################################################
########################################################################
####                       protected methods                        ####

########################################################################
#### _dataname
#
# Return a name to use in printing error messages and the 
# like. Returns the *-modelname* option.
#
body ::tycho::Model::_dataname {} {
    return $modelname
}    

########################################################################
#### notifyDataChange
#
# Notify subscribers except _subscriber_ with the given change in data.
# This method searches for all subscribers that have subscribed to
# the given data, and either calls their notify{} method,
# or, if a script was supplied when the subscriber subscribed (as
# the *whattodo* argument), evaluates that script in the global context.
#
# Although subscribers are supposed to unsubscribe themselves before
# dying, this doesn't always happen (especially when debugging!).
# So, this method checks that the subscriber still exists, and if
# it doesn't, unsubscribes the offending subscriber.
#
# As a special case, if the command name is "sequence," all following
# arguments are assumed to be individual commands, and subscribers
# are notified of each such command.
#
body ::tycho::Model::notifyDataChange {subscriber command index args} {

    # Test for the command "sequence", and recursively call if so
    if { $command == "sequence" } {
	eval notifyDataChange $subscriber $index
	foreach cmd $args {
	    eval notifyDataChange $subscriber $cmd
	}
	return
    }
    # The subscribers to notify
    set subscribers {}

    # Get subscribers to "all"
    foreach subindex [array names _subscription *,all] {
	lappend subscribers [lindex [split $subindex ","] 0] \
		$index $_subscription($subindex)
    }

    # Get subscribers with a matching index
    foreach subindex [array names _subscription *,$index] {
	eval lappend subscribers [split $subindex ","] \
		[list $_subscription($subindex)]
    }

    # Process each subscriber
    foreach {sub index script} $subscribers {
	# Don't notify the caller
	if { $sub != "" && $sub == $subscriber } {
	    continue
	}
	# Unsubscribe the subscriber if it no longer exists!
	if { $sub != "" && [::info which -command $sub] == "" } {
	    unsubscribe $sub
	    continue
	}
	if { $script != "" } {
	    # if there's a script supplied by the subscriber, evaluate it
	    uplevel \#0 $script
	} else {
	    # By default, call the subscriber's notify{} method
	    uplevel \#0 $sub notify $command [list $index] $args
	}
    }
}

########################################################################
#### notifyEvent
#
# Notify all subscribers of an event. This method searches for all
# subscribers that have subscribed to the given event, and either`
# calls their notify{} method, or, if a script was supplied when
# the subscriber subscribed (as the *whattodo* argument), evaluates
# that script in the global context.
#
# Although subscribers are supposed to unsubscribe themselves before
# dying, this doesn't always happen (especially when debugging!).
# So, this method checks that the subscriber still exists, and if
# it doesn't, unsubscribes the offending subscriber.
#
body ::tycho::Model::notifyEvent {event} {
    # The subscribers to notify
    set subscribers {}

    # Get subscribers with a matching index
    foreach subindex [array names _eventsubscription *,$event] {
	eval lappend subscribers [split $subindex ","] \
                [list $_eventsubscription($subindex)]
    }

    # Process each subscriber
    foreach {sub index script} $subscribers {
	# Unsubscribe the subscriber if it no longer exists!
	if { $sub != "" && [::info which -command $sub] == "" } {
	    unsubscribe $sub
	    continue
	}
	if { $script != "" } {
	    # if there's a script supplied by the subscriber, evaluate it
	    uplevel \#0 $script
	} else {
	    # By default, call the subscriber's notify{} method
	    uplevel \#0 $sub notify $event
	}
    }
}

########################################################################
#### sequence
#
# Execute a sequence of commands and return the inverse command.
# Each argument is a single command. This method's main purpose is
# for constructing complex commands for the undo and redo history.
#
body ::tycho::Model::sequence {args} {
    set inverse [list sequence]
    foreach cmd $args {
        lappend inverse [$this evalInSpecificContext eval $cmd]
    }
    return $inverse
}
