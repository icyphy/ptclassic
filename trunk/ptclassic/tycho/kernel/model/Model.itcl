##########################################################################
# Version: $Id$
# Author: John Reekie, Edward A. Lee
#
# Copyright (c) 1996-1997 The Regents of the University of California.
#  rights reserved.
# 
# Permission is hereby granted, without written agreement and without
# license or royalty fees, to use, copy, modify, and distribute this
# software and its documentation for any purpose, provided that the above
# copyright notice and the following two paragraphs appear in all copies
# of this software.
# 
# IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY
# FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
# ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF
# THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.
# 
# THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE
# PROVIDED HEREUNDER IS ON AN "AS IS" BASIS, AND THE UNIVERSITY OF
# CALIFORNIA HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,
# ENHANCEMENTS, OR MODIFICATIONS.
#                                                         COPYRIGHTENDKEY
##########################################################################


##########################################################################
#### Model
#
# This class is the abstract superclass of Tycho's implementation of the 
# _model_ component of the model-view user interface architecture.  The 
# model-view architecture is a derivation of the well-known 
# model-view-controller architecture developed as part of Smalltalk.
# The model-view derivation combines 
# MVC's view and controller into a single abstraction -- the key forces 
# driving this change are the increased control functionality provided 
# these days by widgets in UI frameworks (including Tk) and the increased 
# amount of direct manipulation and feedback, which makes the 
# functionality of the view and controller more tightly coupled -- 
# see the book _Designing Object-oriented User Interfaces_, Dave Collins,
# 1995.
#
# The _Model_ class is subclassed to provide application-specific (or 
# application-related, at least), information models.  (The corresponding 
# view class in Tycho is named _View_.) This abstract superclass supports 
# multiple views using the ``publish-and-subscribe'' design pattern (known 
# as the ``Observer'' pattern in books such as Gamma _et al's_ `Design 
# Patterns.'' It also incorporates two additional factors not essential 
# to, but very useful to, the model abstraction: standard data
# interchange formats, persistence and a command history.
#
# Multiple views can _subscribe_ to the same model -- when any view 
# changes the data in the model, the other subscribed views are notified 
# of the change.  (Note: I use ``notify'' instead of ``update'' to 
# avoid possible confusion with Tk's update{} procedure.) The notification 
# model is what is known as the ``push'' model: when data is changed, the 
# subscribers are informed of the type of the change _and_ the changed 
# data.  When a view subscribes, it specified a value that is used to
# decide when to notify the view. Views can subscribe to all changes,
# changes to a single item of data, or changes that match a pattern.
#
# A model has three file-related options *-sourcefile*, 
# *-datafile*, and *-statefile*.  These are all file names, and any may be 
# used, depending on the subclass and the particular application.  The 
# "sourcefile" is a file containing information needed to build the data and 
# is never modified by the data object; the "datafile" is a file containing 
# the same information, but can be written by the data object: it is thus 
# the same as the usual *-file* option to the Tycho editors; the "statefile" 
# is a file containing the data in a form that can be rapidly 
# reconstructed by the data object.  The state is a simple Tcl 
# implementation of the ``Memento'' design pattern (Gamma _et al_).
#
# A key aspect of a user interface that encourages user interaction and 
# exploration is the ability to ``undo'' any operation.  This class 
# implements a reasonably flexible, unbounded, undo and redo 
# mechanism, so that any change to a model can be undone and redone.  The 
# undo history implemented by this class is linear -- an interesting 
# extension of the history mechanism is to make it tree-structured, for 
# applications such as design exploration, where a designer may want to 
# try out a number of different design paths and "milestone" significant 
# designs in a tree or forest of alternative designs.
#
# <i>(Edward has pointed out the relation between persistence, undo, 
# and version control. We need to work out a good abstraction for
# these mechanisms.)</i>
#
# <i>(A tree-structured</i> undo facility would be very interesting
# to explore. This would be easier to implement if we split the
# history facilities of this class into a separate class -- this
# would make it an instance of the ``CommandServer'' pattern of
# Buschmann et al's _A System of Patterns_.)
#
# A model generally contains six groups of methods:
#
# <ul>
# <li>Change commands: add{}, replace{}, dataconfigure{}, delete{}, 
#     execute{}, and so on.
#     These are the commands that are available for undo/redo
#     and publishing. Suggested commands are :
#    
#     <ul>
#     <li>*add* _name_ _data_ _args_: Add new data with the given name.
#          Some subclasses may not allow this operation if data already
#          exists at the given index, while others will just insert
#          additional data at that index. If the data subclass accepts
#          data options, then following arguments are option values.
#  		   The method is often named for the type of data: _entry_,
#		   _vertex_, _edge_, and so on.
#     <li>*assign* _index_ _data_: Assign a new value to the data at the
# 	 	   given index. Some subclasses may not allow this operation
#          if data does not exist at the given index; others will.
#     <li>*create* _index_ _args_: Create some kind of data with the given
#          index, where the additional arguments describe how to create
#          the data. This method is appropriate for models of graphical
#          diagrams. <i>See note below regarding returned values.</i>
#     <li>*dataconfigure* _index_ ?_option_? ?_value_? ...: Configure
#          options of
#          data at the given index. This method is appropriate in any 
#          model in which some data can be given additional attributes.
#          It is often renamed according to the model: entryconfigure{},
#          itemconfigure{}, textconfigure{}, and so on.
#     <li>*delete* _index_: Delete data at the given index.
#     </ul>
#
#     Every data change command 
#     must return an _inverse_ command -- that is, a command that can be 
#     executed (in the scope of the model object) to undo the change.
#     Some commands may choose to return the null string if the command
#     failed.    
#     <b>Note</b>: Commands such as create{} cannot return a new 
#     identifier, since they must return an inverse command. This shifts
#     the onus onto the client to provide names for new graphical objects
#     (for example), but is not difficult (after all, that's what Tk
#     widgets require).
#    
# <li>Access commands: These comands get values of the data. Examples
#     might include get{}, match{}, names{}. These must be implemented
#     by subclasses. Most will define a 
#     function called datacget{} or something similar, which can be used
#     to access configuration options of data.
#    
# <li>File commands: load{}, save{}, internalize{}, externalize{},
#     read{}, write{}, describe{}. load{} and save{} must never be overridden; 
#     the others usually are.
#    
# <li>Publish-subscribe commands: subscribe{}, unsubscribe{}, publish{},
#     and update{}.
#     None of these must ever be overridden (except in special
#     circumstances, such as the _Publisher_ and _WidgetPreferences_ 
#     classes).
#   
# <li>Undo-redo commands: record{}, undo{}, redo{}, mark{},
#     clearHistory{}, and 
#     compactHistory{}. These commands manipulate the undo history in various
#     ways. None of these must ever be overridden (except in special
#     circumstances, such as the _Publisher_ and _WidgetPreferences_ 
#     classes).
# </ul>
#
class ::tycho::Model {
    inherit ::tycho::Object ::tycho::Interchange

    constructor {args} {}
    destructor {}
    
    #################################################################
    ####                        options                          ####

    # The name of this model
    public variable modelname ""

    # The file that this data is based on
    public variable datafile {}

    # How to match when looking for subscribers to notify. Can be
    # "exact," "glob", "regexp"
    public variable notifymode "exact"

    # A script that changes the default notification mechanism
    public variable notifyscript {}

    # A script saying how to parse data from a "source" file
    public variable parsescript {}

    # The separator character for hierarchical models. If 
    # null, do not execute code that assumes hierarchy.
    public variable separator "."

    # The immutable file that this data is based on
    public variable sourcefile {}

    # The file used for storing this data
    public variable statefile {}

    # If true, options are checked, otherwise any are allowed
    public variable strictoptions 1

    #################################################################
    ####                     public methods                      ####

    # Clear the undo history
    method clearHistory {args}
    
    # Compact a portion of the undo history
    method compactHistory {from to publish {command {}} {inverse {}}}
    
    # Compare two marks
    method compareMarks {mark1 operator mark2}

    # Add or change default attributes of an entity type
    method configureEntity {type args}
    
    # Add or change default attributes of a link type
    method configureLink {type args}
    
    # Describe the data in the model in TIM
    method describe {{prefix {}}}

    # Add a new type of entity to the model
    method defineEntity {type args}
    
    # Add a new type of link to the model
    method defineLink {type vcount acount args}
    
    # Externalize the model into a state file
    method externalize {fd {mode all}}
    
    # Add to the model from a state file or a string
    method internalize {type data}
    
    # Load data into the object
    method load {args}

    # Get or set a mark in the undo history
    method mark {{markname {}} {position current}}

    # Publish a change in data
    method publish {command index args}

    # Read data into the model
    method read {type data}
    
    # Record a change in data
    method record {command index args}

    # Redo changes to the data
    method redo {{distance 1}}

    # Write the model to its files
    method save {args}

    # Subscribe to data changes that match an index pattern
    method subscribe {subscriber pattern {whattodo {}}}

    # Undo changes to the data
    method undo {{distance 1}}

    # Unsubscribe from data changes
    method unsubscribe {subscriber {pattern {}}}

    # Update the model with a change in data
    method update {subscriber command index args}

    # Write the model to a file in TIM format
    method write {fd {prefix {}}}
    
    #################################################################
    ####                  protected methods                      ####

    # Notify the subscribers of a change in data
    protected method notify {subscriber command pattern args}

    # Return the "name" to print in error messages
    protected method _dataname {}
    
    #################################################################
    ####                  protected variables                    ####

    # The marks in the redo/undo history
    protected variable historyMark
    
    # The array of flags indicating whether an undo/redo command
    # was published
    protected variable publishable
    
    # The array of subscriptions. Each array index is a pair of
    # the subscriber and the pattern and the value is the notify
    # script (if any).
    protected variable subscriptions
    
    # The array of redo commands
    protected variable redoCommands

    # The array of undo commands
    protected variable undoCommands

    #################################################################
    ####                   private methods                       ####
    
    # Evaluate code in this object's context
    private method evalInSpecificContext {args} {eval $args}

    method debug {args} {
	eval $args
    }
}


#########################################################################
#### -strictoptions configuration
# This option provides external access to the _strictoptions variable
# in the _Interchange_ superclass, which controls whether
# options are checked for validity.
#
configbody ::tycho::Model::strictoptions {
    set _strictoptions $strictoptions
}

#########################################################################
#### -separator configuration
# This option provides external access to the _separator variable
# in the _Interchange_ superclass, which specifies the separator
# character used to separator hierarchy levels. It is null if the
# model does not support hierarchy. The separator cannot be changed
# if the model already contains data.
#
configbody ::tycho::Model::separator {
    if { [array names _info] != "" } {
	error "Model $modelname already contains data"
    }
    set _separator $separator
}

########################################################################
#### constructor
#
body ::tycho::Model::constructor {args} {
    # Initialize history marks
    set historyMark(current) 0
    set historyMark(first) 0
    set historyMark(last) 0
    set historyMark(loaded) 0
    set historyMark(published) 0
    set historyMark(saved) 0

    # Initialize the first node of the history
    set undoCommands(0) {}
    set redoCommands(0) {}
    set publishable(0) 0

    # Evaluate options
    eval configure $args

    # If there is no modelname, supply a default
    if { $modelname == "" } {
	set modelname [::info namespace tail $this]
    }
}

########################################################################
#### clearHistory
#
# Clear the undo history. The first argument is the command to clear
# from, the second the one to clear to. The arguments can be omitted,
# in which case they default to "first" and "last." The commands in
# the history are deleted from the one _after_ the "from" mark up
# to _and including_ the "to" mark. (The "first" command is a null
# command, so you don't have to worry about that fact that you cannot
# actually delete it.)
#
# If the "from" mark is not earlier than the "to" mark, there will
# be no error generated, but no commands will be cleared either.
# If either mark does not exist, then an error will be generated.
# Any marks that point to a deleted command will be changed to point
# to the "from" mark. (Any marks that are above the "to" mark still
# point to  the same commands, although the actual index of that
# command will have changed.)
#
# The two indexes can also be raw integer indexes into the history,
# but this is intended for internal use only.
#
body ::tycho::Model::clearHistory {{from first} {to last}} {
    # Get the indexes corresponding to the marks
    if { ! [info exists historyMark($from)] } {
	error "Unknown mark $from in $modelname"
    }
    if { ! [info exists historyMark($to)] } {
	error "Unknown mark $to in $modelname"
    }
    if { ! [string match {[0-9]*} $from] } {
	set fromindex $historyMark($from)
    } else {
	set fromindex $from
    }
    if { ! [string match {[0-9]*} $to] } {
	set toindex $historyMark($to)
    } else {
	set toindex $to
    }

    # Do nothing if from is not earlier than to
    if { $fromindex >= $toindex } {
	return
    }

    # Clear the commands
    set i [expr $fromindex + 1]
    while { $i <= $toindex } {
	unset undoCommands($i)
	unset redoCommands($i)
	unset publishable($i)
	incr i
    }

    # Because the history indexes are contiguous, we have to shift
    # any commands above "to" down to fill in the gap left by the
    # deleted commands. (Note: i is already set to "to + 1")
    set delta [expr $toindex - $fromindex] 
    while { $i <= $historyMark(last) } {
	set undoCommands([expr $i - $delta]) $undoCommands($i)
	set redoCommands([expr $i - $delta]) $redoCommands($i)
	set publishable([expr $i - $delta]) $publishable($i)

	unset undoCommands($i)
	unset redoCommands($i)
	unset publishable($i)
	incr i
    }

    # If any marks got clobbered, set them to "from". Any marks
    # above "to" are shifted down the right amount.
    foreach {mark index} [array get historyMark] {
	if { $index > $fromindex || $index <= $toindex } {
	    set historyMark($mark) $fromindex
	} elseif { $index > $toindex } {
	    set historyMark($mark) [expr $index - $delta]
	}
    }
}

########################################################################
#### compactHistory
#
# Compact a portion of the undo history. The first two arguments are the 
# marks of the command to compact from and the command to compact to: commands
# from _the one after_ "from" up to _and including_ "to" are compacted
# into a single command. The third
# argument is a flag indicating whether the compacted command is to
# be marked as publishable: if it is, then an undo or redo of the 
# compacted command will be published. If the
# fourth and fifth arguments are supplied, they are the commands that
# replace the compacted commands; without these commands, this method
# will append the compacted commands.
#
# Any valid marks can be specified -- see clearHistory{} for
# more information. The "from" mark must be earlier than the
# "to" mark: an error will be flagged if it is not.
# If either mark does not exist, then an error will be generated.
#
body ::tycho::Model::compactHistory \
	{from to publish {command {}} {inverse {}}} {

    # Get the indexes corresponding to the marks
    if { ! [info exists historyMark($from)] } {
	error "Unknown mark $from in $modelname"
    }
    if { ! [info exists historyMark($to)] } {
	error "Unknown mark $to in $modelname"
    }
    set fromindex $historyMark($from)
    set toindex   $historyMark($to)

    # Flag an error if from is not earlier than to
    if { $fromindex >= $toindex } {
	error "Cannot compact from $from ($fromindex) to $to ($toindex) in $modelname"
    }
    
    # Build composite commands if not supplied
    if { $command == "" } {
	set i [expr $fromindex + 1]
	while { $i <= $toindex } {
	    append command "    " redoCommands($i) "\n"
	    append inverse "    " undoCommands($i) "\n"
	}
    }

    # Put the new command into the history
    set redoCommands($toindex) $command
    set undoCommands($toindex) $inverse
    set publishable($toindex) $publish

    # Clear the compacted commands
    clearHistory $from [expr $toindex - 1]
}

########################################################################
#### compareMarks
#
# Compare two marks, where _operator_ is a relational operator such
# as &amp;. This is most often used to compare a mark withe _current_.
# For example, to test whether the model has been modified since
# it was last saved, execute
# <pre>
#     $model compareMarks current > saved
# </pre>
#
body ::tycho::Model::compareMarks {mark1 operator mark2} {
    if { ! [::info exists historyMark($mark1)] } {
	error "Unknown mark $mark1 in $modelname"
    }
    if { ! [::info exists historyMark($mark2)] } {
	error "Unknown mark $mark2 in $modelname"
    }
    # FIXME: Will this work with the Tcl8.0 byte-compiler?
    expr $historyMark($mark1) $operator $historyMark($mark2)
}

########################################################################
#### configureEntity
#
# Add or change default attributes of an entity type. The argument list
# consists of attribute-value pairs. For each, if a default
# attribute does not exist, add it; if it does exist, change the
# default value to the given one. Default attributes cannot be
# changed once the model contains entities of that type, so the
# method flags an error if that is the case. The
# "special" attribute <b>-valued</b> can be used to change the flag
# that states whether an entity has a value. This method is not
# undoable or publishable.
# 
body ::tycho::Model::configureEntity {type args} {
    if { [array names _info [list $type * * *]] != "" } {
	error "Cannot change default attributes of $type: data exists"
    }
    array set temp $_typeinfo($type,defaults)
    array set temp $args
    if { [::info exists temp(-valued)] } {
	set _typeinfo($type,valued) temp(-valued)
	unset temp(-valued)
    }
    set _typeinfo($type,defaults) [array get temp]
    return ""
}

########################################################################
#### configureLink
#
# Add or change default attributes of a link type. The argument list
# consists of attribute-value pairs. For each, if a default
# attribute does not exist, add it; if it does exist, change the
# default value to the given one. Default attributes cannot be
# changed once the model contains links of that type, so the
# method flags an error if that is the case.  The
# "special" attributes <b>-named</b> can be used to change the flag
# that states whether an entity has a name, and the special entity
# <b>-lcount</b> can be used to change the number of entities linked
# by this link type. This method is not undoable or publishable.
#
body ::tycho::Model::configureLink {type vcount acount args} {
    if { [array names _info([list $type * * *])] != "" } {
	error "Cannot change default attributes of $type: data exists"
    }
    array set temp $_typeinfo($type,defaults)
    array set temp $args
    if { [::info exists temp(-named)] } {
	set _typeinfo($type,named) temp(-named)
	unset temp(-named)
    }
    if { [::info exists temp(-lcount)] } {
	set _typeinfo($type,lcount) temp(-lcount)
	unset temp(-lcount)
    }
    set _typeinfo($type,defaults) [array get temp]
    return ""
}

########################################################################
#### describe
#
# Return a string that describes the model.
# See the <a href="Interchange.html"> Interchange</a> class.
#
body ::tycho::Model::describe {{prefix {}}} {
    _describe $prefix
}

########################################################################
#### defineEntity
#
# Add a new type of entity to the model. The first argument
# is the type name of the entity.
# Following arguments are attribute names and their default values.
#  The "special" attribute <b>-valued</b> is a flag that states
# whether an entity has a value (default is zero). This method is not
# undoable or publishable. 
# Flag an error if the given type already exists (either as an
# entity or a link). This method is not undoable or pubishable.
#
body ::tycho::Model::defineEntity {type args} {
    array set temp {-valued 0}
    array set temp $args
    set valued $temp(-valued)
    unset temp(-valued)
    _defineentity $type $valued [array get temp]
    return ""
}

########################################################################
#### defineLink
#
# Add a new type of link to the model. The first argument
# is the type name of the link; the second argument is
# zero or one, indicating whether the link has a value;
# the third argument is the number of entities it links.
# Following arguments are option names and their default values.
# The "special" attributes <b>-named</b> is a flag
# that states whether an entity has a name (default is zero),
# and the special entity
# <b>-lcount</b> sets the number of entities linked
# by this link type (default is two).
# Flag an error if the given type already exists (either as an
# entity or a link). This method is not undoable or pubishable.
# 
body ::tycho::Model::defineLink {type vcount acount args} {
    array set temp {-named 0 -lcount 2}
    array set temp $args
    set named  $temp(-named)
    set lcount $temp(-lcount)
    unset temp(-named)
    unset temp(-lcount)
    _definelink $type $named $lcount $args
}

########################################################################
#### externalize
#
# Write a class-dependent description of the data to a file.
# The argument is a file descriptor so that this method can be used
# to write a collection of models to a single file. In the Model class,
# this method writes the undo/redo history. Subclasses should override
# this method and use chain to include the undo history. The second
# argument, if present, cen be one of "all," (the default), "nohistory,"
# or "historyonly."
#
# The format of the state file must be such that the object can be
# reconstructed by the internalize{} method. Usually, this will mean
# that the object can be loaded by sourcing the file within the
# object context. In general, the file will be a collection of set{}
# and *array set* commands.
#
body ::tycho::Model::externalize {fd {mode all}} {
    puts $fd "# Tycho model state file for $modelname"
    puts $fd "# This file is automatically generated:"
    puts $fd "# do not modify it!\n\n"
    
    if { $mode != "nohistory" } {
	puts $fd "# Undo/redo history\n"
	puts $fd "array set undoCommands [list [array get undoCommands]]\n"
	puts $fd "array set redoCommands [list [array get redoCommands]]\n"
	puts $fd "array set publishable  [list [array get publishable]]\n"
	puts $fd "array set historyMark  [list [array get historyMark]]\n"
    }
    _externalize $fd
}

########################################################################
#### internalize
#
# Load a class-dependent description of the data.
# See the <a href="Interchange.html"> Interchange</a> class.
#
body ::tycho::Model::internalize {type data} {
    _internalize $type $data
}

########################################################################
#### load
#
# Load the data from files. With no arguments given, this method
# reads from the most recent of the *-datafile*, *-sourcefile*,
# and *-statefile* options.
# If there are arguments, they are option-value pairs, where the
# valid options are *-datafile*, *-sourcefile*, and *-statefile*,
# and the values are used instead of the options of the object. To
# prevent a file from being read, supply a null value for that option.
#
# Note that none of the *-datafile*, *-sourcefile*, or *-statefile* options
# cause the data to be reloaded when they are changed: this must be done
# explicitly by a) deleting the data and b) calling this method.
# In all cases, a load _adds_ (or overwrites) data already in this
# class, so if a load is intended to give an object all of its data
# then must first be cleared (depending on the particular subclass, this
# may require one or many calls to delete{}). (It would probably just
# be faster to delete the object and create a new one.)
#
# <i>Do not override this method: override read{} and
# internalize{} instead.</i>
#
body ::tycho::Model::load {args} {
    # Override options with args
    set temp(-sourcefile) $sourcefile
    set temp(-datafile) $datafile
    set temp(-statefile) $statefile
    array set temp $args

    # Figure out which is the most recent file.
    set time 0 ;# FIXME: is this reliable???
    set file ""
    set type ""
    foreach {y f} [array get temp] {
	if { $f  != "" } {
	    set f [::tycho::expandPath $f]
	    if { [file exists $f] } {
		set t [file mtime $f]
		if { $t > $time } {
		    set file $f
		    set type $y
		    set time $t
		}
	    }
	}
    }
    if { $file == "" } {
	error "No file found to load"
    }

    # Remember this position
    set historyMark(loaded) $historyMark(current)

    # Load data from the file according to what type of file it
    # is.
    switch -exact /$type {
        "/-sourcefile" {
            # Load the model from the source file. If the -parsescript
            # option is present, execute that to load the file. Otherwise
            # assume that the source file format is the same as the data
            # file format and use read{}.
            if { $parsescript != "" } {
                uplevel #0 [list apply $parsescript $file $this]
            } else {
                read "file" $file
            }
        }
        "/-datafile" {
            # Load the model from the data file
            read "file" $file
        }
        "/-statefile" {
            # Load the model from the state file. If there's an error,
	    # and we're loading the default files, try again with the
	    # datafile.
            if [catch {internalize "file" $file}] {
		if { ! [::info exists temp(-statefile)] } {
		    set savedstatefile $statefile
		    set statefile ""
		    load
		    set statefile $savedstatefile
		}
	    }
        }
    }
}

########################################################################
#### mark
#
# Place a mark in the undo history. The first argument is the name of
# the mark to set. The second is the name of the mark to set it to;
# if omitted, it defaults to "current". Models maintain at least 
# the following marks, which can be the second argument to
# this method but not the first:
# <ul>
# <li>*current*: The most recent command executed.
# <li>*root*: The first command in the history.
# <li>*published*: The most recently published command.
# <li>*saved*: The last command before the last save to files.
# <li>*loaded*: The last command before the file was last loaded.
# </ul>
#
# (Note the policy with marking commands: the command marked is the
# last one executed to get to the state represented by the given
# mark. Thus, the "current" command is the most recently-executed
# one: to undo, execute the inverse of that command; to redo,
# re-execute the following command.)
#
# If _position_ is the empty string, delete the mark.
# An error is flagged if _position_ is not empty and not a mark
# in the history. <b>Note</b>: Do not assume that a value of zero
# is the position of the first command in the undo history. Note also that
# mark names are unique: you cannot have more than one mark of the same
# name.
#
# If no arguments at all are supplied, return a list containing the
# names of all marks.
#
# Marks are a powerful and general mechanism for manipulating the undo
# history. For example, if a client wishes to makes a series of
# incremental changes but have the undo mechanism treat all those
# changes as a single change, it can set a mark before the incremental
# changes, and either i) make sure that it calls undo{} and redo{}
# using the marks it has set, or ii) _compact_ the history since that
# mark into a single command (see the compactHistory{} method).
#
body ::tycho::Model::mark {{markname {}} {position current}} {
    # Return all mark names
    if { $markname == "" } {
	return [array names historyMark]
    }

    if { $position == "" } {
	# Delete a mark
	unset historyMark($markname)
    } else {
	if { ! [::info exists historyMark($position)] } {
	    error "Mark $position unknown in $modelname"
	}
	# Set a mark
	set historyMark($mark) $historyMark($position)
    }
}

########################################################################
#### publish
#
# Publish data. This is the same as recording it, except that 
# the change is forwarded to any subscribers (see notify{})
# that have subscribed to the given index. The change is forwarded
# by the notify{} method, which can be overridden to change the
# notification behaviour. This method is designed to be called by
# entities that are _not_ also subscribers to this model; subscribers
# must call the update{} method. The first argument
# is the command to execute on the model; the second the data index,
# and remaining arguments are additional arguments to the command.
#
body ::tycho::Model::publish {command index args} {
    eval [list update {} $command $index] $args
}

########################################################################
#### read
#
# Read data from a data file or from a string.
# See the <a href="Interchange.html">
# Interchange</a> class.
#
body ::tycho::Model::read {type data} {
    _read $type $data
}

########################################################################
#### record
#
# Execute a command on this data object and record the command and
# its inverse for undoing.
#
body ::tycho::Model::record {command index args} {
    # Clear the redo future if needed
    if { $historyMark(current) < $historyMark(last) } {
	clearHistory current last
    }

    # Execute the command and remember its result (the undo command).
    # If the command causes an error, this method will abort,
    # and neither the command nor its undo command will be recorded.
    set undo [eval [list $this $command $index] $args]

    # If there was no error, proceed to record the command
    incr historyMark(current)
    incr historyMark(last)
    set redoCommands($historyMark(current)) \
	    [concat [list $command $index] $args]
    set publishable($historyMark(current)) 0

    # Record the undo command
    set undoCommands($historyMark(current)) $undo

    # Mark the command as not publishable
    set publishable($historyMark(current)) 0
}

########################################################################
#### redo
#
# Redo a data change. If an argument is given and it is an integer,
# redo that many steps, or until the end of the redo future is reached.
# If not an integer, the argument must be a mark, and commands are redone
# up to _and including_ the marked command. Flag an error if the mark
# does not exist. If the mark is not later than the current position,
# then do nothing. 
#
# As each command is redone, the change is published if the original
# command was published. 
#
# Return the number of commands redone.
#
body ::tycho::Model::redo {{distance 1}} {
    # If a mark is given, figure out the distance
    if { ! [string match {[0-9]*} $distance] } {
	# Check that the mark exists
	if { ! [::info exists historyMark($distance)] } {
	    error "Unknown mark $distance in $modelname"
	}
	set distance [expr $historyMark($distance) - $historyMark($current)]
    }
    # Go forward only as far as the last command
    if { $distance > $historyMark(last) - $historyMark(current) } {
	set distance [expr $historyMark(last) - $historyMark(current)]
    }

    # Redo the commands
    set count 0
    while { $count < $distance } {
	# Adjust indexes
	incr historyMark(current)
	incr count

	# Execute the command
	# FIXME: This should do a catch?
	@scope [info class] [list \
		$this [info class]::evalInSpecificContext \
		eval $redoCommands($historyMark(current))]

	# Publish if publishable
	if { $publishable($historyMark(current)) } {
	    eval notify noone $redoCommands($historyMark(current))
	}
    }

    # Return the number of commands redone
    return $distance
}

########################################################################
#### save
#
# Write the data to a file. With no arguments given, this method
# writes to both files given by the *-datafile* and *-statefile* options.
# If there are arguments, they are option-value pairs, where the
# valid options are *-datafile* and *-statefile*, and the values
# are used instead of the options of the object. Nothing is
# written if either file is null.
#
# The file given by *-datafile* is written in a "user-editable" form:
# depending on the particular subclass, it may be just plain text,
# or it may be a series of method calls that reconstruct the 
# data. The file given by the *-statefile* option contains information
# in a form the particular subclass finds useful, and
# includes code that "clones" the data object quickly, as 
# well as the undo/redo history of that data. Subscription
# information is _not_ written to the state file.
#
# <i>Do not override this method: override write{} and
# externalize{} instead.</i>
#
body ::tycho::Model::save {args} {
    # Override options with args
    set temp(-datafile) $datafile
    set temp(-statefile) $statefile
    array set temp $args

    # Remember this position
    set historyMark(saved) $historyMark(current)
    
    # Expand file names
    if { $temp(-datafile) != "" } {
	set df [tycho::expandPath $temp(-datafile)]
    } else {
	set df ""
    }
    if { $temp(-statefile) != "" } {
	set sf [tycho::expandPath $temp(-statefile)]
    } else {
	set sf ""
    }
    
    # Open files
    set dd ""
    if { $df != "" } {
	if { ! [file exists $df] || [file writable $df] } {
	    set dd [open $df "w"]
	}
    }
    set sd ""
    if { $sf != "" } {
	if { ! [file exists $sf] || [file writable $sf] } {
	    set sd [open $sf "w"]
	}
    }

    # Write the data file and state file. Note that the state
    # file must be written _after_ the data file if load{}
    # is to work correctly.
    if { $dd != "" } {
	write $dd
	close $dd
    }
    if { $sd != "" } {
	externalize $sd
	close $sd
    }
}

########################################################################
#### subscribe
#
# Subscribe to the model. The first argument
# is the name of the subscriber. The second is a pattern that 
# says which data the subscriber want to be kept informed
# about. The mode of pattern-matching depends on the value of
# *-notifymatch* option. (Note that the glob-style and
# regular expression matching is slow and should be avoided
# if the model has many (dozens) of subscribers.) The special
# string "all" can be specified to request that the subscriber
# be notified of all changes.  See the notify{} method for
# a description of the matching process.
#
# By default, when data is published, the
# subscriber's publish{} method is called with the data change
# command (add, replace, dataconfigure, or delete) and its arguments
# as arguments. If the third argument is supplied, it is applied
# (at the global context) to four arguments: the subscriber, the
# command name, the index, and the remaining arguments. 
#
body ::tycho::Model::subscribe {subscriber pattern {whattodo {}}} {
    set subscriptions($subscriber,$pattern) $whattodo
}

########################################################################
#### undo
#
# Undo a data change. If an argument is given and it is an integer,
# undo that many steps, or until the start of the undo history. If not
# an integer, the argument must be a mark, and commands are undone
# back to _but not including_ the marked command. If the mark is not earlier
# in the history than the current position, do nothing. If the mark
# does not exist, flag an error. 
#
# As each command is undone, the change is published if the original
# command was published. 
#
# Return the number of commands undone.
#
body ::tycho::Model::undo {{distance 1}} {
    # If a mark is given, figure out the distance
    if { ! [string match {[0-9]*} $distance] } {
	# Check that the mark exists
	if { ! [::info exists historyMark($distance)] } {
	    error "Unknown mark $distance in $modelname"
	}
	set distance [expr $historyMark($current) - $historyMark($distance)]
    }

    # Go back only as far as the first command (but don't actually
    # execute the first command, since it is a null command)
    if { $distance > $historyMark(current) - $historyMark(first) } {
	set distance [expr $historyMark(current) - $historyMark(first)]
    }

    # Undo the commands
    set count 0
    while { $count < $distance } {
	# Execute the command
	@scope [info class] [list \
		$this [info class]::evalInSpecificContext \
		eval $undoCommands($historyMark(current))]

	# Publish if publishable
	if { $publishable($historyMark(current)) } {
	    eval notify noone $undoCommands($historyMark(current))
	}

	# Adjust indexes
	incr historyMark(current) -1
	incr count
    }

    # Return the number of commands undone
    return $distance
}

########################################################################
#### unsubscribe
#
# Unsubscribe from data at a given index. The subscriber is 
# removed from the subscription list for that index. Note that 
# the index must exactly match an index given to
# the subscribe{} method: it cannot be used to implement
# an exclusion mechanism (one cannot, for example, say "I have
# already subscribed to all character insertions, and I want
# to unsubscribe from all insertions of carriage returns").
#
# If the _pattern_ argument is not supplied, the subscriber is
# unsubscribed from all patterns it has subscribed to.
#
body ::tycho::Model::unsubscribe {subscriber {pattern {}}} {
    if { $pattern != "" } {
	# Unsubscribe from a given pattern
	catch {unset subscriptions($subscriber,$pattern)}
    } else {
	# Unsubscribe from all patterns
	foreach index [array names subscriptions $subscriber,*] {
	    unset subscriptions($index)
	}
    }
}

########################################################################
#### update
#
# Update data. This is the same as recording it, except that 
# the change is forwarded to subscribers (other than the caller)
# that have subscribed to the given index. The change is forwarded
# by the notify{} method, which can be overridden to change the
# notification behaviour. This method is designed to be called by
# subscribers to the model: the first argument is the name of the
# subscriber that is performing the update, and is used to prevent
# the model from updating the caller. To cause a data update from
# a non-subscriber, call the publish{} method. The second argument
# is the command to execute on the model; the third the data index,
# and remaining arguments are additional arguments to the command.
#
body ::tycho::Model::update {subscriber command index args} {
    # Record the command
    eval [list record $command $index] $args

    # Mark command as publishable
    set publishable($historyMark(current)) 1

    # Remember where it happened
    set historyMark(published) $historyMark(current)

    # Notify subscribers.
    eval [list notify $subscriber $command $index] $args
}

########################################################################
#### write
#
# Write data to a data file. See the <a href="Interchange.html">
# Interchange</a> class.
#
body ::tycho::Model::write {fd {prefix {}}} {
    _write $fd $prefix
}

########################################################################
########################################################################
####                       protected methods                        ####

########################################################################
#### _dataname
#
# Return a name to use in printing error messages and the 
# like. Returns the *-modelname* option.
#
body ::tycho::Model::_dataname {} {
    return $modelname
}    

########################################################################
#### notify
#
# Notify subscribers except _subscriber_ with the given change in data.
# How subscribers are found depends on the *-notifymode* option:
# <ul>
# <li><b>exact</b>: Subscribers are notified only if they have subscribed
# with a pattern exactly matching _index_.
# <li><b>glob</b>: Subscribers are notified only if _index_ matches
# a pattern they subscribed with. Matching is done with *string match*.
# <li><b>regexp</b>: Subscribers are notified only if _index_ matches
# a pattern they subscribed with. Matching is done with *regexp*. Note
# that the match will succees if the regexp matches anywhere in the
# index -- to require matching against the whole index, be sure
# to include <b>^</b> and <b>$</b> in the pattern.
# </ul>
#
# The default notification method is very direct: if a subscriber
# matches the index, the given command
# is called directly in the subscriber. This behavior can be changed by
# setting the *-notifyscript* option, which must be a function-script
# that can be applied to four arguments: the subscriber, the command name,
# the index, and a list of remaining arguments. Individual subscribers
# may themselves choose a different notification mechanism when they
# subscribe by providing the *whattodo* argument to subscribe{}.
#
# Although subscribers are supposed to
# unsubscribe themselves before dying, this doesn't always happen
# (especially when debugging!). So this method checks that the subscriber
# still exists, and if it doesn't, unsubscribes the offending subscriber.
#
body ::tycho::Model::notify {subscriber command index args} {
    set subscribers {}

    # Get subscribers to "all"
    foreach subindex [array names subscriptions *,all] {
	lappend subscribers [lindex [split $subindex ","] 0] \
		$index $subscriptions($subindex)
    }

    # Scan for subscribers with a pattern that matches the index
    switch -exact $notifymode {
	"exact" {
	    foreach subindex [array names subscriptions *,$index] {
		eval lappend subscribers [split $subindex ","] \
			[list $subscriptions($subindex)]
	    }
	}
	"glob" {
	    foreach subindex [array names subscriptions] {
		set si [split $subindex ","]
		set sub [lindex $si 0]
		set idx [lindex $si 1]
		if { [string match *,$pattern $index] } {
		    lappend subscribers $sub $idx $subscriptions($subindex)
		}
	    }
	}
	"regexp" {
	    foreach subindex [array names subscriptions] {
		set si [split $subindex ","]
		set sub [lindex $si 0]
		set idx [lindex $si 1]
		if { [regexp $index *,$pattern] } {
		    lappend subscribers $sub $idx $subscriptions($subindex)
		}
	    }
	}
    }
    # Process each subscriber
    foreach {sub index script} $subscribers {
	# Don't notify the caller
	if { $sub != "" && $sub == $subscriber } {
	    continue
	}
	# Unsubscribe the subscriber if it no longer exists!
	if { $sub != "" && [::info which -command $sub] == "" } {
	    unsubscribe $sub
	    continue
	}
	if { $script != "" } {
	    # if there's a script supplied by the subscriber, apply it
	    uplevel #0 ::tycho::apply \
		    [list $script $sub $command $index $args]
	} elseif { $notifyscript != "" } {
	    # Or if there's a global script, apply that
	    uplevel #0 ::tycho::apply \
		    [list $notifyscript $sub $command $index $args]
	} else {
	    # By default, call the subscriber directly
	    uplevel #0 $sub $command [list $index] $args
	}
    }
}
