#
# Query
# ----------------------------------------------------------------------
# The Query class provides support a grid of widgets useful for user input,
# such as entry fields, radiobuttons and checkbuttons, option menus, and
# so on. It provides a simple mechanism designed to easily produce good
# layouts, based on the principles described on pp 162 - 167 of Mullet
# and Sano, "Designing Visual Interfaces: Communication Oriented
# Techniques", SunSoft Press, 1995. Query uses the Tk grid{} geometry
# manager for its underlying geometry management.
#
## WISH LIST:
#   This section lists possible future enhancements.  
#
#   1) Although labels on the left produces simple and clear layouts,
#      labeled bounding boxes are very popular these days. It might
#      be possible to introduce a "labelmode" option that selects
#      either labels on the left or a labeled box. The option needs
#      to be specifiable individually for each group. Mullet and Sano's
#      comment: "While the practice is encouraged by many environments,
#      it should be used with restraint, since explicit structure is
#      a very poor substitue for effective spatial segregation." (p110).
#   2) The Tk grid is fantastic, but its huge failing is that doesn't
#      allow you to say "make columns 3 to 5 all the same width."
#      This support should be added here, perhaps using the techniques
#      in ButtonBox.
#
# ----------------------------------------------------------------------
#  AUTHOR: H. John Reekie              EMAIL: johnr@eecs.berkeley.edu
#
#  Based on the tycho::Query widget by Edward A. Lee of UC Berkeley.
#  The iwidgets::Query widget makes the widget an itk::Widget instead of an
#  itk::Toplevel, makes grid placement more structured, and adds the notion
#  of allowing arbitrary child widget types. Additional contributions
#  by Joel R. King, Bilung Lee, Christopher Hylands, Seehyun Kim, and
#  Mark L. Ulferts. Query is contributed to [incr Widgets] by the Tycho
#  project at UC Berkeley: http://ptolemy.eecs.berkeley.edu/tycho.
#
#  $Id$
# ----------------------------------------------------------------------
#
# Copyright (c) 1995-1997 The Regents of the University of California.
# All rights reserved.
# 
# Permission is hereby granted, without written agreement and without
# license or royalty fees, to use, copy, modify, and distribute this
# software and its documentation for any purpose, provided that the
# above copyright notice and the following two paragraphs appear in all
# copies of this software.
# 
# IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY
# FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
# ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF
# THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.
# 
# THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE
# PROVIDED HEREUNDER IS ON AN "AS IS" BASIS, AND THE UNIVERSITY OF
# CALIFORNIA HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,
# ENHANCEMENTS, OR MODIFICATIONS.
# 
# 						PT_COPYRIGHT_VERSION_2
# 						COPYRIGHTENDKEY
#######################################################################

#
# Usual options.
#
itk::usual Query {
    keep -font -background -cursor
}

# ------------------------------------------------------------------
##                            QUERY
# ------------------------------------------------------------------
#
# The Query class provides support a grid of widgets useful for user input,
# such as entry fields, radiobuttons and checkbuttons, option menus, and
# so on. It provides a simple mechanism designed to easily produce good
# layouts, based on the principles described on pp 162 - 167 of Mullet
# and Sano, <i>Designing Visual Interfaces: Communication Oriented
# Techniques</i>, SunSoft Press, 1995.
#
# Mullet and Sano propose that widget layouts use a "canonical grid"
# which is basically a 12-column grid that divides the window
# into one, two, three, four, or six columns. A single window can use
# combinations of numbers of columns in different rows (for example,
# some rows may be divided into three columns, and some into six).
# They use the left-most column for the label describing the purpose
# of a widget or group of widgets -- this can either be the left
# column of the chosen grid size or an additional column to the left
# of the grid.
#
# Query requires that each label in the left column corresponds
# to either a single widget (entry, checkbutton, and so on), or to
# a "group" of widgets. When the Query widget is created,
# the number of columns is specified as the <b>-columnspan</b> option.
# (The default is four.) Widgets and groups are added with the <b>add</b>
# method. By default, Query places a label for each
# widget in column zero, and the widget itself spanning columns
# one to three. If the first argument to <b>add</b> is
# "group," then the label applies to a group of widgets, each of
# which spans a single column. For example, one could create a
# group and then add six "child" checkbuttons to that group, and
# Query will neatly place them in two rows of three.
#
# The default behaviour makes it easy to construct common layouts,
# and is very much the same sort of behaviour as implemented in the
# Tycho Query dialog upon which this is based. More flexible
# layout can be achieved in a number of ways. Firstly, <b>-columnspan</b>
# can be set to a value other than the default. Secondly, the
# <b>-childspan</b> option could be set to a non-zero value, forcing
# GriddedOptions to use that span for each new widget. For example,
# setting <b>-columnspan</b> to six and <b>-childspan</b> to 2 will cause
# widgets to be placed into four layout columns (labels in
# columns 0 and 3, widgets spanning columns 1-2 and 4-5), with groups
# being divided each into two columns.
#
# Individual items also have options that affect layout. The
# <b>-columnspan</b> item option controls the number of columns
# that a widget crosses, and if set, overrides the default given
# by <b>-childspan</b> <b>-rowspan</b> does likewise for rows (although
# this should be used very sparingly). Every item also has <b>-row</b> and
# <b>-column</b> options, which specify the placement of the item label:
# the widget or group is always placed in the column to the right
# of the label.
#
# Query supports a set of operations on widgets irrespective
# of widget type: setting the current value, reading the current
# value, and enabling and disabling user input. This
# makes accessing the results from a modal dialog (for example)
# very simple: a single method call returns a list of tag-value
# pairs that can be set into an array and read as required!
# Individual widgets can also be accessed directly for more
# detailed configuration. 
#
# Query provides a useful set of widgets for placing into
# a layout, including entry and text fields, radio buttons and
# check buttons, and option menus. However, since the number
# of different kinds of widget that could be placed into a
# Query window is potentially unlimited, the Query
# class can have new widget types added to its collection of
# known widget types by calling the <b>newtype</b> procedure, together
# with options that tell it how to create and access widgets of
# that type.
#
# <h3>Item types</h3>
#
# By default, Query recognises a number of widget types. Unless
# indicated otherwise, these all accept any options valid
# for the corresponding Tk widget type, and the following:
# <ul>
# <li><b>-label</b> _string_: The text to place in the
# label that appears at the left of the widget. The default is null.
#
# <li><b>-column</b> _int_: The column of the grid in which to place
# the label. The widget will be placed in the column after this one.
# If there are two or more columns available in the currect row,
# the default is the first column available. Otherwise the default is
# column zero.
#
# <li><b>-columnspan</b> _int_: The number of columns spanned by the
# label and the created widget. The default is the <b>-childspan</b>
# option of the Query widget or the number of columns remaining
# in this row, whichever is smallest.
#
# <li><b>-initial</b> _value_: The initial value assigned to
# this widget.
#
# <li><b>-row</b> _int_: The row of the grid in which to place the label
# and widget. If there are two or more columns available in the current
# row, the default is the current row. Otherwise the default is column zero.
#
# <li><b>-rowspan</b> _int_: The number of rows spanned by the
# created widget. The default is one.
#
# <li><b>-sticky</b> _string_: The "stickiness" of the widget within
# its alloted boxes. This overrides the <b>-sticky</b> option specified
# for its type.
# </ul>
#
# The known widget types are as follows. (Note that additional types
# can be defined with the <b>newtype</b> procedure, and that unrecognised
# types can also be created -- see below.)
#
# <dl>
# <dt><b>entry</b>
# <dd>
# A Tk entry widget.
#
# <dt><b>checkbutton</b>
# <dd>
# A Tk checkbutton. Checkbuttons can usefully be placed into groups,
# as well as being a labeled item.
#
# <dt><b>frame</b>
# <dd>
# A Tk frame. Frames are useful for creating an area in which
# additional layout can be performed. They can also be used
# to create a "blank" area in the grid which can be filled
# in later. (The difference to creating a frame and using the
# <b>hskip</b> or <b>vskip</b> method is that with a frame,
# the assigned row and column can be queried at a later time.)
#
# <dt><b>group</b> _tag_ ?_option value_...? ?contents?
# <dd>
# A group of items. A group has a label, and contains a set of
# items within it. See <i>Item Groups</i> below.
# The <b>group</b> command also accepts a declarative
# specification of its contents -- see <i>Declarative Syntax</i>.
#
# <dt><b>radiobutton</b>
# <dd>
# A Tk radiobutton. Radiobuttons are usually used only within
# a shared item group.
#
# <dt><b>text</b>
# <dd>
# A Tk text widget.
#
# <dt><b>_type_</b>
# <dd>
# A widget of some other type. New types can be added to the Query
# class with the <b>newtype</b> procedure, and can then be created
# in the same way as the built-in item types.
#
# </dl>
#
# <h3>Item groups</h3>
#
# The item type <b>group</b> creates a label and then allocates
# space for a group of items. Items within a group have hierarchical
# tags, constructed as for Tk widgets. Groups accept the following
# options:
#
# <ul>
# <li><b>-childspan</b> _int_: The default value of <b>-columnspan</b>
# for the group's children.
#
# <li><b>-column</b> _int_: The start column of the group. The
# group label will be placed in this column, and group members
# in columns to the right.
# If there are two or more columns available in the currect row,
# the default is the first column available. Otherwise the default is
# column zero.
#
# <li><b>-columnspan</b> _int_: The number of columns spanned by the
# group, including the label. The default is the <b>-childspan</b>
# option of the Query widget or the number of columns remaining
# in this row, whichever is smallest.
#
# <li><b>-initial</b> _value_: If not null, the initial value of a
# variable created for the whole group. In this case, all members of
# the group are given a shared variable rather than individual ones.
# This is most useful for radiobutton groups. The value of the group will
# be the value of this single variable. If this option is null,
# each member will get its own variable and the value of the
# group will be a list of the values of each group member.
#
# <li><b>-label</b> _string_: The text to place in the
# label that appears at the left of the widget. The default is null.
#
# <li><b>-row</b> _int_: The start row of the group.
# If there are two or more columns available in the current row,
# the default is the current row. Otherwise the default is
# column zero.
#
# <li><b>-rowspan</b> _int_: The number of rows spanned by the
# group. If zero, the group expands until the next top-level
# item is added. If not zero, that many rows are reserved for
# the group and unfilled positions are available for later use.
# The default is zero.
# </ul>
#
# Any options not recognised become default options which will be
# passed to the constructor of each member of the group.
# Items can be added to a group in one of two ways.
# The first is to add items to a group later by using
# hierarchical tags, as in:
# <pre>
#   $items add group foo -initial a
#   $items add radiobutton foo.a -text A
#   $items add radiobutton foo.b -text B
# </pre>
#
# The second is to add a list of widget commands at the end
# of the options when creating the group. For example,
# <pre>
#   $items add group foo -initial a {
#       radiobutton a -text A
#       radiobutton b -text B
#   }
# </pre>
# See <i>Declarative Syntax</i> below.
# 
# Groups cannot be nested, so tags of the form <code>a.b.c</code>
# cannot be passed to the <b>add</b> method. (This restriction
# may be relaxed in future -- there's no fundamental reason
# not to have arbitrary nesting.) Items added to a group
# accept any options valid for their widget type, and the
# following:
# <ul>
# <li><b>-column</b> _int_: The column in which to place the member, relative
# to the group's start column. Default is the next column, or the
# first column of the group if the end of the group's span
# has been reached.
#
# <li><b>-columnspan</b> _int_: The number of columns spanned by
# this member. The default is one.
#
# <li><b>-initial</b> _value_: The initial value of the variable
# created for this member.
#
# <li><b>-row</b> _int_:  The row in which to place the member, relative
# to the group's start row. The default is the same row, or the
# next row if the end of the group's span has been reached.
#
# <li><b>-rowspan</b> _int_: The number of columns spanned by
# this member. The default is one. If this option is not zero, then
# all subsequent members may have
# to have explicit <b>row</b> and <b>column</b> options given to prevent
# collision of this item with subsequent items.
# </ul>
#
# Note that individual items within a group are not labeled.
#
# <h3>Control Scripts</h3>
#
# Query provides a fairly straight-forward mechanism for defining
# new item types. For each of the operations it supports on
# its items, it has a small script that it evaluates to
# perform this action. If you use Query only with the predefined
# item types (which is adequate for most common applications),
# then you do not need to read about control scripts. If,
# however, you need to add a new widget type, then call the
# <b>newtype</b> procedure. This procedure accepts a number
# of options that specify the scripts that Query evaluates
# to perform operations on items of the new type.
#
# Before evaluating a script, Query performs the following
# substitutions:
# <ul>
# <li><code>%a</code> is substituted with additional arguments.
# <li><code>%t</code> is substituted with the item tag.
# <li><code>%v</code> is substituted with the control variable.
# <li><code>%w</code> is substituted with the widget path.
# <li><code>%Q</code> is substituted with the Query widget.
# </ul>
#
# The options accepted by <b>newtype</b> are:
# <ul>
# <li><b>-assign</b>: Set a value to the item. If null, an attempt
# to assign a value will raise an error.
# The default is <code>{set %v %a}</code>.
# <li><b>-create</b>: Create an item. An error will be raised
# of this option is not specified.
# <li><b>-delete</b>: Delete the item.
# The default is <code>{destroy %w}</code>.  If null,
# the widget cannot be deleted, and an error will be raised
# on an attempt to do so.
# <li><b>-disable</b>: Disable user input to the item. If null,
# the widget cannot be disabled.
# The default is <code>{%w configure -state disabled}</code>.
# <li><b>-enable</b>: Enable user input to the item. If null,
# the widget cannot be disabled.
# The default is <code>{%w configure -state normal}</code>.
# <li><b>-get</b>: Get the item's value. If null, an attempt
# to get the item's value will return null.
# The default is <code>{set %v}</code>.
# <li><b>-options</b>: This is not a control script, but will
# be passed as the second argument to <b>itk_component add</b>,
# to control option propagation.
# The default is <code>{usual}</code>.
# </ul>
#
class iwidgets::Query {
    inherit itk::Widget
    
    constructor {args} {}
    destructor {}
    
    public variable columnspan 4
    public variable childspan 4
    public variable childstyle "simple"

    itk_option define -entrybackground entryBackground Background grey90

    itk_option define -font font Font \
            "-Adobe-Helvetica-Medium-R-Normal--*-120-*-*-*-*-*-*"
    itk_option define -labelfont labelFont Font  \
            "-Adobe-Helvetica-Bold-R-Normal--*-120-*-*-*-*-*-*"
    itk_option define -labelcolor labelColor Foreground black
    itk_option define -labelanchor labelAnchor Anchor "e"

    itk_option define -padx padX PadX 0
    itk_option define -pady padY PadY 0
    
    method add     {type tag args}
    method assign  {tag value}
    method delete  {tag}
    method disable {tag}
    method enable  {tag}
    method exists  {tag}
    method get     {{pattern {}}}
    method group   {tag args}
    method hskip   {columns {parent {}}}
    method itemcget      {tag option}
    method itemconfigure {tag {option {}} args}
    method vskip   {{parent {}}}
    
    proc newtype {type args}   ;# add a new type
    
    private method _getcmd   {mode tag args}
    private method _group    {mode tag args}
    private method _drawitem \
            {tag style label col row colspan rowspan {path {}} {sticky {}}}
 

    # Common information about item types
    private common _knowntypes {
	checkbutton
	entry
	group
	radiobutton
    }
    private common _assign     ;# assign to a widget
    private common _create     ;# create a new widget
    private common _disable    ;# disable a widget
    private common _enable     ;# enable a widget
    private common _get        ;# get a widget's value
    private common _sticky     ;# options for stickiness of each type
    private common _options    ;# options for itk_component add

    # Unique counters
    private common widgetCounter 0   ;# counter to generate unique numbers
    private variable itemCounter 0   ;# Counter to generate widget paths
    private variable unique          ;# unique for each widget

    # Gridding variables: one entry per item, indexed by tag
    private variable _row           ;# item row w/o borders
    private variable _col           ;# item column w/o borders
    private variable _rowspan       ;# the height of this item with borders
    private variable _lastcol       ;# last column of item
    private variable _nextcol       ;# next column after this item
    private variable _height        ;# height of the current row w/ borders
    private variable _curcol        ;# current grid column
    private variable _currow        ;# current grid row
    private variable _childspan     ;# default span of child widgets
    private variable _childstyle    ;# default style of child widgets

    # Item information, one per item
    private variable _type          ;# the type of each item
    private variable _children      ;# the children of each group

    # Initialize common arrays
    array set _assign {
	default     {set {%v} %a}
	entry       {%w delete 0 end; %w insert 0 %a}
	group       {_group assign %a}
    }
    array set _create {
	default     {}
	checkbutton {eval ::checkbutton %w -variable {{%v}} %a}
	entry       {eval ::entry %w -textvariable {{%v}} %a}
	radiobutton {eval ::radiobutton %w -variable {{%v}} %a}
    }
    array set _delete {
	default     {destroy %w}
	group       {_group delete %t}
    }
    array set _disable {
	default     {%w configure -state disabled}
	group       {_group disable %t}
    }
    array set _enable {
	default     {%w configure -state normal}
	group       {_group enable %t}
    }	
    array set _get {
	default     {set {%v}}
	group       {_group get %t}
    }
    array set _sticky {
	default     "ew"
	checkbutton "w"
	radiobutton "w"
    }
    array set _options {
	default {usual}
	entry {
	    usual
	    rename -background -entrybackground entryBackground Background
	}
    }
    foreach mode {assign create delete disable enable get sticky options} {
	foreach type $_knowntypes {
	    if ![::info exists _[set mode]($type)] {
		set _[set mode]($type) [set _[set mode](default)]
	    }
	}
    }
    method debug {args} {
	eval $args
    }
}

#
# Use option database to override default resources.
#
# option add *Query.thickness 3 widgetDefault ???

#
# Provide a lowercase access method for the Query class.
#
proc ::iwidgets::query { path args } {
    # Create widget
    uplevel ::iwidgets::Query $path $args
}

# ------------------------------------------------------------------
##                        CONSTRUCTOR
# ------------------------------------------------------------------
body iwidgets::Query::constructor {args} {
    set _row() 0
    set _col() 0
    set _currow() 0
    set _curcol() 0
    set _height() 1

    set unique [incr widgetCounter]
    
    # Evaluate options
    eval itk_initialize $args
}


# ------------------------------------------------------------------
##                             OPTIONS
# ------------------------------------------------------------------

# ----------------------------------------------------------------------
## OPTION -columnspan
#
# The number of columns in the grid. The default is four. Changing
# this option only affects the layout of items subsquently added
# to the grid, not of items already added.
# ----------------------------------------------------------------------
configbody iwidgets::Query::columnspan {
    set _columnspan() $itk_option(-columnspan)
    set _nextcol() $itk_option(-columnspan)
    set _lastcol() $itk_option(-columnspan)
}

# ----------------------------------------------------------------------
## OPTION -childspan
#
# The default column span of top-level groups. If zero, the item will
# span all remaining columns of the grid. The default is zero.
# Changing this option only affects the default column span of
# groups subsequently added to the grid, not of items already added. 
# ----------------------------------------------------------------------
configbody iwidgets::Query::childspan {
    set _childspan() $itk_option(-childspan)
}

# ----------------------------------------------------------------------
## OPTION -childstyle
#
# The default style of top-level items. Any non-group item will be
# drawn in this style, while groups will default to this style
# but can override it. The default is "simple."
# ----------------------------------------------------------------------
configbody iwidgets::Query::childstyle {
    set _childstyle() $itk_option(-childstyle)
}

# ----------------------------------------------------------------------
## OPTION -labelanchor
#
# The default anchoring of the text labels. The value of this option
# is passed directly to the <b>-sticky</b> option of the Tk <b>grid</b>
# command. It can be overridden for individual widgets and labels
# by calling the <b>grid configure</b>command with the Tk widget
# path as argument.
# ----------------------------------------------------------------------
configbody iwidgets::Query::labelanchor {
}

# ----------------------------------------------------------------------
## OPTION -labelcolor
#
# The default foreground color of the text labels. This can be overridden
# by directly accessing the label widgets.
# ----------------------------------------------------------------------
configbody iwidgets::Query::labelcolor {
}

# ----------------------------------------------------------------------
## OPTION -labelfont
#
# The default font of the text labels. This can be overridden
# by directly accessing the label widgets.
# ----------------------------------------------------------------------
configbody iwidgets::Query::labelfont {
}

# ----------------------------------------------------------------------
## OPTION -padx
#
# The default horizontal padding to use when gridding widgets. Widgets
# are gridded with the <b>-padx</b> option to the Tk <b>grid</b> command
# set to this value. To override this value for individual widgets,
# call <B>grid configure</b> directly with the component
# widget. For example:
# # <pre>
#   grid configure [$griddeditems component size] -padx 4
# </pre>
# ----------------------------------------------------------------------
configbody iwidgets::Query::padx {
    foreach slave [grid slaves $itk_interior] {
	if { [grid info $slave -padx] != $itk_option(-padx) } {
	    grid configure $slave -padx $itk_option(-padx)
	}
    }
}

# ----------------------------------------------------------------------
## OPTION -pady
#
# The default horizontal padding to use when gridding widgets. Widgets
# are gridded with the <b>-pady</b> option to the Tk <b>grid</b> command
# set to this value. To override this value for individual widgets,
# call <B>grid configure</b> directly directly with the component
# widget. For example:
# # <pre>
#   grid configure [$griddeditems component size] -pady 4
# </pre>
# ----------------------------------------------------------------------
configbody iwidgets::Query::pady {
    foreach slave [grid slaves $itk_interior] {
	if { [grid info $slave -pady] != $itk_option(-pady) } {
	    grid configure $slave -pady $itk_option(-pady)
	}
    }
}


# ------------------------------------------------------------------
##                             METHODS
# ------------------------------------------------------------------

# ------------------------------------------------------------------
## METHOD: add type tag ?option value...? 
#
# Add a new item to the layout. The first argument is the name
# of the widget type to create. This is followed by the _tag_
# that will be used to reference the widget, then an option-value
# list. The options can be any that are valid for the widget type
# _type_, plus options that specify labeling and positioning
# information, as described in the section <i>Item Types</i>
# above. For each item, a variable is created that can be used to
# hold its value, which can be accessed within control scripts
# as *%v*.
#
body iwidgets::Query::add {type tag args} {
    if [::info exists _layout($tag)] {
	error "Item already exists: \"$tag\""
    }
    if ![::info exists _create($type)] {
	error "Unknown item type \"$type\": must be one of $_knowntypes"
    }
    # Decompose the tag
    regexp {^((.*)\.)?[^\.]+$} $tag _ _ par

    # Remember key parameters
    set _type($tag) $type
    lappend _children($par) $tag
    set path $itk_interior._[incr itemCounter]

    # Extract options
    array set opts [list \
	    -initial {} -label {} \
	    -columnspan $_childspan($par) \
 	    -style $_childstyle($par) \
            -sticky $_sticky($type) ]
    array set opts $args

    set init   $opts(-initial)
    set label  $opts(-label)
    set sticky $opts(-sticky)
    set span   $opts(-columnspan)
    set style  $opts(-style)

    unset \
	    opts(-initial)  \
	    opts(-label) \
            opts(-columnspan) \
            opts(-sticky) \
            opts(-style)

    # Create the widget
    set itk_component($tag) $path    ;# hack so _getcmd works...
    itk_component add $tag {
        eval [_getcmd create $tag [array get opts]]
    } $_options($type)  ;# emacs indenting \}

    # Draw the item according to its style. Side-effect layout parameters
    _drawitem $tag $style $label \
            $_curcol($par) $_currow($par) \
            $span 1 $itk_component($tag) $sticky

    # Set the initial value
    assign $tag $init

    # Adjust counters
    if { $_rowspan($tag) > $_height($par) } {
	set _height($par) $_rowspan($tag)
    }
    if { $_nextcol($tag) >= $_lastcol($par) } {
	set _curcol($par) $_col($par)
	incr _currow($par) $_height($par)
	set _height($par) 1
    } else {
	set _curcol($par) $_nextcol($tag)
    }
}

# ------------------------------------------------------------------
## METHOD: assign tag value
#
# Assign a value to an item. The value must make sense for the item.
# If the item is a group with a shared variable, the value will
# be assigned to the shared variable. If the group is not shared,
# the value must be a list, and one consecutive elements of the list
# will be assigned to each member of the group, in the order created.
# Raise an error if _tag_ does not exist.
#
body iwidgets::Query::assign {tag value} {
    if ![::info exists _row($tag)] {
	error "Unknown tag: \"$tag\""
    }
    eval [_getcmd assign $tag $value]
}

# ------------------------------------------------------------------
## METHOD: delete tag
#
# Delete an item. If the item is a group, all members of the group
# will also be deleted. Raise an error if _tag_ does not exist.
#
body iwidgets::Query::delete {tag} {
    if ![::info exists _row($tag)] {
	error "Unknown tag: \"$tag\""
    }
    if { $_delete($tag) == "" } {
	return
    }
    grid forget $itk_component(tag)
    eval [_getcmd delete $tag]
    
    # Clean up internal data
    unset itk_component($tag)
    unset _row($tag)
    unset _column($tag)
    unset _currow($tag)
    unset _curcol($tag)
    unset _columnspan($tag)
    unset _rowspan($tag)
    unset _childspan($tag)
    
    if [regexp {^((([^\.]+).)*)[^\.]+$} $tag _ _ par] {
        set t [lsearch -exact $_children($par) $tag]
        set _children($par) [lreplace $_children($par) $t $t]
    }
}

# ------------------------------------------------------------------
## METHOD: disable tag
#
# Disable an item. If the item is a group, all members of the group
# will also be disabled. Raise an error if _tag_ does not exist.
#
body iwidgets::Query::disable {tag} {
    if ![::info exists _row($tag)] {
	error "Unknown tag: \"$tag\""
    }
    eval [_getcmd disable $tag]
}

# ------------------------------------------------------------------
## METHOD: enable tag
#
# Enable an item. If the item is a group, all members of the group
# will also be enabled. Raise an error if _tag_ does not exist.
#
body iwidgets::Query::enable {tag} {
    if ![::info exists _row($tag)] {
	error "Unknown tag: \"$tag\""
    }
    eval [_getcmd enable $tag]
}

# ------------------------------------------------------------------
## METHOD: get ?pattern?
#
# Get the value of one or more items. If the _tag_ argument is
# not supplied or is null, return the value of that item.
# If the tag is a group with a shared variable, the group's value
# is that value of that variable. Otherwise the group's value is 
# a list of member tags and their values. If the argument is
# not supplied, return tha tag-value list containing all top-level
# items.
#
body iwidgets::Query::get {{tag {}}} {
    if { $tag != "" } {
        return [eval [_getcmd get $tag]]
    } else {
        set result {}
        foreach tag $_children() {
            set cmd [_getcmd get $tag]
            if { $cmd != "" } {
                lappend result $tag [eval [_getcmd get $tag]]
            }
        }
        return $result
    }
}

# ------------------------------------------------------------------
## METHOD: group tag $args
#
# Add a group. Options are as described in <i>Item Groups</b> above.
#
body iwidgets::Query::group {tag args} {
    if [::info exists _layout($tag)] {
	error "Item already exists: \"$tag\""
    }
    # Decompose the tag
    regexp {^((.*)\.)?[^\.]+$} $tag _ _ par

    # Remember key parameters
    set _type($tag) group
    lappend _children($par) $tag
    set path $itk_interior._[incr itemCounter]

    # Extract options
    array set opts [list \
            -initial    {} \
            -label      {} \
            -row        $_currow($par) \
            -column     $_curcol($par) \
            -rowspan    1 \
            -columnspan $_childspan($par) \
            -childspan  1 \
            -style      $_childstyle($par) \
            -childstyle plain]
    array set opts $args

    # Draw the borders according to style. Side-effect layout parameters
    _drawitem $tag $opts(-style) $opts(-label) \
            $_curcol($par) $_currow($par) \
            $opts(-columnspan) $opts(-rowspan)

    # Set up counters for this group
    set _currow($tag) $_row($tag)
    set _curcol($tag) $_col($tag)
    set _height($tag) 1
    set _childspan($tag)  $opts(-childspan)
    set _childstyle($tag) $opts(-childstyle)

    # Adjust counters
    if { $_rowspan($tag) > $_height($par) } {
	set _height($par) $_rowspan($tag)
    }
    if { $_nextcol($tag) >= $_lastcol($par) } {
	set _curcol($par) $_col($par)
	incr _currow($par) $_height($par)
	set _height($par) 1
    } else {
	set _curcol($par) $_nextcol($tag)
    }
    # If the initial value is not null, create the shared
    # variable -- that way we know it's a shared group later
    if { $opts(-initial) != "" } {
        set [scope $tag$unique] $opts(-initial)
    }
}

# ------------------------------------------------------------------
## METHOD: hskip columns ?parent?
#
# Skip to the next location. The _columns_ argument is the
# number of columns to skip. The _parent_ argument, if supplied,
# is the name of a group within which to skip.
# If the skip takes the current column counter past the end of the
# group, call <b>vskip</b> to move to the next row.
#
body iwidgets::Query::hskip {columns {parent {}}} {
    if { $parent != "" && ![::info exists _layout($parent)] } {
        error "Unknown group: \"$parent\""
    }
    incr _curcol($parent) $columns
    if { $_curcol($parent) >= [lindex $_layout($parent) 2] } {
        vskip $parent
    }
}

# ------------------------------------------------------------------
## METHOD: itemcget tag option
#
# Get an option of an item. The options can be any that can be specified
# in the call to <b>add</b> when the widget _tag_ was created. Raise
# an error if _tag_ does not exist.
#
body iwidgets::Query::itemcget {tag option} {
    if ![::info exists _row($tag)] {
	error "Unknown tag: \"$tag\""
    }
    if { $option == "-label" } {
	$itk_component(${tag}label) cget -text
    } elseif [regexp {^-(row|column|rowspan|columnspan|sticky)$} $option] {
	array set opts [grid info $itk_component($tag)
	set opts($option)
    } else { 
	$itk_component($tag) cget $option
    }
}

# ------------------------------------------------------------------
## METHOD: itemconfigure tag ?option? ?value? ?option value...?
#
# Configure options of an item. Raise an error if _tag_ does not exist.
# If only a single argument is supplied, return the value lists of
# all options. If two arguments are supplied, the second is taken
# to be an option and the value list of that option is returned.
# If more arguments are supplied, each option is set to the specified
# value, with the exception of the following:
# <ul>
# <li>The options <b>-row</b>, <b>-column</b>, <b>-columnspan</b>
# and <b>-rowspan</b>. It would be possible to support changing
# these, but it's just tedious and doesn't seem to be something
# that would be needed very often... If an attempt is made to
# change them they will just be ignored.
# <li>The <b>-initial</b> options of the type <b>group</b>. This
# cannot be changed since either a) it's only the initial of a
# shared group and changing it would mean nothing, or b) it's
# being changed from null to non-null or vice-versa. which implies
# changing a group from shared to non-shared or vice-versa.
# </ul>
#
body iwidgets::Query::itemconfigure {tag {option {}} args} {
    if ![::info exists _row($tag)] {
	error "Unknown tag: \"$tag\""
    }
    if { $option == "" } {
	set result {}
	foreach o {row column rowspan columnspan sticky} {
	    lappend result [itemconfigure $tag $o]
	}
	return $result
    } elseif { $args == "" } {
	if { $option == "-label" } {
	    $itk_component(${tag}label) configure -text
	} elseif [regexp {^-(row|column|rowspan|columnspan|sticky)$} $option] {
	    array set opts [grid info $itk_component($tag)
	    list $option {} {} $opts($option) $opts($option)
	} elseif [regexp {^-(initial|childspan)$} {
	    return ""
	} else {
	    $itk_component($tag) configure $option
	}
    } else {
	foreach {option value} [concat $option $args] {
	    if { $option == "-label" } {
		$itk_component(${tag}label) configure -text $value
	    } elseif { $option == "-sticky" } {
		grid configure $itk_component($tag) -sticky $value
	    } elseif [regexp {^-(row|column|rowspan|columnspan)$} $option] {
		;# do nothing
	    } elseif [regexp {^-(initial|childspan)$} {
		;# Do nothing
	    } else {
		$itk_component($tag) configure $option $value
	    }
	}
    }
}

# ------------------------------------------------------------------
## METHOD: vskip ?parent?
#
# Skip to the next row. The current row counter is incremented
# by the row span of the item in the current row with the
# largest row span, and the current row counter reset to zero.
# If the _parent_ argument is supplied the row counter within
# that group is incremented.
#
body iwidgets::Query::vskip {{parent {}}} {
    if { $parent != "" && ![::info exists _layout($parent)] } {
		error "Unknown group: \"$parent\""
    }
    set _curcol($parent) $_col($parent)
    incr _currow($parent) $_height($parent)
    set _height($parent) 1
}

# ------------------------------------------------------------------
##                           PRIVATE METHODS
# ------------------------------------------------------------------

# ------------------------------------------------------------------
## METHOD: _drawitem tag style label col row colspan rowspan ?path? ?sticky?
#
# Draw an item and update the grid parameters accordingly. Input:
# <ul>
# <li>_col_ is the absolute base column of the item including borders
# <li>_row_ is the absolute base row of the item including borders
# <li>_colsnap_ is the column span of the item without borders
# <li>_rowspan_ is the row span of the item without borders
# </ul>
#
# Output:
# <ul>
# <li><i>_col($tag)</i> is the absolute base column of the item without border
# <li><i>_row($tag)</i> is the absolute base row of the item without borders
# <li><i>_nextcol($tag)</i> is the next column after this item
# <li><i>_rowspan($tag)</i> is the height including borders
# </ul>
#
#
body iwidgets::Query::_drawitem {tag style label \
	col row colspan rowspan {path {}} {sticky {}}} {
    set delta 0
    switch -exact $style {
	"plain" {
	    if { $path != "" } {
		grid $path \
			-row $row -column $col \
			-columnspan $colspan \
			-rowspan $rowspan \
			-sticky $sticky
            }
	}
	"simple" {
	    # Label
	    itk_component add ${tag}label {
		label $itk_interior._[incr itemCounter] -text $label
	    } {
		keep -background -cursor
		rename -font -labelfont labelFont Font
		rename -foreground -labelcolor labelColor Foreground
	    }
	    grid $itk_component(${tag}label) \
		    -row $row \
		    -column $col \
		    -sticky $itk_option(-labelanchor)
	    incr col

	    # Item
	    if { $path != "" } {
		grid $path \
			-row $row -column $col \
			-columnspan $colspan \
			-rowspan $rowspan \
			-sticky $sticky
	    }
        }
        "separated" {
	    # Create and grid the frame that contains the separator
            itk_component add ${tag}frame {
                frame $itk_interior._[incr itemCounter]
            }
            grid $itk_component(${tag}frame) \
                    -row $row -column $col \
                    -rowspan 1 -columnspan $colspan \
                    -sticky nsew

             # Configure this row
            grid rowconfigure $itk_interior $row -minsize 30

	    # Create and place the separator line
            itk_component add ${tag}separator {
                frame $itk_interior._[incr itemCounter] \
                        -height 2 -borderwidth 1 -relief sunken
            }
            place $itk_component(${tag}separator) \
                    -x 3 -y 18 \
                    -width -6 -relwidth 1 \
                    -in $itk_component(${tag}frame) 

            # Create the label and place it. -labelanchor is ignored.
            itk_component add ${tag}label {
                label $itk_interior._[incr itemCounter] -text $label
            }
            place $itk_component(${tag}label) -x 9 -y 18 -anchor w \
                    -in $itk_component(${tag}frame)

            # Now grid the item and raise it so it shows
            incr row
	    if { $path != "" } {
		grid $path \
			-row $row -column $col \
			-columnspan $colspan \
			-rowspan $rowspan \
			-sticky $sticky
                raise $path
            }
            incr rowspan 1
	}
	"boxed" {
	    # Create and grid the frame that covers the whole region
            itk_component add ${tag}frame {
                frame $itk_interior._[incr itemCounter]
            }
            grid $itk_component(${tag}frame) -row $row -column $col \
                    -rowspan [expr $rowspan+2] -columnspan [expr $colspan+2] \
                    -sticky nsew

            # Configure the border rows and columns. (How can we avoid
            # doing this redundantly?)
            grid columnconfigure $itk_interior $col -minsize 12
            grid columnconfigure $itk_interior [expr $col+$colspan+1] \
                    -minsize 12
            grid rowconfigure $itk_interior $row -minsize 24
            grid rowconfigure $itk_interior [expr $row+$rowspan+1] -minsize 12

            # Create the border and place it
            itk_component add ${tag}border {
                frame $itk_interior._[incr itemCounter] \
                        -borderwidth 2 -relief groove
            }
            place $itk_component(${tag}border) \
                    -x 6 -y 12 \
                    -width -12 -height -18 -relwidth 1 -relheight 1 \
                    -in $itk_component(${tag}frame)

            # Create the label and place it. -labelanchor is ignored.
            itk_component add ${tag}label {
                label $itk_interior._[incr itemCounter] -text $label
            }
            place $itk_component(${tag}label) -x 12 -y 12 -anchor w \
                    -in $itk_component(${tag}frame)

            # Now grid the item and raise it so it shows
            incr col
            incr row
	    if { $path != "" } {
		grid $path \
			-row $row -column $col \
			-columnspan $colspan \
			-rowspan $rowspan \
			-sticky $sticky
                raise $path
            }
            incr delta
            incr rowspan 2
	}
	default {
	    error "Unknown style: \"$style\""
	}
    }
    # By the time we get here, row and col must be the base
    # of the actual item. rowspan must be the full height;
    # colspan must be the distance to the next item
    set _col($tag) $col
    set _row($tag) $row
    set _lastcol($tag) [incr col $colspan]
    set _nextcol($tag) [incr col $delta]
    set _rowspan($tag) $rowspan
}

# ------------------------------------------------------------------
## METHOD: _getcmd mode tag ?arg...?
#
# Get the command to evaluate for a widget. The _mode_ argument
# selects the widget mode and must be one of <b>get</b>, <b>assign</b>,
# <b>enable</b>, <b>delete</b>, <b>disable</b>, or <b>create</b>.
# The _tag_ argument is the item to evaluate the command on.
#
body iwidgets::Query::_getcmd {mode tag args} {
    set command [set _[set mode]($_type($tag))]
    if { $command != "" } {
        if [::info exists itk_component($tag)] {
            regsub -all %w $command $itk_component($tag) command
        }
        regsub -all %v $command [scope $tag$unique] command
        regsub -all %t $command $tag command
        regsub -all %Q $command $this command
        regsub -all %a $command $args command
    }
    return $command
}

# ------------------------------------------------------------------
## METHOD: _group mode tag ?option value ...?
#
# Access a group. The mode is assign, delete, disable, enable,
# or get.
#
body iwidgets::Query::_group {mode tag args} {
    switch -exact $mode {
	"assign" {
	    if [::info exists [scope $tag$unique]] {
		# Shared group
		set [scope $tag$unique] $args
	    } else {
		# Not a shared group
		foreach t $_children($tag) v $args {
		    assign $t $v
		}
	    }
	}
	"delete" {
	    foreach t $_children($tag) {
		delete $t
	    }
	    grid forget $itk_component(${tag}label)
	    destroy $itk_component(${tag}label)
	    destroy $itk_component($tag)
	    unset itk_component(${tag}label)
	    foreach i [array names _rowheight $tag,*] {
		unset _rowheight
	    }
	}
	"disable" {
	    foreach t $_children($tag) {
		disable $t
	    }
	}
	"enable" {
	    foreach t $_children($tag) {
		enable $t
	    }
	}
	"get" {
	    if [::info exists [scope $tag$unique]] {
		# Shared group
		set [scope $tag$unique]
	    } else {
		# Not a shared group
		set result {}
		foreach t $_children($tag) {
		    lappend result $t [get $t]
		}
		return $result
	    }
	}
    }
}
    
# ------------------------------------------------------------------
##                          PROCEDURES
# ------------------------------------------------------------------

# ------------------------------------------------------------------
## PROCEDURE: newtype type ?option value?
#
# Add a new item type to the Query class. The _type_ is the
# item type. Following arguments are an option-value list,
# where legal options are as described in <i>Control Scripts</i>
# above. Raise an error if the _type_ already exists, or
# if an invalid option is specified.
#
body iwidgets::Query::newtype {type args} {
    if { [lsearch -exact $_knowntypes $type] != -1 } {
	error "Type \"$type\" is already defined"
    }
    array set opts $args
    foreach c {assign create delete disable enable get sticky options} {
	if ![::info exists opts(-$c) {
	    set _[set c]($type) [set _[set c](default)]
	} else {
	    set _[set c]($type) $opts(-$c)
	    unset opts(-$c)
	}
    }
    if { [array names opts] != "" } {
	error "bad option: \"[lindex [array names opts] 0]\""
    }
    lappend _knowntypes $type
}
