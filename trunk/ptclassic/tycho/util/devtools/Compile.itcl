# Compiler baseclass that compiles and loads files
#
# @Author: Christopher Hylands
#
# @Version: $Id$
#
# @Copyright (c) 1997 The Regents of the University of California.
# All rights reserved.
#
# Permission is hereby granted, without written agreement and without
# license or royalty fees, to use, copy, modify, and distribute this
# software and its documentation for any purpose, provided that the above
# copyright notice and the following two paragraphs appear in all copies
# of this software.
#
# IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY
# FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
# ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF
# THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.
#
# THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE
# PROVIDED HEREUNDER IS ON AN "AS IS" BASIS, AND THE UNIVERSITY OF
# CALIFORNIA HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,
# ENHANCEMENTS, OR MODIFICATIONS.
# 
#                                        PT_COPYRIGHT_VERSION_2
#                                        COPYRIGHTENDKEY
#######################################################################

##############################################################################
#### compileC
# Invoke an external program using compileCTcl.
# The format of the command is exactly that of the Tcl "exec" command,
# with colorization (parseError function called).
#
set compiler {}
proc ::tycho::compileC { args } {
    global tcl_platform compiler
    if {$tcl_platform(platform) == "macintosh"} {
	error "Sorry, the tcl \"exec\" command is not supported on the\
		Macintosh.\nThe command:\n$args\ncannot be executed"
    }

    # NOTE: Unix-ism.
    # WARNING: winfo doesn't work for some reason!
    # Now always creating a new widget
    if {$compiler=={}} {
        set compiler [::tycho::CompileCTcl [::tycho::autoName .compilerC]]
    }

    if [catch {eval $compiler compile $args} msg] {
        # The command failed.  It would be nice to check to see
        # whether the program exists, and generate a suitable message,
        # but it's not clear how to do this.
        error "The following command invocation failed:\n \
                $args\n \
                Is the program [lindex $args 0] installed and in your path?\n \
                $msg"
    }
}


#######################################################################
#### Compile
# The Compile baseclass provides a common interface that can be used
# to compile files and load them in.  Child classes, such as CompileCTcl
# derive from this class and refine the functionality.
#
# <p>
# Here is an example of how to use the Compile.  This example
# does not do much
# <tcl><pre>
#     set compiler [::tycho::Compile]
#     $compiler compileAndLoad {Compile.itcl}
# </pre></tcl>
#
class ::tycho::Compile {

    constructor {args} {}
    destructor {}
    
    ###################################################################
    ####                            options                        ####

    ###################################################################
    ####                         public methods                    ####

    # Compile each file in the list of filenames.
    public method compile { filenames}

    # Compile and load in each file in the list of filenames.
    public method compileAndLoad { filenames}

    # Compile and run in each file in the list of filenames.
    public method compileAndRun { filenames}

    # If the editor widget exists, then jump to the next error
    public method jumpToLine {cLineNum eLineNum fname}

    # Jump to the next error when the "Next Error" button is clicked
    public method jumpNextError {} 

    # Set the error count so that jumpNextError will jump correctly.
    public method setErrorCount {num}
    
    # Compile the file.
    method compileFiles {}

    public variable view {}
    ###################################################################
    ####                   protected methods                       ####

    # Check the source files for necessary features.
    protected method checkSourceFiles {}

    # Parse the error message, determine action (language dependent)
    # This is always called by compileFiles. It's generic here
    protected method parseError {results } {}

    # Create a makefile.
    protected method createMakefile {}

    # Jump to line number in the Edit class, used by parseError only.
    protected method jumpToParent {line Edit} {}

    # Initialize variables from the filename list.
    protected method initialize {filenames}

    # Run make and then load the result back into Tycho.
    protected method loadFiles {}

    # Determine the name of the makefile.
    protected method makefileName {}

    # Access the "misc" preferences
    protected method preference {mode args}

    # Print status messages to the controlling widget, if any.
    protected method putStatus {msg}

    ###################################################################
    ####                   protected variables                     ####

    # basename (filename before the extension) of the first file in the list.
    protected variable basename {}

    # Directory that the first file in the list resides in.
    protected variable dirname {}

    # List of files to be compiled and loaded.
    protected variable filenameList {}

    # First file in filenameList
    protected variable firstFile {}

    # Name of the makefile to use.
    protected variable makefile makefile

    # Name of the Exec widget used to compile
    protected variable compileWidget {}

    ###################################################################
    ####                     private variables                     ####
    private variable editorWidget {}
    private variable errorList {}
    private variable errorCount {}
}

#######################################################################
#### constructor
#
body ::tycho::Compile::constructor {args} {
    # compileWidget is the execModal widget
    # NOTE: editor name is $editorName"
    set editorName [$this cget -view]
    set editorWidget $editorName.history.text
}


#######################################################################
#### destructor
#
body ::tycho::Compile::destructor {} {
}


    ###################################################################
    ###################################################################
    ####                      public methods                       ####

#######################################################################
#### compile
# Compile each file in the list of filenames.
#
body ::tycho::Compile::compile {filenames} {
    initialize $filenames
    # Should we check that the files exist here?
    checkSourceFiles
    set makefile [makefileName]
    createMakefile
    compileFiles
}
#######################################################################
#### compileAndLoad
# Compile and load in each file in the list of filenames.
#
body ::tycho::Compile::compileAndLoad {filenames} {
    compile $filenames
    loadFiles
}
#######################################################################
#### compileAndRun
# Compile and load in each file in the list of filenames.
#
body ::tycho::Compile::compileAndRun {filenames} {
    initialize $filenames
}


    ###################################################################
    ###################################################################
    ####                      protected methods                    ####

#####################################################################
#### parseError
#
# Parse the error output from a compiler. Although this function is
# generic, it works for many different compilers such as gcc,
# javac, etc.
#
# The convention is:
# ::parseError {result}
# Where result is in the following form "status EditWidget_name"
#
# The output of an error message must be in the following:
# file_name:line_number: Error message here
#
body ::tycho::Compile::parseError {results} {
    # Default is that we don't have an error
    set errorCount -1

    # Simple parse the results here.
    set editorName [$this cget -view]
    set text $compileWidget.history.text

    # Set the next button so it calls to our nextError function
    $compileWidget.bbox buttonconfigure next \
            -command "$this jumpNextError"

    # puts "editorName=$editorName, compileWidget=$compileWidget, text=$text, this=$this"
    set eLineNum -1     ;# We haven't read the line number yet
    set cLineNum 0      ;# Compiler's line starts at 0
    set errorCount 0    ;# If errorCount==-1, then we have no error
    set errorList {}    ;# Default is that our list is empty

    # Get the output of the compiler
    #set output [[lindex $results 1].history get 0.0 end]
    set output [$results.history get 0.0 end]
    set output [split $output "\n"]
    foreach line $output {
        incr cLineNum
        # The text index starts off on 1, the lindex starts off on 0
        #set line [lindex $output [expr $i-1]]

        # Does it match the format? "test.cc:15: Error message here"
        # Does it match the format? "test.cc:15: warning: Error_msg_here"
        if {[regexp {([^:]+):([0-9]+): (.+)} $line tmp fname tmpeLineNum msg]\
                && $tmpeLineNum!=$eLineNum} {
            incr errorCount
            # This ensures only one line per many lines of error output
            set eLineNum $tmpeLineNum
            if {[regexp {(warning): (.+)} $msg]} {
                #FIXME: Change me to preference
                set color {purple}
            } else {
                #FIXME: Change me to preference
                set color {red}
                lappend errorList [list $cLineNum $eLineNum $fname]
            }
            $text tag add error$errorCount $cLineNum.0 $cLineNum.end
            $text tag configure error$errorCount -foreground $color -underline 0
            # Two actions to the error binding:
            # 1) jump to the lines (and highlight)
            # 2) update internal count, so Next button will know where to jump
            $text tag bind error$errorCount <Double-Button-1> \
                    "$this jumpToLine $cLineNum $eLineNum $fname ;\
                    $this setErrorCount $errorCount"
        }
    }
    # If we have detected an error, then we want to start from the beginning
    if {$errorCount!=-1} {set errorCount 0}
}

body ::tycho::Compile::setErrorCount {count} {
    set errorCount $count
}

#######################################################################
#### jumpNextError
# Make sure we don't jump too far. errorList has the following format:
# { {cLineNum eLineNum} {cLineNum eLineNum} ... }
# Where cLinNum is the compiler's line number, along with
# eLineNum, which is the editor's line number.
#
body ::tycho::Compile::jumpNextError {} {
    # NOTE: errorCount=$errorCount   errorList=$errorList
    if {$errorCount!=-1 && $errorCount<[llength $errorList]} {
        # Find out where in the list my information is located.
        # This has the format {{1 2 asdf.cc} {5 10 fdsa.cc} ...}
        set entry [lindex $errorList $errorCount]
        set cLineNum [lindex $entry 0]
        set eLineNum [lindex $entry 1]
        set fname [lindex $entry 2]
        jumpToLine $cLineNum $eLineNum $fname
        incr errorCount
    } else {
        set errorCount 0
    }

}

# This will open file context, and jump to entry number.
# eLineNum = editor's line number (where error occured)
# cLineNum = compiler's line number (where error reported)
# fname = filename of the error source code.
body ::tycho::Compile::jumpToLine {cLineNum eLineNum fname} {
    # Name of our editor/viewer
    #set editorName [$this cget -view]

    set editorName [::tycho::File::openContext $fname]
    set editorName [string trim $editorName :]

    # Jump to the line in editor
    $editorName seeFragment "line $eLineNum"

    # Jump to the line in the compile/exec widget
    set history $compileWidget.history
    if {[winfo exists $history]} {
        $history seeFragment "line $cLineNum"
    } else {
        error "Compile/Exec widget doesn't exist."
    }
}



#######################################################################
#### checkSourceFiles
# Check the source files for necessary features. 
# For example, when a C file is loaded into Tcl, an initialization
# procedure with a specific name is called.
# In the Compile baseclass, this method is a noop.
#
body ::tycho::Compile::checkSourceFiles {} {
}

#######################################################################
#### compileFiles
# Compile the files
#
body ::tycho::Compile::compileFiles {} {
    # FIXME: compileString should be a preference.
    # FIXME: dirname should be a preference.
    
    #putStatus "About to make shared object, when complete, be sure to \
    #        close the Exec window to continue."

    # Compile.  If we already have a compileWidget, reuse it. 
    if {![winfo exists $compileWidget]} {
        #set compileWidget [$this cget -view].compile
        #set retList [::tycho::execModal $compileString $dirname]

        set autostart 1
        set autodestroy 0

        set compileString "make -f $makefile"
        set compileWidget \
                [::tycho::Monitor [::tycho::autoName .makeExec] \
                -autostart $autostart -autodestroy $autodestroy \
                -command $compileString -dir $dirname]

        # Basic initialization here
        if {$compileString != {} } {
            $compileWidget configure -command $compileString
        }
        if {$dirname != {} } {
            $compileWidget configure -dir $dirname
        }

        $compileWidget raiseWindow

        if {$autostart} {
            #$compileWidget execProcessInMonitor
            $compileWidget getStatusWait
            parseError $compileWidget
        } else {
            # Raise current window back, since default is not autostart
            set editorName [$this cget -view]
            if {$editorName!={}} {$editorName raiseWindow}
        }
   } else {
        #set retList [::tycho::execModal {} {} $compileWidget]
        $compileWidget raiseWindow
        # Make sure we parse the output of the compiler (ie. esp. error msg)
        # Colorize our monitor
        $compileWidget execProcessInMonitor
        $compileWidget getStatusWait
        parseError $compileWidget
    }


    #set statusVariableName [$compileWidget getStatusVariableName]
    #global $statusVariableName
    
    # If statement is used to prevent crashing
    #if [info exists $statusVariableName] {
    #    return [list [$execWidget getStatusWait] $execWidget]
    #} else {
    #    error "ERROR IN execModal: $statusVariableName doesn't exist!"
    #}

    #putStatus ""
    #return $retList
}

#######################################################################
#### createMakefile
# Create a makefile.   Usually subclasses modify this method.
# The makefile that is created is named by the *makefile* protected variable.
body ::tycho::Compile::createMakefile {} {
}

#######################################################################
#### initialize
# Initialize the some protected variables from the list of filenames.
# 
body ::tycho::Compile::initialize {filenames} {
    if {[llength $filenames] == 0} {
	error "::tycho::Compile::compileAndLoad must be passed a list of files"
    }
    set filenameList $filenames
    set firstFile [lindex $filenameList 0]
    set dirname [file dirname $firstFile]
    set basename [file rootname [file tail $firstFile]]
}

#######################################################################
#### loadFiles
# Run load the shared objects back into Tycho.
# In the Compile baseclass, this method is a noop.
#
body ::tycho::Compile::loadFiles {} {
}

#######################################################################
#### makefileName
# Determine the name of the makefile
# The directory where the first file in the list is searched for
# the following files in order:
# <OL>
# <LI> <CODE>makefile</CODE>
# <LI> <CODE>Makefile</CODE>
# <LI> A file with the same base as the file being evaluated and
# a <CODE>.mk</CODE> extension.  For example, if the file being
# evaluated is named <CODE>myTclCommands.c</CODE>, then we look for 
# <CODE>myTclCommands.mk</CODE>
# </OL>
#
body ::tycho::Compile::makefileName {} {
    if [file exists [file join $dirname makefile]] {
	set makefile makefile
    } elseif [file exists [file join $dirname Makefile]] {
	set makefile Makefile
    } else {
	set makefile $basename.mk
    }
}

#####################################################################
#### preference
# Access the preferences associated with this widget. This method
# overrides the default method in ::tycho::TWidget to access the
# "misc" preferences.
#
body ::tycho::Compile::preference {mode args} {
    eval ::tycho::preference $mode "misc" $args
}

#######################################################################
#### printStatus
# Print status messages if -view was passed at construction time.
#
body ::tycho::Compile::putStatus {msg} {
    if {$view != {}} {
	$view putStatus $msg
    }
}
