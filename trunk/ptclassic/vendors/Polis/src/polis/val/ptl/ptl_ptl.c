 /*************************************************************************

  Copyright   [Copyright (c) 1994-1998 The Regents of the Univ. of California.
  All rights reserved.

  Permission is hereby granted, without written agreement and without license
  or royalty fees, to use, copy, modify, and distribute this software and its
  documentation for any purpose, provided that the above copyright notice and
  the following two paragraphs appear in all copies of this software.

  IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY FOR
  DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT
  OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF THE UNIVERSITY OF
  CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

  THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
  INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
  FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS ON AN
  "AS IS" BASIS, AND THE UNIVERSITY OF CALIFORNIA HAS NO OBLIGATION TO PROVIDE
  MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.]

******************************************************************************/
/*
 * Revision Control Information
Version identification:
@(#)DERCScheduler.h     $Id$

Author: Luciano, Neil Smyth, Mudit Goel

 * $Source$
 
 *
 */

#include "polis.h" 
#include "ptl_int.h"

extern st_table * s2c_local_vars ARGS(( net_node_t * ));
void pl_print_cfsm ARGS(( FILE *, net_node_t *, net_node_t *, char *,
        int, int, int, int ));
static void pl_print_var ARGS(( net_node_t * ));
static void var_type ARGS(( net_var_t * ));
static void pl_print_defstar ARGS(( FILE *, net_node_t *, char * ));
static void pl_print_inputs ARGS(( FILE *, net_node_t *, int ));
static void pl_print_outputs ARGS(( FILE *, net_node_t *, char *, int ));
static void pl_print_private ARGS(( FILE *, net_node_t * ));
static void pl_print_protected ARGS(( FILE *, net_node_t * ));
static void pl_print_public ARGS(( FILE *, net_node_t *, char * ));
static void pl_print_state ARGS(( FILE *, net_node_t *, int, int ));
static void pl_print_constructor ARGS(( FILE *, net_node_t * ));
static void pl_print_method ARGS(( FILE *, net_node_t *, int, int ));
static void pl_print_code ARGS((FILE *,net_node_t *,net_node_t *,char *,int,int,int));
static void pl_print_setup ARGS(( FILE *, net_node_t *, int ));
static void pl_print_begin ARGS(( FILE *, net_node_t *, char *, int ));
static void pl_print_go ARGS(( FILE *, net_node_t *, char *, int, int, int ));
static void pl_print_end ARGS(( FILE *, net_node_t * ));
static net_var_t * isInputEvent ARGS(( net_var_t *, net_node_t * ));
static net_var_t * isSensor ARGS(( net_var_t *, net_node_t * ));
static net_var_t * isInputInt ARGS(( net_var_t *, net_node_t * ));
static net_var_t * isInputValue ARGS(( net_var_t *, net_node_t * ));
static net_var_t * isOutputEvent ARGS(( net_var_t *, net_node_t * ));
static net_var_t * isIntOutput ARGS(( net_var_t *, net_node_t * ));
static net_var_t * isOutputValue ARGS(( net_var_t *, net_node_t * ));
static char * typecheck ARGS(( char * ));

void pl_print_cfsm( fp, root_node, node, outfire, trace, compat, autotick, unittime )
     FILE *fp; 
     net_node_t *root_node, *node;
     char *outfire;
     int trace, compat, autotick, unittime;
{
    if (( node == NIL(net_node_t)) || ( net_node_type( node ) != COMP ))
        return;
    
    pl_print_defstar( fp, node, outfire );
    pl_print_inputs( fp, node, autotick );
    pl_print_outputs( fp, node, outfire, autotick );
    pl_print_public( fp, node, outfire);
    pl_print_private( fp, node );
    if ( trace ) {
        pl_print_protected( fp, node );
    } 
    pl_print_state( fp, node, compat, unittime );
    pl_print_constructor( fp, node );
    pl_print_method( fp, node, autotick, unittime );
    pl_print_code( fp, root_node, node, outfire, trace, autotick, unittime );
    pl_print_setup( fp, node, compat );
    pl_print_begin( fp, node, outfire, trace );
    pl_print_go( fp, node, outfire, trace, autotick, unittime );
    pl_print_end( fp, node );
}

static void pl_print_defstar( fp, node, option )
     FILE *fp;
     net_node_t *node;
     char *option;
{
    char *model_name;
    estm_cost_t *cost;
    int resourceId, i;
    
    model_name = net_node_name( net_node_model( node ));
    fprintf( fp, "defstar {\n" );
    fprintf( fp, "  name { %s%s }\n", model_name, option );
    fprintf( fp, "  domain { DE }\n" );
    fprintf( fp, "  derivedfrom { RCStar }\n" );
    fprintf( fp, "  desc { Star generated by POLIS\n" );
    if (( resourceId = estm_net_node_num_costs( node )) == 0 ) {
        fprintf( fp, "No cost calculation available.\n" );
    } else {
        for ( i = 0; i < resourceId; i++ ) {
            cost = estm_net_node_costs( node, i );
            fprintf( fp, "%s:\n", estm_net_node_cpu_names( node, i ));
            /*      fprintf( fp, "%s:\n", estm_net_node_cpu_names( node, i )); */
            fprintf( fp, "    min_time: %d\n", estm_cost_min_time( cost ));
            fprintf( fp, "    max_time: %d\n", estm_cost_max_time( cost ));
            fprintf( fp, "    tot_size: %d\n", estm_cost_code_size( cost ));
        }
    }
    fprintf( fp, "  }\n" );
}

/* Define input ports. Get real name, and not event name
   from the description
*/
static void pl_print_inputs( fp, node, autotick )
     FILE *fp;
     net_node_t *node;
     int autotick;
{
    net_var_t *var, *pvar, *tvar;
    char typest[63];
    
    /* Input events */
    foreach_net_node_fanin( node, var ) {
        if ( pvar = isInputEvent( var, node )) {
            strcpy( typest, util_make_valid_name( pvar ));
            if ( strcmp( typest, "e__selftrigger" ) || !autotick ) {
                fprintf( fp, "  input {\n" );
                fprintf( fp, "    name { %s }\n", util_make_valid_name( pvar ));
                if ( tvar = isInputValue( pvar, node )) {
                    strcpy( typest, os_io_var_type( tvar ));
                    typecheck( typest );
                    if (! strcmp (typest, "double")) {
                        fprintf( fp, "    type { float }\n" );
                    }
                    else {
                        fprintf( fp, "    type { %s }\n", typest );
                    }
                } else {
                    fprintf( fp, "    type { int }\n" );
                }
                fprintf( fp, "  }\n" );
            }
        }
    } end_foreach_net_node_fanin;
    
    /* Input sensors */
    foreach_net_node_fanin( node, var ) {
        if ( pvar = isSensor( var, node )) {
            fprintf( fp, "  input {\n" );
            fprintf( fp, "    name { s_%s }\n", util_make_valid_name( pvar ) + 2 );
            strcpy( typest, os_io_var_type( pvar ));
            typecheck( typest );
            if (! strcmp (typest, "double")) {
                fprintf( fp, "    type { float }\n" );
            }
            else {
                fprintf( fp, "    type { %s }\n", typest );
            }
            fprintf( fp, "    desc { sensor }\n" );
            fprintf( fp, "  }\n" );
        }
    } end_foreach_net_node_fanin;
}

/* Define output ports. Get real name, and not event name
   from the description
*/
static void pl_print_outputs( fp, node, option, autotick )
     FILE *fp; 
     net_node_t *node;
     char *option;
     int autotick;
{
    net_var_t *var, *pvar, *tvar;
    char typest[63];
    
    foreach_net_node_fanout( node, var ) {
        pvar = isOutputEvent( var, node );
        if ( pvar == NULL ) pvar = isIntOutput( var, node );
        if ( pvar != NULL ) {
            strcpy( typest, util_make_valid_name( pvar ));
            if ( strcmp( typest, "e_o__selftrigger" ) || !autotick ) {
                fprintf( fp, "  output {\n" );
                fprintf( fp, "    name { %s }\n", util_make_valid_name( pvar ));
                if ( tvar = isOutputValue( pvar, node )) {
                    strcpy( typest, os_io_var_type( tvar ));
                    typecheck( typest );
                    if (! strcmp (typest, "double")) {
                        fprintf( fp, "    type { float }\n" );
                    }
                    else {
                        fprintf( fp, "    type { %s }\n", typest );
                    }
                } else {
                    fprintf( fp, "    type { int }\n" );
                }
                fprintf( fp, "  }\n" );
            }
        }
    } end_foreach_net_node_fanout;
    if ( strlen( option ) > 0 && option[ 1 ] == 'F' ) {
        fprintf( fp, "  output {\n" );
        fprintf( fp, "    name { firing }\n" );
        fprintf( fp, "    type { int }\n" );
        fprintf( fp, "  }\n" );
    }
}

static void pl_print_private( fp, node )
     FILE *fp;
     net_node_t *node;
{
    /* net_var_t *var, *pvar; */
    
    fprintf( fp, "\n  private {\n" );
    fprintf( fp, "    double min_time;\n" );
    fprintf( fp, "    double end_time;\n" );
    /* fprintf( fp, "    static double _delay;\n" ); move to code */
    fprintf( fp, "    FILE *fpfire;\n" );
    fprintf( fp, "    FILE *fpover;\n" );
    fprintf( fp, "  }\n\n" );
}

static void pl_print_public( fp, node, option )
     FILE *fp;
     net_node_t *node;
     char* option;
{
    net_var_t *var, *pvar, *assoc_var;
    st_table *local_vars;
    st_generator *gen;
    char typest[64];
    char* model_name;
    
    model_name = net_node_name( net_node_model( node ));
    
    fprintf( fp, "  public {\n" );
    
    fprintf( fp, "\n      /* Variables  taken from DERCStar */ \n");
    fprintf( fp, "    double now;\n" );
    fprintf( fp, "    double clkFreq; /* perhaps make private ? */\n");
    fprintf( fp, "    int resourceId;\n");
    fprintf( fp, "    // Pointers to the event queues of the DERCScheduler controlling the simulation;\n");
    
    /* should this be here??? 
       fprintf( fp, "\n    static DE%s%s* ", model_name, option );
       fprintf( fp, "%s%s_Star;\n", model_name, option ); */
    
    
    /* Input event flags */
    fprintf( fp, "    /* Input event flags */\n" );
    foreach_net_node_fanin( node, var ) {
        if ( pvar = isInputEvent( var, node )) {
            fprintf( fp, "    int %s_flag;\n", util_make_valid_name( pvar ));
        }
    } end_foreach_net_node_fanin;
    
    /* Settable constants */
    fprintf( fp, "    /* Settable constants */\n" );
    local_vars = s2c_local_vars( node );
    st_foreach_item( local_vars, gen, (char **) &pvar, (char **) &var ) {
        if ( net_var_type( pvar, USER_CONSTANT )) {
            fprintf( fp, "    int c%s;\n", util_make_valid_name( pvar ) + 1 );
        }
    }
    
    /* State and output variables */
    fprintf( fp, "    /* State and output variables */\n" );
    st_foreach_item( local_vars, gen, (char **) &pvar, (char **) &var ) {
        if ( net_var_type( var, ST )) {
            assoc_var = net_var_assoc_var( var );
            assert(assoc_var==NIL(net_var_t) || !net_var_type(assoc_var,EVENT));
            strcpy( typest, os_io_var_type( pvar ));
            typecheck( typest );
            fprintf( fp, "    %s ", typest );
            fprintf( fp, "%s;\n", util_make_valid_name( pvar ) + 2 );
        }
    }
    foreach_net_node_trans_out( node, var ) {
        if ( net_var_type( var, VALUE ) && !net_var_assoc_var( var )) {
            pvar = net_var_parent_var( var, node );
            strcpy( typest, os_io_var_type( pvar ));
            typecheck( typest );
            fprintf( fp, "    %s ", typest );
            fprintf( fp, "%s;\n", util_make_valid_name( pvar ) + 2 );
        }
    } end_foreach_net_node_trans_out;
    
    fprintf( fp, "  }\n" );
    fprintf( fp, "  ccinclude { \"InfString.h\" }\n" );
    /*  st_free_table( local_vars ); */
}

static void pl_print_protected( fp, node )
     FILE *fp;
     net_node_t *node;
{
    fprintf( fp, "  protected {\n" );
    fprintf( fp, "    TclStarIfc tcl;\n" );
    
    fprintf( fp, "  }\n" );
    fprintf( fp, "  hinclude { \"TclStarIfc.h\" }\n" );
    fprintf( fp, "  ccinclude { \"ptk.h\" }\n" );
    fprintf( fp, "  state {\n" );
    fprintf( fp, "    name { tcl_file }\n" );
    fprintf( fp, "    type { string }\n" );
    fprintf( fp, "    default {\"$POLIS/polis_lib/ptl/PolisShowValues.tcl\"}\n" );
    fprintf( fp, "    desc { The file from which to read the Tcl script }\n" );
    fprintf( fp, "    attributes { A_NONSETTABLE }\n" );
    fprintf( fp, "  }\n" );
    fprintf( fp, "  state {\n" );
    fprintf( fp, "    name { debug }\n" );
    fprintf( fp, "    type { int }\n" );
    fprintf( fp, "    default { \"0\" }\n" );
    fprintf( fp, "    desc { Show the internal variables in a debug window }\n" );
    fprintf( fp, "  }\n" );
}

static void pl_print_state( fp, node, compat, unittime )
     FILE *fp;
     net_node_t *node;
     int compat, unittime;
{
    net_var_t *var, *pvar;
    st_table *local_vars;
    st_generator *gen;
    
    fprintf( fp, "  state {\n" );
    fprintf( fp, "    name { Priority }\n" );
    fprintf( fp, "    type { int }\n" );
    fprintf( fp, "    default { 0 }\n" );
    fprintf( fp, "    desc { Priority: 0 -> lower }\n" );
    fprintf( fp, "  }\n" );
    fprintf( fp, "  state {\n" );
    fprintf( fp, "    name { Clock_freq }\n" );
    fprintf( fp, "    type { float }\n" );
    fprintf( fp, "    default{ Clock_freq }\n" );
    fprintf( fp, "    desc { CPU Clock frequency }\n" );
    fprintf( fp, "  }\n" );
    fprintf( fp, "  state {\n" );
    fprintf( fp, "    name { resourceName }\n" );
    fprintf( fp, "    type { string }\n" );
    fprintf( fp, "    default {\"HW\"}\n" );
    fprintf( fp, "    desc { resource to be used for simulation }\n" );
    fprintf( fp, "  }\n" );
    fprintf( fp, "  state {\n" );
    fprintf( fp, "    name { policy }\n" );
    fprintf( fp, "    type { string }\n" );
    fprintf( fp, "    default { \"{SCHEDULER}\" }\n" );
    fprintf( fp, "    desc {Scheduling Policy to be used for simulation }\n" );
    fprintf( fp, "  }\n" );
    fprintf( fp, "  state {\n" );
    fprintf( fp, "    name { firename }\n" );
    fprintf( fp, "    type { string }\n" );
    fprintf( fp, "    default { \"{Firingfile}\" }\n" );
    fprintf( fp, "    desc { File to write firing information }\n" );
    fprintf( fp, "    attributes { A_NONSETTABLE }\n" );
    fprintf( fp, "  }\n" );
    fprintf( fp, "  state {\n" );
    fprintf( fp, "    name { overname }\n" );
    fprintf( fp, "    type { string }\n" );
    fprintf( fp, "    default { \"{Overflowfile}\" }\n" );
    fprintf( fp, "    desc { File to write overflow information }\n" );
    fprintf( fp, "    attributes { A_NONSETTABLE }\n" );
    fprintf( fp, "  }\n" );
    
    
    /* Settable constants */
    local_vars = s2c_local_vars( node );
    st_foreach_item( local_vars, gen, (char **) &pvar, (char **) &var ) {
        if ( net_var_type( pvar, USER_CONSTANT )) { 
            fprintf( fp, "  state {\n" );
            fprintf( fp, "    name { %s }\n", util_make_valid_name( pvar ) + 2 );
            fprintf( fp, "    type { int }\n" );
            fprintf( fp, "    default { \"%d\" }\n", net_var_const_value( pvar ));
            fprintf( fp, "    desc { Settable constant }\n" );
            fprintf( fp, "  }\n" );
        }
    }
    /*  st_free_table( local_vars ); */
}

static void pl_print_constructor( fp, node )
     FILE *fp;
     net_node_t *node;
{
    fprintf( fp, "\n\n  constructor {\n    delayType = TRUE;\n" );
    fprintf( fp, "    _delay = 0.0;\n");
    fprintf( fp, "  }\n" );
}

static void pl_print_method( fp, node, autotick, unittime )
     FILE *fp;
     net_node_t *node;
     int autotick, unittime;
{
    net_var_t *var, *assoc_var, *pvar;
    int output_event_count;
    char pvarst[ 1024 ];
    
    fprintf( fp, "  method {\n");
    fprintf( fp, "    name { emitEventToIntQ }\n");
    fprintf( fp, "    access { public }\n" );
    fprintf( fp, "    type { void }\n" );
    fprintf( fp, "    arglist { \"( int outputPort, double delay )\" }\n" );
    fprintf( fp, "    code {\n" );  
    fprintf( fp, "      double emitTime;\n" ); 
    fprintf( fp, "      StarLLCell *temp = (StarLLCell)storeList->getAndRemove(); \n" ); 
    fprintf( fp, "      if (temp == 0) temp = new StarLLCell(-1, -1); \n" ); 
    fprintf( fp, "      if (needsSharedResource) { \n" );
    fprintf( fp, "                emitTime = now + (delay/clkFreq);\n" ); 
    fprintf( fp, "      } else { emitTime = now + (1/clkFreq); } \n" ); 
    fprintf( fp, "      temp->time = emitTime; \n" ); 
    fprintf( fp, "      temp->outputPort = outputPort; \n" ); 
    fprintf( fp, "      emittedEvents->append(temp); \n" ); 
    fprintf( fp, "    } \n" ); 
    fprintf( fp, "  } \n" ); 

    
    fprintf( fp, "  method {\n");
    fprintf( fp, "    name { emitEvent }\n");
    fprintf( fp, "    access { public }\n" );
    fprintf( fp, "    type { void }\n" );
    fprintf( fp, "    arglist { \"(StarLLCell* cell, double emitTime)\" }\n" );
    fprintf( fp, "    code {\n" );

    output_event_count = 1;
    foreach_net_node_fanout( node, var ) {
        pvar = isOutputEvent( var, node );
        if ( pvar == NULL ) pvar = isIntOutput( var, node );
        if ( pvar != NULL ) {
            fprintf( fp, "      static const int c%s = %d;\n",
                    util_make_valid_name( pvar ), output_event_count++ );
        }
    } end_foreach_net_node_fanout;
    fprintf( fp, "\n" );

    fprintf( fp, "      switch( cell->outputPort ) {\n" );

    foreach_net_node_fanout( node, var ) {
        pvar = isOutputEvent( var, node );
        if ( pvar == NULL ) pvar = isIntOutput( var, node );
        if ( pvar != NULL ) {
            strcpy( pvarst, util_make_valid_name( pvar ));
            fprintf( fp, "            case c%s:\n", pvarst );
            fprintf( fp, "                OutDEPort tl = & %s;\n",pvarst ); 
            fprintf( fp, "                tl->put(event->realTime) << ");
            assoc_var = net_var_assoc_var( var );
            if ( assoc_var == NIL(net_var_t)) {
                fprintf( fp, "1;\n" );
            } else {
                if ( !isIntOutput( var, node )) {
                    fprintf( fp, "%s;\n", util_make_valid_name(
                            net_var_parent_var( assoc_var, node )));
                } else {
                    fprintf( fp, "%s;\n", util_make_valid_name( assoc_var ));
                }
            }
                   
            fprintf( fp, "                break;\n" );
        }
    } end_foreach_net_node_fanout;
    fprintf( fp, "            default:\n               break;\n" );
    fprintf( fp, "      }\n" );
    fprintf( fp, "      storeList->append(cell);\n");
    fprintf( fp, "    }\n  }\n");



    fprintf( fp, "  method {\n" );
    fprintf( fp, "    name { getDelay }\n");
    fprintf( fp, "    access { public }\n" );
    fprintf( fp, "    type { double }\n" );
    fprintf( fp, "    arglist { \"()\" }\n" );
    fprintf( fp, "    code {\n" );
    fprintf( fp, "      if (needsSharedResource) return _delay/clkFreq;\n" );
    fprintf( fp, "      else return 1/clkFreq;\n");
    fprintf( fp, "    }\n}\n\n");
  

  
    fprintf( fp, "  method {\n" );
    fprintf( fp, "    name { getEvents }\n");
    fprintf( fp, "    access { public }\n" );
    fprintf( fp, "    type { \"SequentialList*\" }\n" );
    fprintf( fp, "    arglist { \"()\" }\n" );
    fprintf( fp, "    code {\n" );
    fprintf( fp, "      return emittedEvents;\n" );
    fprintf( fp, "    }\n}\n\n");

    /*
     * Clean up input events
     */
    fprintf( fp, "  method {\n" );
    fprintf( fp, "    name { CleanUp }\n" );
    fprintf( fp, "    access { public }\n" );
    fprintf( fp, "    type { void }\n" );
    fprintf( fp, "    arglist { \"( int emitted )\" }\n" );
    fprintf( fp, "    code {\n" );
    fprintf( fp, "      if ( emitted ) {\n" );
    /* Clear input event flags */
    foreach_net_node_fanin( node, var ) {
        if ( pvar = isInputEvent( var, node )) {
            fprintf( fp, "        %s_flag = 0;\n", util_make_valid_name( pvar ));
        }
    } end_foreach_net_node_fanin;
    fprintf( fp, "      }\n" );  
    fprintf( fp, "    }\n" );
    fprintf( fp, "  }\n" );
}

static void pl_print_code( fp, root_node, node, option, trace, autotick, unittime )
     FILE *fp;
     net_node_t *root_node, *node;
     char *option;
     int autotick, unittime;
{
    net_var_t *var, *pvar, *assoc_var, *tvar;
    char *node_name, *model_name, typest[63];
    int output_event_count;
    st_table *local_vars;
    st_generator *gen;
    
    node_name = net_node_name( node );
    model_name = net_node_name( net_node_model( node ));
    
    fprintf( fp, "  code {\n" );
    fprintf( fp, "#include \"swlib.c\"\n" );
    fprintf( fp, "#include \"uC_types.h\"\n\n" );
    
    /* Delay computation */
    fprintf( fp, "#define DELAY(d) {if (%s%s_Star->needsSharedResource) {_delay += (d);}}\n", 
            model_name, option );
    fprintf( fp, "#define illegal_cpu() 0\n" );
    
    /*
     * Input event macros
     */
    fprintf( fp, "/* Input event macros */\n" );
    foreach_net_node_fanin( node, var ) {
        if ( pvar = isInputEvent( var, node )) {
            fprintf( fp, "#define detect_%s_", util_make_valid_name( pvar ));
            fprintf( fp, "to_%s ", util_map_pathname( node_name ));
            strcpy( typest, util_make_valid_name( pvar ));
            if ( strcmp( typest, "e__selftrigger" ) || !autotick ) {
                fprintf( fp, "%s%s_Star->", model_name, option );
                fprintf( fp, "%s_flag\n", util_make_valid_name( pvar ));
            } else {
                fprintf( fp, "1\n" );
            }
        }
    } end_foreach_net_node_fanin;
    
    /*
     * Output event macros
     */
    fprintf( fp, "/* Output event macros */\n" );
    foreach_net_node_fanout( node, var ) {
        if ( pvar = isOutputEvent( var, node )) {
            fprintf( fp, "#define emit_%s() ", util_make_valid_name( pvar ));
            fprintf( fp, "%s%s_Star->emitEventToIntQ( %s, _delay)\n", model_name, 
                    option, util_make_valid_name( pvar ));
        } else if ( pvar = isIntOutput( var, node )) {
            fprintf( fp, "#define emit_%s() ", 
                    util_make_valid_name( net_var_parent_var( pvar, node )));
            fprintf( fp, "%s%s_Star->emitEventToIntQ( %s, _delay)\n", model_name, 
                    option, util_make_valid_name( pvar ));
        }
    } end_foreach_net_node_fanout; 
    
    fprintf( fp, "#define startup( p )\n" );
    fprintf( fp, "#define cleanup( p, e ) " );
    fprintf( fp, "%s%s_Star->CleanUp( e )\n", model_name, option ); 
    fprintf( fp, "#define always_cleanup( p ) " );
    fprintf( fp, "%s%s_Star->CleanUp( 1 )\n", model_name, option ); 
    fprintf( fp, "#define cpu %s%s_Star->resourceId\n", model_name, option );
    
    /*
     * Settable constant macros
     */
    fprintf( fp, "/* Settable constant macros */\n" );
    local_vars = s2c_local_vars( node );
    st_foreach_item( local_vars, gen, (char **) &pvar, (char **) &var ) {
        if ( net_var_type( pvar, USER_CONSTANT )) {
            fprintf( fp, "#define %s ", util_make_valid_name( pvar ));
            fprintf( fp, "%s%s_Star->", model_name, option );
            fprintf( fp, "c%s\n", util_make_valid_name( pvar ) + 1 );
        }
    }
    
    /*
     * State and output variable macros
     */
    fprintf( fp, "/* State and output variable macros */\n" );
    st_foreach_item( local_vars, gen, (char **) &pvar, (char **) &var ) {
        if ( net_var_type( var, ST )) {
            assoc_var = net_var_assoc_var( var );
            assert(assoc_var==NIL(net_var_t) || !net_var_type(assoc_var,EVENT));
            fprintf( fp, "#define %s ", util_make_valid_name( pvar ));
            fprintf( fp, "%s%s_Star->", model_name, option );
            fprintf( fp, "%s\n", util_make_valid_name( pvar ) + 2 );
        }
    }
    foreach_net_node_trans_out( node, var ) {
        if ( net_var_type( var, VALUE ) && !net_var_assoc_var( var )) {
            pvar = net_var_parent_var( var, node );
            fprintf( fp, "#define %s ", util_make_valid_name( pvar ));
            fprintf( fp, "%s%s_Star->", model_name, option );
            fprintf( fp, "%s\n", util_make_valid_name( pvar ) + 2 );
        }
    } end_foreach_net_node_trans_out;
    
    /*
     * Output event constants
     */
    fprintf( fp, "    /* Output event constants */\n" );
    output_event_count = 1;
    foreach_net_node_fanout( node, var ) {
        pvar = isOutputEvent( var, node );
        if ( pvar == NULL ) pvar = isIntOutput( var, node );
        if ( pvar != NULL ) {
            fprintf( fp, "    static const int %s = %d;\n",
                    util_make_valid_name( pvar ), output_event_count++ );
        }
    } end_foreach_net_node_fanout;
    
    /*
     * Variables declarations
     */
    fprintf( fp, "    /* Input variable declarations */\n" );
    foreach_net_node_fanin( node, var ) {
        if ( assoc_var = isInputValue( var, node )) {
            pvar = net_var_parent_var( assoc_var, node );
            strcpy( typest, os_io_var_type( pvar ));
            typecheck( typest );
            fprintf( fp, "    %s ", typest );
            fprintf( fp, "%s;\n", util_make_valid_name( pvar ));
        }
    } end_foreach_net_node_fanin;
    foreach_net_node_fanin( node, var ) {
        if ( pvar = isSensor( var, node )) {
            strcpy( typest, os_io_var_type( pvar ));
            typecheck( typest );
            fprintf( fp, "    %s ", typest );
            fprintf( fp, "%s;\n", util_make_valid_name( pvar ));
        }
    } end_foreach_net_node_fanin;
    
    fprintf( fp, "    /* Output variable declarations */\n" );
    foreach_net_node_trans_out( node, var ) {
        if ( !net_var_type( var, ST ) && !net_var_type( var, EVENT ) && 
                !net_var_is_func_or_net_outp( net_var_parent_var( var, node ))) {
            assoc_var = net_var_assoc_var( var );
            if ( assoc_var != NIL(net_var_t) && net_var_type( assoc_var, EVENT )) {
                strcpy( typest, os_io_var_type( net_var_parent_var( var, node )));
                typecheck( typest );
                fprintf( fp, "    %s ", typest );
                fprintf( fp, "%s;\n",
                        util_make_valid_name( net_var_parent_var( var, node )));
            }
        }
    } end_foreach_net_node_trans_out;
    fprintf( fp, "\n" );
    fprintf( fp, "    double _delay;\n" );
    
    /* agghhhhh.....*/
    fprintf( fp, "\n    /* FIXME: Not to be kept static */ ");
    fprintf( fp, "\n    static DE%s%s* ", model_name, option );
    fprintf( fp, "%s%s_Star = NULL;\n", model_name, option );
    /* Define debugging procedure, if -g was selected */
    if ( trace ) {
        fprintf( fp, "static int grabDebugInfo( ClientData, Tcl_Interp*, " );
        fprintf( fp, "int, char*[] )\n" );
        fprintf( fp, "{\n" );
        fprintf( fp, "    InfString value;\n\n" );
        /* State and output variables */
        st_foreach_item( local_vars, gen, (char **) &pvar, (char **) &var ) {
            if ( net_var_type( var, ST )) {
                assoc_var = net_var_assoc_var( var );
                assert(assoc_var==NIL(net_var_t) || !net_var_type(assoc_var,EVENT));
                strcpy( typest, os_io_var_type( pvar ));
                typecheck( typest );
                fprintf( fp, "    value << (%s) ", typest );
                fprintf( fp, "%s%s_Star->", model_name, option );
                fprintf( fp, "%s << \" \";\n", util_make_valid_name( pvar ) + 2 );
            }
	}
	foreach_net_node_trans_out( node, var ) {
            if ( net_var_type( var, VALUE ) && !net_var_assoc_var( var )) {
                pvar = net_var_parent_var( var, node );
                strcpy( typest, os_io_var_type( pvar ));
                typecheck( typest );
                fprintf( fp, "    value << (%s) ", typest );
                fprintf( fp, "%s%s_Star->", model_name, option );
                fprintf( fp, "%s << \" \";\n", util_make_valid_name( pvar ) + 2 );
            }
	} end_foreach_net_node_trans_out;
        /* Input valued events */
	foreach_net_node_fanin( node, var ) {
            if ( assoc_var = isInputValue( var, node )) {
                pvar = net_var_parent_var( assoc_var, node );
                strcpy( typest, os_io_var_type( pvar ));
                typecheck( typest );
                fprintf( fp, "    value << (%s) ", typest );
                fprintf( fp, "%s << \" \";\n", util_make_valid_name( pvar ));
            }
	} end_foreach_net_node_fanin;
        /* Input sensors */
	foreach_net_node_fanin( node, var ) {
            if ( pvar = isSensor( var, node )) {
                strcpy( typest, os_io_var_type( pvar ));
                typecheck( typest );
                fprintf( fp, "    value << (%s) ", typest );
                fprintf( fp, "%s << \" \";\n", util_make_valid_name( pvar ));
            }
	} end_foreach_net_node_fanin;
        /* Output valued events and output variables */
	foreach_net_node_trans_out( node, var ) {
            if ( !net_var_type( var, ST ) && !net_var_type( var, EVENT ) && 
                    !net_var_is_func_or_net_outp( net_var_parent_var( var, node ))) {
                assoc_var = net_var_assoc_var( var );
                if ( assoc_var != NIL(net_var_t) && net_var_type( assoc_var, EVENT )) {
                    pvar = net_var_parent_var( var, node );
                    strcpy( typest, os_io_var_type( pvar ));
                    typecheck( typest );
                    fprintf( fp, "    value << (%s) ", typest );
                    fprintf( fp, "%s << \" \";\n", util_make_valid_name( pvar ));
                }
            }
	} end_foreach_net_node_trans_out;
        if ( unittime ) {
            fprintf( fp, "    value << (float) %s%s_Star->now;\n", model_name, option );
        } else {
            fprintf( fp, "    value << (int) %s%s_Star->now;\n", model_name, option );
        }
	fprintf( fp, "    Tcl_SetResult( ptkInterp, (char *) value, " );
	fprintf( fp, "TCL_VOLATILE );\n" );
	fprintf( fp, "    return TCL_OK;\n" );
        fprintf( fp, "}\n\n" );
    }
    fprintf( fp, "#include \"%s.c\"\n", util_map_pathname( node_name ));
    fprintf( fp, "  }\n" );
    /*  st_free_table( local_vars );  FIXME : ???? */
}

static void pl_print_setup( fp, node, compat )
     FILE *fp;
     net_node_t *node;
     int compat;
{
    fprintf( fp, "  setup {\n" );
    fprintf( fp, "      timeOfArrival = -1;\n" );
    fprintf( fp, "      Closeflow();\n" );
    fprintf( fp, "  }\n" );
}

static void pl_print_begin( fp, node, option, trace )
     FILE *fp;
     net_node_t *node;
     char *option;
{
    int init, n, i;
    net_var_t *var, *pvar, *assoc_var, *tvar;
    char *node_name, *model_name;
    st_table *local_vars;
    st_generator *gen;
    
        node_name = net_node_name( node );
    model_name = net_node_name( net_node_model( node ));
    fprintf( fp, "  begin {\n" );
    fprintf( fp, "    char stemp[1024];\n" );
    fprintf( fp, "    InfString name;\n\n" );
    /* set variables which reflect Star parameters, and others*/
    fprintf( fp, "    /* set variables which reflect Star parameters*/ \n");
    fprintf( fp, "    strcpy( stemp, policy); \n");
    fprintf( fp, "    if(!strcmp(\"RoundRobin\", stemp)) schedPolicy = 0;\n");
    fprintf( fp, "    else if(!strcmp(\"NonPreemptive\", stemp)) schedPolicy = 1;\n"); 
    fprintf( fp, "    else if(!strcmp(\"Preemptive\", stemp)) schedPolicy = 2;\n");
    fprintf( fp, "    else {\n");
    fprintf( fp, "        strcat( stemp, \": not a valid scheduling Policy\" );\n");
    fprintf( fp, "        Error::abortRun( stemp );\n");
    fprintf( fp, "    }\n");
    fprintf( fp, "    priority = Priority;\n");
    fprintf( fp, "    clkFreq = Clock_freq;\n\n"); 
    fprintf( fp, "    clkFreq = (1000000)*clkFreq;\n\n");
    fprintf( fp, "    strcpy(resource, resourceName); \n" );
    fprintf( fp, "    if (!strcmp(resource, \"HW\")) needsSharedResource = 0;\n");
    fprintf( fp, "    else needsSharedResource = 1; \n");
    fprintf( fp, "    %s%s_Star = this;\n", model_name, option );
    fprintf( fp, "\n    emittedEvents = new SequentialList();\n");
    fprintf( fp, "    storeList = new SequentialList();\n");
    fprintf( fp, "    _delay = 0.0;\n");
    fprintf( fp, "    if ( needsSharedResource < 2 ) {\n" );
    
    
    /* State and output variables initialization */
    fprintf( fp, "      /* State and output variables initialization */\n" );   
    local_vars = s2c_local_vars( node );
    st_foreach_item( local_vars, gen, (char **) &pvar, (char **) &var ) {
        if ( net_var_type( var, ST )) {
            assoc_var = net_var_assoc_var( var );
            assert(assoc_var==NIL(net_var_t) || !net_var_type(assoc_var,EVENT));
            n = net_var_number_init_values( var );
            if ( n == 1 || !net_var_type( var, OUTPUT )) {
                init = net_var_get_init_value( var, 0 );
                fprintf( fp, "      %s = %d;\n", util_make_valid_name(pvar) + 2, init );
            }
        }
    }
    foreach_net_node_trans_out( node, var ) {
        if ( net_var_type( var, VALUE ) && !net_var_assoc_var( var )) {
            pvar = net_var_parent_var( var , node );
            n = net_var_number_init_values( var );
            if ( n == 1 || !net_var_type( var, OUTPUT )) {
                init = net_var_get_init_value( var, 0 );
                fprintf( fp, "      %s = %d;\n", util_make_valid_name(pvar) + 2, init );
            }
        }
    } end_foreach_net_node_trans_out;
    
    /* Settable constant initialization */ 
    fprintf( fp, "      /* Settable constants initialization */\n" );
    st_foreach_item( local_vars, gen, (char **) &pvar, (char **) &var ) {
        if ( net_var_type( pvar, CONSTANT )) {
            fprintf( fp, "      c%s = ", util_make_valid_name( pvar ) + 1 );
            fprintf( fp, "%s;\n", util_make_valid_name( pvar ) + 2 );
        }
    }
    
    fprintf( fp, "      if ( needsSharedResource ) {\n" );
    fprintf( fp, "        strcpy( stemp, resource );\n" );
    fprintf( fp, "        if (( resourceId = (int) _cpu_%s( stemp )) == -1 ) {\n", util_map_pathname( node_name ));
    fprintf( fp, "          strcat( stemp, \": not a valid CPU\" );\n" );
    fprintf( fp, "          Error::abortRun( stemp );\n" );
    fprintf( fp, "        }\n" );
    fprintf( fp, "      }\n" );
    fprintf( fp, "      strcpy( stemp, firename );\n" );
    fprintf( fp, "      fpfire = Openfiring( stemp );\n" );
    fprintf( fp, "      strcpy( stemp, overname );\n" );
    fprintf( fp, "      fpover = Openoverflow( stemp );\n" );
    fprintf( fp, "      now = -1.0;\n" );
    
    /* FIXME : do we need these?  
       
       fprintf( fp, "      saveimpl = needsSharedResource;\n" );
       fprintf( fp, "      needsSharedResource = 0;\n" );
       fprintf( fp, "      _t_%s(0,0);\n", util_map_pathname( node_name ));
       fprintf( fp, "      needsSharedResource = saveimpl;\n" );*/
    
    if ( trace ) {
        fprintf( fp, "      if ( debug ) {\n" );
        fprintf( fp, "        name = Block::fullName();\n" );
        
        i = 0;
        st_foreach_item( local_vars, gen, (char **) &pvar, (char **) &var ) {
            if ( net_var_type( var, ST )) {
                assoc_var = net_var_assoc_var( var );
                assert(assoc_var==NIL(net_var_t) || !net_var_type(assoc_var,EVENT));
                fprintf( fp, "        name << \" %s\";\n", 
                        util_make_valid_name( pvar ) + 2 );
                i++;
            }
	}
	foreach_net_node_trans_out( node, var ) {
            if ( net_var_type( var, VALUE ) && !net_var_assoc_var( var )) {
                pvar = net_var_parent_var( var, node );
                fprintf( fp, "        name << \" %s\";\n", 
                        util_make_valid_name( pvar ) + 2 );
                i++;
            }
	} end_foreach_net_node_trans_out;
	foreach_net_node_fanin( node, var ) {
            assoc_var = net_var_assoc_var( var );
            if ( net_var_type( var, EVENT ) && assoc_var != NIL(net_var_t)) {
                pvar = net_var_parent_var( assoc_var, node );
                fprintf( fp, "        name << \" %s\";\n", util_make_valid_name(pvar));
                i++;
            }
	} end_foreach_net_node_fanin;
	foreach_net_node_fanin( node, var ) {
            if ( pvar = isSensor( var, node )) {
                fprintf( fp, "        name << \" %s\";\n", 
                        util_make_valid_name( pvar ));
                i++;
            }
	} end_foreach_net_node_fanin;
	foreach_net_node_trans_out( node, var ) {
            if ( !net_var_type( var, ST ) && !net_var_type( var, EVENT ) && 
                    !net_var_is_func_or_net_outp( net_var_parent_var( var, node ))) {
                assoc_var = net_var_assoc_var( var );
                if ( assoc_var != NIL(net_var_t) && net_var_type( assoc_var, EVENT )) {
                    fprintf( fp, "        name << \" %s\";\n", 
                            util_make_valid_name( net_var_parent_var( var, node )));
                    i++;
                }
            }
	} end_foreach_net_node_trans_out;
        
        fprintf( fp, "        Tcl_SetVar2( ptkInterp, tcl.id(), \"label\", " );
        fprintf( fp, "(char *) name, TCL_GLOBAL_ONLY );\n" );
        fprintf( fp, "        sprintf( stemp, \"grabDebugInfo_%%s\", tcl.id());\n" );
        fprintf( fp, "        Tcl_CreateCommand( ptkInterp, stemp, " );
        fprintf( fp, "grabDebugInfo, (ClientData) this, NULL );\n" );
        fprintf( fp, "        tcl.setup( this, %d, 0, (const char *) tcl_file );\n",
                i + 1 );
        fprintf( fp, "      }\n" );
    }
    fprintf( fp, "    } else {\n" );
    fprintf( fp, "      strcpy( stemp, \"Implementation not supported!\" );\n" );
    fprintf( fp, "      Error::abortRun( *this, stemp );\n" );
    fprintf( fp, "    }\n" );
    fprintf( fp, "  }\n" );
    /*  st_free_table( local_vars ); */
}

static void pl_print_go( fp, node, option, trace, autotick, unittime )
     FILE *fp;
     net_node_t *node;
     char *option;
     int autotick, unittime;
{
    net_var_t *var, *pvar, *assoc_var, *tvar;
    char *node_name, *model_name;
    int firing = 0;
    char st[ 1024 ];
    
    if ( strlen( option ) > 0 && option[ 1 ] == 'F' ) {
        firing = 1;
    }
    
    node_name = net_node_name( node );
    model_name = net_node_name( net_node_model( node ));
    
    fprintf( fp, "  go {\n" );
    
    /* Initialization */
    fprintf( fp, "    char stemp[ 1024 ];\n" );
    fprintf( fp, "    StringList name;\n" );
    fprintf( fp, "    now = arrivalTime;\n" );
    fprintf( fp, "    name = Block::fullName();\n" );


    fprintf( fp, "    if (feedbackIn.dataNew) {\n" );
    fprintf( fp, "        if (resourcePointer->topStar() == this) {\n" );
    fprintf( fp, "            // This is the dummy event indicating end of resource usage \n" );
    fprintf( fp, "            if(emittedEvents->head() == emittedEvents->tail() ) {\n" );
    fprintf( fp, "                resourcePointer->removeTopStar(this); \n");
    fprintf( fp, "                emittedEvents->getAndRemove(); \n");
    fprintf( fp, "                assert(emittedEvents->getAndRemove() == 0); \n");
    fprintf( fp, "            } else { \n");
    fprintf( fp, "                StarLLCell *temp = (StarLLCell)emittedEvents->getAndRemove(); \n");
    fprintf( fp, "                assert(now == temp->time()); \n");
    fprintf( fp, "                emitEvent(temp, now); \n");
    fprintf( fp, "                refireAtTime(((StarLLCell)emittedEvents->head())->time, 0.0); \n");
    fprintf( fp, "            }\n");
    fprintf( fp, "        } else { \n");
    fprintf( fp, "            //The star has been preempted at the resource  \n");
    fprintf( fp, "            double delay = resourcePointer->getECT(this)->timeWhenFree - ((StarLLCell)emittedEvents->head())->time; \n");
    fprintf( fp, "            //The events being delayed in the queue \n");
    fprintf( fp, "            ListIter listEvents(*emittedEvents); \n");
    fprintf( fp, "            StarLLCell *q;  \n");
    fprintf( fp, "            while((q = (StarLLCell*)listEvents++)!=0) {  \n");
    fprintf( fp, "                q->time = q->time + delay; \n");
    fprintf( fp, "            } \n");
    fprintf( fp, "            refireAtTime(((StarLLCell)emittedEvents->head())->time, 0.0); \n");
    fprintf( fp, "        } \n");
    fprintf( fp, "     } else { // This star is firing for the first time, and has resource if req \n");
    
    /* Check input variables and check for missed deadlines */
    foreach_net_node_fanin( node, var ) {
        if ( pvar = isInputEvent( var, node )) {
            strcpy( st, util_make_valid_name( pvar ));
            if ( strcmp( st, "e__selftrigger" ) || !autotick ) {
                fprintf( fp, "    if ( %s.dataNew ) {\n", st );
                fprintf( fp, "        if ( fpover ) {\n" );
                fprintf( fp, "          if ( %s.numSimulEvents() > 0) {\n",st);
                fprintf( fp, "            sprintf( stemp, \"%%s: %%f %s\\n\", ", st );
                fprintf( fp, "(const char*) name, now);\n" );       
                fprintf( fp, "            Printoverflow( stemp );\n" );
                fprintf( fp, "          }\n" );
                fprintf( fp, "        }\n" );
                fprintf( fp, "        %s_flag = 1;\n", st );
                fprintf( fp, "    }\n" );
            }
        }
    } end_foreach_net_node_fanin;
    
    /* Read input values */
    fprintf( fp, "\n    // Read the input values \n");
    foreach_net_node_fanin( node, var ) {
        if ( assoc_var = isInputValue( var, node )) {
            pvar = net_var_parent_var( var, node );
            fprintf( fp, "    %s = ", 
                    util_make_valid_name( net_var_parent_var( assoc_var, node )));
            fprintf( fp, "(%s)%%0;\n", util_make_valid_name( pvar ));
        }
    } end_foreach_net_node_fanin;
    
    foreach_net_node_fanin( node, var ) {
        if ( pvar = isSensor( var, node )) {
            fprintf( fp, "    %s = ", util_make_valid_name( pvar ));
            fprintf( fp, "(s_%s)%%0;\n", util_make_valid_name( pvar ) + 2 );
        }
    } end_foreach_net_node_fanin;
    
    /* output eachh CFSM firing to the firing file */
    fprintf( fp, "\n    // write to firing file \n");
    fprintf( fp, "    if ( fpfire && needsSharedResource) {\n" );
    fprintf( fp, "      sprintf( stemp, \"%%s: %%f %%d start\\n\", " );
    fprintf( fp, "(const char*) name, now, priority);\n" );
    fprintf( fp, "      Printfiring( stemp );\n" );
    fprintf( fp, "    }\n" );
    
    /* Fire the Star! */
    fprintf( fp, "    min_time = -1;\n" );
    fprintf( fp, "    _delay = 0.0;\n" );
    fprintf( fp, "    _t_%s(0,0); // fire the star\n", util_map_pathname( node_name ));
    fprintf( fp, "    if (needsSharedResource) emitEventToIntQ(0, _delay);// emit dummy event \n");
    fprintf( fp, "    timeOfArrival = -1;// reset this as have finished this firing \n");
    if ( trace ) {
        fprintf( fp, "    if ( debug ) {\n" );
        fprintf( fp, "        tcl.go();\n" );
        fprintf( fp, "    }\n" );
        fprintf( fp, "    refireAtTime(((StarLLCell)emittedEvents->head())->time, 0.0); \n" ); 
        fprintf( fp, "  }\n" );
    }
} 



static void pl_print_end( fp, node )
     FILE *fp;
     net_node_t *node;
{
    fprintf( fp, "}\n" );
}

/* Return parent_var of an Input Event var, otherwise NULL */
/* Includes internal Input Events */
static net_var_t * isInputEvent( var, node )
     net_var_t *var;
     net_node_t *node;
{
    net_var_t *pvar, *tvar;
    
    if ( net_var_type( var, EVENT )) {
        pvar = net_var_parent_var( var, node );
        return pvar;
    }
    return NULL;
}

/* Return parent_var of an Internal Input Event var, otherwise NULL */
static net_var_t * isInputInt( var, node )
     net_var_t *var;
     net_node_t *node;
{
    net_var_t *pvar, *tvar;
    
    if ( net_var_type( var, EVENT )) {
        pvar = net_var_parent_var( var, node );
        tvar = net_var_fanin( pvar );
        if ( pvar == net_var_parent_var( tvar, node )) {
            return pvar;
        } else {
            return NULL;
        }
    }
    return NULL;
}

/* Return parent_var of an Input Sensor var, otherwise NULL */
static net_var_t * isSensor( var, node )
     net_var_t *var;
     net_node_t *node;
{
    net_var_t *pvar, *tvar;
    
    pvar = net_var_parent_var( var, node );
    if ( net_var_type( var, VALUE ) && !net_var_assoc_var( var ) &&
            !net_var_type( pvar, USER_CONSTANT | CONSTANT ) &&
            /*       !net_var_is_func_or_net_outp( pvar ) && 
                     !net_var_is_func_or_net_outp( var ) && */
            !net_var_is_lib_outp( pvar )) {
        for ( tvar = var; net_var_fanin( tvar ); tvar = net_var_fanin( tvar )) ;
        if ( net_var_node( tvar ) != node ) { 
            return pvar;
        } else {
            return NULL;
        }
    }
    return NULL;
}

/* Return assoc_var of an Input Event with value, otherwise NULL */
static net_var_t * isInputValue( var, node )
     net_var_t *var;
     net_node_t *node;
{
    net_var_t *assoc_var;
    
    assoc_var = net_var_assoc_var( var );
    if ( net_var_type( var, EVENT ) && assoc_var != NIL(net_var_t)) {
        return assoc_var;
    } else {
        return NULL;
    }
}

/* Return pvar of an Output Event, otherwise NULL. Does not include
   internal Output Events */
static net_var_t * isOutputEvent( var, node )
     net_var_t *var;
     net_node_t *node;
{
    net_var_t *pvar;
    char name[ 1024 ];
    
    if ( net_var_type( var, EVENT )) {
        pvar = net_var_parent_var( var, node );
        strcpy( name, util_make_valid_name( pvar ));
        if ( strcmp( name, "e__selftrigger" ) == 0 ) {
            return NULL;
        } else {
            return pvar;
        }
    }
    return NULL;
}

/* Return var for Internal Output Events, otherwise NULL */
static net_var_t * isIntOutput( var, node )
     net_var_t *var;
     net_node_t *node;
{
    net_var_t *pvar;
    char name[ 1024 ];
    
    if ( net_var_type( var, EVENT )) {
        pvar = net_var_parent_var( var, node );
        strcpy( name, util_make_valid_name( pvar ));
        if ( strcmp( name, "e__selftrigger" ) == 0 ) {
            return var;
        } else {
            return NULL;
        }
    }
    return NULL;
}

/* Return assoc_var of an Output Event with value */
static net_var_t * isOutputValue( var, node )
     net_var_t *var;
     net_node_t *node;
{
    net_var_t *assoc_var;
    
    assoc_var = net_var_assoc_var( var );
    if ( net_var_type( var, EVENT ) && assoc_var != NIL(net_var_t)) {
        return assoc_var;
    } else {
        return NULL;
    }
}

static char * typecheck( st )
     char *st;
{
    if ( strstr( st, "int" )) strcpy( st, "int" );
    return st;
}







